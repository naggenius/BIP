-- ============================================================
-- PROJET  - Script de creation des packages BIP
-- Date : 02/10/2006	
-- Auteur :  A. SAKHRAOUI
-- Version:	1
--
-- Modifications :
--	
--
-- ============================================================

-- ========================================================
-- bip_packages.sql
-- ========================================================
CREATE OR REPLACE TRIGGER delete_situation
AFTER DELETE ON situ_ress
FOR EACH ROW
BEGIN
	pack_situation_full.delete_situation(:old.ident, :old.datsitu);
END;
/
CREATE OR REPLACE TRIGGER insert_situation
AFTER INSERT ON SITU_RESS
FOR EACH ROW
BEGIN
	Pack_Situation_Full.insert_situation(:NEW.ident, :NEW.datsitu, :NEW.datdep, :NEW.cpident,
	 :NEW.cout , :NEW.dispo, :NEW.marsg2, :NEW.rmcomp, :NEW.PRESTATION, :NEW.dprest, :NEW.soccode,
	:NEW.codsg,:NEW.NIVEAU,:NEW.MONTANT_MENSUEL);
END;
/
CREATE OR REPLACE package PACKBATCH as

	-- Utilitaire : calcul du mois et de l'année de traitement
	-- en cours, non pas d'après la date système, mais d'après
	-- la date de la prochaine mensuelle
	-- -------------------------------------------------------
	procedure CALCDATTRT( P_HFILE in utl_file.file_type,
	                      P_MOISTRT out number,
	                      P_ANTRT   out number );

	-- Utilitaire : calcul de la date de début d'exercice
	-- --------------------------------------------------
	procedure CALCDATDBX( P_HFILE in utl_file.file_type,
	                      P_DATDBX out date );

	-- procedure controle consomm
	-- permet de controler les tables pmw_...
	PROCEDURE controle_consomme(P_HFILE IN utl_file.file_type);

	-- Première prémensuelle : PROMOIM1 et PROMOIM2
	-- Calcul de dates et passage de données N en
	-- données N-1
	-- --------------------------------------------
	procedure ST54700B( P_LOGDIR in varchar2 );
		procedure PROMOIM1( P_HFILE in utl_file.file_type );
		procedure PROMOIM2( P_HFILE in utl_file.file_type );

	-- Les deux prémensuelles et la mensuelle : prise
	-- en compte des données PMW chargées par SQL*LOAD
	-- dans les tables PMW_*
	-- -----------------------------------------------
	procedure ST54700E( P_LOGDIR in varchar2 );

		-- ----------------------------------------
		-- Test pour savoir si une consommation PMW
		-- doit générer une anomalie
		-- ----------------------------------------
		function TESTANO( P_ASTATUT in char, P_ADATESTATUT in date, P_CDEB in date,
		                  P_CHTYP in char )
		         return number;

		-- la fonction  utilise des variables globales
		-- donc pas de RNPS
		-- (ceci dit, la notion de "packaged variable"
		-- n'est pas claire, pour le moins)
		-- -------------------------------------------
		pragma restrict_references( TESTANO, WNDS, WNPS, RNDS );


		function REPTEST( CHTYP in char,
		                  TOTALCHINIT in number,
		                  TOTALCHRAF in number,
		                  CDEB in date,
		                  MUST_ACCEPT_TYPE_2 in char )
		         return char;
		pragma restrict_references( REPTEST, WNDS, WNPS );

		-- Prise en compte entete, etape,
		-- tache/sous-tache et affectations
		-- --------------------------------
		procedure RPETA( P_HFILE in utl_file.file_type );

		-- Prise en compte charges initiales et Reste A Faire
		-- Segments J0 et J2
		-- --------------------------------------------------
		procedure RPINIT_AND_RPRAF( P_HFILE in utl_file.file_type );

		-- Recalcul des dates au niveau etape pour toutes
		-- les etapes de tous les projets presents en PMW
		-- ----------------------------------------------
		procedure RPDATE( P_HFILE in utl_file.file_type );

		-- Remplit la table des anomalies de
		-- sous-traitances
		-- -------------------------------------------
		procedure RPSSTRT( P_HFILE in utl_file.file_type );

		-- Regénération des données de PROPLUS
		-- -------------------------------------------
		procedure P_PROPLUS( P_HFILE utl_file.file_type );

-- Fonction qui permet d'utiliser le truncate dans un bloc pl/sql
	procedure DYNA_TRUNCATE( TABLENAME IN VARCHAR2 );

-- Fonction qui permet d'utiliser le drop index dans un bloc pl/sql
	procedure DYNA_DROP_IND( INDEXNAME IN VARCHAR2 );

-- Fonction qui permet de creer un index dans un blocpl/sql
	procedure DYNA_CREATE_IND( TABLENAME IN VARCHAR2,
                                 INDEXNAME IN VARCHAR2,
                                 COLNAME IN VARCHAR2,
                                           MODETRI IN VARCHAR2,
                                 STORAGE_CLAUSE IN VARCHAR2 DEFAULT NULL);

-- ##################################################################################################
--	Purge TABLE Rejet en fonction de la DATE de statut
-- ##################################################################################################
	PROCEDURE purge_rejet_datestatut( P_HFILE utl_file.file_type ) ;

-- ##################################################################################################
--	Rejet en fonction de la DATE de statut
-- ##################################################################################################
	PROCEDURE rejet_datestatut( P_HFILE utl_file.file_type ) ;

-- ##################################################################################################
--	Copie des donnees rejetees par rejet_datestatut pour les lignes avec sous traitance
-- ##################################################################################################
	PROCEDURE copie_datestatut( P_HFILE utl_file.file_type ) ;

end PACKBATCH;
/

CREATE OR REPLACE package body PACKBATCH as

	-- Gestions exceptions
	-- -------------------
	CALLEE_FAILED exception;
	pragma exception_init( CALLEE_FAILED, -20000 );
	CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
	TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
	ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
	CONSTRAINT_VIOLATION exception;          -- pour clause when
	pragma exception_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
	INDEX_PK_VIOLATION exception;          -- pour clause when
	pragma exception_init( INDEX_PK_VIOLATION, -1 ); -- On essaie d'insérer deux fois le même enreg

	-- Dates Globales pour utilisation dans fonctions
	-- appelées en SQL. Oracle Corp. N'est PAS
	-- composée de Dieux vivants. PL/SQL a été codé
	-- par des gens normaux. Il y a des bugs.
	-- C'est pas (trés) grave, on contourne.
	-- ----------------------------------------------
	G_DAT0101AN date;            -- le 01/01 de l'année de l'exercice
	G_DAT0101ANM1 date;          -- le 01/01 de l'année d'avant celle de l'exercice

	-- ------------------------------------------------
	-- Copier/Coller/Modifier de l'exemple 'drop_table'
	-- de la documentation en ligne de PL/SQL dans
	-- Interaction with Oracle : using DLL and
	-- dynamic SQL
	-- ------------------------------------------------
	procedure DYNA_TRUNCATE( TABLENAME IN VARCHAR2 ) is

		CID integer;

	begin

		-- Open new cursor and return cursor ID.
		-- -------------------------------------
		CID := DBMS_SQL.OPEN_CURSOR;
		-- Parse and immediately execute dynamic SQL statement built by
		-- concatenating table name to command.
		-- ------------------------------------------------------------
		DBMS_SQL.PARSE( CID, 'TRUNCATE TABLE ' || TABLENAME, dbms_sql.v7 );
		-- Close cursor.
		-- -------------
		DBMS_SQL.CLOSE_CURSOR( CID );

	exception

		-- If an exception is raised, close cursor before exiting.
		-- -------------------------------------------------------
		-- note de manuel L : Et si l'exception a lieu pendant le
		-- open ou le close ?
		-- (supposons que LEUR code EST correct)
		-- -------------------------------------------------------
		when others then
			DBMS_SQL.CLOSE_CURSOR( CID );
		      raise;  -- reraise the exception

	end DYNA_TRUNCATE;


      -- CREATE INDEX indexname ON tablename (colname modetri) TABLESPACE IDX
	-- : réalisé par DBT (Denis Blanc-Tranchant) le 29091999


	procedure DYNA_CREATE_IND( TABLENAME IN VARCHAR2,
                                 INDEXNAME IN VARCHAR2,
                                 COLNAME IN VARCHAR2,
					   MODETRI IN VARCHAR2,
				 STORAGE_CLAUSE IN VARCHAR2 DEFAULT NULL) is


		CID integer;
		l_SQL	VARCHAR2(2000);

	begin
		l_SQL := 'CREATE INDEX ' || INDEXNAME || ' ON ' || TABLENAME || ' (' || COLNAME || ' ' || MODETRI || ' ) TABLESPACE IDX';
		IF (STORAGE_CLAUSE IS NOT NULL) THEN
			l_SQL := l_SQL || ' STORAGE ( ' || STORAGE_CLAUSE || ' )';
		END IF;

		-- Open new cursor and return cursor ID.
		-- -------------------------------------
		CID := DBMS_SQL.OPEN_CURSOR;
		-- Parse and immediately execute dynamic SQL statement built by
		-- concatenating table name to command.
		-- ------------------------------------------------------------
		DBMS_SQL.PARSE( CID, l_SQL, dbms_sql.v7 );

		-- Close cursor.
		-- -------------
		DBMS_SQL.CLOSE_CURSOR( CID );

	exception

		-- If an exception is raised, close cursor before exiting.
		-- -------------------------------------------------------
		-- note de manuel L : Et si l'exception a lieu pendant le
		-- open ou le close ?
		-- (supposons que LEUR code EST correct)
		-- -------------------------------------------------------
		when others then
			DBMS_SQL.CLOSE_CURSOR( CID );
		      raise;  -- reraise the exception

	end DYNA_CREATE_IND;



      -- DROP INDEX indexname : réalisé par DBT (Denis Blanc-Tranchant) le 29091999

	procedure DYNA_DROP_IND( INDEXNAME IN VARCHAR2 ) is

		CID integer;

	begin

		-- Open new cursor and return cursor ID.
		-- -------------------------------------
		CID := DBMS_SQL.OPEN_CURSOR;
		-- Parse and immediately execute dynamic SQL statement built by
		-- concatenating table name to command.
		-- ------------------------------------------------------------
		DBMS_SQL.PARSE( CID, 'DROP INDEX ' || INDEXNAME,dbms_sql.v7 );

		-- Close cursor.
		-- -------------
		DBMS_SQL.CLOSE_CURSOR( CID );

	exception

		-- If an exception is raised, close cursor before exiting.
		-- -------------------------------------------------------
		-- note de manuel L : Et si l'exception a lieu pendant le
		-- open ou le close ?
		-- (supposons que LEUR code EST correct)
		-- -------------------------------------------------------
		when others then
			DBMS_SQL.CLOSE_CURSOR( CID );
			IF SQLCODE=-1418 THEN		-- index inexistant : on s'en fout et on continue
				NULL;
			ELSE
				RAISE;
			END IF;
	end DYNA_DROP_IND;

	-- Procedure CONTROLE_CONSOMM : procedure de controle des donnees dans les tables
	-- PMW_CONSOMM, PMW_LIGNE_BIP ....
	-- Suppression des consommes antérieurs a la date d'exercice

	PROCEDURE controle_consomme (P_HFILE IN utl_file.file_type) IS

	L_PROCNAME VARCHAR2(20) := 'controle_consomme';
	ANNEE date;


	BEGIN

	TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

	SELECT datdebex INTO ANNEE
	FROM datdebex;

	TRCLOG.TRCLOG( P_HFILE, 'Début d exercice : ' || ANNEE);
	TRCLOG.TRCLOG( P_HFILE, 'Suppression des consommes antérieur au : ' || ANNEE);

	DELETE PMW_CONSOMM
	WHERE cdeb<ANNEE;

	IF SQL%ROWCOUNT = 0 THEN
		TRCLOG.TRCLOG( P_HFILE, 'Pas de consommes antérieurs à l exercice');
	ELSE
		TRCLOG.TRCLOG( P_HFILE, 'Nombre de lignes supprimées : '|| SQL%ROWCOUNT);
	END IF;

	COMMIT;

	TRCLOG.TRCLOG( P_HFILE, 'Fin de la procedure :'||L_PROCNAME);

	EXCEPTION

	WHEN OTHERS THEN
		TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
		raise CALLEE_FAILED;

	END controle_consomme;

	-- -----------------------------------------
	-- CALCDATTRT : on calcule le numero du mois
	-- de traitement a partir de la date de la
	-- prochaine mensuelle, qu'on trouve dans
	-- la table DATDEBEX. Le mois de traitement
	-- courant est le mois precedent.
	-- La table DATDEBEX est mis a jour en fin
	-- de mensuelle a l'aide de la table
	-- calendrier et de la date systeme.
	-- -----------------------------------------
	procedure CALCDATTRT( P_HFILE in utl_file.file_type,
	                      P_MOISTRT out number,
	                      P_ANTRT   out number ) is

		L_DATTRT date;
		L_PROCNAME varchar2( 16 ) := 'CALCDATTRT';

	begin

		-- Recherche de la date de la
		-- ===> PROCHAINE <=== mensuelle
		-- et renvoi du mois, annee du mois
		-- d'avant
		-- ----------------------------------
		select add_months( CMENSUELLE, -1 )
		into L_DATTRT
		from DATDEBEX;
		P_MOISTRT := to_char( L_DATTRT, 'MM' );
		P_ANTRT   := to_char( L_DATTRT, 'YYYY' );

	exception

		when others then
			TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			raise CALLEE_FAILED;

	end CALCDATTRT;

	-- -----------------------------------------
	-- CALCDATDBX : on rend simplement la date
	-- de debut d'exercice qu'on trouve dans la
	-- table DATDEBEX.
	-- -----------------------------------------
	procedure CALCDATDBX( P_HFILE in utl_file.file_type,
	                      P_DATDBX out date ) is

		L_PROCNAME varchar2( 16 ) := 'CALCDATDBX';

	begin

		select DATDEBEX
		into P_DATDBX
		from DATDEBEX;

	exception

		when others then
			TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			raise CALLEE_FAILED;

	end CALCDATDBX;

	-- -----------------------------------------
	-- PROMOIM1 : certaines donnees N deviennent
	-- des donnees N-1. De LIGNE_BIP vers
	-- LIGNE_BIP et de BUDCONS vers LIGNE_BIP
	-- Mise a jour des j/h N-1 pour Fact. Int.
	-- ancien systeme
	-- -----------------------------------------
	procedure PROMOIM1( P_HFILE in  utl_file.file_type ) is

		L_MOISTRT number;
		L_ANTRT number;
		L_PROCNAME varchar2(16) := 'PROMOIM1';
		L_STATEMENT varchar2(100);

	begin

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

		L_STATEMENT := 'Recherche mois de traitement';
		CALCDATTRT( P_HFILE, L_MOISTRT, L_ANTRT );
		TRCLOG.TRCLOG( P_HFILE, 'Traitement au titre du mois ' ||
		               L_MOISTRT || ' de ' || L_ANTRT );

		-- ---------------------------------------------------------------
		-- Part One : dates et type projet. En TSO-FOCUS il s'agissait de
		-- mettre a jour les colonnes "N-1" de PROJ a l'aide des colonnes
		-- "N" de PROJ2. PROJ2 étant a ce moment la "photo" de la base à
		-- la fin des traitements du mois precedant. Dans le nouveau
		-- système, on utilise une "copie" de LIGNE_BIP et de ETAPE pour
		-- accéder à "proj2". Veuillez relire le document d'architecture
		-- technique et adresser toutes remarques à B.B.
		-- ---------------------------------------------------------------
		-- TVA????    : calculer, pour chaque ligne BIP, les valeurs "N-1"
		-- des 3 dates de fin revisees des fins d'etapes de type "EP",
		-- "ED" et "AP" (s'il y a plusieurs étapes d'un meme type, c'est
		-- la plus grande qui compte car la memorisation "N-1" est au
		-- niveau "ligne bip" et non pas au niveau "etape". Resumé : pour
		-- une ligne et un type, on prend la plus grande date N et elle
		-- devient la date N-1
		-- ---------------------------------------------------------------
		-- Le code "TSO-FOCUS" mouvementait egalement le "centre activité
		-- gestionnaire du produit" de N vers N-1 mais cette donnée n'est
		-- plus dans le modèle.
		-- ---------------------------------------------------------------
		-- Remarque : dans le code FOCUS le join entre proj2 et proj était
		-- codé de telle sorte qu'un nouveau projet (présent dans proj et
		-- pas dans proj2) ne subissait aucune mise a jour
		-- ---------------------------------------------------------------
		-- La "table" proj2 est représenté dans le nouveau systeme par les
		-- tables LIGNE_BIP2 et ETAPE2.
		-- Attention : sous focus, le jour des TVA??? n'était pas stocké
		-- On reproduit
		-- ---------------------------------------------------------------
		L_STATEMENT := 'Update de LIGNE_BIP avec LIGNE_BIP2 - Dates prévues, type projet';
		update LIGNE_BIP PROJ
		set ( TDATFHN,     -- date prevue fin homo. N-1
		      PTYPEN1 ) =  -- type de projet N-1
		( select
		    TDATFHP,     -- date prevue fin homo.
		    TYPPROJ      -- type de projet
		  from LIGNE_BIP2 PROJ2
		  where PROJ.PID = PROJ2.PID ),
		TVAEDN = ( select trunc( max( ENFI ), 'month' ) from
		           ETAPE2 PROJ2 where
		           PROJ.PID = PROJ2.PID and
		           PROJ2.TYPETAP = 'ED' );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

		-- ---------------------------------------------------------------
		-- Part Two : consommation en j/h ancien systeme (le nouveau
		-- systeme est pris en charge par PROMOIM2)
		-- ---------------------------------------------------------------
		-- PCONSN1 doit contenir a la fin de la premensuelle le cumul des
		-- j/h depuis decembre A-1 (inclu) jusqu'au mois (inclu) de la
		-- mensuelle precedente. Pour ce faire, on ajoute a PDECN1 (j/h de
		-- decembre A-1) le contenu de XCUSAG0 (BUDCONS) qui contient le
		-- cumul de janvier a la derniere mensuelle (incluse). Le cas de
		-- la mensuelle de janvier est special : on prend juste PDECN1
		-- puisque le mois de decembre EST le mois de la mensuelle
		-- precedente
		-- ---------------------------------------------------------------
		-- Remarque : dans le code FOCUS le join entre proj et budcons
		-- etait code de telle sorte qu'un nouveau projet (present dans
		-- proj et pas dans budcons) ne subissait aucune mise a jour
		-- ---------------------------------------------------------------
		L_STATEMENT := 'Update LIGNE_BIP avec Cumul consommé à la dernière mensuelle';
		IF L_MOISTRT = 1 then
			update LIGNE_BIP
			set PCONSN1 = PDECN1;
		else
			update LIGNE_BIP lb                  -- qhl : 4/7/00 ajout test nvl
			set lb.PCONSN1 = ( SELECT NVL(lb.PDECN1,0) + NVL(c.CUSAG,0) FROM
			                consomme c
					WHERE lb.pid=c.pid
					AND c.annee=L_ANTRT);
		end if;
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

			-- Trace Stop
			-- ----------
			TRCLOG.TRCLOG( P_HFILE, 'Fin de ' || L_PROCNAME );

	exception

		when others then
			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
			raise CALLEE_FAILED;

	end PROMOIM1;

	-- ----------------------------------------------------------
	-- PROMOIM2 : certaines donnees N deviennent des donnees N-1.
	-- De LIGNE_BIP vers LIGNE_BIP et de BUDCONS vers LIGNE_BIP
	-- Mise a jour des j/h N-1 pour Fact. Int. nouveau systeme
	-- ----------------------------------------------------------
	procedure PROMOIM2( P_HFILE in  utl_file.file_type ) is

		L_MOISTRT number;
		L_ANTRT number;
		L_PROCNAME varchar2(16) := 'PROMOIM2';
		L_STATEMENT varchar2(100);

	begin


		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

		L_STATEMENT := 'Recherche mois de traitement';
		CALCDATTRT( P_HFILE, L_MOISTRT, L_ANTRT );
		TRCLOG.TRCLOG( P_HFILE, 'Traitement au titre du mois ' ||
		               L_MOISTRT || ' de ' || L_ANTRT );

		-- ----------------------------------------------------------
		-- Part One : client maitrise ouvrage et le flag qui signale
		-- qu'aucun changement n'a eu lieu
		-- ----------------------------------------------------------
		-- CI-DESSOUS : Commentaires lus dans source
		-- FOCUS PROMOIM2
		--*----------------------------------------------------------
		--* F.I.
		--* S'IL Y A EU CHANGEMENT DE CA DEPUIS LE MOIS - 1, C'EST-A-DIRE :
		--* SI LE CA TRAITE LE MOIS DERNIER EST DIFFERENT DU CA A IMPUTER CE MOIS
		--* ALORS ON GARDE LE STATUT PCACTOP POUR SAVOIR COMMENT IMPUTER LE
		--*       NOUVEAU CA (SI ANCIEN CA FERME : F, SI ANCIEN CA ERRONE : O)
		--* SINON ON RETABLIT LE TOP A OUVERT (O) POUR NE PAS TRAITER 2 FOIS UNE
		--*       FERMETURE DE CA (LE CA FERME EST DEJA REMPLACE PAR LE NOUVEAU)
		--*----------------------------------------------------------------------
		-- Autres commentaires trouves dans la description du segment PROJ FOCUS
		-- TOP (O:OUVERT,F:FERME) CAMO FACT.INT
		-- ----------------------------------------------------------------------
		-- Remarque : dans le code FOCUS le join entre proj2 et proj etait code
		-- de telle sorte qu'un nouveau projet (present dans proj et pas dans
		-- proj2) ne subissait aucune mise a jour
		-- ----------------------------------------------------------------------
		L_STATEMENT := 'Update LIGNE_BIP avec Ligne_BIP2 - PJCAMON1(CODCAMO),PCACTOP ';
		update LIGNE_BIP PROJ
		set ( PJCAMON1, PCACTOP ) =
		( select PROJ2.CODCAMO,  decode( PROJ.CODCAMO, PROJ2.CODCAMO, 'O',
		                                 PROJ.PCACTOP )
		  from LIGNE_BIP2 PROJ2 where PROJ.PID = PROJ2.PID );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

		-- ---------------------------------------------------------------
		-- Part Two : consomation en j/h nouveau systeme
		-- ---------------------------------------------------------------
		-- Rappel de ce qui est fait en TSO
		--   1 - extraction PID, AN, CODE, DECN1 a partir de proj
		--   2 - extraction PID, AN, CODE, CUSJH a partir de budcons
		--   3 - appariement avec jointure externe des deux cotes à la
		--       fois (mode OLD-OR-NEW)
		--   4 - addition de DECN1 et CUSJH pour donner nouveau CONSN1
		--       (CUSJH pas additionne si on est en premensuelle de
		--       janvier)
		--   5 - update de proj (CONSN1) avec creation eventuelle de
		--       ligne a cause de triplet PID, AN, CODE en provenance de
		--       BUDCONS et qui ne seraient pas dans PROJ (cas normalement
		--       tres improbable mais traite ici en l'absence de
		--       certitude)
		-- Remarque : en focus, tout PID qui n'est QUE dans Budcons n'est
		--            PAS traite : les creations de ligne dans proj a
		--            partir de budcons concernent les triplets
		--           (pid, an, code)
		-- ---------------------------------------------------------------
		-- Mise a niveau de proj a l'aide de BudCons pour regler le
		-- probleme des donnees de budcons qui ne serait pas dans proj
		-- mais seulement pour les pids presents dans proj. Cette dernière
		-- restriction n'est pas codées en SQL : on part du principe que
		-- si on trouve quelque part un pid alors il est dans LIGNE_BIP
		-- (sinon, c'est que quelqu'un a fait sous lui, et c'est vraimant
		-- dégoutant)

	exception

		when others then
			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
			raise CALLEE_FAILED;

	end PROMOIM2;

	-- -----------------------------------------
	-- ST54700B : PROMOI1 et PROMOI2
	-- -----------------------------------------
	procedure ST54700B( P_LOGDIR in varchar2 ) is

		L_HFILE utl_file.file_type;
		L_RETCOD number;

		L_PROCNAME varchar2(16) := 'ST54700B';

	begin

		-- Init de la trace
		-- ----------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
			raise_application_error( TRCLOG_FAILED_ID,
			                         'Erreur : Gestion du fichier LOG impossible',
			                         false );
		end if;

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );


		-- PROMOI1 et PROMOI2
		-- ------------------
		PROMOIM1( L_HFILE );
		PROMOIM2( L_HFILE );

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	exception

		when others then
			rollback;
			if sqlcode <> CALLEE_FAILED_ID and
			   sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                         'Erreur : consulter le fichier LOG',
				                          false );
			else
				raise;
			end if;

	end ST54700B;

	-- -------------------------------------------------------------------
	--	PACKBATCH4.purge_rejet_datestatut vidage des tables des rejets pour lignes demarrée et DATE < moismens-1
	--	PACKBATCH4.rejet_datestatut suppression lignes demarrée et DATE < moismens-1
	--      RPETA   chargement entete, etapes, tache/sous-taches,
	--                    affectations
	--	PACKBATCH4.Purge_Rejet		vidage de la table des rejets
	--	PACKBATCH4.Rejet_Version_RBIP	suppression des fichiers de versions obsoletes
	--	PACKBATCH4.Rejet_Ressource	suppression des ressources inconnues
	--	PACKBATCH4.Rejet_Ligne_BIP	suppression des lignes bip inconnues
	--	PACKBATCH4.Copie_Consomme	chargement du consomme (segments J1)
	--	PACKBATCH4.copie_datestatut      copie données des lignes en sstrait. de statut demarre et DATE < moismens-1
	--  RPINIT_AND_RPRAF  chargement charges Init. et Reste A Faire
	--                    (segments J0 et J2)
	--            RPDATE  recalcul des dates Etapes
	--            RPSSTRT table des anomalies de sous-traitance
	--            P_PROPLUS Regénération des données "récentes" de PROPLUS
	-- -------------------------------------------------------------------
	procedure ST54700E( P_LOGDIR in varchar2 ) is

		L_HFILE utl_file.file_type;
		L_RETCOD number;
		L_PROCNAMESUIVI varchar2(16) := 'alimsuivijhr';
		L_PROCNAME varchar2(16) := 'ST54700E';

	begin

		-- Init de la trace
		-- ----------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );


		-- Toute la prise en compte de PMW
		-- -------------------------------
		CONTROLE_CONSOMME( L_HFILE );
		PACKBATCH.purge_rejet_datestatut( L_HFILE );
		PACKBATCH.rejet_datestatut( L_HFILE );
		RPETA( L_HFILE );
		PACKBATCH4.Purge_Rejet( L_HFILE );
		PACKBATCH4.Rejet_Version_RBIP( L_HFILE );
		PACKBATCH4.Rejet_Ressource( L_HFILE );
		PACKBATCH4.Rejet_Ligne_BIP( L_HFILE );
		PACKBATCH4.Copie_Consomme( L_HFILE );
		PACKBATCH.copie_datestatut( L_HFILE );
		RPINIT_AND_RPRAF( L_HFILE );
		PACKBATCH4.FILTRER_CONSOMME( L_HFILE );
		RPDATE( L_HFILE );
		RPSSTRT( L_HFILE );
		P_PROPLUS( L_HFILE );
		PACKBATCH2.Alim_conso( L_HFILE );
		PACKBATCH4.ALIM_REJET( L_HFILE );

		-- Trace Start pour suivijhr
		-- -----------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAMESUIVI );

		PACK_SUIVIJHR.ALIM_SUIVIJHR;

		-- Trace Stop pour suivijhr
		-- ----------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAMESUIVI  );

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	exception

		when others then
			rollback;
			if sqlcode <> CALLEE_FAILED_ID and
			   sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

	end ST54700E;

	-- -------------------------------------------------------------------
	-- Test pour savoir si une consommation PMW doit générer une anomalie
	-- -------------------------------------------------------------------
	-- Il n'est pas possible d'invoquer une fonction utilisateur dans un
	-- ordre SQL si elle utilise des types de données autres que "natif",
	-- d'où l'absence de gestion d'exception avec la technique du fichier
	-- de LOG.
	-- -------------------------------------------------------------------
	function TESTANO( P_ASTATUT in char, P_ADATESTATUT in date,
	                  P_CDEB in date, P_CHTYP in char )
	         return number is
	begin

		if P_ASTATUT <> ' ' and -- A FAIRE : et si null value ?
		   ( trunc( P_CDEB, 'year' ) > trunc( P_ADATESTATUT, 'year' ) ) then
			return 3;
		else
			if ( P_CDEB < G_DAT0101ANM1 ) and ( P_CHTYP = '1' ) then
				return 1;
			else
				if ( P_CDEB < G_DAT0101AN ) and
				   ( P_CHTYP = '1' ) then
					return 2;
				else
					return 0;
				end if;
			end if;
		end if;

	end TESTANO;


	-- ----------------------------------------
	-- Test pour savoir si une consommation PMW
	-- est à prendre en compte ou a poubelliser
	-- ----------------------------------------
	-- ---------------------------------------------
	-- Il n'est pas possible d'invoquer une fonction
	-- utilisateur dans un ordre SQL si elle utilise
	-- des types de données autres que "natif", d'où
	-- l'absence de gestion d'exception avec la
	-- technique du fichier de LOG.
	-- ---------------------------------------------
	-- ATTENTION : LA VERSION D'ORIGINE DE CE TEST
	-- (DANS LE SOURCE FOCUS) ETAIT UN PEU
	-- DIFFERENTE : D'UN AUTRE COTE, LA VERSION EN
	-- QUESTION AVAIT ETE PREVUE POUR ETRE APPELEE
	-- PENDANT LA CONSTITUTION DE SA2 MAIS L'APPEL
	-- A ETE MIS EN COMMENTAIRE. EN PLUS, LES DEUX
	-- SOURCES CONSOMMATEUR DE SA0 et SA2 ONT ETE
	-- REGROUPES EN PL/SQL. CONSEQUENCES : ON
	-- MODIFIE LE TEST FOCUS POUR QU'UN APPEL AVEC
	-- LE TYPE 2 REPONDE TOUJOURS OK
	-- Signature d'appel cas rpinit et rpraf
	-- MLC19990330_REPTEST
	-- ---------------------------------------------
	function REPTEST( CHTYP in char,         -- type de consommation
	                  TOTALCHINIT in number, -- somme de tous les CHINIT du projet avant delete
	                  TOTALCHRAF in number,  -- somme de tous les CHRAF du projet avant delete
	                  CDEB in date,          -- debut periode de chargement
	                  MUST_ACCEPT_TYPE_2 in char ) -- pour rpinit et rpraf
	         return char is
	begin
		-- ---------------
		-- Nouveau test
		-- ---------------
		if CHTYP = '2' and MUST_ACCEPT_TYPE_2 = 'true' then
			return 'O';
		else
			if CHTYP = '2' and TOTALCHRAF = 0 then
				return 'O';
			else
			  if CHTYP = '0' and TOTALCHINIT = 0 then
					return 'O';
		/**********************************************************/
			  else
				if CDEB < G_DAT0101AN then
						return 'N';
				else
					return 'O';
				end if;
			  end if;
			end if;
		end if;
	end REPTEST;

	-- ------------------------------------------------------------
	-- RPETA   : prise en compte PMW : prise en compte des segments
	--           Etapes, taches,sous-taches et affectation
	--  - alimentation en mode annule et remplace de la table de
	--    travail BATCH_HDLA
	--  - destruction des sous-segments a partir de Etape, pour les
	--    donnees de l'annee en cours. Sous FOCUS cette destruction
	--    etait realisee avec la technique suivante : je sauvegarde
	--    ce que je NE veux PAS detruire, je detruit TOUT, je
	--    recupere ce que je NE voulais PAS detruire. En Oracle la
	--    technique est : je detruits seulement ce que je veux
	--    detruire. A ce jour (09/02/1999) il n'est pas evident que
	--    le resultat est le meme, mais il semble raisonnable de le
	--    penser, en particulier parceque le 'WHERE CDEB LT MOIS'
	--    du source focus ne sauvegarde pas les segments peres sans
	--    fils (dixit PH)
	-- - traitement d'insertion etape, tache/sous-tache et
	--   affectation. En focus, ces insertions étaient réalisées à
	--   l'aide des fichiers SAx et de la table PMW. Version
	--   ORACLE : les insertions sont réalisées en remplaçant les
	--   fichiers SAx par des requêtes ou curseur (en résumé)
	-- - mise à jour des deux dates "remontée" et "traitement" dans
	--   chaque ligne bip traitée.
	-- A REVOIR : remplacer PID in (version TP)
	-- par une jointure dans certaines requetes
	-- ------------------------------------------------------------
	procedure RPETA( P_HFILE in utl_file.file_type ) is

		L_PROCNAME varchar2(16) := 'RPETA';
		L_STATEMENT varchar2(96);

		L_DATDBX date;           -- date du début de l'exercice
		L_MAXNUMTP char(2);      -- version 'Turbo Pascal' exigée

		L_ORAERRMSG varchar2(128); -- pour insert sqlerrm, warning : 128 codé en substr

		L_INSERTED pls_integer;  -- compte insert
		L_SKIPED pls_integer;    -- compte poubelle
		L_REJECTED pls_integer;  -- compte rapport d'erreur

	begin
		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );
		DYNA_TRUNCATE( 'BATCH_CONS_SST_RES_M_BAD');
		-- recupere la date de début de l'exercice en cours
		-- ------------------------------------------------
		L_STATEMENT := 'Recherche date début d''exercice';
		CALCDATDBX( P_HFILE, L_DATDBX );
		TRCLOG.TRCLOG( P_HFILE, 'Début d''exercice : ' ||
		               to_char( L_DATDBX, 'DD/MM/YYYY' ) );

		-- valorise les deux dates '01/01/yyyy'
		-- ------------------------------------
		G_DAT0101AN   := trunc( L_DATDBX, 'year' );
		G_DAT0101ANM1 := add_months( G_DAT0101AN, -12 );

		-- recupere le filtre sur la version Turbo Pascal
		-- ----------------------------------------------
		L_STATEMENT := 'Calcul version actuelle';
		select max( NUMTP) into L_MAXNUMTP from VERSION_TP;
		if L_MAXNUMTP is null then
			raise_application_error( ERR_FONCTIONNELLE_ID,
			                         'max(NUMTP) from VERSION_TP est null !',
			                         true );
		else
			TRCLOG.TRCLOG( P_HFILE, 'Version PMW-BIP de référence : ' ||
			               L_MAXNUMTP );
		end if;

		-- Alimentation de la table de travail BATCH_HDLA
		-- voir signature MLC19990211_BATCH_HDLA
		-- Si le rollback n'est pas necessaire (ce qui est le cas
		-- puisque la table est a usage "local" en mode "replace")
		-- le truncate est beaucoup plus efficace que le delete
		-- (le truncate EST une sequence drop-create). On profite
		-- de la création de cette table pour éviter une jointure
		-- sur LIGNE_BIP quand on voudra faire le test de la mort
		-- qui tue grave : REPTEST
		-- --------------------------------------------------------
		-- TOTALCHRAF ne sert a rien. Il est théoriquement utilisé
		-- par REPTEST mais il semble bien que REPTEST ne soit
		-- jamais utilisé avec des lignes de type 2
		-- --------------------------------------------------------
		-- ATTENTION : TOTALISATIONS TOTALEMENT INUTILES : ON VEUT
		-- JUSTE SAVOIR SI LE RESULTAT EST DIFFERENT DE ZERO !
		-- PLUSIEURS AUTRES TECHNIQUES POSSIBLES
		-- peut être PLUS PERFORMANTES
		-- --------------------------------------------------------
		-- 18/05/1999 : manuel leclerc est un gros nul, signé le
		-- gros nul : il manquait la jointure externe sur la
		-- subquery pour traiter les projets sans conso !
		-- --------------------------------------------------------
		L_STATEMENT := 'Truncate Table BATCH_HDLA';
		DYNA_TRUNCATE( 'BATCH_HDLA' );

		L_STATEMENT := 'Alimentation Table BATCH_HDLA';
		insert into BATCH_HDLA ( PID, ASTATUT, ADATESTATUT,
		                   TOTALCHINIT, TOTALCHRAF )
		( select LIGNE_BIP.PID, LIGNE_BIP.ASTATUT,
		         LIGNE_BIP.ADATESTATUT,
		         TOTAUX.TOTALCHINIT, TOTAUX.TOTALCHRAF
		  from LIGNE_BIP,( select PID, sum( CHINIT ) as TOTALCHINIT,
		                               sum( CHRAF ) as TOTALCHRAF
		                   from CONS_SSTACHE_RES_MOIS
		                   group by PID ) TOTAUX
		  where LIGNE_BIP.PID = TOTAUX.PID (+) );
		-- DONE
		-- ----
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows inserted (after truncate)' );

		-- ----------------------------------------------
		-- detruit toutes les consommations de l'exercice
		-- pour les projets remontes
		-- ----------------------------------------------
		L_STATEMENT := 'Delete CONS_SSTACHE_RES_MOIS pour l''année et PID PMW';
		delete from CONS_SSTACHE_RES_MOIS
		where CDEB >= L_DATDBX and
		      PID in ( select PID from PMW_LIGNE_BIP
		               where PMWBIPVERS = L_MAXNUMTP );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows deleted' );

		-- detruit toutes les affectation sans
		-- consommations pour les projets remontes
		-- PERFORMANCE : peut être remplacer les deux
		-- select par un seul avec jointure et clause
		-- or/and ?
		-- ----------------------------------------------
		L_STATEMENT := 'Delete CONS_SSTACHE_RES sans consommation mais PID PMW';
		DELETE  FROM  CONS_SSTACHE_RES A
		where A.PID in ( select PID from PMW_LIGNE_BIP
		                 where PMWBIPVERS = L_MAXNUMTP ) and
		      not exists ( select /*+ index(B CONSSSTACHERESMOIS_PK) */ null
				   from CONS_SSTACHE_RES_MOIS B
		                   where A.PID   = B.PID  and
		                         A.ECET  = B.ECET and
		                         A.ACTA  = B.ACTA and
		                         A.ACST  = B.ACST and
		                         A.IDENT = B.IDENT );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows deleted' );

		-- detruit toutes les taches, sous-taches sans
		-- affectation pour les projets remontes
		-- ----------------------------------------------
		L_STATEMENT := 'Delete TACHE sans affectation mais PID PMW';
		DELETE  FROM  TACHE A
		WHERE  A.PID IN  ( SELECT  PID FROM  PMW_LIGNE_BIP
		                 WHERE  PMWBIPVERS = L_MAXNUMTP ) AND
		      NOT  EXISTS  ( SELECT  NULL  FROM  CONS_SSTACHE_RES B
		                   WHERE  A.PID  = B.PID  AND
		                         A.ECET = B.ECET AND
		                         A.ACTA = B.ACTA AND
		                         A.ACST = B.ACST );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows deleted' );

		-- detruit toutes les etapes sans tache pour les
		-- projets remontes
		-- ----------------------------------------------
		L_STATEMENT := 'Delete ETAPE sans tache mais PID PMW';
		delete from ETAPE A
		where A.PID in ( select PID from PMW_LIGNE_BIP
		                 where PMWBIPVERS = L_MAXNUMTP ) and
		      not exists ( select null from TACHE B
		                   where A.PID  = B.PID  and
		                         A.ECET = B.ECET );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows deleted' );

		-- Change le statut de tous les projets remontes
		-- ---------------------------------------------
		L_STATEMENT := 'Positionne PETAT a ''M'' pour les projets PMW';
		update LIGNE_BIP set PETAT = 'M'
		where PID in ( select PID from PMW_LIGNE_BIP
		               where PMWBIPVERS = L_MAXNUMTP );
		commit;

		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

		-- TD 355 : J.MAS : Mise à jour de l'origine de la saisie
		-- ---------------------------------------------
		L_STATEMENT := 'Mise à jour de l''origine de la saisie P_SAISIE';
		update LIGNE_BIP lb set lb.P_SAISIE = ( select plb.P_SAISIE from PMW_LIGNE_BIP plb where plb.PID = lb.PID and rownum=1 )
		where lb.PID in (select plb.PID from PMW_LIGNE_BIP plb );
		commit;

		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

		-- --------------------------------------------------------
		-- SA03 : segment G
		-- --------------------------------------------------------
		-- remonte les etapes, taches, sous-taches
		-- --------------------------------------------------------
		-- Le source focus presente quelques particularites
		-- interressantes :
		--    - les calculs sum(), min(), max() sont fait AVANT le
		--      filtre sur les affectations.
		--    - les segments NE sont PAS mis à jour quand ils
		--      pre-existent, c'est a dire chaque fois qu'il y a eu
		--      une consommation l'annee d'avant (autrement dit :
		--      on ne fait que des insert, pas des update)
		--    - tous doublons pendant l'insertion est poubellisé
		-- --------------------------------------------------------
		-- Le curseur principal est la liste des couples distincts
		-- PID, Etape pour lesquels existent au moins une
		-- affectation, avec la contrainte sur la validite du
		-- numero de version TP. Le source focus ajoute un filtre
		-- sur la version TP au moment de la jointure sur les
		-- affectations, mais CA on peut le virer puisqu'il n'y a
		-- qu'un seul numéro de version par fichier PMW : celui du
		--  segment A !
		-- --------------------------------------------------------
		-- Si quelqu'un veut essayer de coder ca en une seule
		-- requete ensembliste a peu pres lisible et acceptee par
		-- PL/SQL 7.3.3.4, je lui souhaite bien du plaisir
		-- --------------------------------------------------------
		-- on profite d'avoir un select et on un ordre de mise à
		-- jour pour régler le problème du numéro de version par
		-- une jointure et non par un "where pid in ( select...)"
		-- L'optimisation des performances passe peut être par
		-- l'ajout d''une colonne numtp dans toutes les tables
		-- PMW_* qui ne l'ont pas, colonnes que l'on renseignerait
		-- après le load
		-- --------------------------------------------------------
		-- Etape
		-- -----
		L_STATEMENT := 'Truncate Table BATCH_ETAPE_BAD';
		DYNA_TRUNCATE( 'BATCH_ETAPE_BAD' );
		L_STATEMENT := 'Insertion des Etapes';
		L_INSERTED := 0;
		L_SKIPED := 0;
		L_REJECTED := 0;

		declare

			L_ROW_COUNT number;
			cursor C_NEW_ETAPE is select distinct PMW_ACTIVITE.PID, ACET
			                      from PMW_ACTIVITE, PMW_AFFECTA,
			                           PMW_LIGNE_BIP
			                      where PMW_ACTIVITE.PID =  PMW_LIGNE_BIP.PID and
			                            PMW_ACTIVITE.PID = PMW_AFFECTA.PID and
			                            ACET = TCET and
			                            PMWBIPVERS = L_MAXNUMTP;

		begin

			for ONE_ETAPE in C_NEW_ETAPE loop
				-- -------------------------------------------------
				-- on n'insere pas si l'etape existe deja. La clause
				-- distinct du select elimine les tres nombreux
				-- doublons générés par la jointure sur les
				-- affectations mais IL EST POSSIBLE QU'UNE ETAPE
				-- EXISTE DEJA MALGRES LE DELETE EFFECTUE en début
				-- de traitement car ce delete ne concerne que
				-- l'année N. Si les procédures de changement
				-- d'année preservent des données N-1 pour certains
				-- projet alors ON N'INSERE PAS ! CETTE REMARQUE EST
				-- VALABLE EGALEMENT POUR LES TACHES/SOUS-TACHES ET
				-- POUR LES AFFECTATIONS
				-- Etant donné qu'on est obligé de gérer les
				-- exceptions à cause des deux clés étrangère de la
				-- table ETAPE, on ne vérifie pas la non existance
				-- par un select : on traite dup_val_on_index
				-- -------------------------------------------------
				-- On utilise les fonctions de groupe SANS se
				-- preocuper de la jointure sur les affectations,
				-- comme en FOCUS. ATTENTION : fonction de groupe
				-- sur la colonne "type etape" AIET car il est
				-- normalement interdit de selecter une colonne qui
				-- n'est pas dans la clause group by (bien que cela
				-- ne pertube pas le compilateur PL/SQL 7.3.3.4,
				-- mais que ferait-il au run-time ?). Toutes les
				-- AIET des taches d'une meme etape sont
				-- THEORIQUEMENT identiques
				-- -------------------------------------------------
				-- type etape sur 6 en focus dans Proj et PMW mais
				-- table focus type etape avec cle sur 2
				-- Migration SQL : type etape partout sur 2
				-- -------------------------------------------------
				-- Remarque : ceci n'est ni une pipe ni une requete
				-- "n-rows" : une selection sur valeur avec un group
				-- by sur les mêmes colonnes rend obligatoirement 0
				-- ou une lignes
				-- PERFORMANCES : SI LE TAUX DE SKIPED EST
				-- SIGNIFICATIF IL FAUT VERIFIER SI LA LIGNE EXISTE
				-- AVANT D ESSAYER D'INSERER (inutile de calculer le
				--  group by)
				-- -------------------------------------------------
				BEGIN
					-- **** WARNING **** : code dupliqué
					-- ci-dessous pour rapport d'erreur
					-- ---------------------------------
					INSERT  INTO  ETAPE
					(PID, ECET, EDUR, EDEB, EFIN, ENDE, ENFI, TYPETAP )
					(SELECT  PID, ACET, sum( ADUR ), min( ADEB ),
					         max( AFIN ), min( ANDE ), max( ANFI ),
					         max( substr( AIET, 1, 2 ) )
					  FROM  PMW_ACTIVITE
					  WHERE  PID = ONE_ETAPE.PID AND
					        ACET = ONE_ETAPE.ACET
					  GROUP BY  PID, ACET );
					L_INSERTED := L_INSERTED + 1;

				EXCEPTION

					-- Clé primaire dupliquée : poubelle
					-- Clé étrangère mauvaise : rapport et suite
					-- -----------------------------------------
					when dup_val_on_index then
						L_SKIPED := L_SKIPED + 1; -- poubelle

					when CONSTRAINT_VIOLATION then
						L_ORAERRMSG := sqlerrm;
						-- DUPLICATION DE CODE POUR RAPPORT D'ERREUR
						-- -----------------------------------------
						insert into BATCH_ETAPE_BAD
						( PID, ECET, EDUR, EDEB, EFIN, ENDE, ENFI,
						  TYPETAP, ERRMSG )
						( select PID, ACET, sum( ADUR ), min( ADEB ),
						         max( AFIN ), min( ANDE ), max( ANFI ),
						         max( substr( AIET, 1, 2 ) ),
						         substr( L_ORAERRMSG, 1, 128 )
						  from PMW_ACTIVITE
						  where PID = ONE_ETAPE.PID and
						        ACET = ONE_ETAPE.ACET
						  group by PID, ACET );
						L_REJECTED := L_REJECTED + 1;

					when others then
						-- Curseur : info disponible
						-- -------------------------
						TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' ||
						               L_STATEMENT || '] ( PID=' ||
						               ONE_ETAPE.PID || ', CET=' ||
						               ONE_ETAPE.ACET || ' ) : ' ||
						               SQLERRM );
						raise CALLEE_FAILED;

				end; -- block insert

			end loop; -- curseur etape

		end; -- block etape

		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || L_INSERTED ||
		               ' rows inserted. ' || L_SKIPED || ' rows skiped. ' ||
		               L_REJECTED || ' rows rejected.' );

		-- ----------------------------------------------------------
		-- Tache, sous-tache
		-- ----------------------------------------------------------
		-- On ne prend que les sous-taches affectees. En fait, on est
		-- sensé ne prendre que les taches et sous-taches du
		-- traitement ci-dessus des étapes, sans élimination des
		-- doublons mais avec un ON MATCH REJECT. PERFORMANCES : il
		-- "pourrait" être plus rapide de traiter l'insertion des
		-- taches/sous-taches toute de suite après avoir traité une
		-- etape (curseur du traitement ci-dessus) mais c'est loin
		-- d'être évident à priori.
		-- On a une clause distinct pour éliminer les nombreux
		-- doublons qui arrivent à cause de la jointure sur les
		-- affectations. En contrepartie, on ne selectionne pas les
		-- colonnes utiles, qu'on va donc devoir rechercher pour
		-- l'insertion
		-- ----------------------------------------------------------
		L_STATEMENT := 'Truncate Table BATCH_TACHE_BAD';
		DYNA_TRUNCATE( 'BATCH_TACHE_BAD' );
		L_STATEMENT := 'Insertion des Taches/Sous-taches';
		L_INSERTED := 0;
		L_SKIPED := 0;
		L_REJECTED := 0;


		declare

			L_ROW_COUNT number;

			cursor C_NEW_TACHE is select distinct PMW_ACTIVITE.PID, ACET, ACTA, ACST
			                      from PMW_ACTIVITE, PMW_AFFECTA,
			                           PMW_LIGNE_BIP
			                      where PMW_ACTIVITE.PID = PMW_LIGNE_BIP.PID and
			                            PMWBIPVERS = L_MAXNUMTP and
			                            PMW_ACTIVITE.PID = PMW_AFFECTA.PID and
			                            ACET = TCET and
			                            ACTA = TCTA and
			                            ACST = TCST;

		begin

			for ONE_TACHE in C_NEW_TACHE loop
				-- --------------------------------------------------
				-- on n'insere pas si la tache existe deja
				-- IL PEUT Y AVOIR UNE TACHE QUI EXISTE DEJA MALGRES
				-- LE DISTINCT CI-DESSUS : C'EST COMME POUR LES
				-- ETAPES : LA TACHE N'A PEUT ETRE PAS ETE DELETEE EN
				-- DEBUT DE TRAITEMENT
				-- --------------------------------------------------
				-- A la différence de l'insert ETAPE, il n'y a aucun
				-- group by a faire ici : IL Y A RISQUE POTENTIEL
				-- QU'ON ESSAYE ICI D'INSERER PLUSIEURS LIGNES D'UN
				-- COUP (s'il y a doublons sur PMW_ACTIVITE) CELA
				-- ARRIVE CHAQUE FOIS QU'UN CHEF DE PROJET REMONTE EN
				-- DOUBLE. LE CODE FOCUS POUBELISE LES TACHES EN
				-- DOUBLE ALORS QU'IL A ADDITIONNE ALEGREMENT LES
				-- ADUR POUR FAIRE EDUR. SOLUTIONS : utilisation de
				-- la pseudo-colonne de comptage du "ResultSet" pour
				-- ne prendre qu'un seul exemplaire de la
				-- tache/sous-tache
				-- --------------------------------------------------
				begin
					-- **** WARNING **** : code dupliqué
					-- ci-dessous pour rapport d'erreur
					-- ---------------------------------
					insert into TACHE
					( PID, ECET, ACTA, ACST, ADEB, AFIN, ANDE, ANFI,
					  ADUR, ASNOM, ASTA, APCP, AIST, AISTTY, AISTPID )
					( select PID, ACET, ACTA, ACST, ADEB, AFIN, ANDE,
					         ANFI, ADUR, ASNOM, ASTA, APCP, AIST,
					         DECODE(AIST, 'HEUSUP', NULL, substr(AIST,1,2)),
					         DECODE(AIST, 'HEUSUP', NULL, rtrim(substr(AIST, 3, 4 )))
					  from PMW_ACTIVITE
					  where PID = ONE_TACHE.PID and
					        ACET = ONE_TACHE.ACET and
					        ACTA = ONE_TACHE.ACTA and
					        ACST = ONE_TACHE.ACST and
					        rownum < 2 );
					L_INSERTED := L_INSERTED + 1;

				exception

					-- Clé primaire dupliquée : poubelle
					-- Clé étrangère mauvaise : rapport et suite
					-- -----------------------------------------
					when dup_val_on_index then
						L_SKIPED := L_SKIPED + 1; -- poubelle

					when CONSTRAINT_VIOLATION then
						L_ORAERRMSG := sqlerrm;
						-- DUPLICATION DE CODE POUR RAPPORT D'ERREUR
						-- -----------------------------------------
						L_REJECTED := L_REJECTED + 1;
						insert into BATCH_TACHE_BAD
						( PID, ECET, ACTA, ACST, ADEB, AFIN, ANDE, ANFI,
						  ADUR, ASNOM, ASTA, APCP, AIST, AISTTY, AISTPID,
						  ERRMSG )
						( select PID, ACET, ACTA, ACST, ADEB, AFIN, ANDE,
						         ANFI, ADUR, ASNOM, ASTA, APCP, AIST,
						         DECODE(AIST, 'HEUSUP', NULL, substr(AIST,1,2)),
					         	 DECODE(AIST, 'HEUSUP', NULL, rtrim(substr(AIST, 3, 4))),
						         substr( L_ORAERRMSG, 1, 128 )
						  from PMW_ACTIVITE
						  where PID = ONE_TACHE.PID and
						        ACET = ONE_TACHE.ACET and
						        ACTA = ONE_TACHE.ACTA and
						        ACST = ONE_TACHE.ACST and
						        rownum < 2 );

					when others then
						-- Curseur : info disponible
						-- -------------------------
						TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' ||
						               L_STATEMENT || '] ( PID=' ||
						               ONE_TACHE.PID || ', CET=' ||
						               ONE_TACHE.ACET || ', CTA=' ||
						               ONE_TACHE.ACTA || ', CST=' ||
						               ONE_TACHE.ACST || ') : ' ||
						               SQLERRM );
						raise CALLEE_FAILED;

				end; -- end block insert

			end loop; -- curseur tache

		end; -- block tache

		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || L_INSERTED ||
		               ' rows inserted. ' || L_SKIPED || ' rows skiped. ' ||
		               L_REJECTED || ' rows rejected.' );

		-- ----------------------------------------------------------
		-- SA4 : segment I AFFECTATIONS
		-- ----------------------------------------------------------
		-- Le contenu du SA4 est un sous-ensemble de PMW_AFFECTAT
		-- (segment I) restreint a l'aide d'une consultation de
		-- PMW_CONSOMM (segment J) et de BATCH_HDLA (extraction de proj,
		-- segment CONSOMM). Le probleme est que ce dernier segment
		-- (table CONS_SSTACHE_RES_MOIS) VIENT de subir un delete de
		-- la mort ! On ne sait donc PLUS reconstituer SA4. D'ou la
		-- creation de la table de travail BATCH_HDLA
		-- MLC19990211_BATCH_HDLA
		-- ----------------------------------------------------------
		-- les petites transformations sur le numéro de ressource
		-- sont faites AVANT jointure dans le source FOCUS.
		-- ----------------------------------------------------------
		-- Vérification de l'existance d'une consommation vérifiant
		-- la règle focus REPTEST : deux solutions : dans le curseur
		-- ou à chaque fetch. Choix fait à ce jour 12/02/1999 : au
		-- fetch. Autre choix le 25/03/1999 : à l'open
		-- ----------------------------------------------------------
		-- Mêmes remarques que pour l'insertion des taches : la
		-- jointure sur le niveau du dessous (ici les consommations)
		-- provoquent de nombreux doublons : on les élimine par la
		-- clause distinct et on ne récupère en fait que des clés
		-- donc a chaque fetch on relira la ligne à inserer
		-- ----------------------------------------------------------
		-- une ligne n'est à prendre en compte que si on trouve une
		-- consommation qui vérifie la règle REPTEST
		-- ----------------------------------------------------------
		L_STATEMENT := 'Truncate Table BATCH_CONS_SSTACHE_RES_BAD';
		DYNA_TRUNCATE( 'BATCH_CONS_SSTACHE_RES_BAD' );
		L_STATEMENT := 'Insertion des Affectations';
		L_INSERTED := 0;
		L_SKIPED := 0;
		L_REJECTED := 0;

		declare

			cursor C_NEW_AFF is select distinct PMW_AFFECTA.PID, TCET, TCTA, TCST, TIRES
			                    from PMW_AFFECTA, PMW_CONSOMM, PMW_LIGNE_BIP,
			                         BATCH_HDLA
			                    where PMW_AFFECTA.PID = PMW_LIGNE_BIP.PID and
			                          PMW_AFFECTA.PID = BATCH_HDLA.PID and
			                          PMW_AFFECTA.PID  = PMW_CONSOMM.PID and
			                          TCET  = CCET and
			                          TCTA  = CCTA and
			                          TCST  = CCST and
			                          TIRES = CIRES and
			                          PMWBIPVERS = L_MAXNUMTP and
			                          REPTEST( CHTYP, TOTALCHINIT,
			                                   TOTALCHRAF, CDEB, 'false' ) = 'O';



		begin

			for ONE_AFFECT in C_NEW_AFF loop

				begin

					-- ----------------------------------------------
					-- on redemande les données. On utilise la
					-- pseudo-colonne de comptage pour ne voir que
					-- le premier des doublons
					-- ----------------------------------------------
					-- **** WARNING **** : code dupliqué ci-dessous
					-- pour rapport d'erreur
					-- ----------------------------------------------
					insert into CONS_SSTACHE_RES
					( PID, ECET, ACTA, ACST, IDENT, TPLAN, TACTU, TEST )
					( select PID, TCET, TCTA, TCST,
					         decode( TIRES, '******', 0,
					                 to_number( substr( TIRES, 1, 5 ) ) ),
					         TPLAN, TACTU, TEST
					  from PMW_AFFECTA
					  where PID = ONE_AFFECT.PID and
					        TCET = ONE_AFFECT.TCET and
					        TCTA = ONE_AFFECT.TCTA and
					        TCST = ONE_AFFECT.TCST and
					        TIRES = ONE_AFFECT.TIRES and
					        rownum < 2 );

					L_INSERTED := L_INSERTED + 1;

				exception

					-- Clé primaire dupliquée : poubelle
					-- Clé étrangère mauvaise : rapport et suite
					-- -----------------------------------------
					when dup_val_on_index then
						L_SKIPED := L_SKIPED + 1; -- poubelle

					when CONSTRAINT_VIOLATION then
						L_ORAERRMSG := sqlerrm;
						-- DUPLICATION DE CODE POUR RAPPORT D'ERREUR
						-- -----------------------------------------
						L_REJECTED := L_REJECTED + 1;
						insert into BATCH_CONS_SSTACHE_RES_BAD
						( PID, ECET, ACTA, ACST, IDENT, TPLAN, TACTU,
						  TEST, ERRMSG )
						( select PID, TCET, TCTA, TCST,
						         decode( TIRES, '******', 0,
						                 to_number( substr( TIRES, 1, 5 ) ) ),
						         TPLAN, TACTU, TEST,
						         substr( L_ORAERRMSG, 1, 128 )
						  from PMW_AFFECTA
						  where PID = ONE_AFFECT.PID and
						        TCET = ONE_AFFECT.TCET and
						        TCTA = ONE_AFFECT.TCTA and
						        TCST = ONE_AFFECT.TCST and
						        TIRES = ONE_AFFECT.TIRES and
						        rownum < 2 );

					when others then
						-- Curseur : info disponible
						-- -------------------------
						TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' ||
						               L_STATEMENT || '] ( PID=' ||
						               ONE_AFFECT.PID || ', CET=' ||
						               ONE_AFFECT.TCET || ', CTA=' ||
						               ONE_AFFECT.TCTA || ', CST=' ||
						               ONE_AFFECT.TCST || ', IDT=' ||
						               ONE_AFFECT.TIRES || ') : ' || SQLERRM );
						raise CALLEE_FAILED;

				end; -- end block insert

			end loop; -- curseur affectation

		end; -- end block affectation

		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || L_INSERTED ||
		               ' rows inserted. ' || L_SKIPED || ' rows skiped. ' ||
		               L_REJECTED || ' rows rejected.' );

		-- --------------------------------------------
		-- TRAITEMENT DES DATES DE TRANSFERTS ET DE
		-- TRAITEMENTS PMW-BIP
		-- --------------------------------------------
		-- Ce qu'on appelle un "projet remonté" dans la
		-- suite des traitements est un projet present
		-- dans le SA6-SA7
		-- --------------------------------------------
		-- ATTENTION : SI LES INFOS PMW REMONTENT EN
		-- DOUBLE LA SUBQUERY REND PLUSIEURS LIGNES
		-- PROTECTION PAR COMPTAGE RESULT-SET
		-- --------------------------------------------
		L_STATEMENT := 'Mise à jour des dates de traitement';
		update LIGNE_BIP
		set TTRMENS = (select NVL(trunc(dertrait), trunc(sysdate)) from datdebex),
		    TTRFBIP = ( select to_date( to_char( sqrt( P_AA_CARRE ), 'FM00' ) ||
		                                to_char( sqrt( P_MM_CARRE ), 'FM00' ) ||
		                                to_char( sqrt( P_JJ_CARRE ), 'FM00' ),
		                             'RRMMDD' )
		                from PMW_LIGNE_BIP
		                where LIGNE_BIP.PID = PMW_LIGNE_BIP.PID and rownum < 2 )
		where PID in ( select PID from PMW_LIGNE_BIP
		               where PMWBIPVERS = L_MAXNUMTP );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );

		exception

			when others then
				if sqlcode <> CALLEE_FAILED_ID then
					TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT ||
					               '] : ' || SQLERRM );
				end if;
				TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;

	end RPETA;

	-- -----------------------------------------------------------
	-- UPDATE_OR_INSERT_CUSAG
	-- Routine   de mise à jour effective de CONS_SSTACHE_RES_MOIS
	-- en ce qui concerne le "segment J1" (conso.) de PMW_CONSOMM
	-- Cette routine se VAUTRE si clés étrangères ne sont pas
	-- correctes car l'appelant est censé avoir vérifié qu'une
	-- affectation existe. PERFOMANCES : si l'appelant ne fait
	-- pas cette vérification, il faut la faire içi mais gérer
	-- l'exception de manière applicative
	-- -----------------------------------------------------------
	procedure UPDATE_OR_INSERT_CUSAG( P_HFILE in utl_file.file_type,
	                                  P_PID in char, P_ET in char, P_TA in char,
	                                  P_ST in char, P_IDENT in number, P_CDEB in date,
	                                  P_CDUR in number, P_CUSAG in number,
	                                  P_NEW_CONSO out boolean ) is

		L_PROCNAME varchar2( 32 ) := 'UPDATE_OR_INSERT_CUSAG';
		L_STATEMENT varchar2( 96 );

		L_CDEB date; -- au premier jour du mois, par précaution

	begin

		L_STATEMENT := 'Essai d''Update';
		L_CDEB := trunc( P_CDEB, 'month' );

		update CONS_SSTACHE_RES_MOIS
		set CDUR  = P_CDUR,
		    CUSAG = CUSAG + P_CUSAG
		where PID = P_PID and
		      ECET = P_ET and
		      ACTA = P_TA and
		      ACST = P_ST and
		      IDENT = P_IDENT and
		      CDEB = L_CDEB;
		if sql%notfound then
			L_STATEMENT := 'No Data Found : Insert';
			-- A ce jour, 29/03/1999, les colonnes CHINIT, CHRAF et
			-- SHPROUF sont mises à zéro lors de l'insert
			-- ----------------------------------------------------
			insert into CONS_SSTACHE_RES_MOIS
			( PID, ECET, ACTA, ACST, IDENT, CDEB, CDUR, CUSAG, CHINIT, CHRAF )
			VALUES ( P_PID, P_ET, P_TA, P_ST, P_IDENT, L_CDEB,
			         P_CDUR, P_CUSAG, 0, 0 );
			P_NEW_CONSO := true;
		else
			P_NEW_CONSO := false;
		end if;

	exception

		when others then
			TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT ||
			               '] : ( PID =' || P_PID || ', ET=' || P_ET ||
			               ', TA=' || P_TA || ', ST=' || P_ST || ', IDENT=' || P_IDENT ||
			               ', CDEB=' || P_CDEB || ', CDUR=' || P_CDUR ||
			               ', CUSAG=' || P_CUSAG || ' ) : ' || SQLERRM );
			raise CALLEE_FAILED;

	end UPDATE_OR_INSERT_CUSAG;

	-- ----------------------------------------------------------------
	-- GET_CJOUR    Petite fonction utilitaire qui lit CALENDRIER et
	-- considère que les mois absents font 21 jours ouvrés. Cette
	-- fonction n'impose pas que la date soit celle du premier jour du
	-- mois
	-- ----------------------------------------------------------------
	-- Le trunc est donc effectué par précaution. CETTE FONCTION EST
	-- APPELLEE UN GRAND NOMBRE DE FOIS ET UTILISE UNE TABLE : UNE
	-- OPTIMISATION DE TYPE "CACHE-MEMOIRE" EST A CONSIDERER.
	-- ----------------------------------------------------------------
	function GET_CJOUR( P_HFILE in utl_file.file_type, DTMONTH in date )
	         return number is

		L_CJOUR number;
		L_PROCNAME varchar2(16) := 'GET_CJOUR';

	begin

		select CJOURS into L_CJOUR from calendrier
		where CALANMOIS = trunc( DTMONTH, 'month' );
		return L_CJOUR;

	exception

		when no_data_found then
			return 21;

		when others then

			TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [date=' || DTMONTH ||
			              '] : ' || SQLERRM );
			raise CALLEE_FAILED;

	end GET_CJOUR;


	-- -----------------------------------------
	-- CALCJOUROUVR Petite fonction utilitaire
	-- qui calcule le nombre de jour ouvrés
	-- entre deux dates en enlevant les
	-- wekk end et les jours fériés. Les deux
	-- bornes sont incluses dans le compte
	-- ATTENTION : cette fonction a besoin d'une
	-- table des jours fériés.
	-- CETTE FONCTION EST APPELLEE UN GRAND
	-- NOMBRE DE FOIS ET UTILISE UNE TABLE : UNE
	-- OPTIMISATION DE TYPE "CACHE-MEMOIRE" EST
	-- A CONSIDERER.
	-- -----------------------------------------
	function CALCJOUROUVR( P_HFILE in utl_file.file_type,
	                       DTSTART in date )
		return number is

		L_PROCNAME varchar2(16) := 'CALCJOUROUVR';
		L_STATEMENT varchar2(64);

		NBJOURTOTAL number;       -- nombre de jour restant à examiner
		NBJOUROUVR number;        -- nombre de jour au boulot
		DAYSTART date;            -- ramené à la journée pour éviter ennuis
		DAYEND date;              -- ramené à la journée pour éviter ennuis
		DAYOFWEEK char(1);        -- jour de la semaine Lundi = '1', Dimanche = '7'
		ROWCOUNT number;          -- résultat du select count(*) fériés

	begin

		L_STATEMENT := 'Calcul date';
		DAYSTART := DTSTART;
		DAYEND   := last_day( DAYSTART );
		NBJOURTOTAL := DAYEND - DAYSTART + 1;
		NBJOUROUVR := 0;

		-- Date de fin strictement plus petite que
		-- date de début : pas d'entrée en boucle
		-- ---------------------------------------

		while NBJOURTOTAL > 0 loop
			-- On n'ajoute un jour que si on n'est pas
			-- sur un week-end ou un jour ferié
			-- ---------------------------------------
			-- Lundi = '1', Dimanche = '7'
			-- ---------------------------------------
			L_STATEMENT := 'Get Day Of Week';
			select to_char( DAYSTART, 'D' ) into DAYOFWEEK
			from dual;

			if DAYOFWEEK <> '6' and DAYOFWEEK <> '7' then
				-- pas à la maison, peinard, quoique
				-- si peut être quand même
				-- ---------------------------------
				L_STATEMENT := 'Count Jour Fériés';
				select count(*) into ROWCOUNT
				from JFERIE where DATJFER = DAYSTART;
				if ROWCOUNT = 0 then
					-- bon, au boulot, alors
					-- ---------------------
					NBJOUROUVR := NBJOUROUVR + 1;
				end if;
			end if;
			NBJOURTOTAL := NBJOURTOTAL - 1;
			DAYSTART := DAYSTART + 1;
		end loop;

		return NBJOUROUVR;

	exception

		when others then

			TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT || '] : ' ||
			               ' (Date Start =' || DTSTART || ') : ' ||
			               SQLERRM );
			raise CALLEE_FAILED;

	end CALCJOUROUVR;

	-- -----------------------------------------------------------
	-- LOAD_CONSO_INIT_RAF
	-- Routine de mise à jour effective de CONS_SSTACHE_RES_MOIS
	-- en ce qui concerne les "segments J0 et J2" de PMW_CONSOMM
	-- Le CUSAG en paramètre va aller soit vers CHINIT soit vers
	-- CHRAF en fonction de CHTYP
	-- -----------------------------------------------------------
	procedure LOAD_CONSO_INIT_RAF( P_HFILE in utl_file.file_type,
	                               P_PID in char, P_ET in char, P_TA in char,
	                               P_ST in char, P_IDENT in char, P_CDEB in date,
	                               P_CDUR in number, P_CUSAG in number,
	                               P_CHTYP in char,
	                               P_RESULT out char,
                                   P_NUMERO_PASSE in pls_integer ) is

		L_PROCNAME varchar2(48) := 'LOAD_CONSO_INIT_RAF' || P_NUMERO_PASSE;
		L_STATEMENT varchar2(64);

		L_CDEB date;          -- au premier jour du mois, par précaution
		L_IDENT number ( 5 ); -- ressource

	begin

		L_STATEMENT := 'Decode Ressource';
		select decode( P_IDENT, '******', 0,
		               to_number( substr( P_IDENT, 1, 5 ) ) )
		into L_IDENT from dual;

		L_CDEB := trunc( P_CDEB, 'month' );
		L_STATEMENT := 'Update';

--  DEBUGING CODE
--		TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT || '] : ' ||
--		               ' (PID=' || P_PID || ', ET=' || P_ET || ', TA=' ||
--		               P_TA || ', ST=' || P_ST || ', IDENT=' || P_IDENT ||
--		               ', CDEB=' || P_CDEB || ', CDUR=' || P_CDUR ||
--		               ', CHRAF=' || P_CUSAG || ')' );
--		P_RESULT := 'U';
--		return;
--  DEBUGING CODE

		-- on essaye de ne mettre à jour que CDUR et ou CHINIT ou
		-- CHRAF en fonction du type d'enreg. traité
		-- ------------------------------------------------------
		update CONS_SSTACHE_RES_MOIS set
		CDUR   = P_CDUR,
		CHINIT = decode( P_CHTYP, '0',
		                 decode( P_NUMERO_PASSE, 1, 0, P_CUSAG + CHINIT ),
		                 CHINIT ),
		CHRAF  = decode( P_CHTYP, '2',
		                 decode( P_NUMERO_PASSE, 1, 0, P_CUSAG + CHRAF )
		               , CHRAF )
		where PID = P_PID and
		      ECET = P_ET and
		      ACTA = P_TA and
		      ACST = P_ST and
		      IDENT = L_IDENT and
		      CDEB = L_CDEB;
		if sql%notfound then
			L_STATEMENT := 'Echec Update : Insert';

			-- on ajoute avec CUSAG à 0 et CHINIT ou CHRAF aussi
			-- en fonction du type d'enreg. traité
			-- -------------------------------------------------
			insert into CONS_SSTACHE_RES_MOIS
			( PID, ECET, ACTA, ACST, IDENT, CDEB, CDUR, CUSAG, CHINIT, CHRAF )
			VALUES ( P_PID, P_ET, P_TA, P_ST, L_IDENT, L_CDEB,
			         P_CDUR, 0,
			         decode( P_CHTYP, '0',
			                 decode( P_NUMERO_PASSE, 1, 0, P_CUSAG ),
			                 0 ),
			         decode( P_CHTYP, '2',
			                 decode( P_NUMERO_PASSE, 1, 0, P_CUSAG ),
			                 0 ) );
			P_RESULT := 'I';
		else
			P_RESULT := 'U';
		end if;
		return;

	exception

		when CONSTRAINT_VIOLATION then

			-- Trés certainement à cause de rpeta. Soit problème dans
			-- le fichier PMW (segment G, I, J incohérants) Soit
			-- problème sur les clé étrangère type d'étapes et
			-- ressources. La vrai cause du problème a été stockée
			-- dans BATCH_ETAPE_BAD et/ou dans BATCH_TACHE_BAD
			-- et/ou dans BATCH_CONS_SSTACHE_RES_BAD
			-- ------------------------------------------------------
			if P_NUMERO_PASSE = 1 then
				insert into BATCH_REJETSRP
				( PID, ECET, ACTA, ACST, IDENT, ERRMSG )
				VALUES ( P_PID, P_ET, P_TA, P_ST, P_IDENT,
				         'REJET POUR AFFECTATION ABSENTE' );
			end if;
			P_RESULT := 'R';
			return;

		when others then

			TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT || '] : ' ||
			               ' (PID=' || P_PID || ', ET=' || P_ET || ', TA=' ||
			               P_TA || ', ST=' || P_ST || ', IDENT=' || P_IDENT ||
			               ', CDEB=' || P_CDEB ||') : ' || SQLERRM );
			raise CALLEE_FAILED;

	end LOAD_CONSO_INIT_RAF;

	-- ------------------------------------------------------------------
	-- RPINIT_AND_RPRAF
	--           prise en compte PMW : prise en compte des consommations
	--           de type 0 et 2
	-- ------------------------------------------------------------------
	-- ATTENTION : $rpinit et $rpraf sont deux programme identique à la
	-- virgule près sauf que :
	--      1   - $rpinit concerne chinit (avec les segments PMW J0 alors
	--            que $rpraf concerne chraf avec les segments PMW J2
	--      2   - $rpinit prend en entrée SA0 alors que $rpraf prend SA2
	--      3   - SA0 est constitué avec le filtre reptest. SA4 aurait pu
	--            sauf que l'appel est en commentaire !
	-- ------------------------------------------------------------------
	-- voir aussi signature MLC19990330_REPTEST
	-- ------------------------------------------------------------------
	-- Deux passes : une pour remettre à zéro et une pour cumuler car
	-- on veut cumuler les doublons d'un traitements mais pas avec les
	-- données du traitements d'avant !
	-- ------------------------------------------------------------------
	-- ATTENTION : LA PRISE EN COMPTE DU RESTE-A-FAIRE NE FILTRE PAS AVEC
	-- LE TEST DE LA MORT QUI TUE MORTELLEMENT : REPTEST. C'EST PAS
	-- CONFONDRE AVEC LA CHINIT
	-- ------------------------------------------------------------------
	-- En focus on part du SAx : extraction de PMW_CONSOMM avec
	-- restrictions suivantes :
	--      - Le fameux test REPTEST pour refuser de prendre en compte
	--        certaines consommmations ($rpinit)
	--      - Elimination des code BIP pour lesquels la remontée s'est
	--        effetuée avec une mauvaise version de PMW-Turbo Pascal
	--      - Uniquement les consommations de type 0 ($rpinit) 1 ($rpraf)
	--      - Elimination des consommations nulles
	-- ------------------------------------------------------------------
	-- A la différence de $rpcons, si on ne trouve pas CDEB dans
	-- calendrier on n'en fait pas un fromage, on prend 21 jours ouvrés.
	-- Nota : il y a d'autres différences (beaucoup plus importantes,
	-- comme par exemple le test qui va provoquer un éclatement en
	-- plusieurs mois et qui n'est pas le même dans rpcons et rpinit,
	-- ce qui signifie qu'à CDEB, CDUR et CUSAG identiques, la création
	-- ou non de ligne CDEB+n dépend de CHTYP) (sans parler, si quand
	-- même, du fait que rpinit définit une notion de charge journalière
	-- traduisant le travail à XX% dont rpcons se moque comme de sa
	-- première chemise)
	-- ------------------------------------------------------------------
	-- $rpinit et $rpraf sont deux programmes (suite du commentaires
	-- finalement supprimée...)
	-- ------------------------------------------------------------------
	-- ATTENTION : PAC. Les calculs focus sont fait trés délicat à
	-- reproduire en SQL : On ne sait pas trops qu'elle est la
	-- signification PRECISE du type D8.2. Je penche pour
	-- l'hypothèse suivante : 8 chiffres significatifs, mais
	-- format d'affichage avec deux décimales. Cela expliquerait
	-- pourquoi un CUSAG de 1 et un CDUR de 220 donne une charge
	-- journalière non nulle. Ce type de comportement n'est pas
	-- facile à reproduire en SQL car il faudrait effectuer un
	-- arrondi dépendant du nombre de chiffre significatif du résultat !
	-- Solution actuelle : étant donné que le problème ne semble
	-- apparaître que pour les charges journalières trés petites
	-- du type 0,00xxxxx
	-- on demande à ORACLE une précision maximale
	-- -----------------------------------------------------------------
	procedure RPINIT_AND_RPRAF( P_HFILE in utl_file.file_type ) is

		L_PROCNAME varchar2( 32 ) := 'RPINIT_AND_RPRAF';
		L_STATEMENT varchar2( 128 );

		L_DATDBX date;           -- date du début de l'exercice
		L_MAXNUMTP char(2);      -- version courante attendue pour PMWBIPVERS
		L_DAT0101AN date;        -- le 01/01 de l'année de l'exercice
		L_DAT0101ANM1 date;      -- le 01/01 de l'année d'avant celle de l'exercice
		L_JOUROUVRES number;     -- jour ouvrés de CDEB jusqu'à la fin du mois
		L_CJOUR number;           -- nombre de jour ouvrés d'un mois dans calendrier
		L_CHARGE_ONE_MONTH number( 8, 2 ); -- mis en base pour un mois
		L_CHARGE_ALL_MONTH number( 8, 2 ); -- cumul du déjà affecté
		L_DUREE_NON_AFFECTEE number;       -- jour ouvrés non encore chargés
		L_NEXT_MONTH date;                 -- un des mois suivants celui de CDEB
		L_CHARGE_MOYENNE number;           -- CUSAG / CDUR, précision maximale
		                                   -- CUSAG = 1, CDUR = 220 ==> 0,00454545...

		L_NUMERO_PASSE pls_integer;    -- passe 1 : remise à 0, passe 2 : cumul

		L_RESULT char( 1 );           -- résultat essai d'insert
		L_INSERTED pls_integer;       -- compte insert
		L_UPDATED pls_integer;        -- compte update
		L_REJECT pls_integer;         -- compte rejets
		L_SPLIT_INSERTED pls_integer; -- compte insert répartition
		L_SPLIT_UPDATED pls_integer;  -- compte update répartition
		L_SPLIT_REJECT pls_integer;   -- compte rejets répartition
		L_TOTALCONSO pls_integer;     -- compte ligne du curseur

		cursor C_NEW_INRA is select PMW_CONSOMM.PID, CCET, CCTA, CCST,
		                            CIRES , CDEB, CDUR, CUSAG, CHTYP
		                     from PMW_CONSOMM, BATCH_HDLA, PMW_LIGNE_BIP
		                     where PMW_CONSOMM.PID = BATCH_HDLA.PID and
		                           PMW_CONSOMM.PID = PMW_LIGNE_BIP.PID and
		                           PMWBIPVERS =  L_MAXNUMTP and
		                           ( CHTYP = '0' or CHTYP = '2' ) and
		                           CUSAG <> 0 and
		                           REPTEST( CHTYP, TOTALCHINIT, TOTALCHRAF, CDEB, 'true' ) = 'O';

	begin

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

		-- recupere la date de début de l'exercice en cours
		-- ------------------------------------------------
		L_STATEMENT := 'Recherche date début d''exercice';
		CALCDATDBX( P_HFILE, L_DATDBX );
		TRCLOG.TRCLOG( P_HFILE, 'Début d''exercice : ' ||
		                        to_char( L_DATDBX, 'DD/MM/YYYY' ) );

		-- valorise les deux dates '01/01/yyyy'
		-- ------------------------------------
		G_DAT0101AN   := trunc( L_DATDBX, 'year' );
		G_DAT0101ANM1 := add_months( G_DAT0101AN, -12);

		-- recupere le filtre sur la version Turbo Pascal
		-- ----------------------------------------------
		L_STATEMENT := 'Calcul version actuelle';
		select max( NUMTP) into L_MAXNUMTP from VERSION_TP;
		if L_MAXNUMTP is null then
			raise_application_error( ERR_FONCTIONNELLE_ID,
							 'max(NUMTP) from VERSION_TP est null !', true );
		else
			TRCLOG.TRCLOG( P_HFILE, 'Version PMW-BIP de référence : ' || L_MAXNUMTP );
		end if;

		L_STATEMENT := 'Ouverture Curseur des Consommations (passe 1)';
		L_NUMERO_PASSE := 1;

		<<one_more_time>>

		L_INSERTED    := 0;
		L_UPDATED     := 0;
		L_REJECT      := 0;
		L_SPLIT_INSERTED := 0;
		L_SPLIT_UPDATED  := 0;
		L_SPLIT_REJECT   := 0;
		L_TOTALCONSO     := 0;

		-- boucle de prise en compte des consommations
		-- -------------------------------------------
		for ONE_INRA in C_NEW_INRA loop

			L_TOTALCONSO := L_TOTALCONSO + 1;

--	DEBUGING CODE
--			if ONE_INRA.PID <> 'A24' or ONE_INRA.CHTYP <> '2' or
--			   ONE_INRA.CIRES <> '08505*' or
--			   ONE_INRA.CDEB <> to_date( '01/01/1999', 'DD/MM/YYYY' ) then
--				goto END_LOOP_RPINIRAF;
--			end if;
--	DEBUGING CODE

			-- recherche du nb de jour ouvrés total théorique
			-- ----------------------------------------------
			L_CJOUR := GET_CJOUR( P_HFILE, ONE_INRA.CDEB );

			-- Analyse du cas
			-- --------------
			L_JOUROUVRES := CALCJOUROUVR( P_HFILE, ONE_INRA.CDEB );

			-- si la durée est plus petite ou égale, on balance tout et c'est fini
			-- -------------------------------------------------------------------
			if ONE_INRA.CDUR <= L_JOUROUVRES then

				LOAD_CONSO_INIT_RAF( P_HFILE,
				                     ONE_INRA.PID, ONE_INRA.CCET, ONE_INRA.CCTA,
				                     ONE_INRA.CCST, ONE_INRA.CIRES, ONE_INRA.CDEB,
				                     L_CJOUR, ONE_INRA.CUSAG, ONE_INRA.CHTYP,
				                     L_RESULT, L_NUMERO_PASSE );

				if L_RESULT = 'I' then
					L_INSERTED := L_INSERTED + 1;
				else
					if L_RESULT = 'U' then
						L_UPDATED := L_UPDATED + 1;
					else
						L_REJECT := L_REJECT + 1;
					end if;
				end if;

			else

				-- il FAUT étaler sur plusieurs mois
				-- ---------------------------------
				-- On commence par remplir le premier mois
				-- ---------------------------------------
				-- Reproduction de l'algo focus qui garantit une
				-- sous-estimation systématique des charges afin
				-- d'éviter un reliquat négatif sur le dernier
				-- mois : trunc au lieu de round pour la charge
				-- a affecter
				-- ---------------------------------------------
				L_CHARGE_MOYENNE := ONE_INRA.CUSAG / ONE_INRA.CDUR;
				L_CHARGE_ONE_MONTH :=  trunc( L_CHARGE_MOYENNE * L_JOUROUVRES, 2 );
				LOAD_CONSO_INIT_RAF( P_HFILE,
				                     ONE_INRA.PID, ONE_INRA.CCET, ONE_INRA.CCTA,
				                     ONE_INRA.CCST, ONE_INRA.CIRES, ONE_INRA.CDEB,
				                     L_CJOUR, L_CHARGE_ONE_MONTH, ONE_INRA.CHTYP,
				                     L_RESULT, L_NUMERO_PASSE );

				if L_RESULT = 'I' then
					L_INSERTED := L_INSERTED + 1;
				else
					if L_RESULT = 'U' then
						L_UPDATED := L_UPDATED + 1;
					else
						L_REJECT := L_REJECT + 1;
						-- Ajout manuel L. 20-05-1999 : comme en focus
						-- on n'essaye pas de traiter la suite de la
						-- répartition : ca ne va pas le faire, donc
						-- on passe à l'enreg. suivant
						-- -------------------------------------------
						goto END_LOOP_RPINIRAF;
					end if;
				end if;

				-- initialise compteurs
				-- --------------------
				L_CHARGE_ALL_MONTH := L_CHARGE_ONE_MONTH;
				L_DUREE_NON_AFFECTEE := ONE_INRA.CDUR - L_JOUROUVRES;
				L_NEXT_MONTH := trunc( add_months( ONE_INRA.CDEB, 1 ), 'month' );

				-- On boucle tant qu'il reste une période non chargée
				-- --------------------------------------------------
				while L_DUREE_NON_AFFECTEE > 0 loop

					L_CJOUR := GET_CJOUR( P_HFILE, L_NEXT_MONTH );
					if L_DUREE_NON_AFFECTEE <= L_CJOUR then

						-- C'est le dernier mois, on balance le reste
						-- ------------------------------------------
						LOAD_CONSO_INIT_RAF( P_HFILE,
						                     ONE_INRA.PID, ONE_INRA.CCET,
						                     ONE_INRA.CCTA, ONE_INRA.CCST,
						                     ONE_INRA.CIRES, L_NEXT_MONTH,
						                     L_CJOUR,
						                     ONE_INRA.CUSAG - L_CHARGE_ALL_MONTH,
						                     ONE_INRA.CHTYP, L_RESULT,
						                     L_NUMERO_PASSE );

						if L_RESULT = 'I' then
							L_SPLIT_INSERTED := L_SPLIT_INSERTED + 1;
						else
							if L_RESULT = 'U' then
								L_SPLIT_UPDATED := L_SPLIT_UPDATED + 1;
							else
								L_SPLIT_REJECT := L_SPLIT_REJECT + 1;
								-- Ajout manuel L. 20-05-1999 : comme en focus
								-- on n'essaye pas de traiter la suite de la
								-- répartition : ca ne va pas le faire, donc
								-- on passe à l'enreg. suivant.
								-- Remarque (en passant) : ce code ne
								-- normalement pas être atteint, puisque le
								-- goto est codé à la première tentative
								-- -------------------------------------------
								goto END_LOOP_RPINIRAF;
							end if;
						end if;

						-- force la sortie de boucle
						-- -------------------------
						exit;

					else

						-- on charge le mois
						-- -----------------
						L_CHARGE_ONE_MONTH :=
						        trunc(  L_CHARGE_MOYENNE * L_CJOUR, 2 );
						LOAD_CONSO_INIT_RAF( P_HFILE,
						                     ONE_INRA.PID, ONE_INRA.CCET,
						                     ONE_INRA.CCTA, ONE_INRA.CCST,
						                     ONE_INRA.CIRES, L_NEXT_MONTH,
						                     L_CJOUR, L_CHARGE_ONE_MONTH,
						                     ONE_INRA.CHTYP, L_RESULT,
						                     L_NUMERO_PASSE );
						if L_RESULT = 'I' then
							L_SPLIT_INSERTED := L_SPLIT_INSERTED + 1;
						else
							if L_RESULT = 'U' then
								L_SPLIT_UPDATED := L_SPLIT_UPDATED + 1;
							else
								L_SPLIT_REJECT := L_SPLIT_REJECT + 1;
								-- Ajout manuel L. 20-05-1999 : comme en focus
								-- on n'essaye pas de traiter la suite de la
								-- répartition : ca ne va pas le faire, donc
								-- on passe à l'enreg. suivant.
								-- Remarque (en passant) : ce code ne
								-- normalement pas être atteint, puisque le
								-- goto est codé à la première tentative
								-- -------------------------------------------
								goto END_LOOP_RPINIRAF;
							end if;
						end if;
						-- les compteurs
						-- -------------
						L_CHARGE_ALL_MONTH := L_CHARGE_ALL_MONTH +
						                      L_CHARGE_ONE_MONTH;
						L_DUREE_NON_AFFECTEE := L_DUREE_NON_AFFECTEE -
						                        L_CJOUR;
						L_NEXT_MONTH := add_months( L_NEXT_MONTH, 1 );

					end if; -- if dernier mois

				end loop; -- loop si reste duréee non chargée

			end if; -- if tout tient sur le premier mois

			-- ********************
			-- FIN DE BOUCLE
			-- ********************
			<<END_LOOP_RPINIRAF>>
			null;

		end loop; -- curseur conso init

		if L_NUMERO_PASSE = 1 then
			L_STATEMENT := 'Ouverture Curseur des Consommations (passe 2)';
			L_NUMERO_PASSE := 2;
			goto ONE_MORE_TIME;
		end if;

		-- Rapport détaillé
		-- ----------------
		TRCLOG.TRCLOG( P_HFILE, 'Lignes parcourues (Curseur): ' || L_TOTALCONSO );
		TRCLOG.TRCLOG( P_HFILE, 'Lignes insérées (Date d''origine) : ' || L_INSERTED );
		TRCLOG.TRCLOG( P_HFILE, 'Lignes mises à jour (Date d''origine) : ' || L_UPDATED );
		TRCLOG.TRCLOG( P_HFILE, 'Lignes insérées (Répartition) : ' || L_SPLIT_INSERTED );
		TRCLOG.TRCLOG( P_HFILE, 'Lignes mises à jour (Répartition) : ' || L_SPLIT_UPDATED );
		TRCLOG.TRCLOG( P_HFILE, 'Lignes rejetées (Date d''origine) : ' || L_REJECT );
		TRCLOG.TRCLOG( P_HFILE, 'Lignes rejetées (Répartition) : ' || L_SPLIT_REJECT );

		commit;

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );

	exception

		when others then
			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
			raise CALLEE_FAILED;

	end RPINIT_AND_RPRAF;

	-- ------------------------------------------------------------------
	-- RPDATE  : mise à jour du segment ETAPE avec les nouvelles dates
	--           mini et maxi de début et de fin des sous-taches de
	--           l'étape (dates initiales et dates révisées)
	-- ------------------------------------------------------------------
	-- PERFORMANCE : UPDATE DE JOINTURE A ESSAYER
	-- ------------------------------------------------------------------
	procedure RPDATE( P_HFILE in utl_file.file_type ) is

		L_PROCNAME varchar2(16) := 'RPDATE';
		L_STATEMENT varchar2(64);

		L_MAXNUMTP char(2);   -- version courante attendue pour PMWBIPVERS

	begin

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

		-- recupere le filtre sur la version Turbo Pascal
		-- ----------------------------------------------
		L_STATEMENT := 'Calcul version actuelle';
		select max( NUMTP) into L_MAXNUMTP from VERSION_TP;
		if L_MAXNUMTP is null then
			raise_application_error( ERR_FONCTIONNELLE_ID,
							 'max(NUMTP) from VERSION_TP est null !', true );
		else
			TRCLOG.TRCLOG( P_HFILE, 'Version PMW-BIP de référence : ' || L_MAXNUMTP );
		end if;

		-- recalcule les dates des étapes pour laquelle
		-- le PID était présent dans la remontée
		-- --------------------------------------------
		L_STATEMENT := 'Update Dates Etapes';
		update ETAPE
		set ( EDEB, EFIN, ENDE, ENFI ) =
		    ( select min( ADEB ), max( AFIN ), min( ANDE ), max( ANFI )
		      from tache where ETAPE.PID = TACHE.PID and
		                       ETAPE.ECET = TACHE.ECET )
		where PID in ( select PID from PMW_LIGNE_BIP
	                     where PMWBIPVERS = L_MAXNUMTP );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );

	exception

		when others then

			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
			raise CALLEE_FAILED;

	end RPDATE;

	-- -------------------------------------------------------------------
	-- RPSSTRT : mettre à jour la table SSTRT en fonction du contenu de
	--           proj. Cette table ne sert certainement à rien d'un point
	--           de vue FONCTIONNEL(comme de NOMBREUSES autres tables).
	--           Elle existe sous focus pour des raison de performance.
	--           Procédure reprise à l'identique sous oracle pour la
	--           raison fondamentale suivante : ET POURQUOI PAS ?
 	-- -------------------------------------------------------------------
	-- AUSSI : mettre des cusag a 0 si c'est illégal
 	-- -------------------------------------------------------------------
	-- Question : les traitements précédants testent parfois la valeur de
	-- CUSAG, ne devrait-on pas inverser l'ordre des traitements.
	-- Réponse : et ta soeur ?
 	-- -------------------------------------------------------------------
 	-- LE RAPPORT $RPSSTRT ne donnne pas lieu à constitution d'une table
	-- dédiée : le contenu de SSTRT permet de le reconstituer
	-- -------------------------------------------------------------------
	-- le source focus fabrique un fichier temporaire qui permet
	--            - edition de $rpsstrt
	--            - alimentation de SSTRT
	--            - mise à zéro de cusag
	-- Le traitement ci-dessous est architecturé autrement : le fichier
	-- temporaire est remplacé par une requête ensembliste d'alimentation
	-- de SSTRT. Cette table servira à l'édition du rapport et SERT à
	-- la mise à zéro des CUSAG. POUR CE FAIRE il a été nécessaire
	-- d'enrichir chaque ligne de SSTRT avec les informations de clé
	-- primaires qui manquaient pour attaquer CONS_SSTACHE_RES_MOIS en
	-- mise à jour. Il s'agit de la triplette Etape, Tache, SsTache.
	-- -------------------------------------------------------------------
	procedure RPSSTRT( P_HFILE utl_file.file_type ) is

		L_PROCNAME varchar2(16) := 'RPSSTRT';
		L_STATEMENT varchar2(64);

		L_MOISTRT number( 2 );
		L_ANTRT number( 4 );
		L_FDOTY date; -- First Day Of The Year (yeah, man)

	begin

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

		-- "destruction" de la table SSTRT
		-- -------------------------------
		L_STATEMENT := 'Truncate SSTRT';
		DYNA_TRUNCATE( 'SSTRT' );

		-- recherche année de traitement
		-- -----------------------------
		CALCDATTRT( P_HFILE, L_MOISTRT, L_ANTRT );
		L_FDOTY := trunc( to_date( L_ANTRT, 'YYYY'), 'year' );
		TRCLOG.TRCLOG( P_HFILE, 'Traitement avec date début au ' || L_FDOTY );

		-- ajout des anomalies
		-- -------------------

		-- ---------------------------------------------------------------
		-- on ne fait le contrôle de sous-traitance correcte  que pour les
		-- CDEB "récentes", d'un autre côté, la mensuelle des données de
		-- décembre tourne en janvier (si tout va bien, poil au
		-- métatarsien), donc, petite bidouille (limite grosse bidouille)
		-- en focus, à grand coup de date système et de test à la noix (du
		-- genre : est-ce que, par le plus grand des hasards, on ne serait
		-- pas en janvier ? Si ? Zut ! bonne année quand même !)
		-- ---------------------------------------------------------------
		-- ce point DEVRAIT être pris en compte par la jolie technique
		-- "année du mois précédant la date de la prochaine mensuelle",
		-- qui est utilisée par ailleurs dans d'autres procédures, mais
		-- le programmeur de $rpsstrt est arrivé après le début de la
		-- séance : il a raté la pub.
		-- ---------------------------------------------------------------
		-- 01/04/1999. Je craque : ce point EST (en SQL) pris en compte
		-- par la technique évoquée.
		-- ---------------------------------------------------------------
		-- On ajoute dans SSTRT les consommations non nulles sur des
		-- taches de sous-traitances, si le projet pour lequel on bosse a
		-- un statut non blanc et si on la date de pose de ce statut est
		-- une année antérieure (on peut consommer en sous-traitance toute
		-- l'année de la pose du statut : on ne s'occupe pas du jour et du
		-- mois de la pose de statut par rapport au mois de consommation).
		-- Cette recherche de consommation "invalide" ne s'effectue que
		-- pour les consommations de l'année de traitement
		-- ---------------------------------------------------------------
		-- PERFORMANCES
		-- OPTIMISATION POSSIBLE : par exemple, insérer avec un libellé
		-- LIBDSG à null pour éviter jointure STRUCT_INFO alors qu'on est
		-- dans un full-scan de filtre puis passer un update ensembliste
		-- sur SSTRT, ("quelques" lignes insérées seulement)
		-- REMARQUE : LA JOINTURE SUR STRUCT_INFO POURRAIT CERTAINEMENT
		-- ETRE FAITE AU MOMENT DE L'UTILISATION DE LA TABLE
		-- ---------------------------------------------------------------
		L_STATEMENT := 'Insert SSTRT';
		insert into SSTRT ( PID, PDSG, AISTPID,
		                    TIRES, CDEB, CUSAG, ASTATUT,
					  ADATESTATUT, LIBDSG, ECET, ACTA, ACST, PNOM )
		select A.PID, A.CODSG, AISTPID, IDENT, CDEB, CUSAG, B.ASTATUT,
		       B.ADATESTATUT, LIBDSG, C.ECET, C.ACTA, C.ACST, A.PNOM
		from LIGNE_BIP A, LIGNE_BIP B, TACHE T, CONS_SSTACHE_RES_MOIS C,
		     STRUCT_INFO S
		where A.PID = T.PID   and         -- jointure proj - tache
		      T.AISTTY = 'FF' and         -- filtre sous-traitance
		      T.ECET = C.ECET and         -- jointure tache - conso
		      T.ACTA = C.ACTA and         --        idem
		      T.ACST = C.ACST and         --        idem
		      T.PID  = C.PID  and         --        idem
		      C.CUSAG <> 0    and         -- filtre consommation nulle
		      trunc( C.CDEB, 'year' ) >=
		      L_FDOTY         and         -- filtre conso de l'année
		      T.AISTPID = B.PID and       -- jointure tache-proj
		      B.ASTATUT <> '  ' and       -- filtre statut non blanc
		      B.ADATESTATUT < L_FDOTY           and       -- filtre statut de l'année
		      A.CODSG = S.CODSG;          -- jointure proj - struct_info
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows inserted' );

  -- Ajout des projets sous-traités inexistants
		L_STATEMENT := 'Insert SSTRT projets sous-traites inexistants';
		insert into SSTRT ( PID, PDSG, AISTPID,
		                    TIRES, CDEB, CUSAG,
					   LIBDSG, ECET, ACTA, ACST, PNOM )
		select  A.PID, A.CODSG, AISTPID, IDENT, CDEB, CUSAG, LIBDSG, C.ECET, C.ACTA, C.ACST, A.PNOM
		from LIGNE_BIP A,TACHE T, CONS_SSTACHE_RES_MOIS C,
		     STRUCT_INFO S
		where A.PID = T.PID   and         -- jointure proj - tache
		      T.AISTTY = 'FF' and         -- filtre sous-traitance
		      T.ECET = C.ECET and         -- jointure tache - conso
		      T.ACTA = C.ACTA and         --        idem
		      T.ACST = C.ACST and         --        idem
		      T.PID  = C.PID  and         --        idem
		      C.CUSAG <> 0    and         -- filtre consommation nulle
		      trunc( C.CDEB, 'year' ) >= L_FDOTY         and         -- filtre conso de l'année
		      T.AISTPID not in (select pid from ligne_bip) and       -- jointure tache-proj
		      A.CODSG = S.CODSG;

		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows inserted' );

		-- Utilisation de la technique "mise à jour de jointure" pour
		-- changer un peu.
		-- ----------------------------------------------------------
		L_STATEMENT := 'Mise à zéro des CUSAG en erreur';
		update ( select C.CUSAG from SSTRT S, CONS_SSTACHE_RES_MOIS C
		         where S.PID = C.PID and
		               S.ECET = C.ECET and
		               S.ACTA = C.ACTA and
		               S.ACST = C.ACST and
		               S.TIRES = C.IDENT and
		               S.CDEB = C.CDEB )
		set CUSAG = 0;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

		commit;

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );

	exception

		when others then

			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
			raise CALLEE_FAILED;

	end RPSSTRT;

	-- -------------------------------------------------------------------
	-- P_PROPLUS : Créer from scratch COMPLUS, qui ajouté à une sauvegarde
	--             de PROPLUS pour les années antérieures (ANTPLUS), va
	--             devenir le nouveau PROPLUS
	-- -------------------------------------------------------------------
	-- ATTENTION : sous focus, l'année est codée en dur. Le changement de
	-- la date n'est "traditionnelement" fait qu'en avril ! Il se trouve
	-- que les diverses situations présentes pour une ressource dans RES
	-- ne sont pas "forcément" cohérentes. De plus, l'algorithme qui
	-- "filtre" les situations utilise intensivement le 01/01 de l'année
	-- codée en dur comme "date pivot". En conséquence, il est probable
	-- que le PROPLUS qui serait calculé fin janvier APRES UN CHANGEMENT
	-- DE DATE PIVOT et le PROPLUS qui est calculé fin avril après un
	--  changement de date pivot (après la mensuelle de début avril) NE
	-- DONNERAIENT pas les même résultats Y COMPRIS POUR les données des
	-- premiers mois de l'année CETTE AFFIRMATION REPOSE SUR LE FAIT QUE
	-- LE FILTRE SUR LES SITUATIONS NE DONNERAIT PAS LE MEME RESULTAT POUR
	-- LES SITUATIONS INCOHERENTES. Dans l'optique d'une reproduction
	-- fidèle des traitements focus, ce traitement utilise lui aussi le
	-- pivot d'Avril (PREMIERE ACTIVATION FIN AVRIL/DEBUT MAI).
	-- Selection des situations à prendre en compte :
	--      1° : toutes les situations de la table SITU_RESS
	--      2°   Pour chaque ident, s'il existe des situations à date de
	--           début strictement inférieure au 01/01/AA, alors il ne
	--           faut garder que LA situation de la plus grande de début
	--           (dans le paquet des situations de date de début
	--           inférieure à 01/01/AA)
	--      3° : Pour chaque ident, s'il existe une situation de date de
	--           début strictement inférieure à 01/01/AA alors elle est
	--           unique en vertu du paragraphe précédent. Il faut
	--           l'enlever, si, pour l'Ident, il existe aussi une
	--           situation à date de début EGALE au 01/01/AA.
	--      4° : Pour chaque ident, s'il existe une situation de date de
	--           début strictement inférieure à 01/01/AA ET avec une
	--           date de départ également strictement inférieure au
	--           01/01/AA, alors elle est unique et elle vient peut être
	--           d'être éliminée par le paragraphe précédent. Il faut en
	--           tout cas l'éliminer s'il n'existe pas de situation avec
	--           date de début strictement supérieure au 01/01/AA.
	-- -------------------------------------------------------------------
	-- Résumé, en gros  : On essaye de ne garder que les situations
	-- pertinentes, on enlève tout ce qui est vieux si on peut trouver une
	-- "prise de relai" au 01/01/AA. Sans prise de relai au 01/01/AA, on
	-- ne vire que si la date de départ est vieille ET si il existe quand
	-- même un relai après le 01/01/AA. On garde des vieilles situations
	-- "non relayées"
	-- -------------------------------------------------------------------
	-- Extractions à l'origine de COMPLUS
	--
	--   1° : Dans les Conso, On "group by" par PID, IDENT, CDEB et
	--        "type de sous-tache" et on additionne CUSAG, CHINIT et.
	--        CHRAF.
	--
	--   2° : De nombreuses colonnes sont en double : on a les données du
	--        PID et les données du PID sous-traité. On commence par faire
	--        comme s'il n' y avait pas de sous-traitance et on passera un
	--        update plus tard pour la sous-traitance
	--
	--   3° : On ne fait tout ça que pour les CDEB >= année de traitement
	-- -------------------------------------------------------------------
	procedure P_PROPLUS( P_HFILE utl_file.file_type ) is

		L_PROCNAME varchar2( 16 ) := 'P_PROPLUS';
		L_STATEMENT varchar2( 96 );

		-- ********************        -- **********************************
		-- ********** *********        -- mois de bascule, si avril, l'année
		-- *********   ********        -- "change" à partir de la première
		-- ********  *  *******        -- pré-mensuelle de fin avril (pour
		-- *******   *   ******        -- les données d'avril)
		-- ******    *    *****        -- **********************************
		-- *****     *     ****
		-- ****             ***
		-- ***       *       **
		-- **                 *
		-- ********************
		-- ********************
		L_MOIS_BASCULE number := 4;

		L_BORNE_SUP number;      -- si 1996 on supprime 96, 97, 98, ....
		L_BORNE_INF number;      -- si 1996 on supprime 96, 95, 94, ....
		L_BORNE_SUP_DT date;     -- L_BORNE_SUP en tant que date
		L_BORNE_INF_DT date;     -- L_BORNE_INF en tant que date

		L_MOISTRT number;
		L_ANTRT number;

	begin

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

		L_STATEMENT := 'Recherche mois de traitement';
		CALCDATTRT( P_HFILE, L_MOISTRT, L_ANTRT );
		TRCLOG.TRCLOG( P_HFILE, 'Traitement au titre du mois ' ||
		               L_MOISTRT || ' de ' || L_ANTRT );

		-- calcul des années de bornes en fonctions
		-- du mois pivot
		-- ----------------------------------------
--		if L_MOISTRT < L_MOIS_BASCULE then
--			L_BORNE_SUP := L_ANTRT - 1;
--		else
			L_BORNE_SUP := L_ANTRT;   -- on n'utilise plus d'annee pivot
--		end if;
		L_BORNE_INF := L_BORNE_SUP - 12;   -- 98 ==> on supprime 86
		L_BORNE_SUP_DT := to_date( '01/01/' || to_char( L_BORNE_SUP, 'FM0000' ),
		                           'DD/MM/YYYY' );
		L_BORNE_INF_DT := to_date( '01/01/' || to_char( L_BORNE_INF, 'FM0000' ),
		                           'DD/MM/YYYY' );

		-- Supression des données de l'année courante
		-- PERFORMANCES : ON POURRAIT FAIRE UN
		-- CREATE AS AVEC FILTRE POUR SIMULER LA
		-- TECHNIQUE PROPLUS = ANTPLUS + COMPLUS
		-- ------------------------------------------
		-- WARNING : ROLL-BACK SEGMENT
		-- ------------------------------------------
		TRCLOG.TRCLOG( P_HFILE, 'Dates bornes : ' || L_BORNE_INF || ', ' ||
		               'L_BORNE_SUP' );
		L_STATEMENT := 'Delete Années de PROPLUS';


		-- DBT: Ajout de Denis Blanc-Tranchant le 29091999
		-- on droppe les indexes pour gagner en performance
		DYNA_DROP_IND('PROPLUS_IDX2');
		DYNA_DROP_IND('PROPLUS_IDX3');
		DYNA_DROP_IND('PROPLUS_IDX4');
		DYNA_DROP_IND('PROPLUS_IDX5');
		DYNA_DROP_IND('PROPLUS_IDX6');

		delete from PROPLUS
		where ( trunc( CDEB, 'year' ) >= L_BORNE_SUP_DT );

            -- or( trunc( CDEB, 'year' ) <= L_BORNE_INF_DT );
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows deleted' );


		-- PERFORMANCE : IL EXISTE UN POINT A PARTIR DU QUEL IL VAUT MIEUX
		-- FAIRE DU PROCEDURAL NORMALEMENT COMPLEXE QUE DE L'ENSEMBLISTE
		-- DELIRANT (EN PARTICULIER SI ON COMMENCE A EMPILER LES SUB-QUERY
		-- CORRELLEES)
		--               une petite voix, au fond : oui, quand ?
		-- ---------------------------------------------------------------
		-- PERFORMANCE : TENTATIVE DE COMPROMIS : TABLES INTERMEDIAIRES.
		-- On introduit un peu de procédural en travailant par étape mais
		-- chaque étape est composées de requêtes ensembliste
		-- ---------------------------------------------------------------

		-- Etape 1 : préparation de la liste des situations valides
		-- On reproduit focus
		-- 2001 : code entierement refait en utilisant SITU_RESS_FULL
		-- Tout est dans PACKBATCH4.Maj_situation_Proplus
		-- --------------------------------------------------------

		-- Etape 2 : préparation de la liste des consommés à inclure dans
		-- proplus pour le compte de ce traitement. Performance : on fait
		-- comme s'il n'y avait aucune sous-traitance. On passera un
		-- Update pour la sous traitance
		-- --------------------------------------------------------------
		-- Le code focus utilise le type d'étape dans un "group by"
		-- sur les sous-taches de même AIST, PID, TIRES ! Plutôt que
		-- de prendre le type de l'étape dont le rang au carré est le
		-- plus proche de la racine cubique du quantième, on va prendre
		-- la valeur max (plutôt).
		-- --------------------------------------------------------------
		L_STATEMENT := 'Truncate BATCH_PROPLUS_COMPLUS';
		DYNA_TRUNCATE( 'BATCH_PROPLUS_COMPLUS' );

		L_STATEMENT := 'Insert dans BATCH_PROPLUS_COMPLUS';
		insert into BATCH_PROPLUS_COMPLUS
		( PID,
		  AIST,
		  AISTTY,
		  TIRES,
		  CDEB,
		  PTYPE,
		  PNOM,
		  PDSG,
		  PCPI,
		  PCMOUVRA,
		  PDATDEBPRE,
		  PNMOUVRA,
		  FACTPID,
		  FACTPTY,
		  FACTPNO,
		  FACTPDSG,
		  FACTPCP,
		  FACTPCM,
		  RNOM,
		  RPRENOM,
              RTYPE,
		  DATDEP,
		  DIVSECGROU,
		  CPIDENT,
		  COUT,
		  MATRICULE,
		  SOCIETE,
		  QUALIF,
		  DISPO,
		  CUSAG,
		  CHINIT,
		  CHRAF )
		select
		  CONSO.PID,
		  CONSO.AIST,
		  substr( CONSO.AIST, 1, 2 ),
		  CONSO.IDENT,
		  CONSO.CDEB,
		  BIP.TYPPROJ,
		  BIP.PNOM,
		  BIP.CODSG,
		  BIP.PCPI,
		  BIP.CLICODE,
		  BIP.PDATDEBPRE,
		  BIP.PNMOUVRA,
		  CONSO.PID,  -- FACTPID
		  BIP.TYPPROJ,  -- FACTPTY
		  BIP.PNOM,   -- FACTPNO
		  BIP.CODSG,  -- FACTPDSG
		  BIP.PCPI,   -- FACTPCP
		  BIP.CLICODE, -- FACTPCM
		  RES.RNOM,
		  RES.RPRENOM,
              RES.RTYPE,
		  null,       -- SITU.DATDEP
		  null,       -- SITU.CODSG focus res DIVSECGROU
		  null,       -- SITU.CPIDENT
		  null,       -- SITU.COUT
		  RES.MATRICULE,
		  null,       -- SITU.SOCCODE focus res SOCIETE
		  null,       -- SITU.PRESTATION focus res QUALIF
		  null,       -- SITU.DISPO
		  CONSO.CUSAG,
		  CONSO.CHINIT,
		  CONSO.CHRAF
		from LIGNE_BIP BIP, CENTRE_ACTIVITE ACTI, RESSOURCE RES,
		     ( select C.PID as PID, T.AIST as AIST, C.IDENT as IDENT,
		              C.CDEB as CDEB, sum( cusag ) as CUSAG,
		              sum( CHINIT ) as CHINIT, sum( CHRAF ) as CHRAF
		       from ETAPE E, TACHE T, CONS_SSTACHE_RES_MOIS C
		       where E.PID = T.PID and
		             E.ECET = T.ECET and
		             T.PID = C.PID and
		             T.ECET = C.ECET and
		             T.ACTA = C.ACTA and
		             T.ACST = C.ACST and
		             CDEB >= L_BORNE_SUP_DT
		       group by C.PID, T.AIST, C.IDENT, C.CDEB ) CONSO
		where BIP.PID = CONSO.PID and
		      BIP.CODCAMO = ACTI.CODCAMO and
		      CONSO.IDENT = RES.IDENT;
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows inserted' );

		-- Pour chaque consommation, on cherche la situation a prendre en
		-- compte
		PACKBATCH4.Maj_Situation_Proplus( P_HFILE );

		-- On change les données 'FACT' de PID vers
		-- PID de sous-traitance chaque fois qu'il
		-- y a sous-traitance
		-- ----------------------------------------
		L_STATEMENT := 'Mise à jour données de Sous-Traitance';
		update BATCH_PROPLUS_COMPLUS
		set (
		  FACTPID,
		  FACTPTY,
		  FACTPNO,
		  FACTPDSG,
		  FACTPCP,
		  FACTPCM ) =
		( select PID, TYPPROJ, PNOM, CODSG, PCPI, CLICODE
		  from LIGNE_BIP BIP,
                   CENTRE_ACTIVITE ACTI
		  where rtrim(substr( BATCH_PROPLUS_COMPLUS.AIST, 3, 4 )) = BIP.PID
              and   (AISTTY = 'FF' or AISTTY = 'DC')
              and   BIP.CODCAMO = ACTI.CODCAMO )
		where AISTTY = 'FF' or
		      AISTTY = 'DC';
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows updated' );

		-- On balance le résultat dans PROPLUS
		-- -----------------------------------
		L_STATEMENT := 'Insert dans PROPLUS';
		insert into PROPLUS
		( PID,
		  AIST,
		  AISTTY,
		  TIRES,
		  CDEB,
		  PTYPE,
		  PNOM,
		  PDSG,
		  PCPI,
		  PCMOUVRA,
		  PDATDEBPRE,
		  PNMOUVRA,
		  FACTPID,
		  FACTPTY,
		  FACTPNO,
		  FACTPDSG,
		  FACTPCP,
		  FACTPCM,
		  RNOM,
		  RPRENOM,
              RTYPE,
		  DATDEP,
		  DIVSECGROU,
		  CPIDENT,
		  COUT,
		  MATRICULE,
		  SOCIETE,
		  QUALIF,
		  DISPO,
		  CUSAG,
		  CHINIT,
		  CHRAF )
		select
		  PID,
		  AIST,
		  AISTTY,
		  TIRES,
		  CDEB,
		  PTYPE,
		  PNOM,
		  PDSG,
		  PCPI,
		  PCMOUVRA,
		  PDATDEBPRE,
		  PNMOUVRA,
		  FACTPID,
		  FACTPTY,
		  FACTPNO,
		  FACTPDSG,
		  FACTPCP,
		  FACTPCM,
		  RNOM,
		  RPRENOM,
              RTYPE,
		  DATDEP,
		  DIVSECGROU,
		  CPIDENT,
		  COUT,
		  MATRICULE,
		  SOCIETE,
		  QUALIF,
		  DISPO,
		  CUSAG,
		  CHINIT,
		  CHRAF
		from BATCH_PROPLUS_COMPLUS bpc
       -- Modification pour ne pas prendre
       -- en compte les ressources 0
       -- et les consommés de ressources
       -- sans situations excepte pour la 2222
            where bpc.tires <> 0
            and   (bpc.tires = 2222
                   or bpc.datsitu is not null
		  	 or bpc.cusag<>0);
		commit;
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : ' || sql%rowcount ||
		               ' rows inserted' );

		-- DBT: Ajout de Denis Blanc-Tranchant le 29091999
		-- on reconstruit les indexes de PROPLUS 'DROPPES' avant le 'Delete Années'
		DYNA_CREATE_IND('PROPLUS','PROPLUS_IDX2','TIRES','ASC', 'INITIAL 1024 K NEXT 1024 K PCTINCREASE 0');
		DYNA_CREATE_IND('PROPLUS','PROPLUS_IDX3','PID','ASC', 'INITIAL 1024 K NEXT 1024 K PCTINCREASE 0');
		DYNA_CREATE_IND('PROPLUS','PROPLUS_IDX4','FACTPID','ASC', 'INITIAL 1024 K NEXT 1024 K PCTINCREASE 0');
		DYNA_CREATE_IND('PROPLUS','PROPLUS_IDX5','QUALIF','ASC', 'INITIAL 1024 K NEXT 1024 K PCTINCREASE 0');
		DYNA_CREATE_IND('PROPLUS','PROPLUS_IDX6','RTYPE','ASC', 'INITIAL 1024 K NEXT 1024 K PCTINCREASE 0');

		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT || ' : creation des indexes PROPLUS_IDX2...5');

			-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );

	exception

		when others then

			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
			raise CALLEE_FAILED;

	end P_PROPLUS;

	-- ##################################################################################################
PROCEDURE purge_rejet_datestatut( P_HFILE utl_file.file_type ) IS
		l_statement     VARCHAR2(255);
	BEGIN
--	Purge des precedents consommes rejetes
		TRCLOG.TRCLOG( P_HFILE, '*** Debut de purge_rejet_datestatut ***');

		l_statement:='Purge de BATCH_REJET_DATESTATUT';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE batch_rejet_datestatut;
		COMMIT;

		l_statement:='Purge de ETAPE_REJET_DATESTATUT';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE ETAPE_REJET_DATESTATUT;
		COMMIT;

		l_statement:='Purge de TACHE_REJET_DATESTATUT';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE tache_rejet_datestatut;
		COMMIT;

		l_statement:='Purge de CONS_SSTRES_REJET_DATESTATUT';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE cons_sstres_rejet_datestatut;
		COMMIT;

		l_statement:='Purge de CONS_SSTRES_M_REJET_DATESTATUT';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE cons_sstres_m_rejet_datestatut;
		COMMIT;

-- purge des TABLES de sauvegarde
		l_statement:='Purge de etape_back';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE etape_back;
		COMMIT;

		l_statement:='Purge de tache_back';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE tache_back;
		COMMIT;

		l_statement:='Purge de cons_sstache_res_back';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE cons_sstache_res_back;
		COMMIT;

		l_statement:='Purge de cons_sstache_res_mois_back';
		TRCLOG.TRCLOG( P_HFILE,l_statement);
		DELETE cons_sstache_res_mois_back;
		COMMIT;

		TRCLOG.TRCLOG( P_HFILE, '*** Fin de purge_rejet_datestatut ***');

	EXCEPTION
		WHEN OTHERS THEN
		TRCLOG.TRCLOG( P_HFILE, '!!! Fin anormale de la purge des tables de rejet en fonction de la datestatut !!!');
		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
		TRCLOG.TRCLOG( P_HFILE, l_statement);
		RAISE;
	END purge_rejet_datestatut;

-- ##################################################################################################
PROCEDURE rejet_datestatut( P_HFILE utl_file.file_type ) IS

		l_moismens_moins1	DATE;
		l_moismens	DATE;
		l_annee		DATE;
		l_statement	VARCHAR2(2000);

	BEGIN
		TRCLOG.TRCLOG( P_HFILE, '*** Debut de la procedure rejet_datestatut ***');

		l_statement:='Lecture de DATDEBEX';
		TRCLOG.TRCLOG( P_HFILE,l_statement) ;
		SELECT add_months(moismens,-1), datdebex,moismens INTO l_moismens_moins1, l_annee,l_moismens FROM datdebex;


		-- Insertion des donnees rejetees dans BATCH_REJET_DATESTATUT
		l_statement :='Insertion dans BATCH_REJET_DATESTATUT';
		TRCLOG.TRCLOG( P_HFILE,l_statement) ;
		/* 1er cas : on supprime les lignes bip (pas vrai : dont le statut est DEMARRE
		et) dont la DATE de statut est antérieure au mois de traitement -1
		*/
		INSERT INTO  BATCH_REJET_DATESTATUT (PID,AIST,ECET,ACTA,ACST,ADEB,AFIN,ANDE,ANFI,ADUR,APCP,ASTA,ASNOM,
		TPLAN,TACTU,TEST,ASTATUT,ADATESTATUT,CIRES,CUSAG,CDEB,MOISMENS,SSTRAIT)
		SELECT DISTINCT  lb.PID, pmw.aist,pmw.ACET,pmw.ACTA,pmw.ACST,pmw.ADEB,pmw.AFIN,pmw.ANDE,pmw.ANFI,pmw.ADUR,pmw.APCP,pmw.ASTA,
		pmw.asnom,af.TPLAN,af.TACTU,af.TEST,lb.astatut,lb.adatestatut,cons.cires,cons.cusag,cons.cdeb,dx.moismens,'N'
		FROM PMW_ACTIVITE pmw,pmw_affecta af, LIGNE_BIP lb,pmw_consomm cons,datdebex dx
		WHERE lb.PID = pmw.PID
		AND cons.pid=pmw.pid
		AND cons.ccet=pmw.acet
		AND cons.ccta=pmw.acta
		AND cons.ccst=pmw.acst
		AND pmw.pid=af.pid
		AND af.tcet=pmw.acet
		AND af.tcta=pmw.acta
		AND af.tcst=pmw.acst
		AND af.tires=cons.cires
		AND (lb.adatestatut <= add_months(dx.moismens,-1)
-- AND  lb.astatut ='D'
                 )
		;
		COMMIT;

		/* 2eme cas : on supprime les lignes bip qui ont de la sous traitance avec (non : un statut DEMARRE)
		et une DATE de statut antérieure au mois de traitement -1
		*/
		INSERT INTO  BATCH_REJET_DATESTATUT (PID,AIST,ECET,ACTA,ACST,ADEB,AFIN,ANDE,ANFI,ADUR,APCP,ASTA,ASNOM,
		TPLAN,TACTU,TEST,ASTATUT,ADATESTATUT,CIRES,CUSAG,CDEB,MOISMENS,SSTRAIT)
		SELECT  DISTINCT  lb.PID, pmw.aist,pmw.ACET,pmw.ACTA,pmw.ACST,pmw.ADEB,pmw.AFIN,pmw.ANDE,pmw.ANFI,pmw.ADUR,pmw.APCP,pmw.ASTA,
		pmw.asnom,af.TPLAN,af.TACTU,af.TEST,lb.astatut,lb.adatestatut,cons.cires,cons.cusag,cons.cdeb,dx.moismens,'O'
 		 from PMW_ACTIVITE pmw,pmw_affecta af,LIGNE_BIP lb,pmw_consomm cons,datdebex dx
  		where lb.PID = pmw.PID
  		AND pmw.pid=cons.pid
  		AND cons.ccet=pmw.acet
		AND cons.ccta=pmw.acta
		AND cons.ccst=pmw.acst
		AND pmw.pid=af.pid
		AND af.tcet=pmw.acet
		AND af.tcta=pmw.acta
		AND af.tcst=pmw.acst
		AND af.tires=cons.cires
  		AND  (lb.adatestatut IS NULL OR lb.adatestatut > add_months(dx.moismens,-1))
  		AND (( SUBSTR(pmw.aist,0,2)='FF' AND RTRIM(SUBSTR(pmw.aist,3,4)) IN
    			(SELECT bip.pid FROM ligne_bip bip,datdebex
                         WHERE
			 bip.adatestatut <= add_months(dx.moismens,-1))
		    )
		   )
  		 ;
  		 COMMIT;

  		-- Suppression des lignes concernees de la table pmw_consomm

  		l_statement:='Rejet des enregistrements sur lignes D ou A dans les tables PMW_ ';
		TRCLOG.TRCLOG( P_HFILE,l_statement) ;

		DELETE FROM pmw_consomm
		WHERE  pid IN (SELECT rej.pid FROM BATCH_REJET_DATESTATUT rej WHERE
			pmw_consomm.cires=rej.cires
			AND pmw_consomm.ccet=rej.ecet
			AND pmw_consomm.ccta=rej.acta
			AND pmw_consomm.ccst=rej.acst
			)
			;
		COMMIT;

		-- Suppression des lignes concernees de la table pmw_activite
		DELETE FROM pmw_activite
		WHERE  pid IN (SELECT rej.pid FROM BATCH_REJET_DATESTATUT rej WHERE
			pmw_activite.aist=rej.aist
			AND pmw_activite.acet=rej.ecet
			AND pmw_activite.acta=rej.acta
			AND pmw_activite.acst=rej.acst
			)
			;
		COMMIT;

		-- Suppression des lignes concernees de la table pmw_affecta
		DELETE FROM pmw_affecta
		WHERE  pid IN (SELECT rej.pid FROM BATCH_REJET_DATESTATUT rej WHERE
			pmw_affecta.tires=rej.cires
			AND pmw_affecta.tcet=rej.ecet
			AND pmw_affecta.tcta=rej.acta
			AND pmw_affecta.tcst=rej.acst
			)
			;
		COMMIT;

		-- Suppression des lignes concernees de la table pmw_ligne_bip
		DELETE FROM pmw_ligne_bip
		WHERE  pid IN (SELECT pid FROM BATCH_REJET_DATESTATUT
				WHERE sstrait='N')
		;

		COMMIT;

  		/*SAUVEGARDE DE ETAPE TACHE CONS_SSTACHE_RES CONS_SSTACHE_RES_MOIS !!!
  		(c'est mieux pour eviter de faire un export de la base de prod quand le traitement plante !*/

  		l_statement:='Sauvegarde des tables de consommes';
		TRCLOG.TRCLOG( P_HFILE,l_statement) ;

  		INSERT INTO etape_back(ECET,EDUR,ENFI,ENDE,EDEB,EFIN,PID,TYPETAP)
  		        (SELECT ECET,EDUR,ENFI,ENDE,EDEB,EFIN,PID,TYPETAP FROM etape);
  		COMMIT;

  		INSERT INTO tache_back(ACTA,ACST,AISTTY,AISTPID,ADEB,AFIN,ANDE,ANFI,ADUR,APCP,ASNOM,ASTA,AIST,PID,ECET,CDEB_MAX,MOTIF_REJET)
  		 	(SELECT ACTA,ACST,AISTTY,AISTPID,ADEB,AFIN,ANDE,ANFI,ADUR,APCP,
  		 	ASNOM,ASTA,AIST,PID,ECET,CDEB_MAX,MOTIF_REJET FROM tache);
		COMMIT;

  		INSERT INTO cons_sstache_res_back(TPLAN,TACTU,TEST,PID,ECET,ACTA,ACST,IDENT)
	  		 (SELECT TPLAN,TACTU,TEST,PID,ECET,ACTA,ACST,IDENT FROM cons_sstache_res);
		COMMIT;

  		INSERT INTO cons_sstache_res_mois_back(CDEB,CDUR,CUSAG,CHRAF,CHINIT,PID,ECET,ACTA,ACST,IDENT)
  			 (SELECT CDEB,CDUR,CUSAG,CHRAF,CHINIT,PID,ECET,ACTA,ACST,IDENT FROM cons_sstache_res_mois);
		COMMIT;

  		/*on recupere les donnees de tache et etape :
  		on prend dans TACHE les lignes bip avec une ss traitance dont (le statut est demarre et) la datestatut < moismens -1
  		*/

  		l_statement:='Sauvegarde des consommes sur lignes demarrees ou abandonnees';
		TRCLOG.TRCLOG( P_HFILE,l_statement) ;

  		INSERT INTO TACHE_REJET_DATESTATUT (ACTA,ACST,AISTTY,AISTPID,ADEB,AFIN,ANDE,ANFI,ADUR,
  		APCP,ASNOM,ASTA,AIST,PID,ECET,ECET_NEW,ACTA_NEW,ACST_NEW)
  		SELECT  DISTINCT  t.ACTA,t.acst,t.aistty,t.aistpid,t.adeb,t.afin,t.ande,t.anfi,t.adur,
  		t.apcp,t.asnom,t.asta,t.aist,t.PID,t.ecet,t.ecet,t.acta,t.acst
		FROM  tache t,LIGNE_BIP lb,datdebex dx
		WHERE  lb.PID = t.PID
  			AND  (lb.adatestatut IS NULL OR lb.adatestatut > add_months(dx.moismens,-1))
			AND ((SUBSTR(t.aist,0,2)='FF' AND RTRIM(t.aistpid) IN
       				(SELECT bip.pid FROM ligne_bip bip,datdebex
                                  WHERE
		       		 bip.adatestatut <= add_months(dx.moismens,-1))
     		 		)
     			)
     		;
     		COMMIT;

  		--insertion dans ETAPE_REJET_DATESTATUT des données concernant les lignes du 2eme cas
  		l_statement :='Insertion dans ETAPE_REJET_DATESTATUT';
  		INSERT INTO ETAPE_REJET_DATESTATUT (ECET,EDUR,ENFI,ENDE,EDEB,EFIN,PID,TYPETAP,ECET_NEW)
  		SELECT DISTINCT et.ECET,et.EDUR,et.ENFI,et.ENDE,et.EDEB,et.EFIN,et.PID,et.TYPETAP,et.ECET
  		FROM etape et,TACHE_REJET_DATESTATUT rej
  		WHERE  et.PID=rej.pid
		AND et.ecet=rej.ecet
  		;
  		COMMIT;


  		--insertion dans CONS_SSTRES_REJET_DATESTATUT des données concernant les lignes du 2eme cas
  		l_statement :='Insertion dans CONS_SSTRES_REJET_DATESTATUT';
  		INSERT INTO CONS_SSTRES_REJET_DATESTATUT (TPLAN,TACTU,TEST,PID,ECET,ACTA,ACST,IDENT,ECET_NEW,ACTA_NEW,ACST_NEW)
  		SELECT DISTINCT t.TPLAN,t.TACTU,t.TEST,t.PID,t.ECET,t.ACTA,t.ACST,t.IDENT,t.ecet,t.acta,t.acst
  		FROM cons_sstache_res t,TACHE_REJET_DATESTATUT rej
  		WHERE  t.PID=rej.pid
		AND t.ecet=rej.ecet
		AND t.acta=rej.acta
		AND t.acst=rej.acst
     		;
  		COMMIT;

  		--insertion dans CONS_SSTRES_M_REJET_DATESTATUT des données concernant les lignes du 2eme cas
  		l_statement :='Insertion dans CONS_SSTRES_M_REJET_DATESTATUT';
  		INSERT INTO CONS_SSTRES_M_REJET_DATESTATUT (CDEB,CDUR,CUSAG,CHRAF,CHINIT,PID,
  		ECET,ACTA,ACST,IDENT,ECET_NEW,ACTA_NEW,ACST_NEW)
  		SELECT DISTINCT t.CDEB,t.CDUR,t.CUSAG,t.CHRAF,t.CHINIT,t.PID,t.ECET,t.ACTA,t.ACST,t.IDENT,t.ecet,t.acta,t.acst
  		FROM cons_sstache_res_mois t,TACHE_REJET_DATESTATUT rej
  		WHERE  t.PID=rej.pid
		AND t.ecet=rej.ecet
		AND t.acta=rej.acta
		AND t.acst=rej.acst
     		;
  		COMMIT;


		TRCLOG.TRCLOG( P_HFILE, '*** Fin de la procedure rejet_datestatut ***');
	EXCEPTION
		WHEN OTHERS THEN
		TRCLOG.TRCLOG( P_HFILE, '!!! Fin anormale de la procedure rejet_datestatut !!!');
		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
		TRCLOG.TRCLOG( P_HFILE, l_statement);
		RAISE;

END rejet_datestatut;

-- ##################################################################################################
--	Copie des donnees rejetees par rejet_datestatut pour les lignes avec sous traitance
-- ##################################################################################################
PROCEDURE copie_datestatut( P_HFILE utl_file.file_type ) IS
l_statement	VARCHAR2(255);
L_ORAERRMSG VARCHAR2(128);
L_INSERTED pls_integer;
L_REJECTED pls_integer;
L_UPDATED pls_integer;
l_ecet	VARCHAR2(4);
l_acta  VARCHAR2(4);
L_ACST	VARCHAR2(4);

BEGIN
TRCLOG.TRCLOG( P_HFILE, 'Debut insertion donnees concernant les lignes avec ss traitance et datestatut < moismens -1 ');

l_statement:='Insertion dans ETAPE';
L_INSERTED := 0;
L_REJECTED := 0;
L_ECET:='00';
L_ACTA:='00';
L_ACST:='00';

DECLARE
L_PID etape.pid%type;
MAX_ECET EXCEPTION;

 /* curseur pour insertion dans ETAPE
 On sélectionne toutes les etapes à reinserer en se basant sur le pid, le numero d'etape
 et le type d'etape (important pour les calculs FI / Immo) */

CURSOR C_ETAPE IS
	SELECT DISTINCT rej.PID,rej.ECET, rej.EDUR,rej.EDEB,rej.EFIN,rej.ENDE,rej.ENFI,rej.TYPETAP
	FROM etape_rejet_datestatut rej
	MINUS
	SELECT  e.pid,e.ecet,e.edur,e.edeb,e.efin,e.ende,e.enfi,e.typetap
	FROM  etape e;


  BEGIN

  FOR ONE_ETAPE IN C_ETAPE LOOP
     	BEGIN
     		BEGIN

     			/* On verifie que le couple pid,ecet n'est pas deja utilise */
     			SELECT pid  INTO l_pid FROM Etape
     			WHERE etape.pid=ONE_ETAPE.PID
     			AND etape.ecet=ONE_ETAPE.ecet;


		     	/* Si le couple est pris, on insert les enregistrements dans etape après avoir recalculé le numero d'etape */
     			SELECT TO_CHAR(MAX(TO_NUMBER(ecet)) + 1,'000') INTO l_ecet
     			FROM etape e
     			WHERE one_etape.pid=e.pid;

     			L_ECET:=LTRIM(RTRIM(L_ECET));


     			IF TO_NUMBER(l_ecet,'000')>99 THEN
     				-- On ne peut etendre le numero d etape... l'enregistrement est rejete...
     				RAISE MAX_ECET;
     			END IF;


     			INSERT  INTO  ETAPE ( PID, ECET, EDUR, EDEB, EFIN, ENDE, ENFI,TYPETAP)
     			VALUES (ONE_ETAPE.PID,
     				L_ECET,
     				ONE_ETAPE.EDUR,
     				ONE_ETAPE.EDEB,
     				ONE_ETAPE.EFIN,
     				ONE_ETAPE.ENDE,
     				ONE_ETAPE.ENFI,
     				ONE_ETAPE.TYPETAP);

     				L_INSERTED := L_INSERTED + 1;


     			-- On met à jour le nouveau N° d'etape dans les tables de sauvegarde.
     			-- Ce numero est la nouvelle reference.

     			UPDATE etape_rejet_datestatut e
     			SET ECET_NEW=L_ECET
     			WHERE one_etape.pid=e.pid
     			AND one_etape.ecet=e.ecet;


			-- On met a jour la table tache_rejet_datestatut
			-- si des enregistrements sont rattaches à l'ancien N° d'etape


 			UPDATE tache_rejet_datestatut t
     			SET ECET_NEW=L_ECET
     			WHERE one_etape.pid=t.pid
     			AND one_etape.ecet=t.ecet
     			;

     			IF SQL%NOTFOUND THEN
     				-- on arrête la mise a jour
     				L_PID :='RAS';
     			ELSE
     				-- on met à jour le nouveau n° etape pour les affectations

    				UPDATE CONS_SSTRES_REJET_DATESTATUT c
     				SET ECET_NEW=L_ECET
     				WHERE one_etape.pid=c.pid
     				AND one_etape.ecet=c.ecet
     				;

     				IF SQL%NOTFOUND THEN
     					-- on arrête la mise a jour
     					L_PID :='RAS';
     				ELSE
     					-- on met à jour le nouveau n° etape pour les consommes
     			     		UPDATE CONS_SSTRES_M_REJET_DATESTATUT c
     					SET ECET_NEW=L_ECET
     					WHERE one_etape.pid=c.pid
     					AND one_etape.ecet=c.ecet
     					;

					IF SQL%NOTFOUND THEN
     					-- on arrête la mise a jour
     					L_PID :='RAS';
					END IF;

     				END IF;

     			END IF;
     		EXCEPTION
     			WHEN NO_DATA_FOUND THEN
			/* Si le couple (pid,ecet) n'est pas pris, on insert les enregistrements directement dans etape */

     				INSERT  INTO  ETAPE ( PID, ECET, EDUR, EDEB, EFIN, ENDE, ENFI,TYPETAP)
     				VALUES (ONE_ETAPE.PID,
     				ONE_ETAPE.ECET,
     				ONE_ETAPE.EDUR,
     				ONE_ETAPE.EDEB,
     				ONE_ETAPE.EFIN,
     				ONE_ETAPE.ENDE,
     				ONE_ETAPE.ENFI,
     				ONE_ETAPE.TYPETAP);

     				L_INSERTED := L_INSERTED + 1;

     			WHEN OTHERS THEN

     				TRCLOG.TRCLOG( P_HFILE,'Probleme de reinsertion pour : '|| ONE_ETAPE.PID ||' , '||ONE_ETAPE.ECET || ' - erreur: ' ||SQLERRM);
     				TRCLOG.TRCLOG( P_HFILE, l_statement);
     		END;


     	EXCEPTION

     		--gestion des doublons : recuperation dans une TABLE de rejet
     		when CONSTRAINT_VIOLATION then
     				L_ORAERRMSG := sqlerrm;
     				-- DUPLICATION DE CODE POUR RAPPORT D'ERREUR
     				-- -----------------------------------------
     				insert into BATCH_ETAPE_BAD
     				( PID, ECET, EDUR, EDEB, EFIN, ENDE, ENFI,
     				  TYPETAP, ERRMSG )
     				VALUES (ONE_ETAPE.PID,
     			ONE_ETAPE.ECET,
     			ONE_ETAPE.EDUR,
     			ONE_ETAPE.EDEB,
     			ONE_ETAPE.EFIN,
     			ONE_ETAPE.ENDE,
     			ONE_ETAPE.ENFI,
     			ONE_ETAPE.TYPETAP,
     			SUBSTR(l_ORAERRMSG,1,127));
     				L_REJECTED := L_REJECTED + 1;

     		WHEN MAX_ECET THEN
     			TRCLOG.TRCLOG( P_HFILE, l_statement);
     			TRCLOG.TRCLOG( P_HFILE, '!!! Impossible de reinserer l etape...  PID: '||one_etape.pid||', N°: '||one_etape.ecet||' !!!');

     			insert into BATCH_ETAPE_BAD
     			( PID, ECET, EDUR, EDEB, EFIN, ENDE, ENFI,TYPETAP, ERRMSG )
     			VALUES (ONE_ETAPE.PID,
     			ONE_ETAPE.ECET,
     			ONE_ETAPE.EDUR,
     			ONE_ETAPE.EDEB,
     			ONE_ETAPE.EFIN,
     			ONE_ETAPE.ENDE,
     			ONE_ETAPE.ENFI,
     			ONE_ETAPE.TYPETAP,
     			'Erreur extension ecet');
     				L_REJECTED := L_REJECTED + 1;

     		WHEN OTHERS THEN
     		TRCLOG.TRCLOG( P_HFILE, 'Fin anormale de la reinsertion des enregistrements protégés pour ligne démarrée ou abandonnée');
     		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
     		TRCLOG.TRCLOG( P_HFILE, l_statement);
     		RAISE;
     	END;
     COMMIT;
     L_ECET:='00';
END LOOP;
TRCLOG.TRCLOG( P_HFILE, 'Fin de la reinsertion des etapes');

END;
COMMIT;
TRCLOG.TRCLOG( P_HFILE, L_statement || ' : ' || L_INSERTED ||
		               ' rows inserted. ' || L_REJECTED || ' rows rejected.' );


--**********************************************************
-- Insertion des donnees dans tache
--**********************************************************
l_statement:='Insertion dans TACHE';
TRCLOG.TRCLOG( P_HFILE, l_statement);

L_INSERTED := 0;
L_REJECTED := 0;

DECLARE
L_PID tache.pid%type;
MAX_ACST EXCEPTION;

 /* curseur pour insertion dans TACHE
 On sélectionne toutes les taches à reinserer en se basant sur le pid, le numero d'etape, de tache,
 de sous-tache, le libelle et le type de sous-tache (important pour les calculs FI / Immo, etc.) */

CURSOR C_TACHE IS
	SELECT DISTINCT rej.ACTA,rej.ACST,rej.AISTTY,rej.AISTPID,rej.ADEB,rej.AFIN,rej.ANDE
			,rej.ANFI,rej.ADUR,rej.APCP,rej.ASNOM,rej.ASTA,rej.AIST,rej.PID,rej.ECET_NEW ecet
	FROM TACHE_REJET_DATESTATUT rej
	MINUS
	SELECT  ta.ACTA,ta.ACST,ta.AISTTY,ta.AISTPID,ta.ADEB,ta.AFIN,ta.ANDE
			,ta.ANFI,ta.ADUR,ta.APCP,ta.ASNOM,ta.ASTA,ta.AIST,ta.PID,ta.ECET ecet
	FROM  tache ta
	;

  BEGIN
  FOR ONE_TACHE IN C_TACHE LOOP
     	BEGIN
     		BEGIN
     			L_ACTA:=ONE_TACHE.acta;
     			L_ACST:=ONE_TACHE.acst;

     			/* On verifie que le quadruplet pid,ecet,acta,acst n'est pas deja utilise */
     			SELECT pid  INTO l_pid FROM tache
     			WHERE tache.pid=ONE_TACHE.PID
     			AND tache.ecet=ONE_TACHE.ecet
     			AND tache.acta=ONE_TACHE.acta
     			AND tache.acst=ONE_TACHE.acst;

     		/* Si le quadruplet est pris, on insert les enregistrements dans tache en recalculant n° tache voire sous-tache */

     			SELECT TO_CHAR(MAX(TO_NUMBER(acta)) + 1,'000') INTO l_acta
     			FROM tache t
     			WHERE one_tache.ecet=t.ecet
     			AND one_tache.pid=t.pid;


     			IF TO_NUMBER(l_acta,'000')>99 THEN

     				l_acta :=ONE_TACHE.ACTA;

     				SELECT TO_CHAR(MAX(TO_NUMBER(acst)) + 1,'000') INTO l_acst
     				FROM tache t
     				WHERE one_tache.ecet=t.ecet
     				AND one_tache.pid=t.pid
     				AND one_tache.acta=t.acta;

      				IF TO_NUMBER(l_acst,'000')>99 THEN
     					-- On ne peut etendre le numero de sous-tache... l'enregistrement est rejete...
     					RAISE MAX_ACST;
     				END IF;
     			END IF;

     			L_ACTA:=LTRIM(RTRIM(L_ACTA));
     			L_ACST:=LTRIM(RTRIM(L_ACST));

     			INSERT INTO TACHE (PID,ECET,ACTA,ACST,AISTTY,AISTPID,ADEB,AFIN,ANDE,ANFI,ADUR,APCP,ASNOM,ASTA,AIST)
			VALUES (ONE_TACHE.PID,ONE_TACHE.ECET,DECODE(l_acta,'00',ONE_TACHE.ACTA,l_acta),DECODE(l_acst,'00',ONE_TACHE.ACST,l_acst)
				,ONE_TACHE.AISTTY,ONE_TACHE.AISTPID,ONE_TACHE.ADEB,ONE_TACHE.AFIN,ONE_TACHE.ANDE,ONE_TACHE.ANFI
				,ONE_TACHE.ADUR,ONE_TACHE.APCP,ONE_TACHE.ASNOM,ONE_TACHE.ASTA,ONE_TACHE.AIST
         		       );

     			L_INSERTED := L_INSERTED + 1;

     			-- On met a jour les numero de tache et sous-tache
     			UPDATE tache_rejet_datestatut t
     			SET 	ACTA_NEW=DECODE(l_acta,'00',ONE_TACHE.ACTA,l_acta),
     				 ACST_NEW=DECODE(l_acst,'00',ONE_TACHE.ACST,l_acst)
     			WHERE one_tache.pid=t.pid
     			AND one_tache.ecet=t.ecet
     			AND one_tache.acta=t.acta
     			AND one_tache.acst=t.acst
     			;

    			UPDATE CONS_SSTRES_REJET_DATESTATUT c
     			SET 	ACTA_NEW=DECODE(l_acta,'00',ONE_TACHE.ACTA,l_acta),
     				ACST_NEW=DECODE(l_acst,'00',ONE_TACHE.ACST,l_acst)
     			WHERE one_tache.pid=c.pid
     			AND one_tache.ecet=c.ecet
     			AND one_tache.acta=c.acta
     			AND one_tache.acst=c.acst
     			;

     			IF SQL%NOTFOUND THEN
     				-- on arrête la mise a jour
     				L_PID :='RAS';
     			ELSE
     				-- on met à jour les nouveaux n° de tache et de sous-tache pour les consommes

     				UPDATE CONS_SSTRES_M_REJET_DATESTATUT c
     				SET 	ACTA_NEW=DECODE(l_acta,'00',ONE_TACHE.ACTA,l_acta),
     					ACST_NEW=DECODE(l_acst,'00',ONE_TACHE.ACST,l_acst)
     				WHERE one_tache.pid=c.pid
     				AND one_tache.ecet=c.ecet
     				AND one_tache.acta=c.acta
     				AND one_tache.acst=c.acst
     				;

				IF SQL%NOTFOUND THEN

     				L_PID :='RAS';
     				END IF;
     			END IF;
     		EXCEPTION

			WHEN NO_DATA_FOUND THEN
					INSERT INTO TACHE (PID,ECET,ACTA,ACST,AISTTY,AISTPID,ADEB,AFIN,ANDE,ANFI,ADUR,APCP,ASNOM,ASTA,AIST)
					VALUES (ONE_TACHE.PID,ONE_TACHE.ECET,ONE_TACHE.ACTA,ONE_TACHE.ACST,ONE_TACHE.AISTTY
					,ONE_TACHE.AISTPID,ONE_TACHE.ADEB,ONE_TACHE.AFIN,ONE_TACHE.ANDE,ONE_TACHE.ANFI
					,ONE_TACHE.ADUR,ONE_TACHE.APCP,ONE_TACHE.ASNOM,ONE_TACHE.ASTA,ONE_TACHE.AIST
                			);

     					L_INSERTED := L_INSERTED + 1;
			WHEN OTHERS THEN
					TRCLOG.TRCLOG( P_HFILE,'Probleme de reinsertion pour : '|| ONE_TACHE.PID ||' , '||ONE_TACHE.ECET || ' , ' ||ONE_TACHE.ACTA||','||ONE_TACHE.ACST||','||L_ACTA||','||L_ACST||' - erreur: ' ||SQLERRM);
     					TRCLOG.TRCLOG( P_HFILE, l_statement);



     		END;
     	EXCEPTION
     		--gestion des doublons : recuperation dans une TABLE de rejet
     		when CONSTRAINT_VIOLATION OR INDEX_PK_VIOLATION then
     				L_ORAERRMSG := sqlerrm;
     				-- DUPLICATION DE CODE POUR RAPPORT D'ERREUR
     				-- -----------------------------------------
     				INSERT INTO BATCH_TACHE_BAD(PID,ECET,ACTA,ACST,AISTTY,AISTPID,ADEB,AFIN,ANDE,ANFI,ADUR,APCP,ASNOM,ASTA,AIST,ERRMSG)
				VALUES (ONE_TACHE.PID,ONE_TACHE.ECET,ONE_TACHE.ACTA,ONE_TACHE.ACST,ONE_TACHE.AISTTY
					,ONE_TACHE.AISTPID,ONE_TACHE.ADEB,ONE_TACHE.AFIN,ONE_TACHE.ANDE,ONE_TACHE.ANFI
					,ONE_TACHE.ADUR,ONE_TACHE.APCP,ONE_TACHE.ASNOM,ONE_TACHE.ASTA,ONE_TACHE.AIST,
         		       		SUBSTR(l_ORAERRMSG,1,127));
     				L_REJECTED := L_REJECTED + 1;

     		WHEN MAX_ACST THEN

     			TRCLOG.TRCLOG( P_HFILE, l_statement);
     			TRCLOG.TRCLOG( P_HFILE, '!!! Impossible de reinserer la tache...  PID: '||one_tache.pid||', N° etape: '||one_tache.ecet||', N° tache: '||one_tache.acta||', N° sous-tache: '||one_tache.acst||' !!!');

     			INSERT INTO BATCH_TACHE_BAD(PID,ECET,ACTA,ACST,AISTTY,AISTPID,ADEB,AFIN,ANDE,ANFI,ADUR,APCP,ASNOM,ASTA,AIST,ERRMSG)
				VALUES (ONE_TACHE.PID,ONE_TACHE.ECET,ONE_TACHE.ACTA,ONE_TACHE.ACST,ONE_TACHE.AISTTY
					,ONE_TACHE.AISTPID,ONE_TACHE.ADEB,ONE_TACHE.AFIN,ONE_TACHE.ANDE,ONE_TACHE.ANFI
					,ONE_TACHE.ADUR,ONE_TACHE.APCP,ONE_TACHE.ASNOM,ONE_TACHE.ASTA,ONE_TACHE.AIST,
         		       		'Erreur extension acst');
     				L_REJECTED := L_REJECTED + 1;

     		WHEN OTHERS THEN
     		TRCLOG.TRCLOG( P_HFILE, 'Fin anormale de modif de la table des rejets concernant les lignes avec ss traitance dont datestatut < moismens -1');
     		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
     		TRCLOG.TRCLOG( P_HFILE, l_statement);
     		RAISE;
     END;
     COMMIT;
     	l_acst := '00';
	l_acta := '00';
END LOOP;
TRCLOG.TRCLOG( P_HFILE, 'Fin de la reinsertion des taches');

END;
COMMIT;

TRCLOG.TRCLOG( P_HFILE, L_statement || ' : ' || L_INSERTED ||
		               ' rows inserted. ' || L_REJECTED || ' rows rejected.' );

/********************************************************
** Mise à jour des affectations
********************************************************/
L_INSERTED := 0;
L_REJECTED := 0;
l_statement:='Insertion dans CONS_SSTACHE_RES';
DECLARE

 /* curseur pour insertion dans CONS_SSTACHE_RES
 On sélectionne toutes les affectations à reinserer en se basant sur le pid, le numero d'etape, de tache,
 de sous-tache et l'identifiant de la ressource */

CURSOR C_AFFECTA IS
	SELECT rej.PID,rej.ECET_NEW,rej.ACTA_NEW,rej.ACST_NEW,rej.ident,rej.TPLAN,rej.TACTU,rej.TEST
	FROM CONS_SSTRES_REJET_DATESTATUT rej
	MINUS
	SELECT c.PID,c.ECET,c.ACTA,c.ACST,c.ident,c.TPLAN,c.TACTU,c.TEST
	FROM cons_sstache_res c;

BEGIN

     TRCLOG.TRCLOG( P_HFILE, l_statement);

     FOR ONE_AFFECTA IN C_AFFECTA LOOP
          	BEGIN
     		INSERT INTO CONS_SSTACHE_RES (PID,ECET,ACTA,ACST,IDENT,TPLAN,TACTU,TEST)
     		VALUES(ONE_AFFECTA.PID,ONE_AFFECTA.ECET_NEW,ONE_AFFECTA.ACTA_NEW,
     			ONE_AFFECTA.ACST_NEW,ONE_AFFECTA.ident,ONE_AFFECTA.TPLAN,
     			ONE_AFFECTA.TACTU,ONE_AFFECTA.TEST)
     		;

     		L_INSERTED := L_INSERTED + 1;

     		EXCEPTION
          		--gestion des doublons : recuperation dans une TABLE de rejet
          		when CONSTRAINT_VIOLATION OR INDEX_PK_VIOLATION then
          				L_ORAERRMSG := sqlerrm;
          				-- DUPLICATION DE CODE POUR RAPPORT D'ERREUR
          				-- -----------------------------------------
          				INSERT INTO BATCH_CONS_SSTACHE_RES_BAD(PID,ECET,ACTA,ACST,IDENT,TPLAN,TACTU,TEST,ERRMSG)
     					VALUES (ONE_AFFECTA.PID,ONE_AFFECTA.ECET_NEW,ONE_AFFECTA.ACTA_NEW,
     					ONE_AFFECTA.ACST_NEW,ONE_AFFECTA.ident,ONE_AFFECTA.TPLAN,
     					ONE_AFFECTA.TACTU,ONE_AFFECTA.TEST,SUBSTR(l_ORAERRMSG,1,127));
          				L_REJECTED := L_REJECTED + 1;

          		WHEN OTHERS THEN
          		TRCLOG.TRCLOG( P_HFILE, 'Fin anormale de modif de la table des rejets concernant les lignes avec ss traitance dont datestatut < moismens -1');
          		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
          		TRCLOG.TRCLOG( P_HFILE, l_statement);
          		RAISE;

     		END;
     	END LOOP;
	COMMIT;
END;

TRCLOG.TRCLOG( P_HFILE, 'Fin d insertion dans cons_sstache_res');
TRCLOG.TRCLOG( P_HFILE, L_statement || ' : ' || L_INSERTED ||
		               ' rows inserted. ' || L_REJECTED || ' rows rejected.' );


/********************************************************
** Mise à jour des consommes
********************************************************/
L_INSERTED := 0;
L_REJECTED := 0;
L_UPDATED := 0;
l_statement:='Insertion dans CONS_SSTACHE_RES_MOIS';
DECLARE

 /* curseur pour insertion dans CONS_SSTACHE_RES_MOIS
 On sélectionne tous les consommes à reinserer en se basant sur le pid, le numero d'etape, de tache,
 de sous-tache, l'identifiant de la ressource et le mois */

CURSOR C_CONSOMMES IS
	SELECT rej.PID,rej.ECET_NEW,rej.ACTA_NEW,rej.ACST_NEW,rej.ident,rej.CDEB,rej.CUSAG
	FROM CONS_SSTRES_M_REJET_DATESTATUT rej
	MINUS
	SELECT c.PID,c.ECET,c.ACTA,c.ACST,c.ident,c.CDEB,c.CUSAG
	FROM cons_sstache_res_mois c;

BEGIN

     TRCLOG.TRCLOG( P_HFILE, l_statement);

     FOR ONE_CONSOMMES IN C_CONSOMMES LOOP
          	BEGIN

          	UPDATE CONS_SSTACHE_RES_MOIS c
          	SET c.CUSAG = NVL(c.CUSAG,0) + ONE_CONSOMMES.CUSAG
          	WHERE ONE_CONSOMMES.pid=c.pid
          	AND ONE_CONSOMMES.ecet_new=c.ecet
          	AND ONE_CONSOMMES.acta_new=c.acta
          	AND ONE_CONSOMMES.acst_new=c.acst
          	AND ONE_CONSOMMES.ident=c.ident
          	AND ONE_CONSOMMES.cdeb=c.cdeb;

          	L_UPDATED := L_UPDATED + 1;

          	IF SQL%NOTFOUND THEN

     			INSERT INTO CONS_SSTACHE_RES_MOIS (PID,ECET,ACTA,ACST,IDENT,CDEB,CUSAG)
     			VALUES(ONE_CONSOMMES.PID,ONE_CONSOMMES.ECET_NEW,ONE_CONSOMMES.ACTA_NEW,
     				ONE_CONSOMMES.ACST_NEW,ONE_CONSOMMES.ident,ONE_CONSOMMES.CDEB,
     				ONE_CONSOMMES.CUSAG);

     		L_INSERTED := L_INSERTED + 1;

     		END IF;
     		EXCEPTION
          		--gestion des doublons : recuperation dans une TABLE de rejet
          		when CONSTRAINT_VIOLATION  OR INDEX_PK_VIOLATION then
          				L_ORAERRMSG := sqlerrm;
          				-- DUPLICATION DE CODE POUR RAPPORT D'ERREUR
          				-- -----------------------------------------
          				INSERT INTO BATCH_CONS_SST_RES_M_BAD(PID,ECET,ACTA,ACST,IDENT,CDEB,CUSAG,ERRMSG)
     					VALUES (ONE_CONSOMMES.PID,ONE_CONSOMMES.ECET_NEW,ONE_CONSOMMES.ACTA_NEW,
     					ONE_CONSOMMES.ACST_NEW,ONE_CONSOMMES.ident,ONE_CONSOMMES.CDEB,
     					ONE_CONSOMMES.CUSAG,SUBSTR(l_ORAERRMSG,1,127));
          				L_REJECTED := L_REJECTED + 1;

          		WHEN OTHERS THEN
          		TRCLOG.TRCLOG( P_HFILE, 'Fin anormale de modif de la table des rejets concernant les lignes avec ss traitance dont datestatut < moismens -1');
          		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
          		TRCLOG.TRCLOG( P_HFILE, l_statement);
          		RAISE;

     		END;
     	END LOOP;
	COMMIT;
END;

TRCLOG.TRCLOG( P_HFILE, 'Fin d insertion dans cons_sstache_res_mois');
TRCLOG.TRCLOG( P_HFILE, L_statement || ' : ' || L_INSERTED ||
               ' rows inserted. ' || L_REJECTED || ' rows rejected.' || L_UPDATED || ' rows updated.' );

COMMIT ;

TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement d insertion des donnees concernant les lignes avec ss traitance dont datestatut < moismens -1');
EXCEPTION

	WHEN OTHERS THEN
		TRCLOG.TRCLOG( P_HFILE,'On est dans le grand block ...');
	TRCLOG.TRCLOG( P_HFILE, 'Fin anormale du traitement d insertion des donnees concernant les lignes avec ss traitance dont datestatut < moismens -1');
	TRCLOG.TRCLOG( P_HFILE, SQLERRM);
	TRCLOG.TRCLOG( P_HFILE, l_statement);
	RAISE;



END copie_datestatut;

end PACKBATCH;
/
CREATE OR REPLACE package PACKBATCH2 as

	-- Existe deja dans PACKBATCH.
	-- Utilitaire : calcul du mois et de l'année de traitement
	-- en cours, non pas d'après la date système, mais d'après
	-- la date de la prochaine mensuelle
	-- -------------------------------------------------------
	procedure CALCDATTRT( P_HFILE in utl_file.file_type,
	                      P_MOISTRT out number,
	                      P_ANTRT   out number );

	-- Utilitaire : calcul de la date de début d'exercice
	-- --------------------------------------------------
--	procedure CALCDATDBX( P_HFILE in utl_file.file_type,
--	                      P_DATDBX out date );

	-- A procedure de la mensuelle
	-- -----------------------------------

	-- Procedure appeller par le shell pour la mensuelle
	-- --------------------------------------
	procedure ST54702F( P_LOGDIR in varchar2 );

      -- Procedure lancée par le shell pour le chargement de
      -- la table centre d'activité
      ------------------------------------------------------
   procedure ST54702K( P_LOGDIR in varchar2 );


      -- Copie ligne_bip et etape dans ligne_bip2 et etape2
      -- --------------------------------------------------
	procedure ST54700G( P_LOGDIR in varchar2 );


      -- Procédure pour le message de début et de bonne fin
      -- --------------------------------------------------
	procedure DEBFINTRAIT( P_LOGDIR in varchar2, P_TYPE_MSG in varchar2 );


	-- Change la date de la prochaine mensuelle
	-- --------------------------
	procedure RPMOISU(P_LOGDIR in varchar2 );

	-- Genere l'historique par projet (prise en compte de la sous-traitance)
	-- -------------------------
	procedure PROHISB(P_HFILE in utl_file.file_type);

	-- Maj des centres d'activite et maitrise d'ouvrage
	-- -------------------------
	procedure CHARGCAM(P_HFILE in utl_file.file_type);

	-- Copie ligne_bip et etape dans ligne_bip2 et etape2
	-- -------------------------
	procedure COPIE_BIP_BIP2(P_HFILE in utl_file.file_type);

	-- Ecriture du message de début fin des batchs
	-- -------------------------
      procedure ECRITURE_MESSAGE(P_HFILE in utl_file.file_type, P_TYPE_MSG in varchar2 );

	-- Maj de consomme
	-- -------------------------
	PROCEDURE Alim_conso(P_HFILE in utl_file.file_type);

	-- Ajout d'une actualité pour indiqué qu'un traitement est en cours
	-- -------------------------
	procedure ADD_ACTUALITE(p_position in varchar2 );

end PACKBATCH2;
/

CREATE OR REPLACE package body PACKBATCH2 as

	-- Gestions exceptions
	-- -------------------

	CALLEE_FAILED exception;
	pragma exception_init( CALLEE_FAILED, -20000 );
	CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
	TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
	ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
	CONSTRAINT_VIOLATION exception;          -- pour clause when
	pragma exception_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère

	-- Dates Globales pour utilisation dans fonctions
	-- appelées en SQL. Oracle Corp. N'est PAS
	-- composée de Dieux vivants. PL/SQL a été codé
	-- par des gens normaux. Il y a des bugs.
	-- C'est pas (trés) grave, on contourne.
	-- ----------------------------------------------
	G_DAT0101AN date;            -- le 01/01 de l'année de l'exercice
	G_DAT0101ANM1 date;          -- le 01/01 de l'année d'avant celle de l'exercice

	-- ------------------------------------------------
	-- Copier/Coller/Modifier de l'exemple 'drop_table'
	-- de la documentation en ligne de PL/SQL dans
	-- Interaction with Oracle : using DLL and
	-- dynamic SQL
	-- ------------------------------------------------
	procedure DYNA_TRUNCATE( TABLENAME IN VARCHAR2 ) is

		CID integer;

	begin

		-- Open new cursor and return cursor ID.
		-- -------------------------------------
		CID := DBMS_SQL.OPEN_CURSOR;
		-- Parse and immediately execute dynamic SQL statement built by
		-- concatenating table name to command.
		-- ------------------------------------------------------------
		DBMS_SQL.PARSE( CID, 'TRUNCATE TABLE ' || TABLENAME,dbms_sql.v7 );

		-- Close cursor.
		-- -------------
		DBMS_SQL.CLOSE_CURSOR( CID );

	exception

		-- If an exception is raised, close cursor before exiting.
		-- -------------------------------------------------------
		-- note de manuel L : Et si l'exception a lieu pendant le
		-- open ou le close ?
		-- (supposons que LEUR code EST correct)
		-- -------------------------------------------------------
		when others then
			DBMS_SQL.CLOSE_CURSOR( CID );
		      raise;  -- reraise the exception

	end DYNA_TRUNCATE;


	-- -----------------------------------------
	-- CALCDATTRT : on calcule le numero du mois
	-- de traitement a partir de la date de la
	-- prochaine mensuelle, qu'on trouve dans
	-- la table DATDEBEX. Le mois de traitement
	-- courant est le mois precedent.
	-- La table DATDEBEX est mis a jour en fin
	-- de mensuelle a l'aide de la table
	-- calendrier et de la date systeme.
	-- -----------------------------------------
	procedure CALCDATTRT( P_HFILE in utl_file.file_type,
	                      P_MOISTRT out number,
	                      P_ANTRT   out number ) is

		L_DATTRT date;
		L_PROCNAME varchar2( 16 ) := 'CALCDATTRT';

	begin

		-- Recherche de la date de la
		-- ===> PROCHAINE <=== mensuelle
		-- et renvoi du mois, annee du mois
		-- d'avant
		-- ----------------------------------
		select add_months( CMENSUELLE, -1 )
		into L_DATTRT
		from DATDEBEX;
		P_MOISTRT := to_char( L_DATTRT, 'MM' );
		P_ANTRT   := to_char( L_DATTRT, 'YYYY' );

	exception

		when others then
			TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			raise CALLEE_FAILED;

	end CALCDATTRT;

	-- -----------------------------------------
	-- CALCDATDBX : on rend simplement la date
	-- de debut d'exercice qu'on trouve dans la
	-- table DATDEBEX.
	-- -----------------------------------------
	procedure CALCDATDBX( P_HFILE in utl_file.file_type,
	                      P_DATDBX out date ) is

		L_PROCNAME varchar2(16):='CALCDATDBX';

	begin

		select DATDEBEX
		into P_DATDBX
		from DATDEBEX;

	exception

		when others then
			TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			raise CALLEE_FAILED;

	end CALCDATDBX;



	-- MENSUELLE contient :
	-- PROHISB    : vide puis remplit la table hispro
	-- -------------------
	procedure ST54702F( P_LOGDIR in varchar2 ) IS

		L_HFILE utl_file.file_type;
		L_RETCOD number;

		L_PROCNAME varchar2(16) := 'ST54702F';

	begin

		-- Init de la trace
		-- ----------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

		-- Lancement des programmes de la mensuelle
		-- --------------

		PROHISB( L_HFILE  );

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	exception

		when others then
			rollback;
			if sqlcode <> CALLEE_FAILED_ID and
			   sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

	end ST54702F;


	-- Change la date de la prochaine mensuelle
	-- MAJ de DATDEBEX
	-- --------------------------
        procedure RPMOISU (P_LOGDIR in varchar2 ) IS

	   L_HFILE utl_file.file_type;
	   L_RETCOD number;
	   L_PROCNAME varchar2(16) := 'RPMOISU';
	   L_STATEMENT varchar2(64);

	BEGIN

	   -- Init de la trace
	   -- ----------------
	   L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
	   if ( L_RETCOD <> 0 ) then
	      raise_application_error( TRCLOG_FAILED_ID,
				       'Erreur : Gestion du fichier LOG impossible',
				       false );
	   end if;

	   -- Trace Start
	   -- -----------
	   TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

	   L_STATEMENT := 'Maj de datdebex';
	   -- Recupere la date de la mensuelle pour
	   -- le mois courant puis
	   -- Maj de CMENSUELLE dans datdebex
	   -- ---------
	   UPDATE DATDEBEX SET (CMENSUELLE) =
	     (SELECT CMENSUELLE
	      FROM   calendrier
	      WHERE  trunc(CALANMOIS, 'MONTH') = trunc(SYSDATE,'MONTH')
	      );
	   TRCLOG.TRCLOG( L_HFILE, L_STATEMENT ||'-'||sql%rowcount);
	   commit;

	   TRCLOG.TRCLOG( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME );

	   -- Trace Stop
	   -- ----------
	   TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
	   TRCLOG.CLOSETRCLOG( L_HFILE );

	exception

	   when others then
	     rollback;
	     if sqlcode <> CALLEE_FAILED_ID and
	       sqlcode <> TRCLOG_FAILED_ID then
		TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
	     end if;
	     if sqlcode <> TRCLOG_FAILED_ID then
		TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );
		raise_application_error( CALLEE_FAILED_ID,
					 'Erreur : consulter le fichier LOG',
					 false );
	     else
		raise;
	     end if;

	end RPMOISU;


--
-- Procedure de mise a jour de la table consomme
--

	PROCEDURE Alim_conso(P_HFILE in utl_file.file_type)
	IS

	L_PROCNAME varchar2(16) := 'Alim_conso';
	L_STATEMENT varchar2(64);

	l_annee integer;
	BEGIN

	-- initialisation de la variable locale l_annee

		select to_number(to_char(datdebex,'YYYY')) into l_annee from datdebex;

	-- insertion dans la table consomme des lignes bip inexistantes pour l'année courante et l'année N-1

	L_STATEMENT:='Lignes BIP inexistantes annee N';

		INSERT INTO CONSOMME (annee,pid,cusag,xcusag)
		(SELECT l_annee,
			lb.pid,
			0,
			0
		 FROM ligne_bip lb
		 WHERE NOT EXISTS (SELECT pid from consomme where consomme.pid = lb.pid
                                        AND consomme.annee = l_annee));

		COMMIT;

	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||':-'||sql%rowcount);


	L_STATEMENT:='Lignes BIP inexistantes annee N-1';

		INSERT INTO CONSOMME (annee,pid,cusag,xcusag)
		(SELECT l_annee-1,
			lb.pid,
			0,
			0
		 FROM ligne_bip lb
		 WHERE NOT EXISTS (SELECT pid from consomme where consomme.pid = lb.pid
						AND consomme.annee = l_annee-1));

		COMMIT;


	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||':-'||sql%rowcount);


	L_STATEMENT:='Alimentation du consomme : cusag';

	-- alimentation de la table CONSOMME
			UPDATE CONSOMME
			SET cusag = (select nvl(sum(cusag),0) from proplus ,datdebex
					where cdeb >= datdebex
					and proplus.factpid = CONSOMME.pid
					and (qualif not in ('MO','GRA','STA','IFO','INT') OR qualif is null))
			WHERE annee = l_annee
			;


			COMMIT;


	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||':-'||sql%rowcount);



	-- pour alimenter le cumul du consommé d'un pid toutes années confondues on doit faire l'update précédent avant
	-- celui-ci pour la prise en compte du nouveau cusag(cumul pour l'année courante) que l'on va ajouter à xcusag
	-- (cumul total)

	L_STATEMENT:='Alimentation du consomme total';

			UPDATE CONSOMME
			SET xcusag = (select nvl(xcusag,0) from consomme cc
						where cc.pid = consomme.pid
						and cc.annee = l_annee-1)
			WHERE annee = l_annee;

			UPDATE CONSOMME
			SET xcusag = nvl(xcusag,0) + nvl(cusag,0)
			WHERE annee = l_annee;

	COMMIT;

	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||':-'||sql%rowcount);

	END Alim_conso;



	procedure PROHISB( P_HFILE in utl_file.file_type ) IS

		L_PROCNAME varchar2( 16 ) := 'PROHISB';
		L_STATEMENT varchar2(64);
		L_MOISTRT   number(2);
		L_ANTRT     number(4);

	begin

	TRCLOG.TRCLOG( P_HFILE, 'Début de ' || L_PROCNAME );
	L_STATEMENT := 'Recherche mois de traitement';

	CALCDATTRT( P_HFILE, L_MOISTRT, L_ANTRT );
	TRCLOG.TRCLOG( P_HFILE, 'Traitement au titre du mois ' || L_MOISTRT || ' de ' || L_ANTRT );

--	TRCLOG.TRCLOG( P_HFILE, 'Traitement au titre du mois ' ||
--			 trunc(add_months(sysdate,-1),'MONTH') || ' de ' || trunc(add_months(sysdate,-1),'MONTH') );

	 -- DELETE ALL ROWS FROM hispro
	 -- ------------------

	L_STATEMENT := 'Table hispro vide';
	DYNA_TRUNCATE('hispro');
	commit;

	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT);

	-- INSERT les donnees dans hispro
	-- FACTPDSG, FACTPID, PID, PDSG, TIRES, CDEB, FACTPNO, PNOM, AISTTY
	-- SECGROU, DIVSECGROU, CUSAG, IDRES
	-- Il y a inversion entre les donnees de proplus et hispro pour PID, FACTPID, FACTPNO, FACTPDSG, PNOM, ,PDSG
	-- ----------------------

	L_STATEMENT := 'Ajout des data dans hispro';
      INSERT INTO hispro (TIRES,
		    CDEB,
		    FACTPDSG,
		    FACTPID,
		    PID,
		    PDSG,
		    FACTPNO,
		    PNOM,
		    CUSAG,
		    IDPRO,
		    FLAG,
		    IDRES
		   )
	SELECT  pro.TIRES,
		pro.CDEB,
		pro.PDSG,
		pro.PID,
		pro.FACTPID,
		pro.FACTPDSG,
		pro.PNOM,
		pro.FACTPNO,
		pro.CUSAG,
		b.IDPRO,
		'2',
		RTRIM(substr(res.rnom,1,11))|| '-' || substr(res.rprenom,1,1)|| '.' as IDRES
	FROM  (SELECT  RTRIM(substr(r.rnom,1,11))|| '-' || substr(r.rprenom,1,1)|| '.' as IDPRO,
			   a.tires as idtires,
			   a.cdeb  as idcdeb,
			   a.pid   as idpid
		  FROM   (SELECT distinct pro.tires,
				     pro.pcpi,
			           pro.pid,
			           pro.cdeb
			    FROM   proplus pro, ressource r
			    WHERE  trunc(pro.CDEB,'YEAR') = trunc(to_date(L_ANTRT, 'YYYY'), 'YEAR')
			    AND    pro.tires = r.ident
			    AND    (pro.AISTTY = 'FF' OR pro.AISTTY = 'DC')
			   ) a,
			   ressource r
		  WHERE  a.pcpi = r.ident) b,
              proplus pro,
              ressource res
	WHERE  pro.tires = res.ident
	AND    trunc(pro.CDEB,'YEAR') = trunc(to_date(L_ANTRT, 'YYYY'), 'YEAR')
	AND    (pro.AISTTY = 'FF' OR pro.AISTTY = 'DC')
	AND    pro.tires = b.idtires
	AND    pro.pid = b.idpid
	AND    pro.cdeb = b.idcdeb
	AND    factpid is not null;

	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||'-'||sql%rowcount);
	commit;

	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME   );

	exception

		when others then
			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||
                                               ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' ||
                                                L_PROCNAME  );
			raise CALLEE_FAILED;

	end PROHISB;

	-- SHELL appele pour lancer CHARGCAM
	-- CHARGCAM : charge la table charge_camo.
	-- ----------
	procedure ST54702K( P_LOGDIR in varchar2 ) IS

		L_HFILE utl_file.file_type;
		L_RETCOD number;
		L_PROCNAME varchar2(16) := 'ST54702K';

	begin

		-- Init de la trace
		-- ----------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

		-- Lancement du programmes de chargement
		-- --------------
		CHARGCAM( L_HFILE );

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	exception

		when others then
			rollback;
			if sqlcode <> CALLEE_FAILED_ID and
			   sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

	end ST54702K;

	-- Maj des centres d'activite et maitrise d'ouvrage
	-- -------------------------
	procedure CHARGCAM( P_HFILE in utl_file.file_type ) IS

		L_PROCNAME varchar2(16):= 'CHARGCAM';
		L_STATEMENT varchar2(64);

	begin


      ---------------------------------------------------
      -- Alimentation de la table contenant des rejéts
	-- de chargement dans la table camo
	---------------------------------------------------

	L_STATEMENT := 'Truncate BATCH_CHARGE_CAMO_BAD';
	DYNA_TRUNCATE('BATCH_CHARGE_CAMO_BAD');

	L_STATEMENT := 'Chargement de la table des rejéts camo';
	insert into BATCH_CHARGE_CAMO_BAD ( XCODCAMO,
      	                              XCLIBRCA,
	       	                      XCLIBCA,
                  	              XCDATEOUVE,
                        	      XCDATEFERM,
                              	      XCODNIV,
					XCANIV1,
					XCANIV2,
                                        XCANIV3,
                                        XCANIV4,
                                        XCDFAIN )
	select XCODCAMO,
      	 XCLIBRCA,
         XCLIBCA,
      	 XCDATEOUVE,
       	 XCDATEFERM,
       	 XCODNIV,
       	 XCANIV1,
       	 XCANIV2,
       	 XCANIV3,
       	 XCANIV4,
       	 XCDFAIN
	from CHARGE_CAMO chcam, CENTRE_ACTIVITE cact
	where to_number(substr(chcam.XCODCAMO, 6, 5)) = cact.CODCAMO
	and  cact.CTOPAMO = 'M';
	commit;
      TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||'-'|| sql%rowcount || 'rows inserted');

	-----------------------------------------------------
	-- Alimentation de la table centre activité à partir
	-- de la table CHARGE_CAMO
	-----------------------------------------------------

	-----------------------------------------------------
	-- MAJ dans le cas le l'existance d'un code centre
	-- d'activité dans la table de chargement et dans la
	-- la table des centres d'activité
	-----------------------------------------------------

      L_STATEMENT := 'Update centre activité';

	update CENTRE_ACTIVITE cact
	set (cact.CODCAMO,
           cact.CLIBCA,
     	   cact.CDATEOUVE,
           cact.CDATEFERM,
           cact.CODNIVCA,
           cact.CANIV4,
           cact.CANIV3,
           cact.CANIV2,
           cact.CANIV1,
           cact.CLIBRCA,
           cact.CTOPAMO,
           cact.CDFAIN ) =
          (select
          to_number(substr(chcam.XCODCAMO, 6, 5)),
          substr(chcam.XCLIBCA, 1, 27),
          trunc(chcam.XCDATEOUVE, 'MONTH'),
          trunc(chcam.XCDATEFERM, 'MONTH'),
          to_number(decode(chcam.XCODNIV, 30, 5, 99, 4, 31, 4, 32, 3,
                                33, 2, 34, 1, 35, 0, 0)),
          to_number(substr(nvl(chcam.XCANIV4, '00000000000'), 6, 5)),
          to_number(substr(nvl(chcam.XCANIV3, '00000000000'), 6, 5)),
          to_number(substr(nvl(chcam.XCANIV2, '00000000000'), 6, 5)),
          to_number(substr(nvl(chcam.XCANIV1, '00000000000'), 6, 5)),
          substr(chcam.XCLIBRCA, 1, 16),
          'A',
          chcam.XCDFAIN
          from CHARGE_CAMO chcam
          where to_number(substr(chcam.XCODCAMO, 6, 5)) = cact.CODCAMO
          and cact.CTOPAMO <> 'M'
          )
      where cact.CODCAMO IN (select cact.CODCAMO
                             from centre_activite cact, charge_camo chcam
                             where to_number(substr(chcam.XCODCAMO, 6, 5)) = cact.CODCAMO
                             and cact.CTOPAMO <> 'M');
      commit;
      TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||'-'||sql%rowcount || 'rows updated');


      -----------------------------------------------------
      -- INSERT dans le cas de l'inéxistance d'un code centre
      -- d'activité dans la table de chargement et dans la
      -- la table des centres d'activités
      -----------------------------------------------------

      L_STATEMENT := 'Insert centre activité';

      insert into CENTRE_ACTIVITE     (  CODCAMO,
                                         CLIBCA,
     	                                 CDATEOUVE,
                                         CDATEFERM,
                                         CODNIVCA,
                                         CANIV4,
                                         CANIV3,
                                         CANIV2,
                                         CANIV1,
                                         CLIBRCA,
                                         CTOPAMO,
                                         CTOPACT,
                                         CDFAIN
                                        )
      select
          to_number(substr(chcam.XCODCAMO, 6, 5)),
          substr(chcam.XCLIBCA, 1, 27),
          trunc(chcam.XCDATEOUVE, 'MONTH'),
          trunc(chcam.XCDATEFERM, 'MONTH'),
          to_number(decode(chcam.XCODNIV, 30, 5, 99, 4, 31, 4, 32, 3,
                                33, 2, 34, 1, 35, 0, 0)),
          to_number(substr(nvl(chcam.XCANIV4, '00000000000'), 6, 5)),
          to_number(substr(nvl(chcam.XCANIV3, '00000000000'), 6, 5)),
          to_number(substr(nvl(chcam.XCANIV2, '00000000000'), 6, 5)),
          to_number(substr(nvl(chcam.XCANIV1, '00000000000'), 6, 5)),
          substr(chcam.XCLIBRCA, 1, 16),
          'A',
          'B',
          chcam.XCDFAIN
      from CHARGE_CAMO chcam
      where not exists (select 1 from CENTRE_ACTIVITE cact
                        where to_number(substr(chcam.XCODCAMO, 6, 5)) = cact.CODCAMO)
	and to_number(substr(chcam.XCODCAMO, 6, 1)) in (1,2);

      commit;
      TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||'-'||sql%rowcount || 'rows inserted');

	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME   );

	exception

		when others then
			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||
                                               ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' ||
                                                L_PROCNAME  );
			raise CALLEE_FAILED;

	end CHARGCAM;


	-- SHELL appele pour lancer COPIE_BIP_BIP2
	--
	-- ----------
	procedure ST54700G( P_LOGDIR in varchar2 ) IS

		L_HFILE utl_file.file_type;
		L_RETCOD number;
		L_PROCNAME varchar2(16) := 'ST54700G';

	begin

		-- Init de la trace
		-- ----------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

		-- Lancement du programmes de chargement
		-- --------------
		COPIE_BIP_BIP2(L_HFILE);

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	exception

		when others then
			rollback;
			if sqlcode <> CALLEE_FAILED_ID and
			   sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

	end ST54700G;


      -- -------------------------------------------------------------------
      -- Procédure de recopie de bip dans bip2 et de etape dans etape2
      -- Ce traitement se fait en fin de mensuelle pour l'analyse des écarts
      -- bip bip2 pour la prémensuelle suivante
      -- -------------------------------------------------------------------

	procedure COPIE_BIP_BIP2(P_HFILE in utl_file.file_type) IS

		L_PROCNAME varchar2(16) := 'COPIE_BIP_BIP2';
		L_STATEMENT varchar2(64);

	begin
      L_STATEMENT := 'Truncate de etape2';
      DYNA_TRUNCATE('ETAPE2');

      L_STATEMENT := 'Truncate de ligne_bip2';
      DYNA_TRUNCATE('LIGNE_BIP2');

      L_STATEMENT := 'Copie ligne_bip ligne_bip2';

      insert into ligne_bip2
      ( PID,
        PJCAMON1,
        ASTATUT,
        ADATESTATUT,
        TTRMENS,
        TTRFBIP,
        TVAEDN,
        TDEBINN,
        TDATFHP,
        TDATFHR,
        TDATFHN,
        TDATEBR,
        TARCPROC,
        POBJET,
        PDATDEBPRE,
        PDATFINPRE,
        PTYPEN1,
        PCACTOP,
        PCONSN1,
        PDECN1,
        PMOYCEN,
        PSITDED,
        PNMOUVRA,
        PCLE,
        PETAT,
        PNOM,
        PCPI,
        TOPTRI,
        TYPPROJ,
        ICPI,
        CODPSPE,
        CODCAMO,
        DPCODE,
        CODSG,
        ARCTYPE,
        AIRT,
        CLICODE,
	  PZONE,
	FLAGLOCK )
      select
        PID,
        PJCAMON1,
        ASTATUT,
        ADATESTATUT,
        TTRMENS,
        TTRFBIP,
        TVAEDN,
        TDEBINN,
        TDATFHP,
        TDATFHR,
        TDATFHN,
        TDATEBR,
        TARCPROC,
        POBJET,
        PDATDEBPRE,
        PDATFINPRE,
        PTYPEN1,
        PCACTOP,
        PCONSN1,
        PDECN1,
        PMOYCEN,
        PSITDED,
        PNMOUVRA,
        PCLE,
        PETAT,
        PNOM,
        PCPI,
        TOPTRI,
        TYPPROJ,
        ICPI,
        CODPSPE,
        CODCAMO,
        DPCODE,
        CODSG,
        ARCTYPE,
        AIRT,
        CLICODE,
	  PZONE,
	FLAGLOCK
      from LIGNE_BIP;
      commit;

      TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||'-'||sql%rowcount);

      L_STATEMENT := 'Copie etape etape2';

      insert into ETAPE2
      ( PID, ECET, EDUR, ENFI, ENDE, EDEB, EFIN, TYPETAP )
      select
        PID, ECET, EDUR, ENFI, ENDE, EDEB, EFIN, TYPETAP
      from ETAPE;
      commit;
      TRCLOG.TRCLOG( P_HFILE, L_STATEMENT ||'-'||sql%rowcount);

	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME   );

	exception

		when others then
			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||
                                               ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' ||
                                                L_PROCNAME  );
			raise CALLEE_FAILED;

	end COPIE_BIP_BIP2;



	-- SHELL appele pour lancer DEBFINTRAIT
	--
	-- ----------
	procedure DEBFINTRAIT( P_LOGDIR in varchar2, P_TYPE_MSG in Varchar2 ) IS

		L_HFILE utl_file.file_type;
		L_RETCOD number;
		L_PROCNAME varchar2(16) := 'DEBFINTRAIT';

	begin

		-- Init de la trace
		-- ----------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-- Trace Start
		-- -----------
--		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );
		TRCLOG.TRCLOG( L_HFILE, 'Start ' || L_PROCNAME || ' -> ' || P_TYPE_MSG);
		-- Lancement du programmes de mise à jour
		-- --------------
		ECRITURE_MESSAGE ( L_HFILE , P_TYPE_MSG );

		-- Trace Stop
		-- ----------
		-- TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	exception

		when others then
			rollback;
			if sqlcode <> CALLEE_FAILED_ID and
			   sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

	end DEBFINTRAIT;


      -- -------------------------------------------------------------------
      -- Ecriture du message de début ou de fin de traitement du batch
      -- -------------------------------------------------------------------

	procedure ECRITURE_MESSAGE(P_HFILE in utl_file.file_type, P_TYPE_MSG in varchar2 ) IS

	  L_PROCNAME varchar2(16) := 'ECRITURE_MESSAGE';
	  L_STATEMENT varchar2(64):= 'LECTURE et ECRITURE DU MESSAGE DE DEBUT FIN';
     L_MSG Varchar2(1024);
     L_DATE Varchar2(10);

     MSG1   VARCHAR2(10);
     MSG2   VARCHAR2(80);
     MSG3	VARCHAR2(50);
     pos1   integer;
     pos2   integer;
     lgth   integer;
     L_NUMTRAIT	number(1);

	BEGIN

	-- DEBUT message en cours
	-- FIN   message de bonne fin
	pos1 := INSTR( P_TYPE_MSG, ' ', 1, 1);
	lgth := LENGTH( P_TYPE_MSG);
	MSG1 := substr( P_TYPE_MSG, 1, pos1-1);
	MSG2 := substr( P_TYPE_MSG, pos1+1, lgth-pos1);

	--on determine si MENUELLE ou 2/3 premensuelle
	pos1 := INSTR( MSG2, ' ', 1, 1);
	pos2 := INSTR( MSG2, ' ', 1, 2);
	IF (pos2 = 0) THEN
		pos2 := LENGTH(MSG2);
	ELSE
		pos2 := pos2-1;
	END IF;
	MSG3 := substr( MSG2, pos1+1, pos2-pos1);

    TRCLOG.TRCLOG( P_HFILE, 'NUMTRAIT >'||MSG3||'<');
	IF ( MSG3 = '1' ) THEN
		L_NUMTRAIT := 1;
		--TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || '===>1');
	ELSE
		IF ( MSG3 = '2' ) THEN
			L_NUMTRAIT := 2;
			--TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || '===>2');
		ELSE
			IF ( MSG3 = 'MENSUELLE' ) THEN
				--TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || '===>3');
				L_NUMTRAIT := 3;
			ELSE
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || '= '||MSG3||'==>?????');
			END IF;
		END IF;
	END IF;

    IF MSG1 = 'DEBUT' THEN
        L_DATE := to_char(sysdate, 'DD/MM/YYYY');
        pack_global.recuperer_message( 5015, '%s1', L_DATE, NULL, L_MSG);
        L_STATEMENT := 'Mise à jour de datdebex DERTRAIT';
        IF  MSG2 = 'TRAITEMENT 1 PRE-MENSUELLE' THEN
            -- old          UPDATE datdebex SET DERTRAIT = trunc(sysdate);
            -- new qhl : ajout de 2 zones dans datdebex pour resoudre le pb de quel est le dernier mois mensuel
            UPDATE datdebex  SET (dertrait, moismens , moismens_nbjo, NUMTRAIT) =
                  (SELECT trunc(sysdate), calanmois, cjours, L_NUMTRAIT FROM calendrier
                   WHERE  calanmois = (SELECT trunc(add_months(cmensuelle,-1),'month') FROM datdebex ) );
        ELSE
            UPDATE datdebex SET (DERTRAIT, NUMTRAIT) = (SELECT trunc(sysdate), L_NUMTRAIT from dual);
        END IF;


    ELSE
        IF MSG1 = 'FIN' THEN
           L_DATE := to_char(sysdate, 'DD/MM/YYYY');
  	        pack_global.recuperer_message( 5014, '%s1', L_DATE, NULL, L_MSG);
        ELSE
           L_MSG := 'Erreur dans la gestion du message de la mensuelle';
        END IF;
    END IF;

	-- Ajout d'une actualité de dernière minute indiquant que le traitement de mensuel est en cours
	ADD_ACTUALITE(MSG1);

    L_STATEMENT := 'Mise à jour de la table des fichiers';

    UPDATE fichier SET contenu = L_MSG
    WHERE IDFIC='mensuelle';
    COMMIT;

	exception

		when others then
			if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||
                                               ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			end if;
			TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' ||
                                                L_PROCNAME  );
			raise CALLEE_FAILED;

	end ECRITURE_MESSAGE;



	-- -------------------------------------------------------------------
    -- ajout d'une actualité indiquant qu'un traitement est en cours
    -- -------------------------------------------------------------------

	procedure ADD_ACTUALITE(p_position in varchar2 ) IS
		v_titre 		  actualite.titre%TYPE;
		v_texte_deb		  actualite.texte%TYPE;
		v_texte_fin		  actualite.texte%TYPE;
		v_date_affich     varchar2(10);
		v_date_debut 	  varchar2(10);
		v_date_fin 		  varchar2(10);
		v_menus 		  varchar2(2000);
		v_userid 		  varchar2(50);
		o_code_actu 	  actualite.code_actu%TYPE;
		o_nbcurseur 	  integer;
		o_message 		  varchar2(2000);
		v_date_dern_trait date;
		l_msg			  VARCHAR2(1024);
		v_moismens		  varchar2(20);
		v_libnumtrait     VARCHAR2(40);
		v_jour		  	  varchar2(10);
		v_date_trait  	  date;
	BEGIN

		BEGIN
			select decode( to_char(moismens,'mm'),'04','d''','08','d''','10','d''','de ')
				   ||trim(to_char(moismens,'month'))||' '||to_char(moismens,'YYYY'), lower(to_char(dertrait,'day')), dertrait,
				   decode(numtrait,1,'pré-mensuelle',2,'pré-mensuelle de régularisation','mensuelle')
			  into v_moismens, v_jour, v_date_trait, v_libnumtrait
			  from datdebex;
		EXCEPTION
			WHEN OTHERS THEN
				DBMS_OUTPUT.put_line('Erreur lors de la récupération du mois de la mensuelle.');
		END;

		--DBMS_OUTPUT.put_line('Jour du lancement : '||v_jour||' '||v_date_trait);

		pack_global.recuperer_message( 21030 , '%1', v_moismens, '', l_msg);
		v_titre       := l_msg;
		pack_global.recuperer_message( 21031 , '%1'  , v_libnumtrait, '', l_msg);
		v_texte_deb	  := l_msg;
		pack_global.recuperer_message( 21032 , '%1'  ,  v_libnumtrait , '', l_msg);
		v_texte_fin	  := l_msg;
		v_date_affich := to_char(v_date_trait, 'dd/mm/yyyy');
		v_date_debut  := to_char(v_date_trait, 'dd/mm/yyyy');
		v_userid 	  := null;
		-- on affecte à l'actualité le profil POURTOUS pour éviter de liste un par un tous les profils se qui poserait
		-- des problèmes à l'ajout la modification ou la suppression d'un profil.
		-- une clause est ajoutée dans la liste des actualité (PACK_LISTE_ACTU) pour ce profil spécifique.
		v_menus 	  := 'POURTOUS,';

		if (trim(lower(v_jour))='vendredi') then
			-- si le traitement est lancé un vendredi il faut que le message soit affiché jusqu'au mardi
			-- la date de fin est la date ou on arrête d'afficher l'actualité
			v_date_fin    := to_char(v_date_trait+5, 'dd/mm/yyyy');
		else
			v_date_fin    := to_char(v_date_trait+3, 'dd/mm/yyyy');
		end if;


		--DBMS_OUTPUT.put_line('Date de fin d''affichage du message : '||v_date_fin);


		if (p_position='DEBUT') then
			/* Passage des actualité de dernière minute en non dernière minute */
			update actualite
			   set derniere_minute='N'
			 where valide='O'
				   and v_date_trait between date_debut and date_fin
				   and derniere_minute = 'O';

			/* création d'une actualité de dernière minute sur la mensuelle en cours */
			BEGIN
				PACK_ACTU.INSERT_ACTUALITE( v_titre, v_texte_deb, v_date_affich, v_date_debut, v_date_fin, 'O', null, 'O',
											 v_menus, null, null, null, v_userid, o_code_actu, o_nbcurseur, o_message);
				--DBMS_OUTPUT.put_line('Actualite insérée : '||o_code_actu);
			EXCEPTION
				WHEN OTHERS THEN
					DBMS_OUTPUT.put_line('Erreur lors de la création d''une actualité : '||o_message);
			END;


		elsif (p_position='FIN') then
			/* on récupère la date du traitement qui vient de finir */
			select dertrait into v_date_dern_trait from datdebex;

			-- DBMS_OUTPUT.put_line('Date de la dernière mensuelle : '||v_date_dern_trait);

			BEGIN
				select code_actu
				  into o_code_actu
				  from actualite
				 where titre = v_titre
				   and v_date_dern_trait between date_debut and date_fin
				   and valide = 'O'
				   and derniere_minute = 'O';

				--DBMS_OUTPUT.put_line('Actu mensuelle en cours, code = '||o_code_actu);

				/* on rend invalide l'actualité 'mensuelle en cours' */
				update actualite
				   set valide = 'N'
				 where code_actu = o_code_actu;

				/* création d'une actualité de dernière minute sur le succès de la mensuelle */
				BEGIN
					PACK_ACTU.INSERT_ACTUALITE( v_titre, v_texte_fin, v_date_affich, v_date_debut, v_date_fin, 'O', null, 'O',
												 v_menus, null, null, null, v_userid, o_code_actu, o_nbcurseur, o_message);
					-- DBMS_OUTPUT.put_line('Actualite insérée : '||o_code_actu);
				EXCEPTION
					WHEN OTHERS THEN
						DBMS_OUTPUT.put_line('Erreur lors de la création d''une actualité : '||o_message);
				END;
			EXCEPTION
				WHEN OTHERS THEN
					DBMS_OUTPUT.put_line('ERREUR Impossible de retrouver l''actualité correspondante au début du traitement.');
			END;

		end if;
	END ADD_ACTUALITE;

end PACKBATCH2;
/
CREATE OR REPLACE PACKAGE packbatch4 IS
-- ##################################################################################################
--	Transert des consommes de CONS_SSTACHE_RES_MOIS vers CONS_SSTACHE_RES_MOIS_REJET
--	pour differents cas de rejet :
--		DATE de consomme superieure a DATE de changement de statut
--		DATE de consomme superieure a DATE des donnees
--		Ligne BIP fermee
-- ##################################################################################################
	PROCEDURE filtrer_consomme( P_HFILE utl_file.file_type );


-- ##################################################################################################
--	constantes correspondant aux motifs de rejet
-- ##################################################################################################
	REJET_STATUT			CONSTANT CHAR(1):='T';
	REJET_STATUT_SS_TRAITANCE	CONSTANT CHAR(1):='S';
	REJET_DONNEE_AVENIR		CONSTANT CHAR(1):='A';
	REJET_FERMEE			CONSTANT CHAR(1):='F';
	REJET_FERMEE_SS_TRAITANCE	CONSTANT CHAR(1):='G';
	REJET_RESSOURCE_INCONNUE	CONSTANT CHAR(1):='R';
	REJET_LBIP_INCONNUE		CONSTANT CHAR(1):='L';
	REJET_LBIP_TYPE9		CONSTANT CHAR(1):='K';


-- ##################################################################################################
--	Mise a jour des informations concernant la situation de la ressource
--	dans la table BATCH_PROPLUS_COMPLUS pour toutes les ressources
-- ##################################################################################################
	PROCEDURE Maj_Situation_Proplus( P_HFILE utl_file.file_type );


-- ##################################################################################################
--	Suppression de toutes les informations provenant de PMW pour lesquels
--	le numero de version de Remontee BIP (PMW_LIGNE_BIP.PMWBIPVERS) n'est pas le bon
--	(le bon est select max( NUMTP) into L_MAXNUMTP from VERSION_TP)
-- ##################################################################################################
	PROCEDURE Rejet_Version_RBIP( P_HFILE utl_file.file_type );


-- ##################################################################################################
--	Copie du consomme depuis PMW_CONSOMM vers CONS_SSTACHE_RES_MOIS
-- ##################################################################################################
	PROCEDURE Copie_Consomme( P_HFILE utl_file.file_type );


-- ##################################################################################################
--	Rejet du consomme sur les ressources qui n'existent pas
-- ##################################################################################################
	PROCEDURE Rejet_Ressource( P_HFILE utl_file.file_type );


-- ##################################################################################################
--	Rejet du consomme sur les lignes BIP qui n'existent pas
-- ##################################################################################################
	PROCEDURE Rejet_Ligne_BIP( P_HFILE utl_file.file_type );


-- ##################################################################################################
--	Purge de la table des rejets
-- ##################################################################################################
	PROCEDURE Purge_rejet( P_HFILE utl_file.file_type );

-- ##################################################################################################
--	Alimentation de TMP_REJETMENS
-- ##################################################################################################
	PROCEDURE Alim_rejet( P_HFILE utl_file.file_type );

END packbatch4;
/

CREATE OR REPLACE PACKAGE BODY packbatch4 IS
--gestion des exceptions
CONSTRAINT_VIOLATION exception;          -- pour clause when
pragma exception_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère

	PROCEDURE filtrer_consomme( P_HFILE utl_file.file_type ) IS
-- ##################################################################################################
		l_moismens	DATE;
		l_annee		DATE;
		l_statement	VARCHAR2(2000);
	BEGIN
		TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement de filtrage du consomme');

		l_statement:='Lecture de DATDEBEX';
		SELECT moismens, datdebex INTO l_moismens, l_annee FROM datdebex;

/*
	MaJ des dates limites pour chaque TACHE (en fait ce sont des sous-taches) :
		- RaZ
		- DATE changement statut sans ss-traitance		T
		- DATE changement statut avec ss-traitance		S
		- DATE des donnees					A
		- DATE changement statut si ligne BIP fermee		F
		- DATE changement statut si ligne BIP fermee avec ss-tr	G
*/
		l_statement:='RAZ de TACHE';
		UPDATE tache SET cdeb_max=NULL, motif_rejet=NULL;

		l_statement:='Maj de la date pour les motifs REJET_STATUT';
		UPDATE tache
			SET cdeb_max=(SELECT adatestatut FROM ligne_bip WHERE ligne_bip.pid=tache.pid)
				, motif_rejet=REJET_STATUT
			WHERE aistty!='FF' OR aistty IS NULL;


		l_statement:='Maj de la date pour les motifs REJET_STATUT_SS_TRAITANCE';
		UPDATE tache
			SET cdeb_max=(SELECT adatestatut FROM ligne_bip WHERE ligne_bip.pid=tache.aistpid)
				, motif_rejet=REJET_STATUT_SS_TRAITANCE
			WHERE aistty='FF';

		l_statement:='Maj de la date pour les motifs REJET_DONNEE_AVENIR';
		UPDATE tache
			SET cdeb_max=l_moismens
				, motif_rejet=REJET_DONNEE_AVENIR
			WHERE cdeb_max IS NULL
				OR cdeb_max>l_moismens;

		l_statement:='Maj de la date pour les motifs REJET_FERMEE';
		UPDATE tache
			SET cdeb_max=(SELECT adatestatut FROM ligne_bip WHERE ligne_bip.pid=tache.pid)
				, motif_rejet=REJET_FERMEE
			WHERE pid IN (SELECT pid FROM ligne_bip WHERE topfer='O')
				AND (aistty!='FF' OR aistty IS NULL);

		l_statement:='Maj de la date pour les motifs REJET_FERMEE_SS_TRAITANCE';
		UPDATE tache
			SET cdeb_max=(SELECT adatestatut FROM ligne_bip WHERE ligne_bip.pid=tache.aistpid)
				, motif_rejet=REJET_FERMEE_SS_TRAITANCE
			WHERE aistpid IN (SELECT pid FROM ligne_bip WHERE topfer='O')
				AND aistty='FF';

/*
	Transert des consommes de CONS_SSTACHE_RES_MOIS vers CONS_SSTACHE_RES_MOIS_REJET
*/
		l_statement:='INSERT dans la table des rejets';
		INSERT INTO cons_sstache_res_mois_rejet
			(cdeb, cdur, cusag, chraf, chinit, pid, ecet, acta, acst, ident, motif_rejet)
			SELECT cons_sstache_res_mois.cdeb
				, cons_sstache_res_mois.cdur
				, cons_sstache_res_mois.cusag
				, cons_sstache_res_mois.chraf
				, cons_sstache_res_mois.chinit
				, cons_sstache_res_mois.pid
				, cons_sstache_res_mois.ecet
				, cons_sstache_res_mois.acta
				, cons_sstache_res_mois.acst
				, cons_sstache_res_mois.ident
				, tache.motif_rejet
			FROM tache
				, cons_sstache_res_mois
			WHERE cons_sstache_res_mois.pid=tache.pid
				AND cons_sstache_res_mois.ecet=tache.ecet
				AND cons_sstache_res_mois.acta=tache.acta
				AND cons_sstache_res_mois.acst=tache.acst
				AND cdeb > cdeb_max
				AND cdeb >= l_annee;

/*
	Suppression des consommes de CONS_SSTACHE_RES_MOIS
*/
		l_statement:='DELETE de la table des consommes';
		DELETE cons_sstache_res_mois
			WHERE cdeb >
				(SELECT cdeb_max
				FROM tache
					WHERE cons_sstache_res_mois.pid=tache.pid
					AND cons_sstache_res_mois.ecet=tache.ecet
					AND cons_sstache_res_mois.acta=tache.acta
					AND cons_sstache_res_mois.acst=tache.acst
				)
				AND cdeb >= l_annee;

		COMMIT;
		TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement de filtrage du consomme');
	EXCEPTION
		WHEN OTHERS THEN
			TRCLOG.TRCLOG( P_HFILE, 'Fin anormale du traitement de filtrage du consomme');
			TRCLOG.TRCLOG( P_HFILE, l_statement);
			TRCLOG.TRCLOG( P_HFILE, SQLERRM);
			RAISE;
	END filtrer_consomme;

-- ##################################################################################################
        PROCEDURE Maj_Situation_Proplus( P_HFILE utl_file.file_type ) IS
	BEGIN
		TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement de Maj des situations dans PROPLUS.');

		update BATCH_PROPLUS_COMPLUS
		set ( DATDEP, DIVSECGROU, CPIDENT, COUT, SOCIETE, QUALIF, DISPO ) =
		( select DATDEP, CODSG, CPIDENT, COUT, SOCCODE, PRESTATION, DISPO
		  from SITU_RESS_FULL
		  where BATCH_PROPLUS_COMPLUS.TIRES = SITU_RESS_FULL.IDENT
			and ( (BATCH_PROPLUS_COMPLUS.CDEB>=SITU_RESS_FULL.DATSITU OR SITU_RESS_FULL.DATSITU IS NULL)
			      and (BATCH_PROPLUS_COMPLUS.CDEB<=SITU_RESS_FULL.DATDEP OR SITU_RESS_FULL.DATDEP IS NULL)
			    )
			and ROWNUM=1		-- petite condition pour se proteger contre les situations en recouvrement
		);
		commit;

		TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement de Maj des situations dans PROPLUS.');
	EXCEPTION
		WHEN OTHERS THEN
			TRCLOG.TRCLOG( P_HFILE, 'Fin anormale du traitement de Maj des situations dans PROPLUS.');
			TRCLOG.TRCLOG( P_HFILE, SQLERRM);
			RAISE;
	END Maj_Situation_Proplus;



-- ##################################################################################################
	PROCEDURE Rejet_Version_RBIP( P_HFILE utl_file.file_type ) IS
		L_MaxVersion	CHAR(2);
		l_statement	VARCHAR2(255);
	BEGIN
		TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement de rejet des versions eronnees de PMW');

-- recuperation de la bonne version
		l_statement:='Lecture de la bonne version de PMW';
		SELECT MAX(numtp)
			INTO L_MaxVersion
			FROM Version_TP;

-- suppression du consomme
		l_statement:='Suppression du consomme';
		DELETE pmw_consomm WHERE pid IN (SELECT pid FROM pmw_ligne_bip WHERE pmwbipvers<>L_MaxVersion);

-- suppression des affectations
		l_statement:='Suppression des affectations';
		DELETE pmw_affecta WHERE pid IN (SELECT pid FROM pmw_ligne_bip WHERE pmwbipvers<>L_MaxVersion);

-- suppression des sous-taches
		l_statement:='Suppression des sous-taches';
		DELETE pmw_activite WHERE pid IN (SELECT pid FROM pmw_ligne_bip WHERE pmwbipvers<>L_MaxVersion);

-- suppression des lignes BIP
		l_statement:='Suppression des lignes BIP';
		DELETE pmw_ligne_bip WHERE pmwbipvers<>L_MaxVersion;

-- et on valide !
		l_statement:='Validation';
		COMMIT;

		TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement de rejet des versions eronnees de PMW');
	EXCEPTION
		WHEN OTHERS THEN
			TRCLOG.TRCLOG( P_HFILE, 'Fin anormale du traitement de rejet des versions eronnees de PMW');
			TRCLOG.TRCLOG( P_HFILE, l_statement);
			TRCLOG.TRCLOG( P_HFILE, SQLERRM);
			RAISE;
	END Rejet_Version_RBIP;




-- ##################################################################################################
	PROCEDURE Copie_Consomme( P_HFILE utl_file.file_type ) IS
		l_statement		VARCHAR2(255);
		l_annee_courante	DATE;
	BEGIN
		TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement de copie du consomme dans CONS_SSTACHE_RES_MOIS');

-- recuperation de l'annee courante
		l_statement:='Lecture de l''annee courante';
		SELECT datdebex
			INTO l_annee_courante
			FROM datdebex;

-- copie des donnees
		l_statement:='Copie des donnees';
		INSERT INTO cons_sstache_res_mois
			(pid, ecet, acta, acst, ident, cdeb, cdur, cusag, chinit, chraf)
			SELECT PMW_CONSOMM.PID					-- PID
				, ccet					-- etape
				, ccta					-- tache
				, ccst					-- ss-tache
				, TO_NUMBER(SUBSTR(cires, 1, 5))	-- identifiante ressource
				, TRUNC(cdeb, 'month')			-- mois de consomme
				, NULL					-- duree en jours ouvrables du mois de consomme
				, SUM(cusag)				-- consomme
				, 0					-- charge initiale
				, 0					-- reste a faire
			FROM pmw_consomm,cons_sstache_res c
			WHERE PMW_CONSOMM.PID = c.pid
				AND ccet = c.ecet
				AND ccta = c.acta
				AND ccst = c.acst
				AND TO_NUMBER(SUBSTR(cires, 1, 5)) = c.ident
				AND cusag!=0
				AND cdeb>=l_annee_courante
				AND chtyp=1
			GROUP BY PMW_CONSOMM.PID, ccet, ccta, ccst, TO_NUMBER(SUBSTR(cires, 1, 5)), TRUNC(cdeb, 'month');

-- validation
		l_statement:='Validation';
		COMMIT;

		TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement de copie du consomme dans CONS_SSTACHE_RES_MOIS');
	EXCEPTION
		WHEN OTHERS THEN
			TRCLOG.TRCLOG( P_HFILE, 'Fin anormale du traitement de copie du consomme dans CONS_SSTACHE_RES_MOIS');
			TRCLOG.TRCLOG( P_HFILE, l_statement);
			TRCLOG.TRCLOG( P_HFILE, SQLERRM);
			RAISE;
	END Copie_Consomme;



-- ##################################################################################################
	PROCEDURE Rejet_Ressource( P_HFILE utl_file.file_type ) IS
		l_statement	VARCHAR2(255);
	BEGIN
		TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement de rejet du consomme portant sur des ressources inconnues');

-- en passant on remplace les identifiants "joker" de ressources par zero
		l_statement:='Maj identifiants ressources ******';
		UPDATE pmw_consomm SET cires='00000*' WHERE cires='******';

-- toutes les lignes qui correspondent a des ressources inconnues sont copiees dans cons_sstache_res_mois_rejet
		l_statement:='Copie des donnees a rejeter dans CONS_SSTACHE_RES_MOIS_REJET';
		INSERT INTO cons_sstache_res_mois_rejet
			(cdeb, cusag, pid, ecet, acta, acst, ident, motif_rejet)
			SELECT cdeb, cusag, pid, ccet, ccta, ccst, TO_NUMBER(SUBSTR(cires, 1, 5)), REJET_RESSOURCE_INCONNUE
			FROM pmw_consomm
			WHERE NOT EXISTS
				(SELECT ident FROM ressource WHERE ident=TO_NUMBER(SUBSTR(pmw_consomm.cires, 1, 5)));

-- toutes les lignes qui correspondent a des ressources inconnues sont supprimees de pmw_consomm
		l_statement:='Suppression des lignes pour les ressources inconnues';
		DELETE pmw_consomm
			WHERE NOT EXISTS
				(SELECT ident FROM ressource WHERE ident=TO_NUMBER(SUBSTR(pmw_consomm.cires, 1, 5)));

-- validation
		l_statement:='Validation';
		COMMIT;

		TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement de rejet du consomme portant sur des ressources inconnues');
	EXCEPTION
		WHEN OTHERS THEN
			TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement de rejet du consomme portant sur des ressources inconnues');
			TRCLOG.TRCLOG( P_HFILE, l_statement);
			TRCLOG.TRCLOG( P_HFILE, SQLERRM);
			RAISE;
	END Rejet_Ressource;


-- ##################################################################################################
	PROCEDURE Rejet_Ligne_BIP( P_HFILE utl_file.file_type ) IS
		l_statement     VARCHAR2(255);
	BEGIN
		TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement de rejet du consomme portant sur des lignes BIP inconnues');

		l_statement:='copie des donnees dans CONS_SSTACHE_RES_MOIS_REJET';
		INSERT INTO cons_sstache_res_mois_rejet
			(cdeb, cusag, pid, ecet, acta, acst, ident, motif_rejet)
			SELECT cdeb, cusag, pid, ccet, ccta, ccst, TO_NUMBER(SUBSTR(cires, 1, 5)), REJET_LBIP_INCONNUE
			FROM pmw_consomm
			WHERE NOT EXISTS
			(SELECT pid FROM ligne_bip where pid=PMW_CONSOMM.PID);

-- toutes les lignes qui correspondent a des lignes bip inconnues sont supprimees de pmw_consomm
		DELETE pmw_consomm
			WHERE NOT EXISTS
			(SELECT pid FROM ligne_bip where pid=PMW_CONSOMM.PID);

-- D¿tecte les lignes bip de type 9
		INSERT INTO cons_sstache_res_mois_rejet
			(cdeb, cusag, pid, ecet, acta, acst, ident, motif_rejet)
			SELECT cdeb, cusag, pid, ccet, ccta, ccst, TO_NUMBER(SUBSTR(cires, 1, 5)), REJET_LBIP_TYPE9
			FROM pmw_consomm
			WHERE pid in
			(SELECT pid FROM ligne_bip where typproj='9');

-- toutes les lignes qui correspondent a des lignes bip de type 9 sont supprimees de pmw_consomm
		DELETE pmw_consomm
			WHERE pid in
			(SELECT pid FROM ligne_bip where typproj='9');

-- validation
		l_statement:='Validation';
		COMMIT;

		TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement de rejet du consomme portant sur des lignes BIP inconnues');
	EXCEPTION
		WHEN OTHERS THEN
		TRCLOG.TRCLOG( P_HFILE, 'Fin anormale du traitement de rejet du consomme portant sur des lignes BIP inconnues');
		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
		TRCLOG.TRCLOG( P_HFILE, l_statement);
		RAISE;
	END Rejet_Ligne_BIP;



-- ##################################################################################################
	PROCEDURE Purge_rejet( P_HFILE utl_file.file_type ) IS
		l_statement     VARCHAR2(255);
	BEGIN
--	Purge des precedents consommes rejetes
		l_statement:='Purge de CONS_SSTACHE_RES_MOIS_REJET';
		DELETE cons_sstache_res_mois_rejet;


-- validation
		l_statement:='Validation';
		COMMIT;
	EXCEPTION
		WHEN OTHERS THEN
		TRCLOG.TRCLOG( P_HFILE, 'Fin anormale du traitement de rejet du consomme portant sur des lignes BIP inconnues');
		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
		TRCLOG.TRCLOG( P_HFILE, l_statement);
		RAISE;
	END Purge_rejet;

-- ##################################################################################################
	PROCEDURE Alim_rejet ( P_HFILE utl_file.file_type ) IS
		l_statement     VARCHAR2(255);

	l_moismens DATE;

	BEGIN
	BEGIN
		TRCLOG.TRCLOG( P_HFILE, 'Suppression des données de TMP_REJETMENS');
--	Purge de la table temporaire
		l_statement:='Purge de TMP_REJETMENS';
		DELETE TMP_REJETMENS;
-- validation
		l_statement:='Validation';
		COMMIT;
	EXCEPTION
		WHEN OTHERS THEN
		TRCLOG.TRCLOG( P_HFILE, 'Fin anormale de la suppression des données de TMP_REJETMENS');
		TRCLOG.TRCLOG( P_HFILE, SQLERRM);
		TRCLOG.TRCLOG( P_HFILE, l_statement);
		RAISE;


	END;
	BEGIN
		SELECT moismens INTO l_moismens FROM datdebex;

		TRCLOG.TRCLOG( P_HFILE, 'Debut de l insertion des donnees de rejet du traitement mensuel');
-- insertion des rejets de cons_sstache_res_mois_rejet
		l_statement:='Copie des donnees de CONS_SSTACHE_RES_MOIS_REJET';
		INSERT INTO tmp_rejetmens
  		(SELECT c.pid,l.codsg,c.ecet,c.acta,c.acst,c.ident,c.cdeb,c.cusag,c.motif_rejet
   		FROM cons_sstache_res_mois_rejet c,ligne_bip l
	 	WHERE l.pid=c.pid
	 	AND c.cusag <> 0)
	 	;

	 	UPDATE tmp_rejetmens SET motif_rejet='A'
	 	WHERE motif_rejet='R'
	 	AND cdeb >l_moismens;

-- insertion des rejets de sstrt
		l_statement:='Copie des donnees de SSTRT';
		INSERT INTO tmp_rejetmens
  		(SELECT pid,pdsg,ecet,acta,acst,tires,cdeb,cusag,'I' FROM sstrt
  		)
  		;
-- insertion des rejets de batch_rejet_datestatut
		l_statement:='Copie des donnees de BATCH_REJET_DATESTATUT';
		INSERT INTO tmp_rejetmens
		 (SELECT b.pid,l.codsg,b.ecet,b.acta,b.acst,to_number(rtrim (b.cires,'*')),b.cdeb,b.cusag,DECODE(b.sstrait,'O','O','N')
		 FROM BATCH_REJET_DATESTATUT b,ligne_bip l
			WHERE
			b.cusag not in (select c.cusag from CONS_SSTACHE_RES_MOIS c
				where b.pid=c.pid
				AND c.cdeb=b.cdeb
				AND c.ident=to_number(rtrim (b.cires,'*'))
				AND c.ecet=b.ecet
				AND c.acta=b.acta
				AND c.acst=b.acst
				AND c.cusag is not null)
			and b.pid=l.pid
			and b.cusag <> 0
  		)
  		;
-- validation
		l_statement:='Validation';
		COMMIT;

		TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement d insertion des donnees de rejet du traitement mensuel');
	EXCEPTION
		WHEN OTHERS THEN
			TRCLOG.TRCLOG( P_HFILE, 'Fin anormale du traitement d insertion des donnees de rejet du traitement mensuel');
			TRCLOG.TRCLOG( P_HFILE, l_statement);
			TRCLOG.TRCLOG( P_HFILE, SQLERRM);
			RAISE;
	END;
	END Alim_rejet;



END packbatch4;
/
CREATE OR REPLACE PACKAGE PACKBATCH_COUTLOGICIEL AS

tempCout number(6,2);

PROCEDURE maj_cout(valeur VARCHAR2);

END PACKBATCH_COUTLOGICIEL;
/

CREATE OR REPLACE PACKAGE BODY PACKBATCH_COUTLOGICIEL AS


procedure maj_cout(valeur VARCHAR2) is

  CURSOR curseur is
  select ident,codsg  from situ_ress where datdep is null and ident in
  (select ident from ressource where rtype='L');

BEGIN

for curseur_Rec in curseur loop

   select cout_log into tempCout from cout_std2,datdebex where curseur_Rec.codsg between
   dpg_bas and dpg_haut
and cout_std2.annee=to_number(to_char(datdebex,'yyyy'));

   if (tempCout is not null) then
     update situ_ress set cout = tempCout where ident=curseur_Rec.ident and datdep
    is null;
   end if;

end loop;

END maj_cout;

END PACKBATCH_COUTLOGICIEL;
/
CREATE OR REPLACE PACKAGE PACKBATCH_IAS AS
--****************************************************
-- Procédure globale d'alimentation des tables pour le batch IAS appelée par le shell
--****************************************************
PROCEDURE IAS(P_LOGDIR          IN VARCHAR2)  ;
--****************************************************
-- Procédure d'alimentation de la table IAS
--****************************************************
PROCEDURE alim_ias(P_HFILE           IN UTL_FILE.FILE_TYPE)   ;
--*************************************************************
-- Procédure d'alimentation de la table TMP_IMMO
--************************************************************
PROCEDURE alim_tmp_immo(P_HFILE           IN UTL_FILE.FILE_TYPE) ;
--*************************************************************
-- Procédure d'alimentation de la table STOCK_FI :lignes et consos
--************************************************************
PROCEDURE alim_tmp_fi (P_HFILE           IN UTL_FILE.FILE_TYPE) ;
--*************************************************************
-- Procédure de mise à jour de la table STOCK_FI_DEC
--************************************************************
PROCEDURE alim_stock_fi_dec(P_HFILE           IN UTL_FILE.FILE_TYPE);
--*************************************************************
-- Procédure d'alimentation de la table STOCK_IMMO
--************************************************************
PROCEDURE alim_stock_immo (P_HFILE           IN UTL_FILE.FILE_TYPE)  ;
--*************************************************************
-- Procédure d'alimentation de la table STOCK_FI :
-- ajout lignes de DEC N-1 et retours arrières
--**************************************************************
PROCEDURE alim_stock_fi(P_HFILE           IN UTL_FILE.FILE_TYPE) ;
--*************************************************************
-- Procédure pour la mise en place d'une répartition dans STOCK_FI (facturation mult-CA) :
-- Répartition des imputations pour les lignes avec le CA 77777
--**************************************************************
PROCEDURE repartition_fi(P_HFILE           IN UTL_FILE.FILE_TYPE) ;
-- **************************************************************************************
-- Vérification des arrondis pour le multi-CA(afin d'avoir le bon montant total à la fin).
-- **************************************************************************************
PROCEDURE verif_arrondis(P_HFILE           IN UTL_FILE.FILE_TYPE) ;
--*************************************************************
-- Procédure de création du fichier pour la FI appelée par le shell
--************************************************************
PROCEDURE fi( P_LOGDIR          IN VARCHAR2,
              p_chemin_fichier  IN VARCHAR2,
              p_nom_fichier     IN VARCHAR2);
--*************************************************************
-- Procédure de création du fichier pour SMS appelée par le shell
--************************************************************
PROCEDURE immo( P_LOGDIR          IN VARCHAR2,
              	p_chemin_fichier  IN VARCHAR2,
              	p_nom_fichier     IN VARCHAR2) ;
--*************************************************************
-- Procédure qui écrit dans un fichier le mois de la mensuelle
--************************************************************
PROCEDURE DATRAIT(   P_LOGDIR          IN VARCHAR2,
                          p_chemin_fichier  IN VARCHAR2,
                          p_nom_fichier     IN VARCHAR2
                        );
--********************************************************************
-- Procédure d'alimentation des tables stock_fi_dec et stock_immo_dec
-- lors de la clôture
--********************************************************************
PROCEDURE cloture(P_LOGDIR          IN VARCHAR2)  ;

END PACKBATCH_IAS;
/

CREATE OR REPLACE PACKAGE  BODY  Packbatch_Ias AS
-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
PRAGMA EXCEPTION_INIT( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     NUMBER := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     NUMBER := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID NUMBER := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
--****************************************************
-- Procédure d'alimentation des tables pour le batch IAS
--****************************************************
PROCEDURE IAS (P_LOGDIR          IN VARCHAR2)  IS

L_HFILE     UTL_FILE.FILE_TYPE;
L_RETCOD    NUMBER;
L_PROCNAME  VARCHAR2(16) := 'IAS';

	BEGIN

		-----------------------------------------------------
		-- Init de la trace
		-----------------------------------------------------
		L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		IF ( L_RETCOD <> 0 ) THEN
		RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
		END IF;

		-----------------------------------------------------
		-- Trace Start
		-----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Debut de ' || L_PROCNAME );

		-----------------------------------------------------
		-- Lancement ...
		-----------------------------------------------------
		--Alimentation de la table IAS
	 	alim_ias( L_HFILE );

	 	-- sélection des lignes pour TMP_IMMO
   	  	alim_tmp_immo( L_HFILE)  ;

		--Alimentation de la table STOCK_IMMO : ajout DEC N-1 et retours arrières
	 	alim_stock_immo( L_HFILE );

	 	-- sélection des lignes pour STOCK_FI
	 	alim_tmp_fi( L_HFILE ) ;

		-- Facturation interne des consommés de répartition
		Packbatch_Ias_Rjh.ALIM_IAS( L_HFILE );

	 	-- Mise à jour des données dans STOCK_FI_DEC
		alim_stock_fi_dec( L_HFILE ) ;

		-- Multi-CA : répartition sur les CA en fonction des taux
		repartition_fi(L_HFILE);

		-- Multi-CA : Vérification des arrondis
		verif_arrondis(L_HFILE);

		--Alimentation de la table STOCK_FI : ajout DEC N-1 et retours arrières
	 	alim_stock_fi( L_HFILE );



		-----------------------------------------------------
		-- Trace Stop
		-----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		Trclog.CLOSETRCLOG( L_HFILE );

	EXCEPTION
		WHEN OTHERS THEN
			IF SQLCODE <> CALLEE_FAILED_ID AND SQLCODE <> TRCLOG_FAILED_ID THEN
				Trclog.Trclog( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			END IF;
			IF SQLCODE <> TRCLOG_FAILED_ID THEN
				Trclog.Trclog( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				Trclog.CLOSETRCLOG( L_HFILE );
				RAISE_APPLICATION_ERROR( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         FALSE );
			ELSE
				RAISE;
			END IF;


END IAS;

--********************************************************************
-- Procédure d'alimentation des tables stock_fi_dec et stock_immo_dec
-- lors de la clôture
--********************************************************************
PROCEDURE cloture(P_LOGDIR          IN VARCHAR2)  IS
L_HFILE     UTL_FILE.FILE_TYPE;
L_RETCOD    NUMBER;
L_PROCNAME  VARCHAR2(16) := 'IAS_ClOTURE';
L_STATEMENT VARCHAR2(256);
CODCAMO_MULTI	NUMBER(6) := 77777;
	BEGIN

		-----------------------------------------------------
		-- Init de la trace
		-----------------------------------------------------
		L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		IF ( L_RETCOD <> 0 ) THEN
		RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
		END IF;

		-----------------------------------------------------
		-- Trace Start
		-----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Debut de ' || L_PROCNAME );
		----------------------------------------------------
		--Stocker les lignes STOCK_FI dans STOCK_FI_DEC
		----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Suppression des lignes STOCK_FI_DEC' );
		DELETE STOCK_FI_DEC;
		COMMIT;

		Trclog.Trclog( L_HFILE, 'Insertion des lignes dans STOCK_FI_DEC' );
		   INSERT INTO STOCK_FI_DEC (	cdeb 		,
										pid 		,
										ident 		,
										typproj 	,
										METIER 		,
										pnom 		,
										codsg 		,
										dpcode 		,
										icpi 		,
										codcamo 	,
										clibrca 	,
										CAFI 		,
										codsgress 	,
										libdsg 		,
										rnom		,
										rtype		,
										PRESTATION	,
										NIVEAU 		,
										soccode 	,
										cada		,
										coutftht	,
										coutft 	,
										coutenv	,
										consojhimmo 	,
										nconsojhimmo 	,
										consoft	,
										consoenvimmo,
										nconsoenvimmo)
		 (SELECT 		TO_DATE('01/12/'||TO_CHAR(d.DATDEBEX,'YYYY'),'DD/MM/YYYY')	,
						s.pid 		,
						s.ident 	,
						s.typproj 	,
						s.METIER 	,
						s.pnom 		,
						s.codsg 	,
						s.dpcode 	,
						s.icpi 		,
						s.codcamo 	,
						s.clibrca 	,
						s.CAFI 		,
						s.codsgress ,
						s.libdsg 	,
						s.rnom		,
						s.rtype		,
						s.PRESTATION,
						s.NIVEAU 	,
						s.soccode 	,
						s.cada		,
						s.coutftht 	,
						s.coutft 	,
						s.coutenv	,
						c.a_consojhimmo,
						c.a_nconsojhimmo,
						c.a_consoft,
						c.a_consoenvimmo,
						c.a_nconsoenvimmo
		   FROM
		   (SELECT * FROM STOCK_FI st
		   WHERE st.cdeb IN (SELECT MAX(cdeb) FROM STOCK_FI f
						 	 WHERE st.ident= f.ident AND st.pid=f.pid
					 		 )
			) s,
		   (SELECT pid,ident,SUM(a_consojhimmo) a_consojhimmo, SUM(a_nconsojhimmo) a_nconsojhimmo,
		   		   SUM(a_consoft) a_consoft, SUM(a_consoenvimmo) a_consoenvimmo, SUM(a_nconsoenvimmo) a_nconsoenvimmo
		    FROM STOCK_FI
		    GROUP BY pid,ident
		    HAVING SUM(a_consojhimmo+a_nconsojhimmo+a_consoft+a_consoenvimmo+a_nconsoenvimmo)!=0) c,
		   DATDEBEX d
		   WHERE
		   		s.ident=c.ident
			AND s.pid=c.pid);
		   L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_FI_DEC';
	       Trclog.Trclog( L_HFILE, L_STATEMENT );

		   COMMIT;

	 	--Vider les tables STOCK_FI, STOCK_FI_1, STOCK_IMMO, STOCK_IMMO_1
		L_STATEMENT := '* Suppression des lignes des tables STOCK_FI, STOCK_FI_1, STOCK_IMMO, STOCK_IMMO_1';
		Trclog.Trclog( L_HFILE, L_STATEMENT );
		Packbatch.DYNA_TRUNCATE('STOCK_FI');
		Packbatch.DYNA_TRUNCATE('STOCK_FI_1');
		Packbatch.DYNA_TRUNCATE('STOCK_IMMO');
		Packbatch.DYNA_TRUNCATE('STOCK_IMMO_1');

		-- Insertion de stock_fi_dec dans stock_fi sera prise en compte
		-- dans stock_fi_1 lors du traitement de janvier
		--
		L_STATEMENT := '* Insertion des lignes des stock_fi_dec dans stock_fi';
		INSERT INTO STOCK_FI(CDEB,
                PID,
                IDENT,
                TYPPROJ,
                METIER,
                PNOM,
                CODSG,
                DPCODE,
                ICPI,
                CODCAMO,
                CLIBRCA,
                CAFI,
                CODSGRESS,
                LIBDSG,
                RNOM,
                RTYPE,
                PRESTATION,
                NIVEAU,
                SOCCODE,
                CADA,
                COUTFTHT,
                COUTFT,
                COUTENV,
                CONSOJHIMMO,
                NCONSOJHIMMO,
                CONSOFT,
                CONSOENVIMMO,
                NCONSOENVIMMO,
                A_CONSOFT,
                A_CONSOENVIMMO,
                A_NCONSOENVIMMO,
                A_CONSOJHIMMO,
                A_NCONSOJHIMMO)
		SELECT CDEB,
                PID,
                IDENT,
                TYPPROJ,
                METIER,
                PNOM,
                CODSG,
                DPCODE,
                ICPI,
                CODCAMO,
                CLIBRCA,
                CAFI,
                CODSGRESS,
                LIBDSG,
                RNOM,
                RTYPE,
                PRESTATION,
                NIVEAU,
                SOCCODE,
                CADA,
                COUTFTHT,
                COUTFT,
                COUTENV,
                CONSOJHIMMO,
                NCONSOJHIMMO,
                CONSOFT,
                CONSOENVIMMO,
                NCONSOENVIMMO,
                A_CONSOFT,
                A_CONSOENVIMMO,
                A_NCONSOENVIMMO,
                A_CONSOJHIMMO,
                A_NCONSOJHIMMO
                FROM STOCK_FI_DEC
                ;

		COMMIT;


		----------------------------------------------------
		--Stocker les lignes STOCK_FI_MULTI dans STOCK_FI_DEC
		-- cas particulier des lignes multi_ca pour lesquelles on met dans STOCK_FI_DEC
		-- les lignes d'origine ( avant éclatement sur les différents CA ) qui ont
		-- été stockées lors du traitement mensuel dans la table STOCK_FI_MULTI
		----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Insertion des lignes de STOCK_FI_MULTI dans STOCK_FI_DEC' );
		   INSERT INTO STOCK_FI_DEC (	cdeb 		,
										pid 		,
										ident 		,
										typproj 	,
										METIER 		,
										pnom 		,
										codsg 		,
										dpcode 		,
										icpi 		,
										codcamo 	,
										clibrca 	,
										CAFI 		,
										codsgress 	,
										libdsg 		,
										rnom		,
										rtype		,
										PRESTATION	,
										NIVEAU 		,
										soccode 	,
										cada		,
										coutftht	,
										coutft 	,
										coutenv	,
										consojhimmo 	,
										nconsojhimmo 	,
										consoft	,
										consoenvimmo,
										nconsoenvimmo)
		 (SELECT 		max(s.cdeb)	,
						s.pid 		,
						s.ident 	,
						max(s.typproj) 	,
						max(s.METIER) 	,
						max(s.pnom) 	,
						max(s.codsg) 	,
						max(s.dpcode) 	,
						max(s.icpi) 	,
						CODCAMO_MULTI	,
						max(s.clibrca) 	,
						max(s.CAFI)		,
						max(s.codsgress),
						max(s.libdsg) 	,
						max(s.rnom)		,
						max(s.rtype)	,
						max(s.PRESTATION),
						max(s.NIVEAU) 	,
						max(s.soccode) 	,
						max(s.cada)		,
						max(s.coutftht)	,
						max(s.coutft) 	,
						max(s.coutenv)	,
						sum(s.consojhimmo),
						sum(nconsojhimmo),
						sum(consoft),
						sum(consoenvimmo),
						sum(nconsoenvimmo)
		   FROM STOCK_FI s
		   WHERE s.pid IN (SELECT distinct pid FROM STOCK_FI_MULTI )
		   GROUP BY s.pid, s.ident);
		   L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes de STOCK_FI_MULTI insérées dans la table STOCK_FI_DEC';
	        Trclog.Trclog( L_HFILE, L_STATEMENT );

		COMMIT ;

		----------------------------------------------------
		--Vider dans STOCK_FI_DEC les lignes correspondant aux lignes BIP qui ont
		-- été insérées précédemment d'après la table STOCK_FI_MULTI
		----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Suppression dans STOCK_FI_DEC des lignes correspondantes à celles de STOCK_FI_MULTI' );

			DELETE FROM STOCK_FI_DEC
			WHERE 	codcamo != CODCAMO_MULTI
			AND     PID IN ( SELECT DISTINCT m.PID
					FROM STOCK_FI_MULTI m );


			L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table STOCK_FI_DEC';
	        Trclog.Trclog( L_HFILE, L_STATEMENT );

		COMMIT ;



		-----------------------------------------------------
		-- Trace Stop
		-----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		Trclog.CLOSETRCLOG( L_HFILE );

	EXCEPTION
		WHEN OTHERS THEN
			IF SQLCODE <> CALLEE_FAILED_ID AND SQLCODE <> TRCLOG_FAILED_ID THEN
				Trclog.Trclog( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			END IF;
			IF SQLCODE <> TRCLOG_FAILED_ID THEN
				Trclog.Trclog( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				Trclog.CLOSETRCLOG( L_HFILE );
				RAISE_APPLICATION_ERROR( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         FALSE );
			ELSE
				RAISE;
			END IF;

END cloture;
--****************************************************
-- Procédure d'alimentation de la table IAS
--****************************************************
PROCEDURE alim_ias(	P_HFILE           IN UTL_FILE.FILE_TYPE)   IS

L_RETCOD    NUMBER;
L_PROCNAME  VARCHAR2(16) := 'ALIM_IAS';
L_STATEMENT VARCHAR2(128);
l_annee  NUMBER(4);
L_COMPTEUR NUMBER :=0;              -- Compteur utilisé pour gérer le commit
L_TOTAL    NUMBER :=0;              -- Compteur utilisé pour gérer le commit
BEGIN
	 Trclog.Trclog( P_HFILE, 'Debut de ' || L_PROCNAME );

	-- -------------------------------------------------------------
	-- Etape préliminaire : Suppression de toutes les lignes de la table iAS
	-- --------------------------------------------------------------
	L_STATEMENT := '* Suppression des lignes de la table IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	Packbatch.DYNA_TRUNCATE('IAS');
	L_COMPTEUR := 0;
	L_TOTAL := 0;

	-- -------------------------------------------------------------
	-- Etape 1 : Insertion des lignes dans la table iAS
	-- --------------------------------------------------------------
	L_STATEMENT := '* Insertion des lignes dans la table IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	DECLARE
		CURSOR c_ias IS
			SELECT DISTINCT
	      			c.cdeb ,
					DECODE(t.aistpid,NULL,t.pid,'    ',t.pid,'   ',t.pid,t.aistpid) factpid,
	      			r.ident ,
					t.pid ,
	      			l.typproj ,
					RTRIM(l.METIER) metier ,
					l.pnom ,
					l.codsg ,
					-- Si le statut du projet est O , D ou A : prend le statut de la ligne BIP
					-- Sinon prend le statut du projet : afin de pouvoir ensuite ne pas immobiliser
					-- toutes les lignes bip du projet en fonction de son statut
					DECODE(p.statut,'O',l.astatut,'D',l.astatut,'A',l.astatut,p.statut) astatut,
					l.dpcode ,
					l.icpi ,
					l.codcamo ,
					ca.clibrca ,
					ca.ctopact ,
					si2.CAFI ,
					sr.codsg  codsgress,
					si2.libdsg ,
	 				r.rnom,
					r.rtype,
					sr.PRESTATION,
					sr.NIVEAU,
					sr.soccode ,
					p.cada ,
					p.DATDEM  ,
					p.datstatut ,
					dp.datimmo ,
					DECODE(e.typetap,NULL,'NO',e.typetap) typetap
		FROM
					CONS_SSTACHE_RES_MOIS c ,
					TACHE t,
					SITU_RESS_FULL sr ,
					LIGNE_BIP l ,
					ETAPE e,
					RESSOURCE r,
					CENTRE_ACTIVITE ca,
					PROJ_INFO p,
					STRUCT_INFO si1,
					STRUCT_INFO si2,
					DOSSIER_PROJET dp,
					FILIALE_CLI f1,
					FILIALE_CLI f2,
					DATDEBEX d
		WHERE
		-- Consommés sur l'année courante :
	 		TO_CHAR(c.cdeb,'YYYY')=TO_CHAR(d.moismens,'YYYY')
			AND TO_CHAR(c.cdeb,'MM')<= TO_CHAR(d.moismens,'MM')
		-- jointure ligne_bip et cons_sstache_res
			--Attention si t.aist n'est pas nul, t.aistpid=''   '
			AND l.pid=DECODE(t.aistpid,NULL,t.pid,'    ',t.pid,'   ',t.pid,t.aistpid)
			AND (t.aistpid IS NULL OR t.aistty='FF' OR t.aistpid='   ' OR t.aistpid='    ')
		-- On prend la ligne Bip d'imputation si elle existe
	            AND c.pid = t.pid
	            AND c.acta=t.acta
	            AND c.acst=t.acst
	            AND c.ecet=t.ecet
	            AND t.pid = e.pid
	            AND t.ecet = e.ecet
		-- jointure ligne_bip et centre_activite
			AND l.codcamo = ca.codcamo
	 	-- jointure ligne_bip et projet_info
			AND l.icpi = p.icpi
		-- jointure ligne_bip et dossier_projet
			AND l.dpcode = dp.dpcode
		-- jointure cons_sstache_res et situ_ress
	         	AND r.ident =sr.ident
			AND c.ident = sr.ident
			AND (c.cdeb >=sr.datsitu OR sr.datsitu IS NULL)
			AND (c.cdeb <=sr.datdep OR sr.datdep IS NULL )
		-- On ne prend pas les lignes dont le consommé est égal à 0
		  	AND c.cusag<>0
		-- ressource dont le CAFI du DPG <>9999 et  le DPG est rattaché à une filiale dont le top immo est oui
			AND sr.codsg=si2.codsg
			AND si2.CAFI!=99999
			AND si2.filcode= f2.filcode
			AND f2.top_immo='O'
		-- ressource dont la prestation <>(IFO,MO ,GRA,INT,STA)
			AND sr.PRESTATION NOT IN ('IFO','MO ','GRA','INT','STA')
		-- Dpg de la ligne rattaché à une filiale dont le top immo est OUI :
			AND l.codsg = si1.codsg
			AND si1.filcode = f1.filcode
			AND f1.top_immo = 'O'
		-- Type de la ligne <5 , 6 ou 8:
		AND  (l.typproj<5 OR l.typproj=6 OR l.typproj=8)
		-- Centre d'activité de la ligne <> 66666 : Exclut lignes d'origine de la répartition
		AND  l.codcamo<>66666 ;

		BEGIN



			FOR un_ias IN c_ias LOOP
				--
				-- On alimente la table IAS avec les données
				--
				INSERT INTO IAS
				(CDEB 		,
			   				FACTPID ,
							IDENT 	,
							PID 		,
							TYPPROJ 	,
							METIER 	,
							PNOM 		,
	                        CODSG 	,
	                        ASTATUT 	,
	                        DPCODE 	,
	                        ICPI 		,
	                        CODCAMO 	,
	                        CLIBRCA 	,
	                        CTOPACT 	,
	                        CAFI  	,
	                        CODSGRESS  	,
	                        LIBDSG 	,
	                        RNOM  	,
	                        RTYPE 	,
	                        PRESTATION	,
	                        NIVEAU   	,
	                        SOCCODE  	,
	                        CADA  	,
	                        DATDEMAR 	,
	                        DATSTATUT  	,
	                        DATIMMO  	,
	                        TYPETAP)
				VALUES
				( un_ias.cdeb, un_ias.factpid, un_ias.ident, un_ias.pid, un_ias.typproj,
				  un_ias.metier, un_ias.pnom, un_ias.codsg, un_ias.astatut, un_ias.dpcode,
				  un_ias.icpi ,un_ias.codcamo ,un_ias.clibrca ,un_ias.ctopact ,un_ias.CAFI ,
				  un_ias.codsgress, un_ias.libdsg ,un_ias.rnom,un_ias.rtype,un_ias.PRESTATION,
				  un_ias.NIVEAU,un_ias.soccode ,un_ias.cada ,un_ias.DATDEM  ,un_ias.datstatut ,
				  un_ias.datimmo , un_ias.typetap
				  );

				-- Gère un commit tous les 500 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=500 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

		EXCEPTION
		WHEN OTHERS THEN
			IF SQLCODE <> CALLEE_FAILED_ID THEN
					Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
			END IF;
			Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;
		END;

		L_TOTAL := L_TOTAL + L_COMPTEUR ;
		L_STATEMENT := '-> '||L_TOTAL||' lignes insérées dans la table IAS';
		Trclog.Trclog( P_HFILE, L_STATEMENT );

	-- Récupère l'année en cours dans une variable
	SELECT TO_NUMBER( TO_CHAR( DATDEBEX, 'YYYY') )
	INTO l_annee
	FROM DATDEBEX;

	-- ------------------------------------------------------------------------------
	-- Etape 2 : ajout des couts dans la table IAS
	-- ------------------------------------------------------------------------------
	-- COUT FORCE DE TRAVAIL
	-- * SG : on prend le coût déjà HTR à partir de la table des coûts standards SG COUT_STD_SG des lignes dont le code société ='SG..',le type='P' par année,niveau,métier,dpg
	-- * Logiciel :coût logiciel HTR de la table COUT_STD2 en fonction du DPG de la ressource
		L_STATEMENT := '* Ajout COUT FORCE DE TRAVAIL SG et Logiciel';
		Trclog.Trclog( P_HFILE, L_STATEMENT );
		UPDATE IAS
		SET coutft= Pack_Utile_Cout.getCout( IAS.soccode, IAS.rtype, l_annee, IAS.METIER,
												IAS.NIVEAU, IAS.codsgress, 0)
		WHERE  IAS.soccode='SG..'
			OR IAS.rtype='L';
	COMMIT;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	-- * SSII : on calcule le coût HTR de la situation de la ressource dont le code société est <>'SG..' , le type='P' avec une situation en cours pour l'année courante
	-- * Forfait Hors Site et sur Site:coût HTR de la situation de la ressource saisi en coût HT dont le type=('E','F') avec une situation en cours.
	L_STATEMENT := '* Ajout COUT FORCE DE TRAVAIL SSII et Forfait';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	UPDATE IAS
	SET (coutftht,coutft) = (SELECT DISTINCT NVL(s.cout,0),
			Pack_Utile_Cout.AppliqueTauxHTR (l_annee, NVL(s.cout,0) , TO_CHAR(IAS.cdeb,'DD/MM/YYYY'), '01 ')
			FROM SITU_RESS_FULL s
			WHERE  s.ident =IAS.ident
			AND (IAS.cdeb>=s.datsitu OR s.datsitu IS NULL)
			AND (IAS.cdeb<=s.datdep OR s.datdep IS NULL)
			)
	WHERE
	 	IAS.soccode!='SG..'
		AND IAS.rtype!='L';
	COMMIT;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	-- COUT D'ENVIRONNEMENT
	-- * SG,SSII,Forfait sur Site : coût d'environnement en HTR de la table COUT_STD2 en fonction du DPG de la ressource
	L_STATEMENT := '* Ajout COUT D''ENVIRONNEMENT SG,SSII,Forfait sur Site';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	UPDATE IAS
	SET coutenv= Pack_Utile_Cout.getCoutEnv(IAS.soccode, IAS.rtype, l_annee , IAS.codsgress)
	WHERE  IAS.rtype != 'L'
	 AND IAS.rtype!='E' ;
    COMMIT;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );


	-- ------------------------------------------------------------------------------
	-- Etape 3 : ajout des consommés dans la table IAS
	-- ------------------------------------------------------------------------------

	--	calcul du conso en jh de la ressource pour une ligne donnée, pour un mois donné et un type d'étape à partir du conso de la table CONS_SSTACHE_RES_MOIS
	L_STATEMENT := '* Calcul du conso en jh';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	UPDATE IAS
	SET consojh = (SELECT NVL(SUM(c.cusag),0)
					  FROM CONS_SSTACHE_RES_MOIS c, TACHE t, ETAPE e
					  WHERE
	 				  	c.pid = t.pid
			            AND c.acta=t.acta
			            AND c.acst=t.acst
			            AND c.ecet=t.ecet
			            AND t.pid = e.pid
			            AND t.ecet = e.ecet
						AND IAS.factpid=DECODE(t.aistpid,NULL,t.pid,'    ',t.pid,'   ',t.pid,t.aistpid)
						AND  c.ident = IAS.ident
						AND c.pid = IAS.pid
						AND c.cdeb = IAS.cdeb
						AND IAS.typetap = DECODE(e.typetap,NULL,'NO',e.typetap));

	COMMIT;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	--	Calcul du conso en euros de la force de travail : consoft = consojh*coutft
	--  et des frais d'environnement : consoenv = consojh*coutenv
	L_STATEMENT := '* Calcul des consos FT et ENV';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	UPDATE IAS
	SET (consoft, consoenv) = (SELECT NVL(consojh,0)*NVL(coutft,0),
				  		  NVL(consojh,0)*NVL(coutenv,0)
					FROM IAS i
	WHERE
	i.typetap=IAS.typetap
	AND i.ident=IAS.ident
	AND i.pid=IAS.pid
	AND i.factpid=IAS.factpid
	AND i.cdeb=IAS.cdeb
	);
	COMMIT;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	Trclog.Trclog( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

EXCEPTION
	WHEN OTHERS THEN
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;

END alim_ias ;
--*************************************************************
-- Procédure de sélection des lignes pour  TMP_IMMO
--************************************************************
PROCEDURE alim_tmp_immo(P_HFILE           IN UTL_FILE.FILE_TYPE)  IS
L_PROCNAME  VARCHAR2(16) := 'ALIM_TMP_IMMO';
L_STATEMENT VARCHAR2(128);
BEGIN
	 Trclog.Trclog( P_HFILE, 'Debut de ' || L_PROCNAME );

	-- --------------------------------------------------------------------------
	-- Etape préliminaire : Suppression de toutes les lignes de la table TMP_IMMO
	-- ---------------------------------------------------------------------------
	L_STATEMENT := '* Suppression des lignes de la table TMP_IMMO';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	Packbatch.DYNA_TRUNCATE('TMP_IMMO');


-- Insertion des lignes immobilisables dans TMP_IMMO
   L_STATEMENT := '* Insertion des lignes immobilisables dans TMP_IMMO';
   Trclog.Trclog( P_HFILE, L_STATEMENT );
   INSERT INTO TMP_IMMO (
						cdeb 		,
						pid 		,
						ident 		,
						typproj 		,
						METIER 		,
						pnom 		,
						codsg 		,
						dpcode 	,
						icpi 		,
						codcamo 	,
						clibrca 		,
						CAFI 		,
						codsgress 	,
						libdsg 		,
						rnom		,
						rtype		,
						PRESTATION	,
						NIVEAU 		,
						soccode 	,
						cada		,
						coutftht	,
						coutft 	,
						coutenv	,
						consojh 	,
						consoft	,
						consoenv)
	(SELECT
						cdeb 		,
						factpid 		,
						ident 		,
						MAX(typproj) 		,
						MAX(METIER) 		,
						MAX(pnom) 		,
						MAX(codsg) 		,
						MAX(dpcode) 	,
						MAX(icpi) 		,
						MAX(codcamo) 	,
						MAX(clibrca) 		,
						MAX(CAFI) 		,
						MAX(codsgress) 	,
						MAX(libdsg) 		,
						MAX(rnom)		,
						MAX(rtype)		,
						MAX(PRESTATION)	,
						MAX(NIVEAU) 		,
						MAX(soccode) 	,
						MAX(cada)		,
						NVL(MAX(coutftht),0),
						NVL(MAX(coutft),0) 	,
						NVL(MAX(coutenv),0) 	,
						NVL(SUM(consojh),0) 	,
						NVL(SUM(consoft),0)	,
						NVL(SUM(consoenv),0)
						FROM IAS
						WHERE
						-- de la date d'immo à la date de statut
						   ( TRUNC(cdeb,'MONTH') BETWEEN TRUNC(datimmo,'MONTH') AND TRUNC(datstatut,'MONTH')
							  OR TRUNC(cdeb,'MONTH')>=TRUNC(datimmo,'MONTH'))
						--	dont le statut comptable de la ligne ou du projet info est égal à 'O','D','A','C' :
						AND astatut IN ('O','D','A','C')
						--	de type 1 : IAS. Typproj=1
						AND typproj=1
						-- Qui ont une étape PACTE immobilisable :
						AND typetap IN ('CT','IG','HD','CN','FA','VI','VH','MD')
						GROUP BY cdeb,ident,factpid
						);
	   COMMIT;
	   L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table TMP_IMMO';
	   Trclog.Trclog( P_HFILE, L_STATEMENT );


	   Trclog.Trclog( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	WHEN OTHERS THEN
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;
END alim_tmp_immo ;
--*************************************************************
-- Procédure de sélection des lignes pour STOCK_FI
--************************************************************
PROCEDURE alim_tmp_fi(P_HFILE           IN UTL_FILE.FILE_TYPE)  IS

CODCAMO_MULTI	NUMBER(6) := 77777;

CURSOR cur_tmp_immo IS
SELECT DISTINCT
immo.cdeb 		AS cdeb ,
immo.pid 		AS pid,
immo.ident 		AS ident,
immo.typproj 	AS typproj,
immo.METIER 	AS METIER,
immo.pnom 		AS pnom,
immo.codsg 		AS codsg,
immo.dpcode 	AS dpcode,
immo.icpi 		AS icpi ,
immo.codcamo 	AS codcamo ,
immo.clibrca 	AS clibrca,
immo.CAFI 		AS CAFI,
immo.codsgress 	AS codsgress,
immo.libdsg 	AS libdsg,
immo.rnom		AS rnom,
immo.rtype		AS rtype	,
immo.PRESTATION	AS PRESTATION,
immo.NIVEAU 	AS NIVEAU,
immo.soccode 	AS soccode ,
immo.cada		AS cada,
immo.coutenv 	AS coutenv,
immo.consojh 	AS consojh,
immo.COUTFT		AS coutft,
immo.COUTFTHT   AS coutftht
FROM IAS i, TMP_IMMO immo
WHERE i.ident=immo.ident
AND  i.factpid = immo.pid
AND	i.cdeb = immo.cdeb
 --	Dont le cafi du DPG de la ressource est différent de 0 et de 88888
	AND immo.CAFI<>0 AND immo.CAFI<>88888
--	Dont le camo de la ligne est différent de 0 :
	AND immo.codcamo<>0
--	Dont le top du camo de la ligne  est différent de " ne pas refacturer " :
	AND i.ctopact <>'S';

L_PROCNAME  VARCHAR2(16) := 'ALIM_TMP_FI';
L_STATEMENT VARCHAR2(128);
l_exist NUMBER(1);


BEGIN
	Trclog.Trclog( P_HFILE, 'Debut de ' || L_PROCNAME );
	-- --------------------------------------------------------------------------
	-- Etape préliminaire : vider STOCK_FI_1, copier STOCK_FI dans STOCK_FI_1, vider STOCK_FI
	-- ---------------------------------------------------------------------------
	L_STATEMENT := '* Copier STOCK_FI dans STOCK_FI_1';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	Packbatch.DYNA_TRUNCATE('STOCK_FI_1');
	INSERT INTO STOCK_FI_1
	SELECT * FROM STOCK_FI
	WHERE fi1!='O' OR fi1 IS NULL; --Ne pas copier les lignes qui existaient dans stock_fi_1 et pas dans stock_fi
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_FI_1';
	COMMIT;
	Packbatch.DYNA_TRUNCATE('STOCK_FI');

	--Prendre les lignes non immobilisables :Force de travail et env
	L_STATEMENT := '* Insertion des lignes non immobilisables dans STOCK_FI:FT et ENV';
    Trclog.Trclog( P_HFILE, L_STATEMENT );
	INSERT INTO STOCK_FI (
						cdeb 		,
						pid 		,
						ident 		,
						typproj 		,
						METIER 		,
						pnom 		,
						codsg 		,
						dpcode 	,
						icpi 		,
						codcamo 	,
						clibrca 		,
						CAFI 		,
						codsgress 	,
						libdsg 		,
						rnom		,
						rtype		,
						PRESTATION	,
						NIVEAU 		,
						soccode 	,
						cada		,
						coutftht	,
						coutft 		,
						coutenv		,
						nconsojhimmo 	,
						consoft ,
						nconsoenvimmo,
						consojhimmo ,
						consoenvimmo
							)
	(SELECT
						cdeb 		,
						factpid 		,
						ident 		,
						MAX(typproj) 		typproj,
						MAX(METIER) 		METIER,
						MAX(pnom) 		pnom,
						MAX(codsg) 		codsg,
						MAX(dpcode) 		dpcode,
						MAX(icpi) 		,
						MAX(codcamo) 	,
						MAX(clibrca) 		,
						MAX(CAFI) 		,
						MAX(codsgress) 	,
						MAX(libdsg) 		,
						MAX(rnom)		,
						MAX(rtype)		,
						MAX(PRESTATION)	,
						MAX(NIVEAU) 		,
						MAX(soccode) 	,
						MAX(cada)		,
						MAX(NVL(coutftht,0)) ,
						MAX(NVL(coutft,0)) ,
						MAX(NVL(coutenv,0)) ,
						SUM(NVL(consojh,0)),
						SUM(NVL(consoft,0)),
						SUM(NVL(consoenv,0)),
						0,
						0
						FROM IAS
	WHERE
--	Dont le cafi du DPG de la ressource est différent de 0 et de 88888
	CAFI<>0 AND CAFI<>88888
--	Dont le camo de la ligne est différent de 0 :
	 AND codcamo<>0
	 AND codcamo IS NOT NULL
--	Dont le top du camo de la ligne  est différent de " ne pas refacturer " :
	AND ctopact <>'S'
	GROUP BY cdeb,factpid,ident,codcamo,CAFI
	MINUS
		SELECT	cdeb 		   		 ,
						pid 		,
						ident 		,
						typproj 	,
						METIER 		,
						pnom 		,
						codsg 		,
						dpcode 		,
						icpi 		,
						codcamo 	,
						clibrca 	,
						CAFI 		,
						codsgress 	,
						libdsg 		,
						rnom		,
						rtype		,
						PRESTATION	,
						NIVEAU 		,
						soccode 	,
						cada		,
						NVL(coutftht,0) 	,
						NVL(coutft,0) 		,
						NVL(coutenv,0)	,
						NVL(consojh,0)	,
						NVL(consoft,0) ,
						NVL(consoenv,0),
						0,
						0
	FROM TMP_IMMO
	);
	COMMIT;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_FI';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	L_STATEMENT := '* Insertion des lignes immobilisables dans STOCK_FI:ENV';
    Trclog.Trclog( P_HFILE, L_STATEMENT );
	--On parcourt la table TMP_IMMO et on compare chaque ligne avec les lignes de la table STOCK_FI
	FOR curseur IN cur_tmp_immo LOOP

			 SELECT COUNT(1) INTO l_exist
			 FROM STOCK_FI
			 WHERE ident=curseur.ident
			 AND pid=curseur.pid
			 AND cdeb=curseur.cdeb
			 AND codcamo=curseur.codcamo
			 AND CAFI=curseur.CAFI
			 AND icpi=curseur.icpi;

		 IF l_exist = 0 THEN
			 -- Créer la ligne dans STOCK_FI
			 INSERT INTO STOCK_FI (
						cdeb 		,
						pid 		,
						ident 		,
						typproj 		,
						METIER 		,
						pnom 		,
						codsg 		,
						dpcode 	,
						icpi 		,
						codcamo 	,
						clibrca 		,
						CAFI 		,
						codsgress 	,
						libdsg 		,
						rnom		,
						rtype		,
						PRESTATION	,
						NIVEAU 		,
						soccode 	,
						cada		,
						coutenv		,
						consojhimmo ,
						consoenvimmo,
						coutftht,
						coutft,
						consoft, nconsojhimmo, nconsoenvimmo
							)
			  VALUES (	curseur.cdeb 		,
						curseur.pid 		,
						curseur.ident 		,
						curseur.typproj 		,
						curseur.METIER 		,
						curseur.pnom 		,
						curseur.codsg 		,
						curseur.dpcode 	,
						curseur.icpi 		,
						curseur.codcamo 	,
						curseur.clibrca 		,
						curseur.CAFI 		,
						curseur.codsgress 	,
						curseur.libdsg 		,
						curseur.rnom		,
						curseur.rtype		,
						curseur.PRESTATION	,
						curseur.NIVEAU 		,
						curseur.soccode 	,
						curseur.cada		,
						NVL(curseur.coutenv,0) 	,
						NVL(curseur.consojh,0)  	,
						NVL(curseur.coutenv * curseur.consojh ,0),
						NVL(curseur.coutftht,0),
						NVL(curseur.coutft,0),
						0, 0, 0
							);
			 ELSE
			 -- La ligne existe déjà dans STOCK_FI
			 -- Ajouter les consos immo dans la ligne et modifier les consos FT
			 	UPDATE STOCK_FI
				SET consojhimmo = NVL(curseur.consojh,0) ,
					nconsojhimmo = NVL(nconsojhimmo,0) - NVL(curseur.consojh,0) ,
					consoft = NVL(coutft,0) * (NVL(nconsojhimmo,0) - NVL(curseur.consojh,0)),
					consoenvimmo = NVL(coutenv,0) * NVL(curseur.consojh,0),
					nconsoenvimmo = NVL(coutenv,0) * (NVL(nconsojhimmo,0) - NVL(curseur.consojh,0))
				WHERE ident=curseur.ident
			 	AND pid=curseur.pid
			 	AND cdeb=curseur.cdeb;

			 END IF;

	COMMIT;
	END LOOP;

	Trclog.Trclog( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);


EXCEPTION
	WHEN OTHERS THEN
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;
END alim_tmp_fi ;


--*************************************************************
-- Procédure de mise à jour des données de STOCK_FI_DEC
--************************************************************
PROCEDURE alim_stock_fi_dec(P_HFILE           IN UTL_FILE.FILE_TYPE)  IS

L_PROCNAME  VARCHAR2(20) := 'ALIM_STOCK_FI_DEC';
L_STATEMENT VARCHAR2(128);

BEGIN
	Trclog.Trclog( P_HFILE, 'Debut de ' || L_PROCNAME );

	-- On regarde si le CAMO de la ligne n'a pas changé par rapport au mois de décembre
	-- si oui, on mofifie le CAMO de la ligne de décembre
	 L_STATEMENT := '* Mise à jour du CODCAMO des lignes de STOCK_FI_DEC';
     	Trclog.Trclog( P_HFILE, L_STATEMENT );
	UPDATE STOCK_FI_DEC st SET codcamo =
		(SELECT DISTINCT lb.codcamo
		FROM  LIGNE_BIP lb
		WHERE lb.pid=st.pid)
	WHERE st.pid IN (SELECT l.pid
				FROM  LIGNE_BIP l
				WHERE
				l.pid=st.pid
				AND l.codcamo != st.codcamo
				and l.codcamo != 66666);
	COMMIT;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table STOCK_FI_DEC';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	--Changement du cafi
	-- Regarder si la situation de décembre a changé en cours d'année
	 L_STATEMENT := '* Mise à jour du CAFI des lignes de STOCK_FI_DEC';
     	Trclog.Trclog( P_HFILE, L_STATEMENT );
	UPDATE STOCK_FI_DEC st SET (CAFI, codsgress) =
		(SELECT DISTINCT i.CAFI,si.codsg
		FROM SITU_RESS_FULL si, STRUCT_INFO i
		WHERE si.datsitu<=st.cdeb
		AND (si.datdep>=st.cdeb OR datdep IS NULL)
		AND si.ident = st.ident
		AND si.codsg = i.codsg
		AND i.CAFI!=st.CAFI)
	WHERE st.ident IN (SELECT DISTINCT si.ident
						FROM SITU_RESS_FULL si, STRUCT_INFO i
						WHERE si.datsitu<=st.cdeb
						AND (si.datdep>=st.cdeb OR datdep IS NULL)
						AND si.ident = st.ident
						AND si.codsg = i.codsg
						AND i.CAFI!=st.CAFI
						AND i.CAFI!=88888);
	COMMIT;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table STOCK_FI_DEC';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	-- On insère toutes les lignes de STOCK_FI_DEC
	 L_STATEMENT := '* Insertion des lignes de STOCK_FI_DEC dans STOCK_FI';
    	 Trclog.Trclog( P_HFILE, L_STATEMENT );
	 INSERT INTO STOCK_FI
	 SELECT * FROM STOCK_FI_DEC;
	 COMMIT;

	--
	-- Suppression des lignes insérées dans la table STOCK_FI dont le métier est FOR
	--
	DELETE FROM STOCK_FI
	WHERE STOCK_FI.METIER = 'FOR' ;

	COMMIT;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes de métier FOR supprimées de la table STOCK_FI';
	Trclog.Trclog( P_HFILE, L_STATEMENT );


	Trclog.Trclog( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

EXCEPTION
	WHEN OTHERS THEN
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;
END alim_stock_fi_dec ;
--*************************************************************
-- Procédure pour la facturation multi-CA :
-- Pour les CODCAMO=77777, on répartit les charges
-- entre les CA de la table repartition_ligne et suivant les différents taux.
--************************************************************
PROCEDURE repartition_fi(P_HFILE           IN UTL_FILE.FILE_TYPE)  IS
CODCAMO_MULTI	NUMBER(6) 	:= 77777;
L_PROCNAME  	VARCHAR2(16) 	:= 'REPARTITION_FI';
L_STATEMENT 	VARCHAR2(128);
CURSOR cur_multi_ca IS
SELECT * FROM STOCK_FI WHERE codcamo=CODCAMO_MULTI;

BEGIN
	Trclog.Trclog( P_HFILE, 'Debut de ' || L_PROCNAME );
	FOR curseur IN cur_multi_ca LOOP
	 	BEGIN
			-- On effectue la mise à jour avec les taux fixés.
			INSERT INTO STOCK_FI(
				cdeb		,
				pid		,
				ident		,
				typproj		,
				METIER		,
				pnom		,
				codsg 		,
				dpcode 		,
				icpi 		,
				codcamo 	,
				clibrca 	,
				CAFI 		,
				codsgress 	,
				libdsg 		,
				rnom		,
				rtype		,
				PRESTATION	,
				NIVEAU 		,
				soccode 	,
				cada		,
				coutftht	,
				coutft		,
				coutenv		,
				consojhimmo 	,
				nconsojhimmo	,
				consoenvimmo	,
				nconsoenvimmo	,
				consoft
				)
			( SELECT
				curseur.cdeb		,
				curseur.pid		,
				curseur.ident		,
				curseur.typproj		,
				curseur.METIER		,
				curseur.pnom 		,
				curseur.codsg 		,
				curseur.dpcode 		,
				curseur.icpi 		,
				rl.codcamo 		,
				ca.clibrca 		,
				curseur.CAFI 		,
				curseur.codsgress 	,
				curseur.libdsg 		,
				curseur.rnom		,
				curseur.rtype		,
				curseur.PRESTATION	,
				curseur.NIVEAU 		,
				curseur.soccode 	,
				curseur.cada		,
				NVL(curseur.coutftht,0)	,
				NVL(curseur.coutft,0)	,
				NVL(curseur.coutenv,0) 	,
				ROUND(NVL(curseur.consojhimmo,0) * (rl.tauxrep/100), 2) 	,
				ROUND(NVL(curseur.nconsojhimmo,0) * (rl.tauxrep/100), 2)	,
				ROUND(NVL(curseur.consoenvimmo,0) * (rl.tauxrep/100), 2)	,
				ROUND(NVL(curseur.nconsoenvimmo,0) * (rl.tauxrep/100), 2)	,
				ROUND(NVL(curseur.consoft,0) * (rl.tauxrep/100), 2)
			  FROM REPARTITION_LIGNE rl, CENTRE_ACTIVITE ca
			  WHERE rl.pid = curseur.pid
			    AND rl.codcamo = ca.codcamo
			    AND rl.datdeb <= curseur.cdeb
			    AND (rl.datfin IS NULL OR rl.datfin > curseur.cdeb)
			);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME || ': Pas de répartition pour la ligne BIP ' || curseur.pid || ' et pour la date ' || TO_CHAR(curseur.cdeb, 'MM/YYYY') || '.');
		END;
		COMMIT;
	END LOOP;
EXCEPTION
	WHEN OTHERS THEN
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;
END repartition_fi;
-- **************************************************************************************
-- Vérification des arrondis dans les coûts (afin d'avoir le bon montant total à la fin).
-- **************************************************************************************
PROCEDURE verif_arrondis(P_HFILE           IN UTL_FILE.FILE_TYPE)  IS
CODCAMO_MULTI	NUMBER(6) 	:= 77777;
L_PROCNAME  	VARCHAR2(16) 	:= 'VERIF_ARRONDIS';
L_STATEMENT 	VARCHAR2(128);

-- Curseur contenant toutes les erreurs d'arrondis
CURSOR cur_err_arrondis IS
	SELECT 	sf.pid,
		sf.cdeb,
		sf.ident,
		consojhimmo - s_consojhimmo d_consojhimmo,
		nconsojhimmo - s_nconsojhimmo d_nconsojhimmo,
		consoenvimmo - s_consoenvimmo d_consoenvimmo,
		nconsoenvimmo - s_nconsoenvimmo d_nconsoenvimmo,
		consoft - s_consoft d_consoft
	FROM 	STOCK_FI sf,
		-- Sommes des Coûts pour les lignes Multi-CA
		(SELECT pid,
			cdeb,
			ident,
			SUM(consojhimmo)	s_consojhimmo,
			SUM(nconsojhimmo)	s_nconsojhimmo,
			SUM(consoenvimmo)	s_consoenvimmo,
			SUM(nconsoenvimmo)	s_nconsoenvimmo,
			SUM(consoft)		s_consoft
		 FROM   STOCK_FI
		 WHERE	codcamo != CODCAMO_MULTI
		   AND 	pid IN (SELECT pid FROM STOCK_FI WHERE codcamo=CODCAMO_MULTI)
		 GROUP BY pid, cdeb, ident
		 ) s_couts
	WHERE sf.codcamo= CODCAMO_MULTI
	  AND sf.pid	= s_couts.pid
	  AND sf.cdeb	= s_couts.cdeb
	  AND sf.ident	= s_couts.ident
	  -- La sommes des coûts multi_CA est différente du coût d'origine.
	  AND (  consojhimmo	!= s_consojhimmo
	    	OR nconsojhimmo	!= s_nconsojhimmo
	    	OR consoenvimmo	!= s_consoenvimmo
	    	OR nconsoenvimmo!= s_nconsoenvimmo
	    	OR consoft	!= s_consoft
	  )
  ;
BEGIN
	-- On corrige la différence à partir sur la première ligne trouvée.
	FOR curseur IN cur_err_arrondis LOOP
		UPDATE STOCK_FI s SET
			consojhimmo	= consojhimmo + curseur.d_consojhimmo,
	    		nconsojhimmo	= nconsojhimmo + curseur.d_nconsojhimmo,
	    		consoenvimmo	= consoenvimmo + curseur.d_consoenvimmo,
	    		nconsoenvimmo	= nconsoenvimmo + curseur.d_nconsoenvimmo,
	    		consoft		= consoft + curseur.d_consoft
		WHERE pid	= curseur.pid
		  AND cdeb	= curseur.cdeb
		  AND ident	= curseur.ident
		  -- On effectue la MAJ sur le même CA tous les mois afin d'éviter des faux retours arrières
		  AND codcamo   = (SELECT 	MAX(sf.codcamo)
		  		   FROM 	STOCK_FI sf
		  		   WHERE  	codcamo!=CODCAMO_MULTI
		  		     AND	s.pid=sf.pid
		  		     AND	s.cdeb=sf.cdeb
		  		     AND	s.ident=sf.ident);
		COMMIT;
	END LOOP;

	Packbatch.DYNA_TRUNCATE('STOCK_FI_MULTI');

	-- On stocke les lignes avec CA = CODCAMO_MULTI(77777) dans la table STOCK_FI_MULTI
	-- Cela servira pour la traitement de cloture

	INSERT INTO STOCK_FI_MULTI(CDEB,
                PID,
                IDENT,
                TYPPROJ,
                METIER,
                PNOM,
                CODSG,
                DPCODE,
                ICPI,
                CODCAMO,
                CLIBRCA,
                CAFI,
                CODSGRESS,
                LIBDSG,
                RNOM,
                RTYPE,
                PRESTATION,
                NIVEAU,
                SOCCODE,
                CADA,
                COUTFTHT,
                COUTFT,
                COUTENV,
                CONSOJHIMMO,
                NCONSOJHIMMO,
                CONSOFT,
                CONSOENVIMMO,
                NCONSOENVIMMO,
                A_CONSOFT,
                A_CONSOENVIMMO,
                A_NCONSOENVIMMO,
                A_CONSOJHIMMO,
                A_NCONSOJHIMMO)
	SELECT CDEB,
                PID,
                IDENT,
                TYPPROJ,
                METIER,
                PNOM,
                CODSG,
                DPCODE,
                ICPI,
                CODCAMO,
                CLIBRCA,
                CAFI,
                CODSGRESS,
                LIBDSG,
                RNOM,
                RTYPE,
                PRESTATION,
                NIVEAU,
                SOCCODE,
                CADA,
                COUTFTHT,
                COUTFT,
                COUTENV,
                CONSOJHIMMO,
                NCONSOJHIMMO,
                CONSOFT,
                CONSOENVIMMO,
                NCONSOENVIMMO,
                A_CONSOFT,
                A_CONSOENVIMMO,
                A_NCONSOENVIMMO,
                A_CONSOJHIMMO,
                A_NCONSOJHIMMO
            FROM STOCK_FI
            WHERE codcamo = CODCAMO_MULTI ;
	COMMIT;

	-- On supprime les CA non refacturés et les CA = CODCAMO_MULTI(77777)
	DELETE STOCK_FI
	WHERE codcamo = CODCAMO_MULTI
	   OR codcamo = 0
	   OR codcamo IS NULL
	   OR codcamo IN (SELECT codcamo FROM CENTRE_ACTIVITE WHERE ctopact = 'S');
	COMMIT;

	Trclog.Trclog( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	WHEN OTHERS THEN
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;
END verif_arrondis;
--*************************************************************
-- Procédure d'alimentation de la table STOCK_IMMO
--************************************************************
PROCEDURE alim_stock_immo(P_HFILE           IN UTL_FILE.FILE_TYPE)  IS
CURSOR cur_stock_immo IS
SELECT * FROM STOCK_IMMO ;

L_PROCNAME  VARCHAR2(16) := 'ALIM_STOCK_IMMO';
L_STATEMENT VARCHAR2(128);
l_consojh NUMBER(12,2);
l_consoft NUMBER(12,2);
l_a_consojh NUMBER(12,2);
l_a_consoft NUMBER(12,2);
l_moismens NUMBER(2);


BEGIN
	  Trclog.Trclog( P_HFILE, 'Debut de ' || L_PROCNAME );
	-- --------------------------------------------------------------------------
	-- Etape préliminaire : vider STOCK_IMMO _1, copier STOCK_IMMO  dans STOCK_IMMO _1, vider STOCK_IMMO
	-- ---------------------------------------------------------------------------
	L_STATEMENT := '* Copier STOCK_IMMO  dans STOCK_IMMO _1';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	Packbatch.DYNA_TRUNCATE('STOCK_IMMO_1');
	INSERT INTO STOCK_IMMO_1
	SELECT * FROM STOCK_IMMO
	WHERE immo1!='O' OR immo1 IS NULL; --Ne pas copier les lignes qui existaient dans stock_fi_1 et pas dans stock_fi

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_IMMO _1';
	COMMIT;
	Packbatch.DYNA_TRUNCATE('STOCK_IMMO');

	 --Insérer dans STOCK_IMMO toutes les lignes de TMP_IMMO
	 INSERT INTO STOCK_IMMO (CDEB,
	 			 			 PID ,
							 IDENT  ,
							 TYPPROJ ,
							 METIER ,
							 PNOM   ,
							 CODSG ,
							 DPCODE  ,
							 ICPI   ,
							 CODCAMO ,
							 CLIBRCA  ,
							 CAFI     ,
							 CODSGRESS,
							 LIBDSG  ,
							 RNOM    ,
							 RTYPE   ,
							 PRESTATION ,
							 NIVEAU    ,
							 SOCCODE  ,
							 CADA    ,
							 COUTFTHT ,
							 COUTFT   ,
							 CONSOJH  ,
							 CONSOFT  )
	 SELECT 				 t.CDEB,
	 			 			 t.PID ,
							 t.IDENT ,
							 t.TYPPROJ ,
							 t.METIER ,
							 t.PNOM   ,
							 t.CODSG ,
							 t.DPCODE  ,
							 t.ICPI   ,
							 t.CODCAMO ,
							 t.CLIBRCA  ,
							 --si cafi=88888 alors prendre le CA du DPG de la ressource
							 DECODE(t.CAFI,88888,s.CENTRACTIV,t.CAFI)     ,
							 t.CODSGRESS,
							 t.LIBDSG  ,
							 t.RNOM    ,
							 t.RTYPE   ,
							 t.PRESTATION ,
							 t.NIVEAU    ,
							 t.SOCCODE  ,
							 t.CADA    ,
							 NVL(t.COUTFTHT,0) ,
							 NVL(t.COUTFT ,0)  ,
							 NVL(t.CONSOJH ,0) ,
							 NVL(t.CONSOFT,0)
	FROM TMP_IMMO t, STRUCT_INFO s
	WHERE t.CODSGRESS=s.CODSG;
	 COMMIT;

	 -- On compare chaque ligne de STOCK_IMMO avec les lignes de STOCK_IMMO_1
	 L_STATEMENT := '* Calcul des retours arrière';
     Trclog.Trclog( P_HFILE, L_STATEMENT );
	 --Calcul des retours arrières
	  FOR curseur IN cur_stock_immo LOOP
	 	BEGIN
	 	 	  SELECT consojh,
					 consoft
					 INTO l_consojh,l_consoft
			  FROM STOCK_IMMO_1 s
			  WHERE s.ident = curseur.ident
			  AND s.pid = curseur.pid
			  AND s.cdeb = curseur.cdeb
			  AND s.icpi=curseur.icpi
			  AND s.CAFI=curseur.CAFI;

			  -- Calcul des retours arrières
			  l_a_consojh := NVL(curseur.consojh,0) - NVL(l_consojh,0);
			  l_a_consoft := NVL(curseur.consoft,0) - NVL(l_consoft,0);


			  UPDATE STOCK_IMMO
			  SET 	a_consojh = l_a_consojh,
					a_consoft = l_a_consoft
			  WHERE ident = curseur.ident
			  AND pid = curseur.pid
			  AND cdeb = curseur.cdeb
			  AND icpi=curseur.icpi
			  AND CAFI=curseur.CAFI;


		EXCEPTION
				 WHEN NO_DATA_FOUND THEN
				 	  UPDATE STOCK_IMMO
					  SET a_consojh = NVL(curseur.consojh,0),
					  	  a_consoft = NVL(curseur.consoft,0)
					  WHERE ident = curseur.ident
			  		  AND pid = curseur.pid
			  		  AND cdeb = curseur.cdeb
			  		  AND icpi=curseur.icpi
			  		  AND CAFI=curseur.CAFI;

		END;


	 END LOOP;
	COMMIT;
	-- Cas où il existe des lignes dans STOCK_IMMO_1 et pas dans STOCK_IMMO
	 L_STATEMENT := '* Insertion des lignes dans STOCK_IMMO existant dans STOCK_IMMO_1 et pas dans STOCK_IMMO';
     Trclog.Trclog( P_HFILE, L_STATEMENT );
	INSERT INTO STOCK_IMMO (cdeb 		,
						pid 		,
						ident 		,
						typproj 	,
						METIER 		,
						pnom 		,
						codsg 		,
						dpcode 		,
						icpi 		,
						codcamo 	,
						clibrca 	,
						CAFI 		,
						codsgress 	,
						libdsg 		,
						rnom		,
						rtype		,
						PRESTATION	,
						NIVEAU 		,
						soccode 	,
						cada		,
						coutftht	,
						coutft 	,
						consojh,
						consoft	,
						a_consojh,
						a_consoft,
						immo1
						)
	 SELECT 			s.cdeb 		,
						s.pid 		,
						s.ident 		,
						s.typproj 	,
						s.METIER 		,
						s.pnom 		,
						s.codsg 		,
						s.dpcode 		,
						s.icpi 		,
						s.codcamo 	,
						s.clibrca 	,
						s.CAFI 		,
						s.codsgress 	,
						s.libdsg 		,
						s.rnom		,
						s.rtype		,
						s.PRESTATION	,
						s.NIVEAU 		,
						s.soccode 	,
						s.cada		,
						NVL(s.coutftht,0)	,
						NVL(s.coutft,0) 	,
						0	,
						0 	,
						DECODE(s.consojh,0, s.a_consojh,- (s.consojh)),
						DECODE(s.consojh,0,s.a_consoft,- s.consoft),
						'O'
		FROM
		(SELECT cdeb,pid,ident,CAFI,icpi FROM STOCK_IMMO_1
		 MINUS
		 SELECT cdeb,pid,ident,CAFI,icpi FROM STOCK_IMMO) n,
		STOCK_IMMO_1 s, DATDEBEX d
		WHERE n.ident=s.ident
		AND n.pid=s.pid
		AND n.cdeb=s.cdeb
		AND n.icpi=s.icpi
		AND n.CAFI=s.CAFI;
		-- on ne compare pas les lignes de dec N-1

		--06/07/2004 KHA gestion immo de janv à dec
		--
		--and to_char(s.cdeb,'MM/YYYY')<>'12/'||to_char(add_months(d.moismens,-12),'YYYY')

		COMMIT;

		-- Mise à jour du CADA en prenant comme référence celui lié au projet le jour du
		-- traitement.

		UPDATE STOCK_IMMO
		SET CADA=(SELECT cada FROM PROJ_INFO
			  WHERE STOCK_IMMO.icpi=PROJ_INFO.icpi)
		;

		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_IMMO';
		Trclog.Trclog( P_HFILE, L_STATEMENT );


		Trclog.Trclog( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	WHEN OTHERS THEN
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;
END alim_stock_immo;
--*************************************************************
-- Procédure d'alimentation de la table STOCK_FI :
-- retours arrières
--**************************************************************
PROCEDURE alim_stock_fi(P_HFILE           IN UTL_FILE.FILE_TYPE)   IS
CURSOR cur_stock_fi IS
SELECT * FROM STOCK_FI ;

L_PROCNAME  VARCHAR2(16) := 'ALIM_STOCK_FI';
L_STATEMENT VARCHAR2(128);

l_consojhimmo NUMBER(10,2);
l_nconsojhimmo NUMBER(10,2);
l_consoft NUMBER(10,2);
l_consoenvimmo NUMBER(10,2);
l_nconsoenvimmo NUMBER(10,2);
l_a_consojhimmo NUMBER(10,2);
l_a_nconsojhimmo NUMBER(10,2);
l_a_consoft NUMBER(10,2);
l_a_consoenvimmo NUMBER(10,2);
l_a_nconsoenvimmo NUMBER(10,2);
l_moismens NUMBER(2);
BEGIN
	  Trclog.Trclog( P_HFILE, 'Debut de ' || L_PROCNAME );

	 -- On compare chaque ligne de STOCK_FI avec les lignes de STOCK_FI_1
	 L_STATEMENT := '* Calcul des retours arrière';
     Trclog.Trclog( P_HFILE, L_STATEMENT );
	 FOR curseur IN cur_stock_fi LOOP
	 	BEGIN
	 	 	  SELECT consojhimmo,
			  		 nconsojhimmo,
					 consoft,
					 consoenvimmo,
					 nconsoenvimmo
					 INTO l_consojhimmo,l_nconsojhimmo,l_consoft,l_consoenvimmo,l_nconsoenvimmo
			  FROM STOCK_FI_1 s
			  WHERE s.ident = curseur.ident
			  AND s.pid = curseur.pid
			  AND s.cdeb = curseur.cdeb
			  AND s.codcamo=curseur.codcamo
			  AND s.CAFI=curseur.CAFI;

			  -- Calcul des retours arrières
			 -- l_a_consojh := (curseur.consojhimmo+curseur.nconsojhimmo)-(l_consojhimmo+l_nconsojhimmo);
			  l_a_consojhimmo := NVL(curseur.consojhimmo,0) - NVL(l_consojhimmo,0);
			  l_a_nconsojhimmo := NVL(curseur.nconsojhimmo,0) - NVL(l_nconsojhimmo,0);
			  l_a_consoft := NVL(curseur.consoft,0) - NVL(l_consoft,0);
			  l_a_consoenvimmo := NVL(curseur.consoenvimmo,0) - NVL(l_consoenvimmo,0);
			  l_a_nconsoenvimmo  := NVL(curseur.nconsoenvimmo,0) - NVL(l_nconsoenvimmo,0);

			  UPDATE STOCK_FI
			  SET 	a_consojhimmo = l_a_consojhimmo,
			  		a_nconsojhimmo = l_a_nconsojhimmo,
					a_consoft = l_a_consoft,
					a_consoenvimmo = l_a_consoenvimmo,
					a_nconsoenvimmo =  l_a_nconsoenvimmo
			  WHERE ident = curseur.ident
			  AND pid = curseur.pid
			  AND cdeb = curseur.cdeb
			  AND codcamo=curseur.codcamo
			  AND CAFI=curseur.CAFI;


		EXCEPTION
				 WHEN NO_DATA_FOUND THEN
				 	  UPDATE STOCK_FI
					  SET a_consojhimmo = NVL(curseur.consojhimmo,0),
					  	  a_nconsojhimmo =NVL(curseur.nconsojhimmo,0),
					  	  a_consoft = NVL(curseur.consoft,0),
						  a_consoenvimmo = NVL(curseur.consoenvimmo,0),
						  a_nconsoenvimmo = NVL(curseur.nconsoenvimmo,0)
					  WHERE ident = curseur.ident
			  		  AND pid = curseur.pid
			  		  AND cdeb = curseur.cdeb
			  		  AND codcamo=curseur.codcamo
			  		  AND CAFI=curseur.CAFI;

		END;


	 END LOOP;
	COMMIT;
	-- Cas où il existe des lignes dans STOCK_FI_1 et pas dans STOCK_FI
	 L_STATEMENT := '* Insertion des lignes dans STOCK_FI existant dans STOCK_FI_1 et pas dans STOCK_FI';
     Trclog.Trclog( P_HFILE, L_STATEMENT );
	INSERT INTO STOCK_FI (cdeb 		,
						pid 		,
						ident 		,
						typproj 	,
						METIER 		,
						pnom 		,
						codsg 		,
						dpcode 		,
						icpi 		,
						codcamo 	,
						clibrca 	,
						CAFI 		,
						codsgress 	,
						libdsg 		,
						rnom		,
						rtype		,
						PRESTATION	,
						NIVEAU 		,
						soccode 	,
						cada		,
						coutftht	,
						coutft 	,
						coutenv	,
						consojhimmo 	,
						nconsojhimmo 	,
						consoft	,
						consoenvimmo,
						nconsoenvimmo,
						a_consojhimmo,
						a_nconsojhimmo,
						a_consoft,
						a_consoenvimmo,
						a_nconsoenvimmo,
						fi1)
	 SELECT 			s.cdeb 		,
						s.pid 		,
						s.ident 		,
						s.typproj 	,
						s.METIER 		,
						s.pnom 		,
						s.codsg 		,
						s.dpcode 		,
						s.icpi 		,
						s.codcamo 	,
						s.clibrca 	,
						s.CAFI 		,
						s.codsgress 	,
						s.libdsg 		,
						s.rnom		,
						s.rtype		,
						s.PRESTATION	,
						s.NIVEAU 		,
						s.soccode 	,
						s.cada		,
						NVL(s.coutftht,0)	,
						NVL(s.coutft,0) 	,
						NVL(s.coutenv,0)	,
						0	,
						0 	,
						0	,
						0	,
						0	,
						- s.consojhimmo,
						- s.nconsojhimmo,
						- s.consoft,
						- s.consoenvimmo,
						- s.nconsoenvimmo,
						 'O'
		FROM
		(SELECT cdeb,pid,ident,CAFI,codcamo FROM STOCK_FI_1
		 MINUS
		 SELECT cdeb,pid,ident,CAFI,codcamo FROM STOCK_FI) n,
		STOCK_FI_1 s, DATDEBEX d
		WHERE n.ident=s.ident
		AND n.pid=s.pid
		AND n.cdeb=s.cdeb
		AND n.codcamo=s.codcamo
		AND n.CAFI=s.CAFI;


		COMMIT;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_FI';
		Trclog.Trclog( P_HFILE, L_STATEMENT );

		Trclog.Trclog( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	WHEN OTHERS THEN
	    ROLLBACK;
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;
END alim_stock_fi;
--*************************************************************
-- Procédure de création du fichier pour la FI
--************************************************************
PROCEDURE fi( P_LOGDIR          IN VARCHAR2,
              p_chemin_fichier  IN VARCHAR2,
              p_nom_fichier     IN VARCHAR2) IS
CURSOR cur_fi IS
--Montant de FI de type OPE=3
SELECT
	'30003'										AS cdbqma,
	LPAD(codcamo,5,'0')								AS cdcamo,
	'30003'										AS cdbqme,
	LPAD(TO_CHAR(CAFI),5,'0')							AS cdcamu,
	'3'					AS cdofei,
	DECODE(SIGN(SUM(a_consoft)),-1,'O',0,'O','N')				AS tregul,
	DECODE(SIGN(SUM(a_consoft)),-1,'-',1,'+')					AS signe,
	LPAD(ROUND(ABS(SUM(a_consoft))*100,0),16,'0')				AS mtopr,
	'EUR'											AS cddv,
	'2'											AS nbdedv
FROM
STOCK_FI
WHERE METIER IN ('ME','MO','HOM')
GROUP BY CAFI, codcamo
HAVING  SUM(a_consoft)<>0
UNION
--Montant de FI de type OPE=4
SELECT
	'30003'										AS cdbqma,
	LPAD(codcamo,5,'0')								AS cdcamo,
	'30003'										AS cdbqme,
	LPAD(TO_CHAR(CAFI),5,'0')							AS cdcamu,
	'4'					AS cdofei,
	DECODE(SIGN(SUM(a_nconsoenvimmo)),-1,'O',0,'O','N')				AS tregul,
	DECODE(SIGN(SUM(a_nconsoenvimmo)),-1,'-',1,'+')					AS signe,
	LPAD(ROUND(ABS(SUM(a_nconsoenvimmo))*100,0),16,'0')				AS mtopr,
	'EUR'											AS cddv,
	'2'											AS nbdedv
FROM
STOCK_FI
WHERE METIER IN ('ME','MO','HOM')
GROUP BY CAFI, codcamo
HAVING  SUM(a_nconsoenvimmo)<>0
UNION
--Montant de FI de type OPE=5
SELECT
	'30003'										AS cdbqma,
	LPAD(codcamo,5,'0')								AS cdcamo,
	'30003'										AS cdbqme,
	LPAD(TO_CHAR(CAFI),5,'0')							AS cdcamu,
	'5'					AS cdofei,
	DECODE(SIGN(SUM(a_consoenvimmo)),-1,'O',0,'O','N')				AS tregul,
	DECODE(SIGN(SUM(a_consoenvimmo)),-1,'-',1,'+')					AS signe,
	LPAD(ROUND(ABS(SUM(a_consoenvimmo))*100,0),16,'0')				AS mtopr,
	'EUR'											AS cddv,
	'2'											AS nbdedv
FROM
STOCK_FI
WHERE METIER IN ('ME','MO','HOM')
GROUP BY CAFI, codcamo
HAVING  SUM(a_consoenvimmo)<>0
UNION
--Montant de FI de type OPE=6
SELECT
	'30003'										AS cdbqma,
	LPAD(codcamo,5,'0')								AS cdcamo,
	'30003'										AS cdbqme,
	LPAD(TO_CHAR(CAFI),5,'0')							AS cdcamu,
	'6'					AS cdofei,
	DECODE(SIGN(SUM(a_consoft)),-1,'O',0,'O','N')				AS tregul,
	DECODE(SIGN(SUM(a_consoft)),-1,'-',1,'+')					AS signe,
	LPAD(ROUND(ABS(SUM(a_consoft))*100,0),16,'0')				AS mtopr,
	'EUR'											AS cddv,
	'2'											AS nbdedv
FROM
STOCK_FI
WHERE METIER IN ('GAP','SAU')
GROUP BY CAFI, codcamo
HAVING  SUM(a_consoft)<>0
UNION
--Montant de FI de type OPE=7
SELECT
	'30003'										AS cdbqma,
	LPAD(codcamo,5,'0')								AS cdcamo,
	'30003'										AS cdbqme,
	LPAD(TO_CHAR(CAFI),5,'0')							AS cdcamu,
	'7'					AS cdofei,
	DECODE(SIGN(SUM(a_consoft)),-1,'O',0,'O','N')				AS tregul,
	DECODE(SIGN(SUM(a_consoft)),-1,'-',1,'+')					AS signe,
	LPAD(ROUND(ABS(SUM(a_consoft))*100,0),16,'0')				AS mtopr,
	'EUR'											AS cddv,
	'2'											AS nbdedv
FROM
STOCK_FI
WHERE METIER = 'EXP'
GROUP BY CAFI, codcamo
HAVING  SUM(a_consoft)<>0
UNION
--Montant de FI de type OPE=8
SELECT
	'30003'										AS cdbqma,
	LPAD(codcamo,5,'0')								AS cdcamo,
	'30003'										AS cdbqme,
	LPAD(TO_CHAR(CAFI),5,'0')							AS cdcamu,
	'8'					AS cdofei,
	DECODE(SIGN(SUM(a_nconsoenvimmo+a_consoenvimmo)),-1,'O',0,'O','N')				AS tregul,
	DECODE(SIGN(SUM(a_nconsoenvimmo+a_consoenvimmo)),-1,'-',1,'+')					AS signe,
	LPAD(ROUND(ABS(SUM(a_nconsoenvimmo+a_consoenvimmo))*100,0),16,'0')				AS mtopr,
	'EUR'											AS cddv,
	'2'											AS nbdedv
FROM
STOCK_FI
WHERE METIER IN ('EXP','GAP','SAU')
GROUP BY CAFI, codcamo
HAVING  SUM(a_nconsoenvimmo+a_consoenvimmo)<>0
ORDER BY 4,2,5;

L_RETCOD    NUMBER;
L_PROCNAME  VARCHAR2(16) := 'FI';
L_HFILE1     UTL_FILE.FILE_TYPE;
L_STATEMENT VARCHAR2(128);
l_moismens	  DATE;
l_hfile      UTL_FILE.FILE_TYPE;
l_nbenreg	  NUMBER(15);

BEGIN
	-----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
	L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE1 );
	IF ( L_RETCOD <> 0 ) THEN
	RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
	END IF;
	-----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------
	Trclog.Trclog( L_HFILE1, 'Debut de ' || L_PROCNAME );

	 L_STATEMENT := 'ECRITURE DANS LES FICHIERS DE FI : début';
	 Trclog.Trclog( L_HFILE1, L_STATEMENT );

	 L_STATEMENT := 'Init du fichier de sortie : ' || p_chemin_fichier || '/' || p_nom_fichier || '.txt';
	 Trclog.Trclog( L_HFILE1, L_STATEMENT );
	 Pack_Global.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);

	 SELECT moismens INTO l_moismens FROM DATDEBEX;

	 -- Création de l'entête du fichier
	 Pack_Global.WRITE_STRING(	l_hfile,
							'1'    	||
							'0'    	||
							'BIP54703'	||
							'DDDD3725'    	||
							'00401'   	||
							'A0374'	||
							TO_CHAR(l_moismens,'yyyymm')	||
							TO_CHAR(SYSDATE,'yyyymmdd')	||
							TO_CHAR(SYSDATE,'HH24MI')		||
							TO_CHAR(LAST_DAY(l_moismens),'yyyymmdd')	||
							RPAD(' ',6)
						);

	 -- Corps du fichier
	 FOR ligne IN cur_fi LOOP
	 	 Pack_Global.WRITE_STRING(	l_hfile,
							'2'			||
							'1'			||
							ligne.cdbqma    	||
							ligne.cdcamo    	||
							ligne.cdbqme	||
							ligne.cdcamu    	||
							ligne.cdofei   	||
							ligne.tregul	||
							ligne.signe	||
							ligne.mtopr	||
							ligne.cddv		||
							ligne.nbdedv	||
							RPAD(' ',15)
						);

		--On compte le nombre de lignes
		l_nbenreg := cur_fi%ROWCOUNT ;

	 END LOOP;

	 -- Fin de fichier
	 Pack_Global.WRITE_STRING(	l_hfile,
							'9'    	||
							'0'    	||
							LTRIM(TO_CHAR(l_nbenreg,'000000000')) ||
							RPAD(' ',49)
						);

	L_STATEMENT := 'FIN ECRITURE DANS LE FICHIER FI';
	Trclog.Trclog( L_HFILE1, L_STATEMENT );
	L_STATEMENT := '-> '||l_nbenreg ||' lignes créées dans le fichier FI';
	Trclog.Trclog( L_HFILE1, L_STATEMENT );
	Pack_Global.CLOSE_WRITE_FILE(l_hfile);

	-----------------------------------------------------
	-- Trace Stop
	-----------------------------------------------------
	Trclog.Trclog( L_HFILE1, 'Fin normale de ' || L_PROCNAME  );
	Trclog.CLOSETRCLOG( L_HFILE1 );

	EXCEPTION
		WHEN OTHERS THEN
			IF SQLCODE <> CALLEE_FAILED_ID AND SQLCODE <> TRCLOG_FAILED_ID THEN
				Trclog.Trclog( L_HFILE1, L_PROCNAME || ' : ' || SQLERRM );
			END IF;
			IF SQLCODE <> TRCLOG_FAILED_ID THEN
				Trclog.Trclog( L_HFILE1, 'Fin ANORMALE de ' || L_PROCNAME  );
				Trclog.CLOSETRCLOG( L_HFILE1 );
				RAISE_APPLICATION_ERROR( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         FALSE );
			ELSE
				RAISE;
			END IF;


END fi;
--*************************************************************
-- Procédure de création du fichier pour SMS appelée par le shell
--************************************************************
PROCEDURE immo( P_LOGDIR          IN VARCHAR2,
              	p_chemin_fichier  IN VARCHAR2,
              	p_nom_fichier     IN VARCHAR2) IS
CURSOR cur_immo IS
SELECT * FROM vue_immo;

L_RETCOD    NUMBER;
L_PROCNAME  VARCHAR2(16) := 'IMMO';
L_HFILE1    UTL_FILE.FILE_TYPE;
L_STATEMENT VARCHAR2(128);
l_hfile 	UTL_FILE.FILE_TYPE;
l_separateur CHAR(1) := ';';
l_nbenreg 	 NUMBER(15);
l_zone_evol_1 VARCHAR2(30) :='';
l_zone_evol_2 VARCHAR2(30) :='';
l_zone_evol_3 VARCHAR2(30) :='';

BEGIN
	-----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
	L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE1 );
	IF ( L_RETCOD <> 0 ) THEN
	RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
	END IF;
	-----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------
	Trclog.Trclog( L_HFILE1, 'Debut de ' || L_PROCNAME );

	 L_STATEMENT := 'ECRITURE DANS LE FICHIER POUR SMS : début';
	 Trclog.Trclog( L_HFILE1, L_STATEMENT );

	 L_STATEMENT := 'Init du fichier de sortie : ' || p_chemin_fichier || '/' || p_nom_fichier || '.txt';
	 Trclog.Trclog( L_HFILE1, L_STATEMENT );
	 Pack_Global.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier , l_hfile);

	 --Nombre de lignes total du fichier y compris la ligne d'entête
	 SELECT COUNT(*)+1 INTO l_nbenreg
	 FROM vue_immo;
	 -- Entête du fichier
	 Pack_Global.WRITE_STRING(	l_hfile,
							'1'    	||l_separateur||
							' '    	||l_separateur||
							'IEC'	||l_separateur||
							'A0374' ||l_separateur||
							TO_NUMBER(TO_CHAR(SYSDATE,'yyyymmdd'))||l_separateur||
							TO_NUMBER(TO_CHAR(SYSDATE,'HH24MISS'))	||l_separateur||
							l_nbenreg
						);

	 -- Corps du fichier
	 --Parcourir la vue vue_immo
	 FOR ligne IN cur_immo LOOP

	 	 Pack_Global.WRITE_STRING(	l_hfile,
							ligne.TYPE_ENREG	||l_separateur||
							ligne.ORIGINE		||l_separateur||
							ligne.ENTITE_PROJET	||l_separateur||
							ligne.PROJET		||l_separateur||
							ligne.COMPOSANT		||l_separateur||
							ligne.CADA			||l_separateur||
							ligne.ANNEE			||l_separateur||
							ligne.MOIS			||l_separateur||
							ligne.TYPE_MONTANT	||l_separateur||
							ligne.MONTANT		||l_separateur||
							ligne.SENS			||l_separateur||
							ligne.DEVISE		||l_separateur||
							ligne.CAFI			||l_separateur||
							l_zone_evol_1		||l_separateur||
							l_zone_evol_2		||l_separateur||
							l_zone_evol_3
						);



	 END LOOP;


	 L_STATEMENT := 'FIN ECRITURE DANS LE FICHIER IMMO';
	Trclog.Trclog( L_HFILE1, L_STATEMENT );
	L_STATEMENT := '-> '||l_nbenreg ||' lignes créées dans le fichier IMMO';
	Trclog.Trclog( L_HFILE1, L_STATEMENT );
	Pack_Global.CLOSE_WRITE_FILE(l_hfile);

	-----------------------------------------------------
	-- Trace Stop
	-----------------------------------------------------
	Trclog.Trclog( L_HFILE1, 'Fin normale de ' || L_PROCNAME  );
	Trclog.CLOSETRCLOG( L_HFILE1 );

	EXCEPTION
		WHEN OTHERS THEN
			IF SQLCODE <> CALLEE_FAILED_ID AND SQLCODE <> TRCLOG_FAILED_ID THEN
				Trclog.Trclog( L_HFILE1, L_PROCNAME || ' : ' || SQLERRM );
			END IF;
			IF SQLCODE <> TRCLOG_FAILED_ID THEN
				Trclog.Trclog( L_HFILE1, 'Fin ANORMALE de ' || L_PROCNAME  );
				Trclog.CLOSETRCLOG( L_HFILE1 );
				RAISE_APPLICATION_ERROR( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         FALSE );
			ELSE
				RAISE;
			END IF;

END immo;
--*************************************************************
-- Procédure qui écrit dans un fichier le mois de la mensuelle
--************************************************************
	PROCEDURE DATRAIT(   P_LOGDIR          IN VARCHAR2,
                          p_chemin_fichier  IN VARCHAR2,
                          p_nom_fichier     IN VARCHAR2
                        ) IS

		L_RETCOD    NUMBER;
		L_PROCNAME  VARCHAR2(16) := 'DATRAIT';
		L_HFILE1    UTL_FILE.FILE_TYPE;
		L_STATEMENT VARCHAR2(128);
		l_hfile2      UTL_FILE.FILE_TYPE;
		l_moismens    VARCHAR2(6);

	BEGIN
	-----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
	L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE1 );
	IF ( L_RETCOD <> 0 ) THEN
	RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
	END IF;
	-----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------
	Trclog.Trclog( L_HFILE1, 'Debut de ' || L_PROCNAME );

	L_STATEMENT := 'Recuperation de la date de la derniere mensuelle';
	SELECT  TO_CHAR(moismens,'mmyyyy')  INTO  l_moismens FROM   DATDEBEX;
	Trclog.Trclog( L_HFILE1, L_STATEMENT || ' : ' || l_moismens );

	L_STATEMENT := 'Init du fichier de sortie : ' || p_chemin_fichier || '/' || p_nom_fichier;
	Pack_Global.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile2);
	Trclog.Trclog( L_HFILE1, L_STATEMENT );

	L_STATEMENT := 'Ecriture date derniere mensuelle dans fichier de sortie';
	Trclog.Trclog( L_HFILE1, L_STATEMENT );
    Pack_Global.WRITE_STRING( l_hfile2, l_moismens  );

	L_STATEMENT := 'Fermeture du fichier de sortie : ' || p_chemin_fichier || '/' || p_nom_fichier;
	Pack_Global.CLOSE_WRITE_FILE(l_hfile2);
	Trclog.Trclog( L_HFILE1, L_STATEMENT );

	Trclog.Trclog( L_HFILE1, 'Fin NORMALE de ' || L_PROCNAME);

	EXCEPTION
		WHEN OTHERS THEN
         	IF UTL_FILE.IS_OPEN(l_hfile2) THEN
				Pack_Global.CLOSE_WRITE_FILE(l_hfile2);
			END IF;
			IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( L_HFILE1, L_PROCNAME ||
                                               ' [' || L_STATEMENT ||
				               '] : ' || SQLERRM );
			END IF;
			Trclog.Trclog( L_HFILE1, 'Fin ANORMALE de ' ||
                                                L_PROCNAME  );
			RAISE CALLEE_FAILED;
	END DATRAIT;

END Packbatch_Ias;
/
CREATE OR REPLACE PACKAGE Packbatch_Ias_Rjh AS


   -- Utilitaire : Facturation interne des consommés de répartition
	-- -----------------------------------------------------------------------------------------------------------------
   PROCEDURE ALIM_IAS( P_HFILE IN UTL_FILE.FILE_TYPE );

   -- Utilitaire : Alimentation de la table RJH_IAS
   -- -----------------------------------------------------------------------------------------------------------
       PROCEDURE ALIM_RJH_IAS( P_HFILE IN UTL_FILE.FILE_TYPE );


   -- Utilitaire : Ajout des couts dans la table RJH_IAS
   -- -------------------------------------------------------------------------------------------------------------
     PROCEDURE MAJ_RJH_IAS_COUTS( P_HFILE IN UTL_FILE.FILE_TYPE );


	-- Utilitaire : Ajout des consommés dans la table RJH_IAS
	-- -----------------------------------------------------------------------------------------------------------------
	 PROCEDURE MAJ_RJH_IAS_CONS( P_HFILE IN UTL_FILE.FILE_TYPE );


	 -- Utilitaire : Alimentation de stock_fi
	-- -----------------------------------------------------------------------------------------------------------------
	 PROCEDURE ALIM_STOCK_FI_RJH( P_HFILE IN UTL_FILE.FILE_TYPE );

END Packbatch_Ias_Rjh;
/

CREATE OR REPLACE PACKAGE BODY Packbatch_Ias_Rjh AS

-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
PRAGMA EXCEPTION_INIT( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     NUMBER := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     NUMBER := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID NUMBER := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
VIOLATION_CONSTRAINT_UNIQUE EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
PRAGMA EXCEPTION_INIT( VIOLATION_CONSTRAINT_UNIQUE, -00001 );







-- Utilitaire : Facturation interne des consommés de répartition
	-- -----------------------------------------------------------------------------------------------------------------
   PROCEDURE ALIM_IAS(P_HFILE IN UTL_FILE.FILE_TYPE ) IS

   L_PROCNAME  VARCHAR2(16) := 'ALIM_IAS';
   L_STATEMENT VARCHAR2(128);
   L_RETCOD    NUMBER;




BEGIN


    -----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------


    Trclog.Trclog( P_HFILE, 'Debut de ' || L_PROCNAME );


    -- ------------------------------------------------------------------------------------------------------
	-- Etape 1 : Alimentation de la table RJH_IAS
	-- ------------------------------------------------------------------------------------------------------

	 Packbatch_Ias_Rjh.ALIM_RJH_IAS( P_HFILE );

	-- ------------------------------------------------------------------------------------------------------
	-- Etape 2 : Ajout des couts dans la table RJH_IAS
	-- ------------------------------------------------------------------------------------------------------

      Packbatch_Ias_Rjh.MAJ_RJH_IAS_COUTS( P_HFILE);

   	-- ------------------------------------------------------------------------------------------------------
	-- Etape 3 : Ajout des consommés dans la table RJH_IAS
	-- ------------------------------------------------------------------------------------------------------

      Packbatch_Ias_Rjh.MAJ_RJH_IAS_CONS( P_HFILE);


	   	-- ------------------------------------------------------------------------------------------------------
	-- Etape 4 : Alimentation de stock_fi
	-- ------------------------------------------------------------------------------------------------------

      Packbatch_Ias_Rjh.ALIM_STOCK_FI_RJH( P_HFILE);




    Trclog.Trclog( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

EXCEPTION
	WHEN OTHERS THEN
	    ROLLBACK;
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;


END ALIM_IAS;









-- Utilitaire : Alimentation de la table RJH_IAS
-- -----------------------------------------------------------------------------------------------------------
PROCEDURE ALIM_RJH_IAS( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

 L_STATEMENT VARCHAR2(128);

BEGIN


     L_STATEMENT := '* Troncature de la table RJH_IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	  -- Troncature RJH_CONSOMME
	  Packbatch.DYNA_TRUNCATE('RJH_IAS');


    L_STATEMENT := '* Insertion des lignes dans la table RJH_IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

		INSERT INTO RJH_IAS (CDEB,
		   				 	 	   		   		   		 	PID,
															IDENT,
															TYPPROJ ,
															METIER,
															PNOM,
                        									CODSG,
                                           					DPCODE,
                       										ICPI,
                       										CODCAMO,
                        									CLIBRCA,
                       										CAFI,
                        									CODSGRESS,
                       										LIBDSG,
                        									RNOM,
                        									RTYPE,
                        									PRESTATION,
                        									NIVEAU,
                        									SOCCODE,
                        									CADA
                       						              )
	  (	SELECT DISTINCT
   	   		    	   									  rc.cdeb ,
														  rc.pid,
      													  r.ident ,
														  l.typproj ,
														  RTRIM(l.METIER) ,
														  l.pnom ,
														  l.codsg ,
														  l.dpcode ,
														  l.icpi ,
														  l.codcamo ,
														  ca.clibrca ,
														  si2.CAFI ,
														  sr.codsg  codsgress,
														  si2.libdsg ,
 														  r.rnom,
														  r.rtype,
														  sr.PRESTATION,
														  sr.NIVEAU,
														  sr.soccode ,
														  p.cada
   		FROM
				RJH_CONSOMME rc,
				SITU_RESS_FULL sr ,
				LIGNE_BIP l ,
				RESSOURCE r,
				CENTRE_ACTIVITE ca,
				PROJ_INFO p,
				STRUCT_INFO si2,
				DOSSIER_PROJET dp,
				DATDEBEX d
	WHERE
	-- Consommés sur l'année courante :
 		TO_CHAR(rc.cdeb,'YYYY')=TO_CHAR(d.moismens,'YYYY')
		AND TO_CHAR(rc.cdeb,'MM')<= TO_CHAR(d.moismens,'MM')
	-- jointure ligne_bip et rjh_consomme
		AND l.pid=rc.pid
	-- jointure ligne_bip et centre_activite
		AND l.codcamo = ca.codcamo
   -- On ne prend pas les lignes dont le ctopact est égal à S
		AND ca.ctopact<>'S'
 	-- jointure ligne_bip et projet_info
		AND l.icpi = p.icpi
	-- jointure ligne_bip et dossier_projet
		AND l.dpcode = dp.dpcode
	-- jointure cons_sstache_res et situ_ress
         AND r.ident =sr.ident
		 AND rc.ident = r.ident
		 AND rc.ident = sr.ident
		AND (rc.cdeb >=sr.datsitu OR sr.datsitu IS NULL)
		AND (rc.cdeb <=sr.datdep OR sr.datdep IS NULL )
	-- On ne prend pas les lignes dont le consommé est égal à 0
	     AND rc.consojh<>0
	-- ressource dont le CAFI du DPG <> 99999 et 88888
		AND sr.codsg=si2.codsg
		AND si2.CAFI<>88888
		AND si2.CAFI<>99999
	-- ressource dont la prestation <>(IFO,MO ,GRA,INT,STA)
		AND sr.PRESTATION NOT IN ('IFO','MO ','GRA','INT','STA')
   -- TYPE de la ligne =9
	  AND  l.typproj=9
	-- Centre d'activité de la ligne <> 66666 : Exclut lignes d'origine de la répartition
	 AND  l.codcamo<>66666
	  ) ;


	COMMIT;

	Trclog.Trclog( P_HFILE, L_STATEMENT ||':-'||SQL%rowcount||' lignes insérées dans la table RJH_IAS');



 END ALIM_RJH_IAS;


-- Utilitaire : Ajout des couts dans la table RJH_IAS
-- -------------------------------------------------------------------------------------------------------------
PROCEDURE MAJ_RJH_IAS_COUTS( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

L_STATEMENT VARCHAR2(128);
l_annee  NUMBER(4);

BEGIN

     -- Récupère l'année en cours dans une variable
	SELECT TO_NUMBER( TO_CHAR( DATDEBEX, 'YYYY') )
	INTO l_annee
	FROM DATDEBEX;

    L_STATEMENT := '* Ajout des couts dans la table RJH_IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	-- COUT FORCE DE TRAVAIL
	-- * SG : on prend le coût déjà HTR à partir de la table des coûts standards SG COUT_STD_SG des lignes dont le code société ='SG..',le type='P' par année,niveau,métier,dpg
	-- * Logiciel :coût logiciel HTR de la table COUT_STD2 en fonction du DPG de la ressource

		L_STATEMENT := '* Ajout COUT FORCE DE TRAVAIL SG et Logiciel';
		Trclog.Trclog( P_HFILE, L_STATEMENT );

		UPDATE RJH_IAS
		SET coutft= Pack_Utile_Cout.getCout( RJH_IAS.soccode, RJH_IAS.rtype, l_annee, RJH_IAS.METIER,
												RJH_IAS.NIVEAU, RJH_IAS.codsgress, 0)
		WHERE  RJH_IAS.soccode='SG..'
			OR RJH_IAS.rtype='L';

	COMMIT;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table RJH_IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );



	-- * SSII : on calcule le coût HTR de la situation de la ressource dont le code société est <>'SG..' , le type='P' avec une situation en cours pour l'année courante
	-- * Forfait Hors Site et sur Site:coût HTR de la situation de la ressource saisi en coût HT dont le type=('E','F') avec une situation en cours.

	L_STATEMENT := '* Ajout COUT FORCE DE TRAVAIL SSII et Forfait';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	UPDATE RJH_IAS
	SET (coutftht,coutft) = (SELECT DISTINCT NVL(s.cout,0),
			Pack_Utile_Cout.AppliqueTauxHTR (l_annee, NVL(s.cout,0) , TO_CHAR(RJH_IAS.cdeb,'DD/MM/YYYY'), '01 ')
			FROM SITU_RESS_FULL s
			WHERE  s.ident =RJH_IAS.ident
			AND (RJH_IAS.cdeb>=s.datsitu OR s.datsitu IS NULL)
			AND (RJH_IAS.cdeb<=s.datdep OR s.datdep IS NULL)
			)
	WHERE
	 	RJH_IAS.soccode!='SG..'
		AND RJH_IAS.rtype!='L';

	COMMIT;


	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table RJH_IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );


	-- COUT D'ENVIRONNEMENT
	-- * SG,SSII,Forfait sur Site : coût d'environnement en HTR de la table COUT_STD2 en fonction du DPG de la ressource

	L_STATEMENT := '* Ajout COUT D''ENVIRONNEMENT SG,SSII,Forfait sur Site';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	UPDATE RJH_IAS
	SET coutenv= Pack_Utile_Cout.getCoutEnv(RJH_IAS.soccode, RJH_IAS.rtype, l_annee , RJH_IAS.codsgress)
	WHERE  RJH_IAS.rtype != 'L'
	 AND RJH_IAS.rtype!='E' ;

    COMMIT;


	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table RJH_IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );




END MAJ_RJH_IAS_COUTS;



-- Utilitaire : Ajout des consommés dans la table RJH_IAS
-- -----------------------------------------------------------------------------------------------------------------

PROCEDURE MAJ_RJH_IAS_CONS( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

L_STATEMENT VARCHAR2(128);

BEGIN

	--	calcul du conso en jh de la ressource pour une ligne donnée, pour un mois donné et  une ressource à partir du conso de la table RJH_CONSOMME
	L_STATEMENT := '* Calcul du conso en jh';
	Trclog.Trclog( P_HFILE, L_STATEMENT );


   UPDATE RJH_IAS
   SET consojh = (SELECT NVL(SUM(r.consojh),0)
					              FROM RJH_CONSOMME r
					              WHERE  r.pid = RJH_IAS.pid
					             AND r.ident = RJH_IAS.ident
					            AND r.cdeb = RJH_IAS.cdeb
	 );
	COMMIT;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table RJH_IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );


	--	Calcul du conso en euros de la force de travail : consoft = consojh*coutft
	--  et des frais d'environnement : consoenv = consojh*coutenv
	L_STATEMENT := '* Calcul des consos FT et ENV';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	UPDATE RJH_IAS
	SET (consoft, consoenv) = (SELECT NVL(i.consojh,0)*NVL(i.coutft,0),
				  		                                                    NVL(i.consojh,0)*NVL(i.coutenv,0)
														  FROM RJH_IAS i
	                                                      WHERE i.pid=RJH_IAS.pid
	                                                      AND i.ident=RJH_IAS.ident
	                                                      AND i.cdeb=RJH_IAS.cdeb
	);
	COMMIT;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table RJH_IAS';
	Trclog.Trclog( P_HFILE, L_STATEMENT );


	END MAJ_RJH_IAS_CONS;


-- Utilitaire : Alimentation de stock_fi
-- -----------------------------------------------------------------------------------------------------------------
PROCEDURE ALIM_STOCK_FI_RJH( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

L_STATEMENT VARCHAR2(128);

BEGIN

	--Prendre les lignes de la table RJH_IAS
	L_STATEMENT := '* Insertion des lignes de la table STOCK_FI';
    Trclog.Trclog( P_HFILE, L_STATEMENT );
	INSERT INTO STOCK_FI (
						  				   	  	 	   cdeb	,
													   pid,
													   ident,
													   typproj,
													   METIER,
													   pnom,
													   codsg,
													   dpcode,
													   icpi,
													   codcamo,
													   clibrca,
													   CAFI	,
													   codsgress,
													   libdsg,
													   rnom	,
													   rtype,
													   PRESTATION,
													   NIVEAU,
													   soccode	,
													   cada	,
													   coutftht	,
													   coutft,
													   coutenv,
													   nconsojhimmo 	,
													   consoft ,
													   nconsoenvimmo,
													   consojhimmo ,
													   consoenvimmo
													   )
	(SELECT
						cdeb,
						pid	,
						ident,
						MAX(typproj) 		typproj,
						MAX(METIER) 		METIER,
						MAX(pnom) 		pnom,
						MAX(codsg) 		codsg,
						MAX(dpcode) 		dpcode,
						MAX(icpi),
						MAX(codcamo),
						MAX(clibrca),
						MAX(CAFI),
						MAX(codsgress),
						MAX(libdsg),
						MAX(rnom),
						MAX(rtype),
						MAX(PRESTATION)	,
						MAX(NIVEAU),
						MAX(soccode),
						MAX(cada),
						MAX(NVL(coutftht,0)) ,
						MAX(NVL(coutft,0)) ,
						MAX(NVL(coutenv,0)) ,
						SUM(NVL(consojh,0)),
						SUM(NVL(consoft,0)),
						SUM(NVL(consoenv,0)),
						0,
						0
						FROM RJH_IAS
						GROUP BY cdeb,pid,ident
	);
	COMMIT;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_FI';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

END ALIM_STOCK_FI_RJH;





END Packbatch_Ias_Rjh;
/
CREATE OR REPLACE PACKAGE PACKBATCH_RA AS
--****************************************************
-- Procédure globale d'alimentation des tables de stock
--****************************************************
PROCEDURE ra (P_LOGDIR          IN VARCHAR2)  ;

--********************************************************
-- Procédure globale d'alimentation des tables de synthese
--********************************************************
PROCEDURE synthese (P_LOGDIR          IN VARCHAR2)  ;
--********************************************************
-- Procédure globale d'alimentation des tables de synthese lancée lors de la prémensuelle
--********************************************************
PROCEDURE synthese_premensuelle (P_LOGDIR          IN VARCHAR2)  ;

--****************************************************
-- Procédure d'alimentation de la table stock_ra
--****************************************************
PROCEDURE alim_stock_ra(P_HFILE           IN utl_file.file_type)   ;
--*************************************************************
-- Procédure de calcul des retours arrieres
--************************************************************
PROCEDURE calcul_ra(P_HFILE           IN utl_file.file_type) ;
--*******************************************************
-- Procédure d'alimentation de la table SYNTHESE_ACTIVITE_MOIS
--*******************************************************
PROCEDURE alim_synth_act_mois(P_HFILE           IN utl_file.file_type)   ;
--*************************************************************
-- Procédure d'alimentation de la table SYNTHESE_ACTIVITE
--************************************************************
PROCEDURE alim_synth_act(P_HFILE           IN utl_file.file_type) ;
--*******************************************************
-- Procédure d'alimentation de la table SYNTHESE_ACTIVITE_MOIS lors de la prémensuelle
--*******************************************************
PROCEDURE alim_synth_act_mois_pre(P_HFILE           IN utl_file.file_type)   ;
--*************************************************************


END PACKBATCH_RA;
/

CREATE OR REPLACE PACKAGE  BODY  PACKBATCH_RA AS

-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
pragma EXCEPTION_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère



--****************************************************
-- Procédure d'alimentation des differentes tables
--****************************************************
PROCEDURE ra (P_LOGDIR          IN VARCHAR2)  IS

L_HFILE     utl_file.file_type;
L_RETCOD    number;
L_PROCNAME  varchar2(16) := 'RA';

	BEGIN

		-----------------------------------------------------
		-- Init de la trace
		-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-----------------------------------------------------
		-- Trace Start
		-----------------------------------------------------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

		-----------------------------------------------------
		-- Lancement ...
		-----------------------------------------------------
		--Alimentation de la table STOCK_RA
	 	alim_stock_ra( L_HFILE );

	 	--Alimentation de la table STOCK_RA : calcul des retours arrières
	 	calcul_ra( L_HFILE );

	 	-----------------------------------------------------
		-- Trace Stop
		-----------------------------------------------------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	EXCEPTION
		when others then
			if sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;


END ra;

--************************************************************
-- Procédure d'alimentation des differentes tables de synthese
--************************************************************
PROCEDURE synthese (P_LOGDIR          IN VARCHAR2)  IS

L_HFILE     utl_file.file_type;
L_RETCOD    number;
L_PROCNAME  varchar2(16) := 'SYNTHESE';

	BEGIN

		-----------------------------------------------------
		-- Init de la trace
		-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-----------------------------------------------------
		-- Trace Start
		-----------------------------------------------------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

		-----------------------------------------------------
		-- Lancement ...
		-----------------------------------------------------
		--Alimentation des tables de synthese
	 	alim_synth_act_mois( L_HFILE );
	 	alim_synth_act( L_HFILE );

		-----------------------------------------------------
		-- Trace Stop
		-----------------------------------------------------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	EXCEPTION
		when others then
			if sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;


END synthese;

--************************************************************
-- Procédure d'alimentation des differentes tables de synthese
-- lancée lors de la prémensuelle
--************************************************************
PROCEDURE synthese_premensuelle (P_LOGDIR          IN VARCHAR2)  IS

L_HFILE     utl_file.file_type;
L_RETCOD    number;
L_PROCNAME  varchar2(30) := 'SYNTHESE_PREMENSUELLE';

	BEGIN

		-----------------------------------------------------
		-- Init de la trace
		-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-----------------------------------------------------
		-- Trace Start
		-----------------------------------------------------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

		-----------------------------------------------------
		-- Lancement ...
		-----------------------------------------------------
		--Alimentation des tables de synthese
	 	alim_synth_act_mois_pre( L_HFILE );

		-----------------------------------------------------
		-- Trace Stop
		-----------------------------------------------------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	EXCEPTION
		when others then
			if sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;


END synthese_premensuelle;


--*************************************************************
-- Sélection des lignes pour STOCK_RA
--************************************************************
PROCEDURE alim_stock_ra(P_HFILE IN utl_file.file_type)  IS

L_PROCNAME  varchar2(16) := 'ALIM_STOCK_RA';
L_STATEMENT varchar2(128);
l_exist NUMBER(1);


BEGIN
	TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );
	-- --------------------------------------------------------------------------------------
	-- Etape 1 : vider STOCK_RA_1, copier STOCK_RA dans STOCK_RA_1, vider STOCK_RA
	-- --------------------------------------------------------------------------------------
	L_STATEMENT := '* Copier STOCK_RA dans STOCK_RA_1';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	-- vide STOCK_RA_1
	PACKBATCH.DYNA_TRUNCATE('STOCK_RA_1');
	-- données de STOCK_RA dans STOCK_RA_1
	INSERT INTO stock_ra_1
	select * from stock_ra
	where flag_ra!='O' or flag_ra is null; --Ne pas copier les lignes qui existaient dans stock_ra_1 et pas dans stock_ra
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_RA_1';
	commit;
	-- vider STOCK_RA
	PACKBATCH.DYNA_TRUNCATE('STOCK_RA');

	-- --------------------------------------------------------------------------------------
	-- Etape 2 : On prend les consommés des lignes BIP en imputation directe
	-- --------------------------------------------------------------------------------------
	L_STATEMENT := '* Insertion des consommés des lignes Bip dans STOCK_RA';
    	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	INSERT into stock_ra (  FACTPID,
				PID 		,
				CDEB 		,
				TYPPROJ         ,
  				METIER          ,
  				PNOM            ,
  				CODSG           ,
  				DPCODE          ,
  				ICPI            ,
  				CADA            ,
  				CODCAMO         ,
  				ECET		,
  				TYPETAP	        ,
  				ACTA		,
  				ACST		,
  				AIST		,
  				ASNOM		,
  				CAFI            ,
  				CODSGRESS       ,
  				IDENT           ,
  				RTYPE           ,
  				NIVEAU          ,
  				PRESTATION      ,
  				SOCCODE         ,
  				--COUTFTHT        ,
  				--COUTFTHTR       ,
  				--COUTENV         ,
  				CONSOJH         ,
  				--CONSOFT         ,
  				--CONSOENV        ,
  				--A_CONSOJH       ,
  				--A_CONSOFT       ,
  				--A_CONSOENV      ,
  				FLAG_RA 	)
	(SELECT /*+ CONS_SSTACHE_RES_MOIS CONS_SSTACHE_RES_MOIS_PK */
			decode(t.aistty,'FF',t.aistpid,t.pid) factpid,
			t.pid pid,
			 c.cdeb ,
      			 l.typproj ,
			 rtrim(l.metier) ,
			 l.pnom ,
			 l.codsg ,
			 l.dpcode ,
			 l.icpi ,
			 p.cada,
			 l.codcamo ,
			 e.ecet,
			 DECODE(e.typetap,NULL,'NO',e.typetap) typetap,
			 t.acta,
			 t.acst,
			 t.aist,
			 t.asnom,
			 si.cafi ,
			 sr.codsg  codsgress,
			 c.ident,
			 r.rtype,
			 sr.niveau,
			 sr.prestation,
			 sr.soccode,
			 NVL(c.cusag,0),
			 'N'
	FROM cons_sstache_res_mois c,tache t,
		etape e,
		ressource r,
		proj_info p,
		struct_info si,
		datdebex d ,
		situ_ress_full sr ,
		ligne_bip l
	WHERE
	-- jointure ligne_bip et tache
		l.pid= decode(t.aistty,'FF',t.aistpid,t.pid)
	-- jointure ligne_bip et projet_info
		and l.icpi = p.icpi
	-- données concernant les ressources
	       	and r.ident =sr.ident
		and c.ident = sr.ident
		and (c.cdeb >=sr.datsitu or sr.datsitu is null)
		and (c.cdeb <=sr.datdep or sr.datdep is null )
	-- ressource dont la prestation n est pas gratuite
		and sr.prestation not in ('IFO','MO ','GRA','INT','STA')
	-- cafi de la ressource
		and si.codsg=sr.codsg
	-- consommés sur l'année en cours
 		and to_char(d.moismens,'YYYY')=to_char(c.cdeb,'YYYY')
		and to_char(c.cdeb,'MM')<= to_char(d.moismens,'MM')
		-- On prend la ligne Bip d'imputation si elle existe
		and c.pid = t.pid
            	and c.acta=t.acta
            	and c.acst=t.acst
            	and c.ecet=t.ecet
            	and t.pid = e.pid
            	and t.ecet = e.ecet
            );

	commit;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table stock_ra';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	--------------------------------------------------------------------------------
	-- ETAPE 3 : insertion des couts
	--------------------------------------------------------------------------------
	-- COUT FORCE DE TRAVAIL
	-- * SG : on prend le coût déjà HTR à partir de la table des coûts standards SG COUT_STD_SG des lignes dont le code société ='SG..',le type='P' par année,niveau,métier,dpg
	L_STATEMENT := '* Ajout cout force de travail SG';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	UPDATE stock_ra
	SET COUTFTHTR = (SELECT distinct NVL(c.cout_sg,0)
			FROM cout_std_sg c, datdebex d
			WHERE
			--Sur l'année courante :
			 to_char(c.annee )=to_char(d.datdebex,'YYYY')
			--sur le dpg de la ressource :
			and stock_ra.codsgress between c.dpg_bas and c.dpg_haut
			--Sur le métier de la ressource :
			and stock_ra.metier = c.metier
			--Sur le niveau de la ressource : les niveaux L,M,N correspondent au niveau HC dans la table COUT_STD_SG
			and decode(stock_ra.niveau,'L','HC','M','HC','N','HC',stock_ra.niveau) = c.niveau)
	WHERE  stock_ra.soccode='SG..'
	AND stock_ra.rtype='P';
	commit;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table stock_ra';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	-- * SSII : cout HT et HTR des ressources dont le code société est <>'SG..' , le type='P' avec une situation en cours pour l'année courante
	-- Forfaits Hors site et sur site : cout HT et HTR type='E' ou 'F' avec une situation en cours pour l'année courante
	L_STATEMENT := '* Ajout cout force de travail SSII';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE stock_ra
	SET (COUTFTHT,COUTFTHTR) = (SELECT DISTINCT NVL(s.cout,0),pack_utile_cout.getCoutHTR(stock_ra.soccode,stock_ra.rtype,to_number(TO_CHAR(stock_ra.cdeb,'YYYY')),stock_ra.metier,stock_ra.niveau,stock_ra.codsg,s.cout,TO_CHAR(stock_ra.cdeb,'DD/MM/YYYY'),si.filcode)
				FROM situ_ress_full s,datdebex d, ressource r,struct_info si
				WHERE
					 s.ident = stock_ra.ident
					 AND (stock_ra.cdeb>=s.datsitu or s.datsitu is null)
					 AND (stock_ra.cdeb<=s.datdep or s.datdep is null)
					 AND to_char(stock_ra.cdeb,'YYYY') = to_char(d.datdebex,'YYYY')
					 AND r.ident=s.ident
					 AND s.codsg = si.codsg)
	WHERE
	 	stock_ra.soccode!='SG..'
	 	AND
	 	-- Type='P' pour personne, Type='F' pour forfait sur site, Type='E' pour forfait hors site
		 (stock_ra.rtype='P' or stock_ra.rtype ='F' or stock_ra.rtype ='E')
	 	;
	commit;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table stock_ra';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	-- * Logiciel : cout logiciel HTR de la table COUT_STD2 en fonction du DPG de la ressource
	L_STATEMENT := '* Ajout cout force de travail logiciel';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	UPDATE stock_ra
	SET COUTFTHTR = (SELECT distinct	NVL(c.cout_log,0)
			FROM cout_std2 c, datdebex d
			WHERE
			--Sur l'année courante :
			to_char(c.annee )=to_char(d.datdebex,'YYYY')
			--sur le dpg de la ressource :
			and stock_ra.codsgress between c.dpg_bas and c.dpg_haut
			)
	WHERE  stock_ra.rtype='L';
	commit;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table stock_ra';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	-- COUT D'ENVIRONNEMENT
	-- *SG,SSII,Forfait sur Site : cout d'environnement en HTR de la table COUT_STD2 en fonction du DPG de la ressource
	L_STATEMENT := '* Ajout cout d''environnement SG,SSII,Forfait sur Site';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	UPDATE stock_ra
	SET COUTENV= (SELECT distinct NVL(decode(stock_ra.soccode,'SG..',c.coutenv_sg,c.coutenv_ssii),0)
			FROM cout_std2 c, datdebex d
			WHERE
			--Sur l'année courante :
			to_char(c.annee )=to_char(d.datdebex,'YYYY')
			--sur le dpg de la ressource :
			and stock_ra.codsgress between c.dpg_bas and c.dpg_haut
			)
	WHERE  stock_ra.rtype != 'L'
	AND stock_ra.rtype!='E' ;
    	commit;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table stock_ra';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );


	--------------------------------------------------------------------------------
	-- ETAPE 4 : insertion des montants
	-- consoft = consojh*coutft et consoenv = consojh*coutenv
	--------------------------------------------------------------------------------
	L_STATEMENT := '* Calcul des montants';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	UPDATE stock_ra
	SET (CONSOFT, CONSOENV) = (select NVL(consojh,0)*NVL(coutfthtr,0),NVL(consojh,0)*NVL(coutenv,0)
				from stock_ra s
	WHERE
	s.typetap=stock_ra.typetap
	and s.ident=stock_ra.ident
	and s.factpid=stock_ra.factpid
	and s.pid=stock_ra.pid
	and s.cdeb=stock_ra.cdeb
	AND s.cafi=stock_ra.cafi
	AND s.ecet=stock_ra.ecet
	AND s.acta=stock_ra.acta
	AND s.acst=stock_ra.acst
	);
	commit;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes modifiées dans la table stock_ra';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

------------------------------------------------------------------------
-- GESTION DES EXCEPTIONS
------------------------------------------------------------------------
EXCEPTION
	when others then
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;



	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

end alim_stock_ra;


-------------------------------------------------------------------------------------
-- CALCUL DES RETOURS ARRIERES
-------------------------------------------------------------------------------------
PROCEDURE calcul_ra(P_HFILE IN utl_file.file_type)   IS

CURSOR cur_stock_ra IS
SELECT * FROM stock_ra ;

L_PROCNAME  varchar2(16) := 'ALIM_RA';
L_STATEMENT varchar2(128);

l_consojh NUMBER(10,2);
l_consoft NUMBER(10,2);
l_consoenv NUMBER(10,2);

l_a_consojh NUMBER(10,2);
l_a_consoft NUMBER(10,2);
l_a_consoenv NUMBER(10,2);

l_moismens NUMBER(2);

BEGIN

TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

-- On compare chaque ligne de STOCK_RA avec les lignes de STOCK_RA_1
L_STATEMENT := '* Calcul des retours arrière';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	 FOR curseur IN cur_stock_ra LOOP
	 	BEGIN
	 	  SELECT CONSOJH,CONSOFT,CONSOENV
			 into l_consojh,l_consoft,l_consoenv
		  FROM stock_ra_1 s
		  WHERE s.ident = curseur.ident
		  AND s.pid = curseur.pid
		  AND s.factpid = curseur.factpid
		  AND s.cdeb = curseur.cdeb
		  AND s.codcamo=curseur.codcamo
		  AND s.cafi=curseur.cafi
		  AND s.ecet=curseur.ecet
		  AND s.acta=curseur.acta
		  AND s.acst=curseur.acst
		  ;

		  -- Calcul des retours arrières
			  l_a_consojh := NVL(curseur.consojh,0) - NVL(l_consojh,0);
			  l_a_consoft := NVL(curseur.consoft,0) - NVL(l_consoft,0);
			  l_a_consoenv := NVL(curseur.consoenv,0) - NVL(l_consoenv,0);

			  UPDATE stock_ra
			  SET 	A_CONSOJH = l_a_consojh,
			  	A_CONSOFT = l_a_consoft,
				A_CONSOENV = l_a_consoenv
			  WHERE ident = curseur.ident
			  AND pid = curseur.pid
			  AND factpid = curseur.factpid
			  AND cdeb = curseur.cdeb
			  AND codcamo = curseur.codcamo
			  AND cafi = curseur.cafi
			  AND ecet = curseur.ecet
		  	  AND acta = curseur.acta
		  	  AND acst = curseur.acst;

		EXCEPTION
			 WHEN No_Data_Found THEN
				 	  UPDATE stock_ra
					  SET   A_CONSOJH = NVL(curseur.consojh,0),
					  	A_CONSOFT =NVL(curseur.consoft,0),
					  	A_CONSOENV = NVL(curseur.consoenv,0)
					  WHERE ident = curseur.ident
			  		  AND pid = curseur.pid
			  		  AND factpid = curseur.factpid
			  		  AND cdeb = curseur.cdeb
			  		  AND codcamo=curseur.codcamo
			  		  AND cafi=curseur.cafi
			  		  AND ecet = curseur.ecet
		  	  		  AND acta = curseur.acta
		  	  		  AND acst = curseur.acst;

		END;


	 END LOOP;
	commit;


	-----------------------------------------------------------------------------
	-- CAS PARTICULIER
	-----------------------------------------------------------------------------
	-- Cas où il existe des lignes dans STOCK_RA_1 et pas dans STOCK_RA
	L_STATEMENT := '* Insertion des lignes dans STOCK_RA existant dans STOCK_RA_1 et pas dans STOCK_RA';
     	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	INSERT INTO stock_ra (  FACTPID		,
				PID 		,
				CDEB 		,
				TYPPROJ         ,
  				METIER          ,
  				PNOM            ,
  				CODSG           ,
  				DPCODE          ,
  				ICPI            ,
  				CADA            ,
  				CODCAMO         ,
  				ECET		,
  				TYPETAP	        ,
  				ACTA		,
  				ACST		,
  				AIST		,
  				ASNOM		,
  				CAFI            ,
  				CODSGRESS       ,
  				IDENT           ,
  				RTYPE           ,
  				NIVEAU          ,
  				PRESTATION      ,
  				SOCCODE         ,
  				COUTFTHT        ,
  				COUTFTHTR       ,
  				COUTENV         ,
  				CONSOJH         ,
  				CONSOFT         ,
  				CONSOENV        ,
  				A_CONSOJH       ,
  				A_CONSOFT       ,
  				A_CONSOENV      ,
  				FLAG_RA 	)
	 SELECT 	s.factpid	,
	 		s.pid 		,
	 		s.cdeb 		,
			s.typproj 	,
			s.metier 		,
			s.pnom 		,
			s.codsg 		,
			s.dpcode 		,
			s.icpi 		,
			s.cada		,
			s.codcamo 	,
			s.ecet		,
			s.typetap	,
			s.acta	,
			s.acst	,
			s.aist	,
			s.asnom	,
			s.cafi 		,
			s.codsgress 	,
			s.ident 		,
			s.rtype		,
			s.niveau 		,
			s.prestation	,
			s.soccode 	,
			NVL(s.coutftht,0)	,
			NVL(s.coutfthtr,0) 	,
			NVL(s.coutenv,0)	,
			0	,
			0 	,
			0	,
			decode(s.consojh,0, s.a_consojh,- s.consojh),
			decode(s.consojh,0,s.a_consoft,- s.consoft),
			decode(s.consojh,0,s.a_consoenv,- s.consoenv),
			'O'
		FROM
		(select cdeb,factpid,pid,ident,cafi,codcamo,ecet,acta,acst from stock_ra_1
		 minus
		 select cdeb,factpid,pid,ident,cafi,codcamo,ecet,acta,acst from stock_ra) n,
		stock_ra_1 s, datdebex d
		where n.ident=s.ident
		and n.pid=s.pid
		and n.factpid=s.factpid
		and n.cdeb=s.cdeb
		AND n.codcamo=s.codcamo
		AND n.cafi=s.cafi
		AND n.ecet = s.ecet
		AND n.acta = s.acta
		AND n.acst = s.acst
		;
		commit;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table STOCK_RA';
		TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

		TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

END calcul_ra ;

--***********************************************************
-- Procédure d'alimentation de la table synthese_activite_mois
--***********************************************************
PROCEDURE alim_synth_act_mois(P_HFILE IN utl_file.file_type)   IS

CURSOR cur_ra IS
select DISTINCT FACTPID,PID,CDEB,TYPPROJ,METIER,PNOM,CODSG,DPCODE,ICPI,CODCAMO,SOCCODE,CONSOJH,CONSOFT,CONSOENV from stock_ra ;

L_PROCNAME  varchar2(16) := 'SYNTH_ACT_MOIS';
L_STATEMENT varchar2(128);

l_exist NUMBER(1);

BEGIN

TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

-- on vide la table
L_STATEMENT := '* vide synthese_activite_mois de l annee courante';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	DELETE SYNTHESE_ACTIVITE_MOIS
	WHERE to_number(to_char(cdeb,'YYYY')) in (select to_number(to_char(datdebex,'YYYY')) from datdebex);
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table SYNTHESE_ACTIVITE_MOIS';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
COMMIT;


-- on alimente la table de synthese avec les données contenues dans le stock ra

L_STATEMENT := '* alimentation de synthese_activite_mois';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	INSERT INTO SYNTHESE_ACTIVITE_MOIS (PID,CDEB,TYPPROJ,METIER,PNOM,CODSG,DPCODE,ICPI,CODCAMO)
  	(select DISTINCT FACTPID,CDEB,TYPPROJ,METIER,PNOM,CODSG,DPCODE,ICPI,CODCAMO
  	 from stock_ra s
  	 where flag_ra <> 'O'
  	 );
  	commit;

-- mise à jour des conso en fonction du code societe
L_STATEMENT := '* consommés des SG';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

		UPDATE SYNTHESE_ACTIVITE_MOIS
  		SET (CONSOJH_SG,CONSOFT_SG,CONSOENV_SG)=
  			(select distinct NVL(SUM(s.consojh),0),NVL(SUM(s.consoft),0),NVL(SUM(s.consoenv),0)
			from stock_ra s
			where
			s.factpid=SYNTHESE_ACTIVITE_MOIS.pid
			and s.cdeb=SYNTHESE_ACTIVITE_MOIS.cdeb
			and s.soccode='SG..')
		;
		commit;

L_STATEMENT := '* consommés des SSII';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

		UPDATE SYNTHESE_ACTIVITE_MOIS
  		SET (CONSOJH_SSII,CONSOFT_SSII,CONSOENV_SSII)=
  			(select distinct NVL(SUM(s.consojh),0),NVL(SUM(s.consoft),0),NVL(SUM(s.consoenv),0)
			from stock_ra s
			where
			s.factpid=SYNTHESE_ACTIVITE_MOIS.pid
			and s.cdeb=SYNTHESE_ACTIVITE_MOIS.cdeb
			and s.soccode<>'SG..')
		;
		commit;

	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;


END alim_synth_act_mois;

--***************************************************************************
-- Procédure d'alimentation de la table synthese_activite : stock sur l'annee
--***************************************************************************
PROCEDURE alim_synth_act(P_HFILE IN utl_file.file_type)   IS

L_PROCNAME  varchar2(16) := 'SYNTH_ACT';
L_STATEMENT varchar2(128);


BEGIN

TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

-- on vide la table
L_STATEMENT := '* vide synthese_activite de l annee courante';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	DELETE SYNTHESE_ACTIVITE
	WHERE annee in (select to_number(to_char(datdebex,'YYYY')) from datdebex);
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table SYNTHESE_ACTIVITE';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
COMMIT;

-- on alimente la table de synthese avec les données contenues dans synthese_activite_mois

L_STATEMENT := '* alimentation de synthese_activite';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	INSERT INTO SYNTHESE_ACTIVITE (PID,ANNEE,TYPPROJ,METIER,PNOM,CODSG,DPCODE,ICPI,CODCAMO)
  	(select DISTINCT PID,to_number(to_char(cdeb,'yyyy')),TYPPROJ,METIER,PNOM,CODSG,DPCODE,ICPI,CODCAMO
  	 from SYNTHESE_ACTIVITE_MOIS s, datdebex d
  	 where s.cdeb >= d.datdebex
  	 );
  	commit;

-- mise à jour des conso
L_STATEMENT := '* consommés';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

		UPDATE SYNTHESE_ACTIVITE
  		SET (CONSOJH_SG,CONSOFT_SG,CONSOENV_SG,CONSOJH_SSII,CONSOFT_SSII,CONSOENV_SSII)=
  			(select distinct NVL(SUM(CONSOJH_SG),0),NVL(SUM(CONSOFT_SG),0),NVL(SUM(CONSOENV_SG),0) ,
  	 				 NVL(SUM(CONSOJH_SSII),0),NVL(SUM(CONSOFT_SSII),0),NVL(SUM(CONSOENV_SSII),0)
			from SYNTHESE_ACTIVITE_MOIS s , datdebex d
			where
			s.pid=SYNTHESE_ACTIVITE.pid
			and s.cdeb >= d.datdebex
			)
		WHERE annee in (select to_number(to_char(datdebex,'YYYY')) from datdebex);

		commit;

	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;


END alim_synth_act;

--***********************************************************
-- Procédure d'alimentation de la table synthese_activite_mois lancée
-- en fin de prémensuelle pour alimenter les données nombre de jours
-- afin d'être utilisées par l'état d'extraction des lignes BIP
-- Les bonnes valeurs sont ensuite mises à jour lors de la mensuelle
--***********************************************************
PROCEDURE alim_synth_act_mois_pre(P_HFILE IN utl_file.file_type)   IS

CURSOR cur_ra IS
select DISTINCT FACTPID,PID,CDEB,TYPPROJ,METIER,PNOM,CODSG,DPCODE,ICPI,CODCAMO,SOCCODE,CONSOJH,CONSOFT,CONSOENV from stock_ra ;

L_PROCNAME  varchar2(30) := 'SYNTH_ACT_MOIS_PRE';
L_STATEMENT varchar2(128);

l_exist NUMBER(1);

BEGIN

TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

-- on vide la table
L_STATEMENT := '* vide synthese_activite_mois du mois courant';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	DELETE SYNTHESE_ACTIVITE_MOIS
	WHERE cdeb in (select moismens from datdebex);
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table SYNTHESE_ACTIVITE_MOIS';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
COMMIT;


-- on alimente la table de synthese avec les données contenues dans le stock ra

L_STATEMENT := '* alimentation de synthese_activite_mois';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	INSERT INTO SYNTHESE_ACTIVITE_MOIS (PID,CDEB,TYPPROJ,METIER,PNOM,CODSG,DPCODE,ICPI,CODCAMO,CONSOJH_SG,CONSOJH_SSII,CONSOFT_SG,CONSOFT_SSII,CONSOENV_SG,CONSOENV_SSII)
	(SELECT p.factpid ,p.cdeb, lb.typproj , lb.metier, lb.pnom, lb.codsg, lb.dpcode, lb.icpi, lb.codcamo, SUM(cusag) , 0 , 0 , 0 , 0 , 0
	 FROM proplus p,  ligne_bip LB, datdebex
	 WHERE p.factpid=LB.pid
	 AND (p.qualif not in ('MO','GRA','IFO','STA','INT') OR P.qualif is null)
	 AND p.cdeb=datdebex.moismens
	 AND LB.codsg > 1
	 GROUP BY p.factpid ,p.cdeb, lb.typproj , lb.metier, lb.pnom, lb.codsg, lb.dpcode, lb.icpi, lb.codcamo);

  	commit;

	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

END alim_synth_act_mois_pre;


END PACKBATCH_RA;
/
CREATE OR REPLACE PACKAGE Packbatch_Repartition AS


    -- Utilitaire : Traitement de répartition
	-- -----------------------------------------------------------------------------------------------------------------
   PROCEDURE ALIM_RJH( P_LOGDIR IN VARCHAR2 );


   -- Utilitaire : Initialisations pour le traitement de répartition
   -- -----------------------------------------------------------------------------------------------------------
   PROCEDURE INIT_RJH_CONSO( P_HFILE IN UTL_FILE.FILE_TYPE );


   -- Utilitaire : Alimentation de la table RJH_CONSOMME
   -- -------------------------------------------------------------------------------------------------------------
   PROCEDURE ALIM_RJH_CONSO( P_HFILE IN UTL_FILE.FILE_TYPE );


	-- Utilitaire : Alimentation de la table consomme à partir de RJH_CONSOMME
	-- -----------------------------------------------------------------------------------------------------------------
	   PROCEDURE ALIM_CONSO( P_HFILE IN UTL_FILE.FILE_TYPE );





END Packbatch_Repartition;
/

CREATE OR REPLACE PACKAGE BODY Packbatch_Repartition  AS


-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
PRAGMA EXCEPTION_INIT( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     NUMBER := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     NUMBER := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID NUMBER := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
VIOLATION_CONSTRAINT_UNIQUE EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
PRAGMA EXCEPTION_INIT( VIOLATION_CONSTRAINT_UNIQUE, -00001 );



-- Utilitaire : Traitement de répartition
-- -----------------------------------------------------------------------------------------------------------------

PROCEDURE ALIM_RJH( P_LOGDIR IN VARCHAR2 ) IS

   L_PROCNAME  VARCHAR2(16) := 'ALIM_RJH_CONSO';
   L_STATEMENT VARCHAR2(128);
   L_HFILE     UTL_FILE.FILE_TYPE;
   L_RETCOD    NUMBER;


BEGIN

    -----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
		L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		IF ( L_RETCOD <> 0 ) THEN
		RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
		END IF;

    -----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------


    Trclog.Trclog( L_HFILE, 'Debut de ' || L_PROCNAME );


    -- ------------------------------------------------------------------------------------------------------
	-- Etape 1 : Initialisations
	-- ------------------------------------------------------------------------------------------------------

	  Packbatch_Repartition.INIT_RJH_CONSO( L_HFILE );

	-- ------------------------------------------------------------------------------------------------------
	-- Etape 2 : Alimentation de la table RJH_CONSOMME
	-- ------------------------------------------------------------------------------------------------------

      Packbatch_Repartition.ALIM_RJH_CONSO( L_HFILE);

   	-- ------------------------------------------------------------------------------------------------------
	-- Etape 3 : Alimentation de la table CONSOMME
	-- ------------------------------------------------------------------------------------------------------

     Packbatch_Repartition.ALIM_CONSO( L_HFILE);


    Trclog.Trclog( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

EXCEPTION
	WHEN OTHERS THEN
	    ROLLBACK;
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;


  END ALIM_RJH;








-- Utilitaire : Alimentations de la table RJH_CONSOMME
-- -------------------------------------------------------------------------------------------------------------

PROCEDURE INIT_RJH_CONSO( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

 L_STATEMENT VARCHAR2(128);
 L_MOISMENS DATE;

BEGIN

    SELECT moismens INTO L_MOISMENS FROM DATDEBEX;

    L_STATEMENT := '* Troncature de la table RJH_CONSOMME';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	  -- Troncature RJH_CONSOMME
	  Packbatch.DYNA_TRUNCATE('RJH_CONSOMME');

	  L_STATEMENT:='* Inexistantes MOIMENS N-1';

	   INSERT INTO RJH_TABREPART_DETAIL (CODREP,MOISREP,PID,TAUXREP,LIBLIGNEREP,TYPTAB)
	  (SELECT
	  		   r1.CODREP,
	                   L_MOISMENS,
	                   r1.PID,
	                   r1.TAUXREP,
	                   r1.LIBLIGNEREP,
	                   r1.TYPTAB
	   FROM RJH_TABREPART_DETAIL r1, RJH_TABREPART rt
                     WHERE r1.MOISREP=ADD_MONTHS(L_MOISMENS,-1)
                     AND rt.CODREP=r1.CODREP
                     AND rt.FLAGACTIF='O'
                     AND r1.TYPTAB='P'
                     AND NOT EXISTS(SELECT r2.CODREP, r2.MOISREP, r2.PID
				                                           FROM  RJH_TABREPART_DETAIL  r2
	  	  						   			               WHERE r2.CODREP=r1.CODREP
														  AND  r2.MOISREP=L_MOISMENS
														  AND r2.PID=r1.PID
														  AND r2.TYPTAB='P')
		);

		COMMIT;

	  	Trclog.Trclog( P_HFILE, L_STATEMENT ||':-'||SQL%rowcount);



 END INIT_RJH_CONSO;




   -- Utilitaire : Alimentation de la table RJH_CONSOMME
   -- -------------------------------------------------------------------------------------------------------------
PROCEDURE ALIM_RJH_CONSO( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

 L_STATEMENT 			VARCHAR2(128);
 msg 					  				VARCHAR(1024);
 v_TAUXREP 					RJH_TABREPART_DETAIL.TAUXREP%TYPE;

 cons_repart       				 NUMBER(12,7);
 nbr 									  NUMBER;
 COMPTER									  NUMBER;


 CURSOR cur_cons_old IS
                     SELECT
				 	 		DISTINCT DECODE(t.aistpid,NULL,t.pid,'    ',t.pid,'   ',t.pid,t.aistpid) factpid,
							 t.pid pid,
			 				c.cdeb ,
      						e.ecet,
							t.acta,
			 				t.acst,
			 				l.codrep,
							c.ident,
							NVL(c.cusag,0) cusag
					 FROM CONS_SSTACHE_RES_MOIS c,TACHE t,
					 	   ETAPE e,
					 	   DATDEBEX d ,
					 	   SITU_RESS_FULL sr ,
						   LIGNE_BIP l
					WHERE
	  					  l.codcamo=66666
						  -- jointure ligne_bip et tache
						  AND l.pid=DECODE(t.aistpid,NULL,t.pid,'    ',t.pid,'   ',t.pid,t.aistpid)
						  AND (t.aistpid IS NULL OR t.aistty='FF' OR t.aistpid='   ' OR t.aistpid='    ')
						  -- données concernant les ressources
		   				  AND c.ident = sr.ident
						  AND (c.cdeb >=sr.datsitu OR sr.datsitu IS NULL)
						  AND (c.cdeb <=sr.datdep OR sr.datdep IS NULL )
						  AND NVL(c.cusag,0) <>0
						  -- ressource dont la prestation n est pas gratuite
						  AND sr.PRESTATION NOT IN ('IFO','MO ','GRA','INT','STA')
						  -- consommés sur l'année en cours
 						  AND TO_CHAR(d.moismens,'YYYY')=TO_CHAR(c.cdeb,'YYYY')
						  AND TO_CHAR(c.cdeb,'MM')<= TO_CHAR(d.moismens,'MM')
						  -- On prend la ligne Bip d'imputation si elle existe
						  AND c.pid = t.pid
        				  AND c.acta=t.acta
        				  AND c.acst=t.acst
        				  AND c.ecet=t.ecet
        				  AND t.pid = e.pid
       	 				  AND t.ecet = e.ecet ;

CURSOR cur_cons IS
                     SELECT
				 	 		DISTINCT p.factpid,
							 p.pid,
			 				p.cdeb ,
      						0 ecet,
							0 acta,
			 				0 acst,
			 				l.codrep,
							p.tires ident,
							NVL(p.cusag,0) cusag
					 FROM PROPLUS p, 
					 	   DATDEBEX d ,
					 	   SITU_RESS_FULL sr ,
						   LIGNE_BIP l
					WHERE
	  					  l.codcamo=66666
						  -- jointure ligne_bip et tache
						  AND l.pid=p.factpid
						  -- données concernant les ressources
		   				  AND p.tires = sr.ident
						  AND (p.cdeb >=sr.datsitu OR sr.datsitu IS NULL)
						  AND (p.cdeb <=sr.datdep OR sr.datdep IS NULL )
						  AND NVL(p.cusag,0) <>0
						  -- ressource dont la prestation n est pas gratuite
						  AND sr.PRESTATION NOT IN ('IFO','MO ','GRA','INT','STA')
						  -- consommés sur l'année en cours
 						  AND TO_CHAR(d.moismens,'YYYY')=TO_CHAR(p.cdeb,'YYYY')
						  AND TO_CHAR(p.cdeb,'MM')<= TO_CHAR(d.moismens,'MM') ;

CURSOR cur_rep(c_codrep CHAR, c_cdeb DATE) IS
                     SELECT *
					 FROM  RJH_TABREPART_DETAIL
			         WHERE codrep=c_codrep
			         AND moisrep=c_cdeb
			         AND typtab='P';

BEGIN

    L_STATEMENT := '* Alimentations de la table RJH_CONSOMME';
	Trclog.Trclog( P_HFILE, L_STATEMENT );

	 COMPTER := 0;
	    FOR curseur IN cur_cons LOOP

		 COMPTER := COMPTER  + 1;

		      SELECT COUNT(*) INTO nbr FROM  RJH_TABREPART_DETAIL
			  WHERE codrep=curseur.codrep
			  AND moisrep=curseur.cdeb
			  AND typtab='P';



			  IF(nbr = 0)THEN

			          Pack_Global.recuperer_message(21033, '%s1',curseur.codrep ,'%s2',TO_CHAR(curseur.cdeb,'dd/mm/yyyy'),NULL, msg);
					 Trclog.Trclog( P_HFILE, msg );

			 ELSE

			     FOR curseur_rep IN cur_rep(curseur.codrep,curseur.cdeb) LOOP
				     BEGIN

				          cons_repart := curseur_rep.TAUXREP * curseur.cusag;

						 INSERT INTO RJH_CONSOMME(
					   					 				 				  	 				CDEB,
																							PID,
																							IDENT,
																							PID_ORIGINE,
																							CONSOJH
																							)
				                                                          VALUES(
																 				     		curseur.cdeb,
																							curseur_rep.pid,
																 							curseur.ident,
																 							curseur.factpid,
																 							cons_repart
																							 );


				       EXCEPTION

             			    WHEN VIOLATION_CONSTRAINT_UNIQUE THEN

	                                    UPDATE RJH_CONSOMME
				                        SET  consojh = consojh + cons_repart
			  	   	                               WHERE      cdeb = curseur.cdeb
							                       AND ident = curseur.ident
			                                       AND pid= curseur_rep.pid
										           AND pid_origine= curseur.factpid;
					 END;

					COMMIT;
			 END LOOP;






			  END IF;









        END LOOP;



Trclog.Trclog( P_HFILE, COMPTER );

 END ALIM_RJH_CONSO;




-- Utilitaire : Alimentation de la table consomme à partir de RJH_CONSOMME
-- -----------------------------------------------------------------------------------------------------------------

PROCEDURE ALIM_CONSO( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

 L_STATEMENT VARCHAR2(128);
l_annee INTEGER;

BEGIN

    SELECT TO_NUMBER(TO_CHAR(DATDEBEX,'YYYY')) INTO l_annee FROM DATDEBEX;


		L_STATEMENT:='Alimentation du consomme : cusag';

	-- alimentation de la table CONSOMME
			UPDATE CONSOMME
			SET cusag = (SELECT NVL(SUM(RJH_CONSOMME.consojh),0) FROM RJH_CONSOMME ,DATDEBEX
					  					WHERE RJH_CONSOMME.pid = CONSOMME.pid
					                     AND RJH_CONSOMME.cdeb >= DATDEBEX.DATDEBEX	)
			WHERE annee = l_annee
			AND CONSOMME.pid IN (SELECT DISTINCT pid FROM RJH_CONSOMME ,DATDEBEX
					  				                        	WHERE  RJH_CONSOMME.cdeb >= DATDEBEX.DATDEBEX )

			 ;


			COMMIT;


	 Trclog.Trclog( P_HFILE, L_STATEMENT ||':-'||SQL%rowcount);



	-- pour alimenter le cumul du consommé d'un pid toutes années confondues on doit faire l'update précédent avant
	-- celui-ci pour la prise en compte du nouveau cusag(cumul pour l'année courante) que l'on va ajouter à xcusag
	-- (cumul total)

	L_STATEMENT:='Alimentation du consomme total';

			UPDATE CONSOMME
			SET xcusag = NVL(xcusag,0) + NVL(cusag,0)
			WHERE annee = l_annee
			AND CONSOMME.pid IN (SELECT DISTINCT pid FROM RJH_CONSOMME ,DATDEBEX
					  				                        	WHERE  RJH_CONSOMME.cdeb >= DATDEBEX.DATDEBEX )

			;

	COMMIT;

	Trclog.Trclog( P_HFILE, L_STATEMENT ||':-'||SQL%rowcount);



 END ALIM_CONSO;






END Packbatch_Repartition;
/
CREATE OR REPLACE PACKAGE Packbatch_Repartition_Arb AS

    -- -----------------------------------------------------------------------------------------------------------------
    -- Utilitaire : Traitement de répartition
    -- -----------------------------------------------------------------------------------------------------------------
   PROCEDURE ALIM_RJH( P_LOGDIR IN VARCHAR2 );

    -- -----------------------------------------------------------------------------------------------------------------
    -- Utilitaire : Traitement de répartition des arbitrés
    -- -----------------------------------------------------------------------------------------------------------------
   PROCEDURE REPART_ARB( P_HFILE IN UTL_FILE.FILE_TYPE );


END Packbatch_Repartition_Arb;
/

CREATE OR REPLACE PACKAGE BODY Packbatch_Repartition_Arb  AS

-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
PRAGMA EXCEPTION_INIT( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     NUMBER := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     NUMBER := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID NUMBER := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
VIOLATION_CONSTRAINT_UNIQUE EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
PRAGMA EXCEPTION_INIT( VIOLATION_CONSTRAINT_UNIQUE, -00001 );


-- -----------------------------------------------------------------------------------------------------------------
-- Utilitaire : Traitement de répartition
-- -----------------------------------------------------------------------------------------------------------------

PROCEDURE ALIM_RJH( P_LOGDIR IN VARCHAR2 ) IS

   L_PROCNAME  VARCHAR2(16) := 'ALIM_RJH_ARB';
   L_STATEMENT VARCHAR2(128);
   L_HFILE     UTL_FILE.FILE_TYPE;
   L_RETCOD    NUMBER;


BEGIN

    -----------------------------------------------------
    -- Init de la trace
    -----------------------------------------------------
		L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		IF ( L_RETCOD <> 0 ) THEN
		RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
		END IF;
    -----------------------------------------------------
    -- Trace Start
    -----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Debut de ' || L_PROCNAME );
    -- ------------------------------------------------------------------------------------------------------
    -- Alimentation des arbitrés dans la table BUDGET
    -- ------------------------------------------------------------------------------------------------------
		Packbatch_Repartition_Arb.REPART_ARB( L_HFILE );
    -- ------------------------------------------------------------------------------------------------------

    Trclog.Trclog( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

EXCEPTION
	WHEN OTHERS THEN
	    ROLLBACK;
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;


END ALIM_RJH;

-- ----------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------

   -- -------------------------------------------------------------------------------------------------------------
   -- Alimentation des arbitrés dans la table BUDGET
   -- -------------------------------------------------------------------------------------------------------------
PROCEDURE REPART_ARB( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

 L_STATEMENT	VARCHAR2(128);

 l_annee	INTEGER;
 l_date		DATE;
 l_anmont	INTEGER;
 v_anmont	NUMBER(12,2);
 cpt1		INTEGER;


--
--  Ramène toutes les tables de repartition qui sont de type ARBITRE.
--
	CURSOR cur_table IS
		SELECT DISTINCT rt.codrep
		FROM RJH_TABREPART_DETAIL rtd, RJH_TABREPART rt
		WHERE rtd.typtab = 'A'
		AND rt.codrep = rtd.codrep;

--
--  Ramène toutes les lignes BIP appartenant à la table de répartition de type 'A'.
--
	CURSOR cur_ligne(c_table_rep CHAR) IS
		SELECT	pid,
			tauxrep
		FROM RJH_TABREPART_DETAIL
		WHERE CODREP=c_table_rep
		AND TYPTAB='A';

-- ------------------------------------------------------------------------------------------------------

 BEGIN
 -- Récupération de la date système et de l'année courante.
    SELECT SYSDATE INTO l_date FROM DUAL;
    SELECT TO_NUMBER(TO_CHAR(DATDEBEX,'YYYY')) INTO l_annee FROM DATDEBEX;

 -- Remet à zéro tous les arbitrés des lignes T9

    L_STATEMENT:='Remise à zéro des arbitrés des lignes T9';

    UPDATE BUDGET
    SET  anmont = 0, apdate = l_date, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
    WHERE  pid IN ( SELECT pid FROM LIGNE_BIP
                    WHERE typproj = 9)
    AND annee=l_annee;
    COMMIT;

    Trclog.Trclog( P_HFILE, L_STATEMENT ||':-'||SQL%rowcount);

 -- Boucle sur toutes les tables de répartition

 	L_STATEMENT := 'Boucle sur toutes les tables de répartition';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	cpt1 := 0 ;

	FOR curseur_tab IN cur_table LOOP
 		cpt1 := cpt1 + 1 ;

 		-- Recherche l'arbitré à répartir pour une table de répartition
 		--
		SELECT SUM(b.ANMONT) INTO l_anmont
        	FROM LIGNE_BIP l,BUDGET b
        	WHERE l.CODREP=curseur_tab.codrep
        	AND b.pid=l.pid
        	AND b.ANNEE=l_annee
        	AND l.codcamo=66666
        	;

		-- Boucle sur les lignes BIP de la table de répartition
		--
	    	FOR curseur_ligne IN cur_ligne(curseur_tab.codrep) LOOP
		  BEGIN

			-- Calcule le montant réparti
          		v_anmont := l_anmont * curseur_ligne.tauxrep ;

			-- Essaie d'insérer dans budget
			INSERT INTO BUDGET (
			 				  	 PID,
								 ANNEE,
								 ANMONT,
								 APDATE,
								 FLAGLOCK
								)
             		VALUES(
					     			curseur_ligne.pid,
								l_annee,
					 			v_anmont,
								l_date,
								0
								);

			EXCEPTION

            		WHEN VIOLATION_CONSTRAINT_UNIQUE THEN

			-- Fait la mise à jour dans budget en ajoutant les arbitrés aux arbitrés existants.
                    	UPDATE BUDGET
                    	SET  anmont = anmont + v_anmont, apdate = l_date, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
                    	WHERE  pid = curseur_ligne.pid;

		  END;
		END LOOP;
	END LOOP;

	COMMIT;

	Trclog.Trclog( P_HFILE, 'Nombre de table traitées pour les arbitrés : ' || cpt1 );

 END REPART_ARB;

END Packbatch_Repartition_Arb;
/
CREATE OR REPLACE PACKAGE Packbatch_Repartition_Ree AS

    -- -----------------------------------------------------------------------------------------------------------------
    -- Utilitaire : Traitement de répartition
    -- -----------------------------------------------------------------------------------------------------------------
   PROCEDURE ALIM_RJH( P_LOGDIR IN VARCHAR2 );

    -- -----------------------------------------------------------------------------------------------------------------
    -- Utilitaire : Traitement de répartition des réestimés
    -- -----------------------------------------------------------------------------------------------------------------
   PROCEDURE REPART_REE( P_HFILE IN UTL_FILE.FILE_TYPE );


END Packbatch_Repartition_Ree;
/

CREATE OR REPLACE PACKAGE BODY Packbatch_Repartition_Ree  AS

-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
PRAGMA EXCEPTION_INIT( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     NUMBER := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     NUMBER := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID NUMBER := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
VIOLATION_CONSTRAINT_UNIQUE EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
PRAGMA EXCEPTION_INIT( VIOLATION_CONSTRAINT_UNIQUE, -00001 );


-- -----------------------------------------------------------------------------------------------------------------
-- Utilitaire : Traitement de répartition
-- -----------------------------------------------------------------------------------------------------------------

PROCEDURE ALIM_RJH( P_LOGDIR IN VARCHAR2 ) IS

   L_PROCNAME  VARCHAR2(16) := 'ALIM_RJH_REE';
   L_STATEMENT VARCHAR2(128);
   L_HFILE     UTL_FILE.FILE_TYPE;
   L_RETCOD    NUMBER;


BEGIN

    -----------------------------------------------------
    -- Init de la trace
    -----------------------------------------------------
		L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		IF ( L_RETCOD <> 0 ) THEN
		RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
		END IF;
    -----------------------------------------------------
    -- Trace Start
    -----------------------------------------------------
		Trclog.Trclog( L_HFILE, 'Debut de ' || L_PROCNAME );
    -- ------------------------------------------------------------------------------------------------------
    -- Alimentation des arbitrés dans la table BUDGET
    -- ------------------------------------------------------------------------------------------------------
		Packbatch_Repartition_Ree.REPART_REE( L_HFILE );
    -- ------------------------------------------------------------------------------------------------------

    Trclog.Trclog( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

EXCEPTION
	WHEN OTHERS THEN
	    ROLLBACK;
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;

END ALIM_RJH;

-- ----------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------

   -- -------------------------------------------------------------------------------------------------------------
   -- Alimentation des réestimés dans la table BUDGET
   -- -------------------------------------------------------------------------------------------------------------
PROCEDURE REPART_REE( P_HFILE IN UTL_FILE.FILE_TYPE ) IS

 L_STATEMENT	VARCHAR2(128);

 l_annee		INTEGER;
 l_date			DATE;
 l_moismens		DATE;
 l_reestime		NUMBER(12,5);
 l_cusag		NUMBER(12,5);
 l_reste_a_faire	NUMBER(12,5);
 v_reestime		NUMBER(12,5);
 cpt1			INTEGER;
 cpt2			INTEGER;


--
--  Ramène toutes les tables de repartition qui sont de type PROPOSE.
--
	CURSOR cur_table IS
		SELECT DISTINCT rt.codrep
		FROM RJH_TABREPART_DETAIL rtd, RJH_TABREPART rt
		WHERE rtd.typtab = 'P'
		AND rt.codrep = rtd.codrep;

--
--  Ramène toutes les lignes BIP appartenant à la table de répartition de type 'P'.
--
	CURSOR cur_ligne(c_table_rep CHAR) IS
		SELECT	pid,
			tauxrep
		FROM RJH_TABREPART_DETAIL
		WHERE CODREP=c_table_rep
		AND MOISREP = l_moismens
		AND TYPTAB='P';

--
--  Ramène toutes les lignes BIP de type 9 qui sont Actives.
--
	CURSOR cur_ligne_detail IS
		SELECT distinct pid
		FROM LIGNE_BIP
		WHERE typproj = 9;

-- ------------------------------------------------------------------------------------------------------

 BEGIN
 -- Récupération de la date système et de l'année courante.
    SELECT SYSDATE INTO l_date FROM DUAL;
    SELECT TO_NUMBER(TO_CHAR(DATDEBEX,'YYYY')) INTO l_annee FROM DATDEBEX;
	SELECT moismens INTO l_moismens FROM DATDEBEX;

 -- Remet à zéro tous les réestimés des lignes T9

    L_STATEMENT:='Remise à zéro des réestimés des lignes T9';

    UPDATE BUDGET
    SET  reestime = 0, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
    WHERE  pid IN ( SELECT pid FROM LIGNE_BIP
                    WHERE typproj = 9)
    AND annee=l_annee;
    COMMIT;

    Trclog.Trclog( P_HFILE, L_STATEMENT ||':-'||SQL%rowcount);

 -- Boucle sur toutes les tables de répartition

 	L_STATEMENT := 'Boucle sur toutes les tables de répartition';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	cpt1 := 0 ;

	FOR curseur_tab IN cur_table LOOP
 		cpt1 := cpt1 + 1 ;

 		-- Recherche du réestimé
 		--
		SELECT NVL(SUM(b.REESTIME),0) INTO l_reestime
        	FROM LIGNE_BIP l,BUDGET b
        	WHERE l.CODREP=curseur_tab.codrep
        	AND b.pid=l.pid
        	AND b.ANNEE=l_annee
        	AND l.codcamo=66666
        	;

 		-- Recherche du consommé
 		--
		SELECT NVL(SUM(c.CUSAG),0) INTO l_cusag
        	FROM LIGNE_BIP l,BUDGET b,CONSOMME c
        	WHERE l.CODREP=curseur_tab.codrep
        	AND b.pid=l.pid
        	AND b.ANNEE=l_annee
        	AND l.codcamo=66666
        	AND b.pid=c.pid
        	AND c.annee=l_annee
        	;

		-- Calcul du reste à faire
		--
		l_reste_a_faire := (l_reestime - l_cusag);

		-- Mise à jour des lignes T9 si le budget reestimé est renseigné et si le reste à faire est positif.
		--
		IF l_reestime > 0 AND l_reste_a_faire > 0
		THEN
			-- Boucle sur les lignes BIP de la table de répartition
			--
	    		FOR curseur_ligne IN cur_ligne(curseur_tab.codrep) LOOP
			  BEGIN
				-- Calcule le montant réparti
          			v_reestime := l_reste_a_faire * curseur_ligne.tauxrep ;

				-- Essaie d'insérer dans budget
				INSERT INTO BUDGET (
			 				  	 PID,
								 ANNEE,
								 REESTIME,
								 FLAGLOCK
								)
             			VALUES(
					     			curseur_ligne.pid,
								l_annee,
					 			v_reestime,
								0
								);

				EXCEPTION

            			WHEN VIOLATION_CONSTRAINT_UNIQUE THEN

				-- Fait la mise à jour dans budget en ajoutant les reestimés aux réestimés existants.
                	    	UPDATE BUDGET
                	    	SET  reestime = reestime + v_reestime, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
                	    	WHERE  pid = curseur_ligne.pid
                	    	  AND  annee = l_annee;
			  END;
			END LOOP;
		END IF;
	END LOOP;

-- ---------------------------------------------------------------

-- Boucle sur toutes les lignes détail de type 9.

 	L_STATEMENT := 'Boucle sur toutes les lignes détail';
	Trclog.Trclog( P_HFILE, L_STATEMENT );
	cpt2 := 0 ;

	FOR curseur_ligne_detail IN cur_ligne_detail LOOP
		cpt2 := cpt2 + 1 ;

		-- Recherche du consommé de la ligne détail.
		--
		BEGIN
		SELECT NVL((c.CUSAG),0) INTO l_cusag
		FROM CONSOMME c
		WHERE c.pid=curseur_ligne_detail.pid
		AND c.ANNEE=l_annee
		;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_cusag := 0;
				TRCLOG.TRCLOG( P_HFILE,'No Data Found consomme pour : ' || curseur_ligne_detail.pid  );
			WHEN OTHERS THEN
				TRCLOG.TRCLOG( P_HFILE,'Probleme de consomme pour : '|| curseur_ligne_detail.pid  );
		END;

		-- Recherche du reestimé de la ligne détail.
		--
		BEGIN
		SELECT NVL((b.REESTIME),0) INTO l_reestime
		FROM BUDGET b
		WHERE b.pid=curseur_ligne_detail.pid
		AND b.ANNEE=l_annee
		;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_reestime := 0;
				TRCLOG.TRCLOG( P_HFILE,'No Data Found reestime pour : '|| curseur_ligne_detail.pid  );
			WHEN OTHERS THEN
				TRCLOG.TRCLOG( P_HFILE,'Probleme de reestime pour : '|| curseur_ligne_detail.pid  );
		END;

		-- Mise à jour du réestimé des lignes de type 9.
		--
		UPDATE BUDGET
		SET  reestime = l_reestime + l_cusag, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
		WHERE  pid = curseur_ligne_detail.pid
		  AND  annee = l_annee;

	END LOOP;

-- ---------------------------------------------------------------
	COMMIT;

	Trclog.Trclog( P_HFILE, 'Nombre de tables traitées pour les réestimés : ' || cpt1 );
	Trclog.Trclog( P_HFILE, 'Nombre de lignes de type 9 mises à jour      : ' || cpt2 );

 END REPART_REE;

END Packbatch_Repartition_Ree;
/
CREATE OR REPLACE PACKAGE packbatch_ressource_ecart AS



--******************************************************
-- Procédure d'alimentation de la table ressource_ecart
-- à partir de la table CONS_SSTACHE_RES_MOIS
--******************************************************
PROCEDURE alim_total_jh(P_LOGDIR          IN VARCHAR2)   ;



--******************************************************
-- Procédure d'alimentation de la table ressource_ecart
-- à partir de la table BJH_ANOMALIES
--******************************************************
PROCEDURE alim_bouclage_jh(P_LOGDIR          IN VARCHAR2)   ;




END packbatch_ressource_ecart;
/

CREATE OR REPLACE PACKAGE BODY packbatch_ressource_ecart AS


-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
pragma EXCEPTION_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère



--******************************************************
-- Procédure d'alimentation de la table ressource_ecart
-- à partir de la table CONS_SSTACHE_RES_MOIS
--******************************************************
PROCEDURE alim_total_jh(P_LOGDIR          IN VARCHAR2)  IS


L_PROCNAME  varchar2(16) := 'ALIM_TOTAL_JH';
L_STATEMENT varchar2(128);
L_HFILE     utl_file.file_type;
L_RETCOD    number;
L_ANNEE varchar2(4);
L_MOISMENS DATE;
l_exist NUMBER(1);

CURSOR cur_re IS
SELECT * FROM ressource_ecart
WHERE type='TOTAL';

l_nbjbip           ressource_ecart.nbjbip%TYPE;
l_nbjgersh         ressource_ecart.nbjgersh%TYPE;
l_nbjmois          ressource_ecart.nbjmois%TYPE;
l_valide           ressource_ecart.valide%TYPE;
l_commentaire      ressource_ecart.commentaire%TYPE;

BEGIN


    SELECT to_char(moismens,'yyyy') INTO L_ANNEE FROM datdebex;

	SELECT moismens INTO L_MOISMENS FROM datdebex;

    -----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                        'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

    -----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------


    TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

	-- ------------------------------------------------------------------------------------------------------
	-- Etape 1 : vider RESSOURCE_ECART, copier RESSOURCE_ECART dans RESSOURCE_ECART_1, vider RESSOURCE_ECART
	--           pour les ecarts de type TOTAL
	-- ------------------------------------------------------------------------------------------------------
	L_STATEMENT := '* Copier RESSOURCE_ECART dans RESSOURCE_ECART_1';
	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-- vide RESSOURCE_ECART_1
	PACKBATCH.DYNA_TRUNCATE('RESSOURCE_ECART_1');

	-- données de RESSOURCE_ECART dans RESSOURCE_ECART_1
	INSERT INTO ressource_ecart_1
	select * from ressource_ecart
	where type='TOTAL';
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table RESSOURCE_ECART_1';
	commit;

	-- vider les lignes de la table RESSOURCE_ECART de type TOTAL
    L_STATEMENT := '* vide les lignes de la table RESSOURCE_ECART de type TOTAL ';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	DELETE RESSOURCE_ECART
	WHERE to_char(cdeb,'YYYY')=L_ANNEE AND TYPE='TOTAL';
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table RESSOURCE_ECART';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
    COMMIT;


	-- vider les lignes de la table RESSOURCE_ECART de type <> TOTAL
    L_STATEMENT := '* vide les lignes de la table RESSOURCE_ECART de type <> de TOTAL non validé';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	DELETE RESSOURCE_ECART
	WHERE to_char(cdeb,'YYYY')=L_ANNEE AND TYPE<>'TOTAL' AND VALIDE='N';
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table RESSOURCE_ECART';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
    COMMIT;


	-- --------------------------------------------------------------------------------------
	-- Etape 2 : On alimente la table RESSOURCE_ECART  par total JH
	--           avec des données de la table con_sstache_res_mois
	-- --------------------------------------------------------------------------------------



    L_STATEMENT := '* alimentation de RESSOURCE_ECART par les écarts de type TOTAL';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );


	INSERT INTO RESSOURCE_ECART (IDENT,CDEB,TYPE,NBJBIP,NBJMOIS,VALIDE,COMMENTAIRE)
  	(select s.ident, s.cdeb, 'TOTAL', SUM(s.cusag), c.cjours,'N','Anomalie'
   	 		from cons_sstache_res_mois s, calendrier c,ressource r
			where to_char(s.cdeb,'yyyy')=L_ANNEE
			and c.calanmois=s.cdeb
			and r.ident=s.ident
			and r.rtype='P'
			group by s.ident,s.cdeb,c.cjours
			having SUM(s.cusag)<>c.cjours

	 UNION
	 select distinct r.ident, L_MOISMENS, 'TOTAL',0, c.cjours,'N','Anomalie'
	 		from ressource r , calendrier c
			where ident in
				  		(
				  		  select distinct ident from situ_ress
						  where datsitu<=L_MOISMENS
						  and (datdep is null or datdep>=L_MOISMENS) and prestation<>'IFO' and prestation<>'GRA'
						  minus
						  select distinct ident from cons_sstache_res_mois
						  where cdeb=L_MOISMENS
						)
 	  	 	and r.rtype='P'
	  	    and c.calanmois=L_MOISMENS

	);
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées de type TOTAL dans la table RESSOURCE_ECART';
	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
  	COMMIT;



	-- --------------------------------------------------------------------------------------
	-- Etape 3 :  Calcul des retours arrière
	--            On compare chaque ligne de RESSOURCE_ECART avec les lignes de RESSOURCE_ECART_1
	-- --------------------------------------------------------------------------------------



     L_STATEMENT := '* Calcul des retours arrière';
     TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	 FOR curseur IN cur_re LOOP
	 	BEGIN
	 	  SELECT NBJBIP, NBJGERSH, NBJMOIS, VALIDE, COMMENTAIRE
			 into l_nbjbip, l_nbjgersh, l_nbjmois, l_valide, l_commentaire
		  FROM ressource_ecart_1 r
		  WHERE r.ident = curseur.ident
		  AND r.cdeb = curseur.cdeb
		  AND r.type = curseur.type
		  ;

		  IF (l_valide = 'O') THEN

			      IF (curseur.nbjbip=l_nbjbip) THEN

			           UPDATE ressource_ecart
			           SET  VALIDE = l_valide,
			  	            COMMENTAIRE = l_commentaire
			           WHERE ident = curseur.ident
			           AND cdeb = curseur.cdeb
			           AND type = curseur.type
			           ;

				   END IF;

		  END IF;

		EXCEPTION

			 WHEN No_Data_Found THEN

				UPDATE ressource_ecart
			    SET  VALIDE = curseur.valide,
			  	     COMMENTAIRE = curseur.commentaire
			    WHERE ident = curseur.ident
			    AND cdeb = curseur.cdeb
			    AND type = curseur.type
			    ;

        END;

	 END LOOP;
	 TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	 COMMIT;


	 TRCLOG.TRCLOG( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;


end alim_total_jh;




--******************************************************
-- Procédure d'alimentation de la table ressource_ecart
-- à partir de la table BJH_ANOMALIES
--******************************************************
PROCEDURE alim_bouclage_jh(P_LOGDIR          IN VARCHAR2)  IS


L_PROCNAME  varchar2(16) := 'ALIM_BOUCLAGE_JH';
L_STATEMENT varchar2(128);
L_HFILE     utl_file.file_type;
L_RETCOD    number;
L_ANNEE varchar2(4);
l_exist NUMBER(1);

CURSOR cur_re IS
SELECT * FROM ressource_ecart
WHERE type<>'TOTAL';

l_nbjbip           ressource_ecart.nbjbip%TYPE;
l_nbjgersh         ressource_ecart.nbjgersh%TYPE;
l_nbjmois          ressource_ecart.nbjmois%TYPE;
l_valide           ressource_ecart.valide%TYPE;
l_commentaire      ressource_ecart.commentaire%TYPE;


BEGIN




SELECT to_char(moismens,'yyyy') INTO L_ANNEE FROM datdebex;



    -----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

    -----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------


    TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );



	-- ------------------------------------------------------------------------------------------------------
	-- Etape 1 : vider RESSOURCE_ECART, copier RESSOURCE_ECART dans RESSOURCE_ECART_1, vider RESSOURCE_ECART
	--           pour les ecarts de type CONGES et ABSDIV
	-- ------------------------------------------------------------------------------------------------------
	L_STATEMENT := '* Copier RESSOURCE_ECART dans RESSOURCE_ECART_1';
	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-- vide RESSOURCE_ECART_1
	PACKBATCH.DYNA_TRUNCATE('RESSOURCE_ECART_1');


	-- données de RESSOURCE_ECART dans RESSOURCE_ECART_1
	INSERT INTO ressource_ecart_1
	select * from ressource_ecart
	where type<>'TOTAL';
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table RESSOURCE_ECART_1';
	commit;

	-- vider les lignes de la table RESSOURCE_ECART de type CONGES et ABSDIV
    L_STATEMENT := '* vide les lignes de la table RESSOURCE_ECART de type different à TOTAL ';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	DELETE RESSOURCE_ECART
	WHERE to_char(cdeb,'YYYY')=L_ANNEE AND TYPE<>'TOTAL';
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table RESSOURCE_ECART';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
    COMMIT;




    -- --------------------------------------------------------------------------------------
	-- Etape 2 : On alimente la table RESSOURCE_ECART  par bouclage JH
	--           avec des données de la table BJH_ANOMALIES de type ABSDIV
	-- --------------------------------------------------------------------------------------


    L_STATEMENT := '* alimentation de RESSOURCE_ECART ECART par les écarts de type ABSDIV';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );


	INSERT INTO RESSOURCE_ECART (IDENT,CDEB,TYPE,NBJBIP,NBJGERSH,NBJMOIS,VALIDE,COMMENTAIRE)
  	(select ident, to_date(to_char(mois)||'/'||L_ANNEE,'mm/yyyy'), typeabsence,sum(coutbip),sum(coutgip),c.cjours,'N','Anomalie'
			from bjh_anomalies ba, ressource r, calendrier c
			where ba.TYPEABSENCE='ABSDIV'
			and r.matricule=ba.matricule
			and calanmois=to_date(to_char(mois)||'/'||L_ANNEE,'mm/yyyy')
			group by ident,mois,typeabsence,cjours
			having sum(coutgip)<>sum(coutbip)
  	 );



  	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	commit;


	-- --------------------------------------------------------------------------------------
	-- Etape 3 : On alimente la table RESSOURCE_ECART  par bouclage JH
	--           avec des données de la table BJH_ANOMALIES de type CONGES
	-- --------------------------------------------------------------------------------------


    L_STATEMENT := '* alimentation de RESSOURCE_ECART ECART par les écarts de type CONGES';
    TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );


	INSERT INTO RESSOURCE_ECART (IDENT,CDEB,TYPE,NBJBIP,NBJGERSH,NBJMOIS,VALIDE,COMMENTAIRE)
  	(select ident, to_date(to_char(mois)||'/'||L_ANNEE,'mm/yyyy'), 'CONGES', sum(coutbip), sum(coutgip), c.cjours, 'N', 'Anomalie'
			from bjh_anomalies ba, ressource r, calendrier c
			where ba.TYPEABSENCE<>'ABSDIV'
			and r.matricule=ba.matricule
			and calanmois=to_date(to_char(mois)||'/'||L_ANNEE,'mm/yyyy')
			group by ident,mois,cjours
			having sum(coutgip)<>sum(coutbip)
  	 );

	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
  	commit;



	-- ------------------------------------------------------------------------------------------
	-- Etape 3 :  Calcul des retours arrière
	--            On compare chaque ligne de RESSOURCE_ECART avec les lignes de RESSOURCE_ECART_1
	-- ------------------------------------------------------------------------------------------



     L_STATEMENT := '* Calcul des retours arrière';
     TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	 FOR curseur IN cur_re LOOP
	 	BEGIN
	 	  SELECT NBJBIP, NBJGERSH, NBJMOIS, VALIDE, COMMENTAIRE
			 into l_nbjbip, l_nbjgersh, l_nbjmois, l_valide, l_commentaire
		  FROM ressource_ecart_1 r
		  WHERE r.ident = curseur.ident
		  AND r.cdeb = curseur.cdeb
		  AND r.type = curseur.type
		  ;

		  IF (l_valide = 'O') THEN

				   IF ( (curseur.nbjbip=l_nbjbip) AND (curseur.nbjgersh=l_nbjgersh) ) THEN

			           UPDATE ressource_ecart
			           SET  VALIDE = l_valide,
			  	            COMMENTAIRE = l_commentaire
			           WHERE ident = curseur.ident
			           AND cdeb = curseur.cdeb
			           AND type = curseur.type
			           ;

				   END IF;

		  END IF;

		  EXCEPTION

			 WHEN No_Data_Found THEN

				UPDATE ressource_ecart
			    SET  VALIDE = curseur.valide,
			  	     COMMENTAIRE = curseur.commentaire
			    WHERE ident = curseur.ident
			    AND cdeb = curseur.cdeb
			    AND type = curseur.type
			    ;

        END;

	 END LOOP;
	 TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	 COMMIT;




	 TRCLOG.TRCLOG( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME);


EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;


end alim_bouclage_jh;




END packbatch_ressource_ecart;
/
CREATE OR REPLACE PACKAGE Packbatch_Rtfe AS


   --********************************************************************
   -- Procédure qui alimente la table rtfe à partir de la table tmp_rtfe
   --********************************************************************
   PROCEDURE load_rtfe(P_LOGDIR          IN VARCHAR2);


   --********************************************************************
   -- Procédure qui insert un ligne qui correspond à un role
   --********************************************************************
   PROCEDURE insert_role(P_IDENT IN NUMBER, P_USER_RTFE IN VARCHAR2, P_NOM IN VARCHAR2, P_PRENOM IN VARCHAR2, P_ROLE IN VARCHAR2);


   --********************************************************************
   -- Procédure qui insert un ligne qui correspond
   -- à un role qui n'est pas trouvé dans la BIP
   --********************************************************************
   PROCEDURE insert_role_error(P_ID IN VARCHAR2, P_NOM IN VARCHAR2, P_PRENOM IN VARCHAR2, P_ROLE IN VARCHAR2);



END Packbatch_Rtfe;
/

CREATE OR REPLACE PACKAGE BODY Packbatch_Rtfe AS

-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
PRAGMA EXCEPTION_INIT( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     NUMBER := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     NUMBER := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID NUMBER := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère



--********************************************************************
-- Procédure qui alimente la table rtfe à partir de la table tmp_rtfe
--********************************************************************
PROCEDURE load_rtfe(P_LOGDIR          IN VARCHAR2)   IS


L_PROCNAME  VARCHAR2(16) := 'ALIM_RTFE';
L_HFILE     UTL_FILE.FILE_TYPE;
L_RETCOD    NUMBER;
L_STATEMENT VARCHAR2(128);

l_ident NUMBER(5);

CURSOR cur_rtfe IS
SELECT * FROM TMP_RTFE;


BEGIN




    -----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
		L_RETCOD := Trclog.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		IF ( L_RETCOD <> 0 ) THEN
		RAISE_APPLICATION_ERROR( TRCLOG_FAILED_ID,
		                        'Erreur : Gestion du fichier LOG impossible',
		                         FALSE );
		END IF;


		Trclog.Trclog( L_HFILE, 'Debut de ' || L_PROCNAME );

	-- On vide la table RTFE
	L_STATEMENT := '* Truncate de la table RTFE';
    Trclog.Trclog( L_HFILE, L_STATEMENT );
	Packbatch.DYNA_TRUNCATE('RTFE');

	-- On vide la table RTFE_ERROR
	L_STATEMENT := '* Truncate de la table RTFE_ERROR';
    Trclog.Trclog( L_HFILE, L_STATEMENT );
	Packbatch.DYNA_TRUNCATE('RTFE_ERROR');



    -----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------


  L_STATEMENT := '* Insetion des données dans la table RTFE';
    Trclog.Trclog( L_HFILE, L_STATEMENT );


	FOR curseur IN cur_rtfe LOOP
	 	BEGIN

		  IF(UPPER(SUBSTR(curseur.ID,1,1)) = 'A')THEN

	 	     SELECT ident INTO l_ident FROM RESSOURCE
		     WHERE UPPER(SUBSTR(matricule,1,6)) = UPPER(SUBSTR(curseur.ID,2,7))
                     AND ROWNUM=1;

		  ELSIF(UPPER(SUBSTR(curseur.ID,1,1)) = 'X')THEN

		     SELECT ident INTO l_ident FROM RESSOURCE
		     WHERE UPPER(matricule) = UPPER(curseur.ID)
                     AND ROWNUM=1 ;

		  ELSE
		     RAISE NO_DATA_FOUND;
		  END IF;


		EXCEPTION

		 WHEN NO_DATA_FOUND THEN

		    BEGIN

			   SELECT ident INTO l_ident FROM RESSOURCE
		       WHERE UPPER(rnom)=UPPER(curseur.sn)
		       AND UPPER(rprenom)=UPPER(curseur.givenname)
		       AND ROWNUM=1;



		    EXCEPTION
		      WHEN NO_DATA_FOUND THEN

		      DBMS_OUTPUT.PUT_LINE('erreur');

		      l_ident := NULL;

		      IF(curseur.sgutiroleatt1 IS NOT NULL)THEN
		      		insert_role_error(curseur.ID,curseur.sn,curseur.givenname,curseur.sgutiroleatt1);
		  	  END IF;
		      IF(curseur.sgutiroleatt2 IS NOT NULL)THEN
		            insert_role_error(curseur.ID,curseur.sn,curseur.givenname,curseur.sgutiroleatt2);
		      END IF;
		      IF(curseur.sgutiroleatt3 IS NOT NULL)THEN
		            insert_role_error(curseur.ID,curseur.sn,curseur.givenname,curseur.sgutiroleatt3);
		      END IF;
		      IF(curseur.sgutiroleatt4 IS NOT NULL)THEN
		            insert_role_error(curseur.ID,curseur.sn,curseur.givenname,curseur.sgutiroleatt4);
		      END IF;
		      IF(curseur.sgutiroleatt5 IS NOT NULL)THEN
		            insert_role_error(curseur.ID,curseur.sn,curseur.givenname,curseur.sgutiroleatt5);
		      END IF;
		      IF(curseur.sgutiroleatt6 IS NOT NULL)THEN
		            insert_role_error(curseur.ID,curseur.sn,curseur.givenname,curseur.sgutiroleatt6);
		      END IF;
		      IF(curseur.sgutiroleatt7 IS NOT NULL)THEN
		            insert_role_error(curseur.ID,curseur.sn,curseur.givenname,curseur.sgutiroleatt7);
		      END IF;
		    END;


       END;



		IF(l_ident IS NOT NULL)THEN

		  IF(curseur.sgutiroleatt1 IS NOT NULL)THEN
		     insert_role(l_ident,curseur.sgzoneid,curseur.sn,curseur.givenname,curseur.sgutiroleatt1);
		  END IF;
		  IF(curseur.sgutiroleatt2 IS NOT NULL)THEN
		     insert_role(l_ident,curseur.sgzoneid,curseur.sn,curseur.givenname,curseur.sgutiroleatt2);
		  END IF;
		  IF(curseur.sgutiroleatt3 IS NOT NULL)THEN
		     insert_role(l_ident,curseur.sgzoneid,curseur.sn,curseur.givenname,curseur.sgutiroleatt3);
		  END IF;
		  IF(curseur.sgutiroleatt4 IS NOT NULL)THEN
		     insert_role(l_ident,curseur.sgzoneid,curseur.sn,curseur.givenname,curseur.sgutiroleatt4);
		  END IF;
		  IF(curseur.sgutiroleatt5 IS NOT NULL)THEN
		     insert_role(l_ident,curseur.sgzoneid,curseur.sn,curseur.givenname,curseur.sgutiroleatt5);
		  END IF;
		  IF(curseur.sgutiroleatt6 IS NOT NULL)THEN
		     insert_role(l_ident,curseur.sgzoneid,curseur.sn,curseur.givenname,curseur.sgutiroleatt6);
		  END IF;
		  IF(curseur.sgutiroleatt7 IS NOT NULL)THEN
		     insert_role(l_ident,curseur.sgzoneid,curseur.sn,curseur.givenname,curseur.sgutiroleatt7);
		  END IF;


		END IF;




	 END LOOP;



	 COMMIT;


	Trclog.Trclog( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME);


	EXCEPTION
	WHEN OTHERS THEN
	    ROLLBACK;
		IF SQLCODE <> CALLEE_FAILED_ID THEN
				Trclog.Trclog( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		END IF;
		Trclog.Trclog( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		RAISE CALLEE_FAILED;




END load_rtfe;




--********************************************************************
-- Procédure qui insert une ligne qui correspond à un role
--********************************************************************
PROCEDURE insert_role(p_ident IN NUMBER, P_USER_RTFE IN VARCHAR2, P_NOM IN VARCHAR2, P_PRENOM IN VARCHAR2, p_role IN VARCHAR2) IS

l_role              VARCHAR2(20);
l_menus             VARCHAR2(200);
l_ss_menus          VARCHAR2(200);
l_bddpg_defaut 		VARCHAR2(30);
l_perim_me 		    VARCHAR2(500);
l_chef_projet 		VARCHAR2(500);
l_mo_defaut		    VARCHAR2(30);
l_perim_mo          VARCHAR2(500);
l_centre_frais  	VARCHAR2(50);
l_ca_suivi 		    VARCHAR2(200);
l_projet 		    VARCHAR2(200);
l_appli        		VARCHAR2(200);
l_ca_fi        		VARCHAR2(200);
l_ca_payeur   		VARCHAR2(200);
l_doss_proj   		VARCHAR2(200);


l_pos NUMBER(7);
l_pos1 NUMBER(7);
l_chaine VARCHAR2(4000);

BEGIN


   --recherche du role
   l_pos := INSTR(p_role,'Role=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+5;
     l_pos1 := INSTR(p_role,':',l_pos,1);


     IF(l_pos1=0)THEN
       l_role := SUBSTR(p_role,l_pos);
     ELSE
	   l_role := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,':Menus=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+7;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_menus := SUBSTR(p_role,l_pos);
     ELSE
	   l_menus := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'Ss_Menus=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+9;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_ss_menus := SUBSTR(p_role,l_pos);
     ELSE
	   l_ss_menus := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'BDDPG_defaut=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+13;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_bddpg_defaut := SUBSTR(p_role,l_pos);
     ELSE
	   l_bddpg_defaut := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;





   l_pos := INSTR(p_role,'Perim_ME=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+9;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_perim_me := SUBSTR(p_role,l_pos);
     ELSE
	   l_perim_me := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

	-- DBMS_OUTPUT.PUT_LINE('l_pos  !'||l_pos);
	-- DBMS_OUTPUT.PUT_LINE('l_pos1  !'||l_pos1);
	-- DBMS_OUTPUT.PUT_LINE('l_perim_me  !'||l_perim_me);


   END IF;

   l_pos := INSTR(p_role,'Chef_Projet=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+12;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_chef_projet := SUBSTR(p_role,l_pos);
     ELSE
	   l_chef_projet := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'MO_defaut=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+10;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_mo_defaut := SUBSTR(p_role,l_pos);
     ELSE
	   l_mo_defaut := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'Perim_MO=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+9;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_perim_mo := SUBSTR(p_role,l_pos);
     ELSE
	   l_perim_mo := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'Centre_Frais=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+13;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_centre_frais := SUBSTR(p_role,l_pos);
     ELSE
	   l_centre_frais := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'CA_Suivi=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+9;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_ca_suivi := SUBSTR(p_role,l_pos);
     ELSE
	   l_ca_suivi := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,':Projet=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+8;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_projet := SUBSTR(p_role,l_pos);
     ELSE
	   l_projet := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;

   l_pos := INSTR(p_role,'Appli=',1,2);

   IF(l_pos>0)THEN

	 l_pos := l_pos+6;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_appli := SUBSTR(p_role,l_pos);
     ELSE
	   l_appli := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'CA_FI=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+6;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_ca_fi := SUBSTR(p_role,l_pos);
     ELSE
	   l_ca_fi := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'CA_Payeur=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+10;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_ca_payeur := SUBSTR(p_role,l_pos);
     ELSE
	   l_ca_payeur := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;

   l_pos := INSTR(p_role,'Doss_proj=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+10;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_doss_proj := SUBSTR(p_role,l_pos);
     ELSE
	   l_doss_proj := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;



  INSERT INTO RTFE(ident,
  		 	  	   user_rtfe,
  		 	  	   nom,
				   prenom,
  		 	  	   ROLE,
				   menus,
				   ss_menus,
				   bddpg_defaut,
				   perim_me,
				   chef_projet,
				   mo_defaut,
				   perim_mo,
				   CENTRE_FRAIS,
  				   ca_suivi,
  				   projet,
  				   appli,
  				   ca_fi,
  				   ca_payeur,
  				   doss_proj
				  )
			VALUES(p_ident,
			       p_user_rtfe,
				   p_nom,
				   p_prenom,
  		 	  	   l_role,
				   l_menus,
				   l_ss_menus,
				   l_bddpg_defaut,
				   l_perim_me,
				   l_chef_projet,
				   l_mo_defaut,
				   l_perim_mo,
				   l_centre_frais,
  				   l_ca_suivi,
  				   l_projet,
  				   l_appli,
  				   l_ca_fi,
  				   l_ca_payeur,
  				   l_doss_proj
				  );
  COMMIT;

END insert_role;



--********************************************************************
-- Procédure qui insert un ligne qui correspond
-- à un role qui n'est pas trouvé dans la BIP
--********************************************************************
PROCEDURE insert_role_error(P_ID IN VARCHAR2, P_NOM IN VARCHAR2, P_PRENOM IN VARCHAR2, P_ROLE IN VARCHAR2) IS

l_role              VARCHAR2(20);
l_menus             VARCHAR2(200);
l_ss_menus          VARCHAR2(200);
l_bddpg_defaut 		VARCHAR2(30);
l_perim_me 		    VARCHAR2(500);
l_chef_projet 		VARCHAR2(500);
l_mo_defaut		    VARCHAR2(30);
l_perim_mo          VARCHAR2(500);
l_centre_frais  	VARCHAR2(50);
l_ca_suivi 		    VARCHAR2(200);
l_projet 		    VARCHAR2(200);
l_appli        		VARCHAR2(200);
l_ca_fi        		VARCHAR2(200);
l_ca_payeur   		VARCHAR2(200);
l_doss_proj   		VARCHAR2(200);


l_pos NUMBER(7);
l_pos1 NUMBER(7);
l_chaine VARCHAR2(4000);

BEGIN


   --recherche du role
   l_pos := INSTR(p_role,'Role=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+5;
     l_pos1 := INSTR(p_role,':',l_pos,1);


     IF(l_pos1=0)THEN
       l_role := SUBSTR(p_role,l_pos);
     ELSE
	   l_role := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,':Menus=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+7;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_menus := SUBSTR(p_role,l_pos);
     ELSE
	   l_menus := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'Ss_Menus=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+9;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_ss_menus := SUBSTR(p_role,l_pos);
     ELSE
	   l_ss_menus := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'BDDPG_defaut=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+13;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_bddpg_defaut := SUBSTR(p_role,l_pos);
     ELSE
	   l_bddpg_defaut := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;





   l_pos := INSTR(p_role,'Perim_ME=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+9;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_perim_me := SUBSTR(p_role,l_pos);
     ELSE
	   l_perim_me := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;




   END IF;

   l_pos := INSTR(p_role,'Chef_Projet=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+12;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_chef_projet := SUBSTR(p_role,l_pos);
     ELSE
	   l_chef_projet := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'MO_defaut=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+10;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_mo_defaut := SUBSTR(p_role,l_pos);
     ELSE
	   l_mo_defaut := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'Perim_MO=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+9;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_perim_mo := SUBSTR(p_role,l_pos);
     ELSE
	   l_perim_mo := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'Centre_Frais=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+13;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_centre_frais := SUBSTR(p_role,l_pos);
     ELSE
	   l_centre_frais := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'CA_Suivi=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+9;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_ca_suivi := SUBSTR(p_role,l_pos);
     ELSE
	   l_ca_suivi := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,':Projet=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+8;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_projet := SUBSTR(p_role,l_pos);
     ELSE
	   l_projet := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;

   l_pos := INSTR(p_role,'Appli=',1,2);

   IF(l_pos>0)THEN

	 l_pos := l_pos+6;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_appli := SUBSTR(p_role,l_pos);
     ELSE
	   l_appli := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'CA_FI=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+6;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_ca_fi := SUBSTR(p_role,l_pos);
     ELSE
	   l_ca_fi := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


   l_pos := INSTR(p_role,'CA_Payeur=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+10;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_ca_payeur := SUBSTR(p_role,l_pos);
     ELSE
	   l_ca_payeur := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;

   l_pos := INSTR(p_role,'Doss_proj=',1,1);

   IF(l_pos>0)THEN

	 l_pos:=l_pos+10;
     l_pos1 := INSTR(p_role,':',l_pos,1);

     IF(l_pos1=0)THEN
       l_doss_proj := SUBSTR(p_role,l_pos);
     ELSE
	   l_doss_proj := SUBSTR(p_role,l_pos,l_pos1-l_pos);
	 END IF;

   END IF;


  INSERT INTO RTFE_ERROR(
  		 	  	   user_rtfe,
  		 	  	   nom,
				   prenom,
				   ROLE,
				   menus,
				   ss_menus,
				   bddpg_defaut,
				   perim_me,
				   chef_projet,
				   mo_defaut,
				   perim_mo,
				   CENTRE_FRAIS,
  				   ca_suivi,
  				   projet,
  				   appli,
  				   ca_fi,
  				   ca_payeur,
  				   doss_proj
				  )
			VALUES(
			       p_id,
  		 	  	   p_nom,
				   p_prenom,
				   l_role,
				   l_menus,
				   l_ss_menus,
				   l_bddpg_defaut,
				   l_perim_me,
				   l_chef_projet,
				   l_mo_defaut,
				   l_perim_mo,
				   l_centre_frais,
  				   l_ca_suivi,
  				   l_projet,
  				   l_appli,
  				   l_ca_fi,
  				   l_ca_payeur,
  				   l_doss_proj
				  );
  COMMIT;

END;




END Packbatch_Rtfe;
/
CREATE OR REPLACE PACKAGE  PACKBATCH_SYNTH_FIN AS

--****************************************************
-- Procédure globale d'alimentation des tables
--****************************************************
PROCEDURE globale (P_LOGDIR          IN VARCHAR2)  ;

--****************************************************
-- Procédures d'alimentation de la table synthese_fin
--****************************************************
PROCEDURE alim_synth_fin_fi(P_HFILE           IN utl_file.file_type)   ;
PROCEDURE alim_synth_fin_immo(P_HFILE           IN utl_file.file_type)   ;

--*******************************************************
-- Procédures d'alimentation de la table synthese_fin_bip
--*******************************************************
PROCEDURE alim_synth_fin_bip(P_HFILE           IN utl_file.file_type)   ;

--*******************************************************
-- Procédures d'alimentation de la table synthese_fin_ress
--*******************************************************
PROCEDURE alim_synth_fin_ress(P_HFILE           IN utl_file.file_type)   ;


END PACKBATCH_SYNTH_FIN;
/

CREATE OR REPLACE PACKAGE  BODY  PACKBATCH_SYNTH_FIN AS

-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
pragma EXCEPTION_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère

--****************************************************
-- Procédure d'alimentation des tables pour le batch IAS
--****************************************************
PROCEDURE globale (P_LOGDIR          IN VARCHAR2)  IS

L_HFILE     utl_file.file_type;
L_RETCOD    number;
L_PROCNAME  varchar2(16) := 'SYNTH_FIN';

	BEGIN

		-----------------------------------------------------
		-- Init de la trace
		-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-----------------------------------------------------
		-- Trace Start
		-----------------------------------------------------
		TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

		-----------------------------------------------------
		-- Lancement ...
		-----------------------------------------------------
		--Alimentation de la table SYNTHESE_FIN
	 	alim_synth_fin_fi( L_HFILE );
	 	alim_synth_fin_immo( L_HFILE );

	 	--Alimentation de la table SYNTHESE_FIN_BIP
	 	alim_synth_fin_bip( L_HFILE );

	 	--Alimentation de la table SYNTHESE_FIN_RESS
	 	alim_synth_fin_ress( L_HFILE );

		-----------------------------------------------------
		-- Trace Stop
		-----------------------------------------------------
		TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( L_HFILE );

	EXCEPTION
		when others then
			if sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;


END globale;


--******************************************************************************
-- Procédure d'alimentation de la table SYNTHESE_FIN avec les donnees de stock_fi
--******************************************************************************
PROCEDURE alim_synth_fin_fi(P_HFILE           IN utl_file.file_type)   IS

L_RETCOD    number;
L_PROCNAME  varchar2(16) := 'ALIM_SYNT_FIN';
L_STATEMENT varchar2(128);
L_ANNEE     number;

BEGIN
	 TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

	 -- Année d'exercice
      	SELECT TO_NUMBER(TO_CHAR(datdebex, 'YYYY')) INTO L_ANNEE
      	FROM datdebex WHERE ROWNUM < 2;

	 -- on vide la table
	L_STATEMENT := '* vide synthese_fin de l annee courante';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	DELETE SYNTHESE_FIN
	WHERE annee=L_ANNEE;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	COMMIT;

	-- -------------------------------------------------------------
	-- Etape 1 : Insertion des lignes dans la table SYNTHESE_FIN si
	-- (annee,pid,codcamo,cafi,codsgress) n existe pas
	-- --------------------------------------------------------------
	L_STATEMENT := '* Etape 1 : Insertion des lignes dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	INSERT INTO SYNTHESE_FIN (ANNEE,
			PID,
			CODSG,
			CODCAMO,
			CAFI,
			CODSGRESS,
			CADA,
			CONSOJHSG_IM      ,
			CONSOJHSSII_IM,
			CONSOFTSG_IM,
			CONSOFTSSII_IM,
			CONSOJHSG_FI,
			CONSOJHSSII_FI,
			CONSOFTSG_FI,
			CONSOFTSSII_FI,
			CONSOENVSG_NI ,
			CONSOENVSSII_NI ,
			CONSOENVSG_IM ,
			CONSOENVSSII_IM ,
			D_CONSOJHSG_FI,
			D_CONSOJHSSII_FI,
			D_CONSOFTSG_FI,
			D_CONSOFTSSII_FI,
			D_CONSOENVSG_NI ,
			D_CONSOENVSSII_NI ,
			D_CONSOENVSG_IM ,
			D_CONSOENVSSII_IM ,
			M_CONSOJHSG_IM,
			M_CONSOJHSSII_IM,
			M_CONSOFTSG_IM,
			M_CONSOFTSSII_IM,
			M_CONSOJHSG_FI,
			M_CONSOJHSSII_FI,
			M_CONSOFTSG_FI,
			M_CONSOFTSSII_FI,
			M_CONSOENVSG_NI ,
			M_CONSOENVSSII_NI ,
			M_CONSOENVSG_IM ,
			M_CONSOENVSSII_IM,
			A_CONSOJH_IM,
			A_CONSOFT_IM,
			A_CONSOJH_FI ,
			A_CONSOFT_FI ,
			A_CONSOENV_NI,
			A_CONSOENV_IM)
	(SELECT distinct
      			L_ANNEE,
      			s.pid,
      			0,
      			s.codcamo,
      			s.cafi,
      			s.codsgress,
      			0,
      			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      	FROM		stock_fi s
	WHERE not exists (select 1 from synthese_fin sf
			  where sf.annee=L_ANNEE
      				and sf.pid=s.pid
      				and sf.codcamo=s.codcamo
      				and sf.cafi=s.cafi
      				and sf.codsgress=s.codsgress
      				)
	);
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;

	-- -------------------------------------------------------------
	-- Etape 2 : alimentation des champs concernant les SG
	-- --------------------------------------------------------------
	L_STATEMENT := '* Etape 2 : alimentation des champs concernant les SG dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (CONSOJHSG_FI,CONSOFTSG_FI,CONSOENVSG_NI,CONSOENVSG_IM,
				M_CONSOJHSG_FI,M_CONSOFTSG_FI,M_CONSOENVSG_NI,M_CONSOENVSG_IM)=
		(select NVL(sum(nvl(consojhimmo,0)+nvl(nconsojhimmo,0)),0),
		nvl(sum(consoft),0),
		nvl(sum(nconsoenvimmo),0),
		nvl(sum(consoenvimmo),0),
		NVL(sum((nvl(a_consojhimmo,0)+nvl(a_nconsojhimmo,0))),0),
		NVL(sum(a_consoft),0),
		NVL(sum(a_nconsoenvimmo),0),
		NVL(sum(a_consoenvimmo),0)
		from stock_fi fi
		where       fi.pid=SYNTHESE_FIN.pid
	      		and fi.codcamo=SYNTHESE_FIN.codcamo
      			and fi.cafi=SYNTHESE_FIN.cafi
      			and fi.codsgress=SYNTHESE_FIN.codsgress
      			and fi.soccode = 'SG..'
      		)
      	WHERE annee=L_ANNEE;

      	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes SG maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;

	-- -------------------------------------------------------------
	-- Etape 3 : alimentation des champs concernant les SSII
	-- --------------------------------------------------------------
	L_STATEMENT := '* Etape 3 : alimentation des champs concernant les SSII dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (CONSOJHSSII_FI,CONSOFTSSII_FI,CONSOENVSSII_NI,CONSOENVSSII_IM,
				M_CONSOJHSSII_FI,M_CONSOFTSSII_FI,M_CONSOENVSSII_NI,M_CONSOENVSSII_IM)=
		(select NVL(sum(nvl(consojhimmo,0)+nvl(nconsojhimmo,0)),0),
		nvl(sum(consoft),0),
		nvl(sum(nconsoenvimmo),0),
		nvl(sum(consoenvimmo),0),
		NVL(sum((nvl(a_consojhimmo,0)+nvl(a_nconsojhimmo,0))),0),
		NVL(sum(a_consoft),0),
		NVL(sum(a_nconsoenvimmo),0),
		NVL(sum(a_consoenvimmo),0)
		from stock_fi fi
		where       fi.pid=SYNTHESE_FIN.pid
	      		and fi.codcamo=SYNTHESE_FIN.codcamo
      			and fi.cafi=SYNTHESE_FIN.cafi
      			and fi.codsgress=SYNTHESE_FIN.codsgress
      			and fi.soccode <> 'SG..'
      		)
      	WHERE annee=L_ANNEE;


      	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes SSII maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;


	-- ----------------------------------------------------------------------
	-- Etape 4 : alimentation des champs concernant decembre N-1 pour les SG
	-- ----------------------------------------------------------------------
	L_STATEMENT := '* Etape 4 : alimentation des champs concernant les SG pour dec n-1 dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (D_CONSOJHSG_FI,D_CONSOFTSG_FI,D_CONSOENVSG_NI,D_CONSOENVSG_IM)=
	(select sum((nvl(consojhimmo,0)+nvl(nconsojhimmo,0))),sum(nvl(consoft,0)),sum(nvl(nconsoenvimmo,0)),sum(nvl(consoenvimmo,0))
		from stock_fi fi
		where fi.soccode = 'SG..'
		and to_number(to_char(fi.cdeb,'yyyy'))=(SYNTHESE_FIN.annee - 1)
		and to_number(to_char(fi.cdeb,'mm'))= 12
      		and fi.pid=SYNTHESE_FIN.pid
      		and fi.codcamo=SYNTHESE_FIN.codcamo
      		and fi.cafi=SYNTHESE_FIN.cafi
      		and fi.codsgress=SYNTHESE_FIN.codsgress
	)
      	WHERE annee=L_ANNEE;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes SG maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;

	-- ----------------------------------------------------------------------
	-- Etape 5 : alimentation des champs concernant decembre N-1 pour les SSII
	-- ----------------------------------------------------------------------
	L_STATEMENT := '* Etape 5 : alimentation des champs concernant les SSII pour dec n-1 dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (D_CONSOJHSSII_FI,D_CONSOFTSSII_FI,D_CONSOENVSSII_NI,D_CONSOENVSSII_IM)=
	(select sum((nvl(consojhimmo,0)+nvl(nconsojhimmo,0))),sum(nvl(consoft,0)),sum(nvl(nconsoenvimmo,0)),sum(nvl(consoenvimmo,0))
		from stock_fi fi
		where fi.soccode <> 'SG..'
		and to_number(to_char(fi.cdeb,'yyyy'))=(SYNTHESE_FIN.annee - 1)
		and to_number(to_char(fi.cdeb,'mm'))= 12
      		and fi.pid=SYNTHESE_FIN.pid
      		and fi.codcamo=SYNTHESE_FIN.codcamo
      		and fi.cafi=SYNTHESE_FIN.cafi
      		and fi.codsgress=SYNTHESE_FIN.codsgress
	)
	WHERE annee=L_ANNEE;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes SSII maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;

	-- -------------------------------------------------------------------------------------
	-- Etape 6 : alimentation des champs concernant les mois inferieurs au mois de mensuelle
	-- -------------------------------------------------------------------------------------
	L_STATEMENT := '* Etape 6 : alimentation des champs concernant les retours arrieres dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (A_CONSOJH_FI,A_CONSOFT_FI,A_CONSOENV_NI,A_CONSOENV_IM )=
	(select sum((nvl(a_consojhimmo,0)+nvl(a_nconsojhimmo,0))),sum(nvl(a_consoft,0)),sum(nvl(a_nconsoenvimmo,0)),sum(nvl(a_consoenvimmo,0))
		from stock_fi fi,datdebex
		where to_number(to_char(fi.cdeb,'yyyy'))=(SYNTHESE_FIN.annee - 1)
		and fi.cdeb < datdebex.moismens
      		and fi.pid=SYNTHESE_FIN.pid
      		and fi.codcamo=SYNTHESE_FIN.codcamo
      		and fi.cafi=SYNTHESE_FIN.cafi
      		and fi.codsgress=SYNTHESE_FIN.codsgress
	)
      	WHERE annee=L_ANNEE;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes < moimens maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;


EXCEPTION
	when others then
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

END alim_synth_fin_fi ;

--******************************************************************************
-- Procédure d'alimentation de la table SYNTHESE_FIN avec les donnees de stock_immo
--******************************************************************************
PROCEDURE alim_synth_fin_immo(P_HFILE           IN utl_file.file_type)   IS

L_RETCOD    number;
L_PROCNAME  varchar2(16) := 'SYNT_FIN_IMMO';
L_STATEMENT varchar2(128);
L_ANNEE     number;

BEGIN
	 TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

	 -- Année d'exercice
      	SELECT TO_NUMBER(TO_CHAR(datdebex, 'YYYY')) INTO L_ANNEE
      	FROM datdebex WHERE ROWNUM < 2;

	-- -------------------------------------------------------------
	-- Etape 7 : Insertion des lignes dans la table SYNTHESE_FIN si
	-- (annee,pid,codcamo,cafi,codsgress) n existe pas
	-- --------------------------------------------------------------
	L_STATEMENT := '* Etape 7 : Insertion des lignes dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
		INSERT INTO SYNTHESE_FIN (ANNEE,
			PID,
			CODSG,
			CODCAMO,
			CAFI,
			CODSGRESS,
			CADA,
			CONSOJHSG_IM      ,
			CONSOJHSSII_IM,
			CONSOFTSG_IM,
			CONSOFTSSII_IM,
			CONSOJHSG_FI,
			CONSOJHSSII_FI,
			CONSOFTSG_FI,
			CONSOFTSSII_FI,
			CONSOENVSG_NI ,
			CONSOENVSSII_NI ,
			CONSOENVSG_IM ,
			CONSOENVSSII_IM ,
			D_CONSOJHSG_FI,
			D_CONSOJHSSII_FI,
			D_CONSOFTSG_FI,
			D_CONSOFTSSII_FI,
			D_CONSOENVSG_NI ,
			D_CONSOENVSSII_NI ,
			D_CONSOENVSG_IM ,
			D_CONSOENVSSII_IM ,
			M_CONSOJHSG_IM,
			M_CONSOJHSSII_IM,
			M_CONSOFTSG_IM,
			M_CONSOFTSSII_IM,
			M_CONSOJHSG_FI,
			M_CONSOJHSSII_FI,
			M_CONSOFTSG_FI,
			M_CONSOFTSSII_FI,
			M_CONSOENVSG_NI ,
			M_CONSOENVSSII_NI ,
			M_CONSOENVSG_IM ,
			M_CONSOENVSSII_IM,
			A_CONSOJH_IM,
			A_CONSOFT_IM,
			A_CONSOJH_FI ,
			A_CONSOFT_FI ,
			A_CONSOENV_NI,
			A_CONSOENV_IM)
	(SELECT distinct
      			L_ANNEE,
      			s.pid,
      			0,
      			s.codcamo,
      			s.cafi,
      			s.codsgress,
      			0,
      			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      	FROM		stock_immo s
	WHERE not exists (select 1 from synthese_fin sf
			  where sf.annee=L_ANNEE
      				and sf.pid=s.pid
      				and sf.codcamo=s.codcamo
      				and sf.cafi=s.cafi
      				and sf.codsgress=s.codsgress
      				)
	);

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;

	-- -------------------------------------------------------------
	-- Etape 8 : alimentation des champs concernant les SG
	-- --------------------------------------------------------------
	L_STATEMENT := '* Etape 8 : alimentation des champs concernant les SG dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (CONSOJHSG_IM,CONSOFTSG_IM,M_CONSOJHSG_IM,M_CONSOFTSG_IM)=
		(select sum((nvl(consojh,0))),sum((nvl(consoft,0))),sum((nvl(a_consojh,0))),sum((nvl(a_consoft,0)))
		from stock_immo si
		where si.soccode = 'SG..'
      		and si.pid=SYNTHESE_FIN.pid
      		and si.codcamo=SYNTHESE_FIN.codcamo
      		and si.cafi=SYNTHESE_FIN.cafi
      		and si.codsgress=SYNTHESE_FIN.codsgress
      		)
      	WHERE annee=L_ANNEE;

      	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes SG maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;

	-- -------------------------------------------------------------
	-- Etape 9 : alimentation des champs concernant les SSII
	-- --------------------------------------------------------------
	L_STATEMENT := '* Etape 9 : alimentation des champs concernant les SSII dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (CONSOJHSSII_IM,CONSOFTSSII_IM,M_CONSOJHSSII_IM,M_CONSOFTSSII_IM)=
		(select sum((nvl(consojh,0))),sum((nvl(consoft,0))),sum((nvl(a_consojh,0))),sum((nvl(a_consoft,0)))
		from stock_immo si
		where si.soccode <> 'SG..'
      		and si.pid=SYNTHESE_FIN.pid
      		and si.codcamo=SYNTHESE_FIN.codcamo
      		and si.cafi=SYNTHESE_FIN.cafi
      		and si.codsgress=SYNTHESE_FIN.codsgress
      		)
      	WHERE annee=L_ANNEE;

      	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes SSII maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;

	-- ----------------------------------------------------------------------
	-- Etape 10 : alimentation des retours arrieres
	-- ----------------------------------------------------------------------
	L_STATEMENT := '* Etape 10 : alimentation des retours arrieres dans SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (A_CONSOJH_IM,A_CONSOFT_IM)=
	(select sum((nvl(a_consojh,0))),sum((nvl(a_consoft,0)))
		from stock_immo si,datdebex
		where si.cdeb < datdebex.moismens
     		and si.pid=SYNTHESE_FIN.pid
      		and si.codcamo=SYNTHESE_FIN.codcamo
      		and si.cafi=SYNTHESE_FIN.cafi
      		and si.codsgress=SYNTHESE_FIN.codsgress
      		)
      	WHERE annee=L_ANNEE;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;

	-- ----------------------------------------------------------------------
	-- Etape 11 : mise à jour de codsg et de cada
	-- ----------------------------------------------------------------------
	L_STATEMENT := '* Etape 11 : mise à jour de codsg et de cada';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN SET (codsg,cada)=
	(select l.codsg, p.cada
		from ligne_bip l , proj_info p
		where l.icpi = p.icpi
     		and l.pid=SYNTHESE_FIN.pid
      		)
      	WHERE annee=L_ANNEE;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes maj dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;


EXCEPTION
	when others then
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

END alim_synth_fin_immo ;


--***************************************************************************
-- Procédure d'alimentation de la table synthese_fin_bip
--***************************************************************************
PROCEDURE alim_synth_fin_bip(P_HFILE IN utl_file.file_type)   IS

L_PROCNAME  varchar2(16) := 'SYNTH_BIP';
L_STATEMENT varchar2(128);
L_ANNEE     number;


BEGIN

TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

 -- Année d'exercice
SELECT TO_NUMBER(TO_CHAR(datdebex, 'YYYY')) INTO L_ANNEE
FROM datdebex WHERE ROWNUM < 2;

-- on vide la table
L_STATEMENT := '* vide synthese_fin_bip de l annee courante';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	DELETE SYNTHESE_FIN_BIP
	WHERE annee = L_ANNEE;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans SYNTHESE_FIN_BIP';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
COMMIT;

-- on alimente la table de synthese avec les données contenues dans synthese_fin

L_STATEMENT := '* alimentation de synthese_fin_bip';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	INSERT INTO SYNTHESE_FIN_BIP
		(PID,
		ANNEE,
		CONSOFTSG_IM,
		CONSOFTSSII_IM,
  		CONSOSG_FI,
  		CONSOSSII_FI,
  		D_CONSOSG_FI,
  		D_CONSOSSII_FI,
  		M_CONSOSG_FI,
  		M_CONSOSSII_FI)
	  	(select PID,
	  		L_ANNEE ,
	  		NVL(SUM(CONSOFTSG_IM),0),
	  		NVL(SUM(CONSOFTSSII_IM),0),
	  		NVL(SUM(CONSOFTSG_FI + CONSOENVSG_NI + CONSOENVSG_IM),0) ,
	  		NVL(SUM(CONSOFTSSII_FI + CONSOENVSSII_NI + CONSOENVSSII_IM),0) ,
	  		NVL(SUM(D_CONSOFTSG_FI + D_CONSOENVSG_NI + D_CONSOENVSG_IM),0) ,
	  	 	NVL(SUM(D_CONSOFTSSII_FI + D_CONSOENVSSII_NI + D_CONSOENVSSII_IM),0) ,
	  		NVL(SUM(M_CONSOFTSG_FI + M_CONSOENVSG_NI + M_CONSOENVSG_IM),0) ,
	  		NVL(SUM(M_CONSOFTSSII_FI + M_CONSOENVSSII_NI + M_CONSOENVSSII_IM),0)
	  	 from SYNTHESE_FIN
	  	 where annee= L_ANNEE
	  	 group by PID
	  	 );

  	commit;
L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes inserees dans SYNTHESE_FIN_BIP';
TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );


	TRCLOG.TRCLOG( P_HFILE, 'Fin NORMALE de ' || L_PROCNAME);
EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;


END alim_synth_fin_bip;


--******************************************************************************
-- Procédure d'alimentation de la table SYNTHESE_FIN_RESS avec les donnees de stock_fi
--******************************************************************************
PROCEDURE alim_synth_fin_ress(P_HFILE           IN utl_file.file_type)   IS

L_RETCOD    number;
L_PROCNAME  varchar2(20) := 'ALIM_SYNT_FIN_RESS';
L_STATEMENT varchar2(128);
L_ANNEE     number;

BEGIN
	 TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

	 -- Année d'exercice
      	SELECT TO_NUMBER(TO_CHAR(datdebex, 'YYYY')) INTO L_ANNEE
      	FROM datdebex WHERE ROWNUM < 2;

	 -- on vide la table
	L_STATEMENT := '* vide synthese_fin_ress de l annee courante';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	Packbatch.DYNA_TRUNCATE('SYNTHESE_FIN_RESS');
	COMMIT;

	-- -------------------------------------------------------------
	-- Etape 1 : Insertion des lignes dans la table SYNTHESE_FIN_RESS
	-- --------------------------------------------------------------
	L_STATEMENT := '* Etape 1 : Insertion des lignes dans la table SYNTHESE_FIN';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	INSERT INTO SYNTHESE_FIN_RESS (ANNEE,
			PID,
			IDENT,
			CODCAMO,
			CAFI,
			CONSOJH_IM,
			CONSOJH_NI,
			CONSOFT,
			CONSOENV_IM,
			CONSOENV_NI,
			D_CONSOJH_IM,
			D_CONSOJH_NI,
			D_CONSOFT,
			D_CONSOENV_IM,
			D_CONSOENV_NI)
	(SELECT 	L_ANNEE,
      			s.pid,
      			s.ident,
      			s.codcamo,
      			s.cafi,
      			nvl(sum(s.consojhimmo),0),
      			nvl(sum(s.nconsojhimmo),0),
      			nvl(sum(s.consoft),0),
				nvl(sum(s.consoenvimmo),0),
				nvl(sum(s.nconsoenvimmo),0),
      			0,0,0,0,0
      	FROM		stock_fi s
      	GROUP BY    s.pid, s.ident, s.codcamo, s.cafi
	);

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table SYNTHESE_FIN_RESS';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;


	-- ----------------------------------------------------------------------
	-- Etape 2 : alimentation des champs concernant decembre N-1
	-- ----------------------------------------------------------------------
	L_STATEMENT := '* Etape 2 : alimentation des champs pour dec n-1 dans SYNTHESE_FIN_RESS';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );

	UPDATE SYNTHESE_FIN_RESS SET (D_CONSOJH_IM,
			D_CONSOJH_NI,
			D_CONSOFT,
			D_CONSOENV_IM,
			D_CONSOENV_NI)=
	(select 	nvl(sum(fi.consojhimmo),0),
      			nvl(sum(fi.nconsojhimmo),0),
      			nvl(sum(fi.consoft),0),
				nvl(sum(fi.consoenvimmo),0),
				nvl(sum(fi.nconsoenvimmo),0)
		from stock_fi fi
		where  to_number(to_char(fi.cdeb,'yyyy'))=(SYNTHESE_FIN_RESS.annee - 1)
		and to_number(to_char(fi.cdeb,'mm'))= 12
      		and fi.pid=SYNTHESE_FIN_RESS.pid
      		and fi.codcamo=SYNTHESE_FIN_RESS.codcamo
      		and fi.cafi=SYNTHESE_FIN_RESS.cafi
      		and fi.ident=SYNTHESE_FIN_RESS.ident
	)	;

	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes SG maj dans la table SYNTHESE_FIN_RESS';
	TRCLOG.TRCLOG( P_HFILE, L_STATEMENT );
	commit;


EXCEPTION
	when others then
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

END alim_synth_fin_ress ;

END PACKBATCH_SYNTH_FIN;
/
CREATE OR REPLACE PACKAGE pack_14mois AS


PROCEDURE sauve_14mois (p_chemin_fichier IN VARCHAR2, -- chemin du log
                        p_nom_fichier    IN VARCHAR2  -- nom du fichier de log
                       );

END pack_14mois;
/
CREATE OR REPLACE PACKAGE pack_activite AS

   -- Définition curseur sur la table activite

   TYPE activite_ViewType IS RECORD ( 	codsg  		ree_activites.codsg%TYPE,
					code_activite 	VARCHAR2(12),
					lib_activite 	VARCHAR2(60)
					);


   TYPE activiteCurType_Char IS REF CURSOR RETURN activite_ViewType;


   PROCEDURE insert_activite ( 	p_codsg 	IN VARCHAR2,
				p_code_activite IN VARCHAR2,
				p_lib_activite 	IN VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                                );

   PROCEDURE update_activite ( 	p_codsg 	IN VARCHAR2,
				p_code_activite IN VARCHAR2,
				p_lib_activite 	IN VARCHAR2,
				p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                              	);

   PROCEDURE delete_activite ( 	p_codsg 	IN VARCHAR2,
				p_code_activite IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2
                              	);

   PROCEDURE select_activite_liste ( 	p_codsg 	IN VARCHAR2,
   					p_global 	IN VARCHAR2,
                               		p_curactivite 	IN OUT activiteCurType_Char ,
                               		p_nbcurseur   	OUT INTEGER,
                               		p_message     	OUT VARCHAR2
                                	);

    PROCEDURE select_activite_act ( 	p_codsg 	IN VARCHAR2,
					p_code_activite IN VARCHAR2,
                               		p_curactivite 	IN OUT activiteCurType_Char ,
                               		p_nbcurseur   	OUT INTEGER,
                               		p_message     	OUT VARCHAR2
                                	);

END pack_activite;
/

CREATE OR REPLACE PACKAGE BODY pack_activite AS

  PROCEDURE insert_activite ( 	p_codsg 	IN VARCHAR2,
				p_code_activite IN VARCHAR2,
				p_lib_activite 	IN VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                              ) IS

     	l_msg VARCHAR2(1024);
     	l_activite_dpg NUMBER;
     	l_ressource_s NUMBER;
     	l_scenario NUMBER ;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

--Insert
	BEGIN

	SELECT count(*)
	INTO l_activite_dpg
	FROM ree_activites
	WHERE codsg = TO_NUMBER(p_codsg);

	IF (l_activite_dpg = 0) THEN

		INSERT INTO ree_activites
		    ( 	codsg,
			code_activite,
			lib_activite,
			type
	 		)
	         VALUES ( 	TO_NUMBER(p_codsg),
	         		'ABSENCES',
	         		'ABSENCES',
	         		'A'
			);

		INSERT INTO ree_activites
		    ( 	codsg,
			code_activite,
			lib_activite,
			type
	 		)
	         VALUES ( 	TO_NUMBER(p_codsg),
	         		'SST FOURNIE',
	         		'SOUS-TRAITANCE FOURNIE',
	         		'F'
			);


		BEGIN
		l_ressource_s := 0 ;
		l_scenario := 0 ;

		-- Insertion de la ressource sous-traitance reçue
		SELECT count(*)
		INTO l_ressource_s
		FROM ree_ressources
		WHERE codsg = TO_NUMBER(p_codsg)
		AND type = 'S';

		IF (l_ressource_s = 0) THEN
			INSERT INTO ree_ressources(CODSG,TYPE,IDENT,RNOM)
		       		VALUES(TO_NUMBER(p_codsg),'S',2,'SST RECUE');
		END IF ;

		-- Insertion du scénario officiel
		SELECT count(*)
		INTO l_scenario
		FROM ree_scenarios
		WHERE codsg = TO_NUMBER(p_codsg) ;

		IF (l_scenario = 0) THEN
			INSERT INTO ree_scenarios(CODSG,CODE_SCENARIO,LIB_SCENARIO,OFFICIEL)
		       		VALUES(TO_NUMBER(p_codsg),'OFFIC','Scénario officiel','O');
		END IF ;

		END;

	END IF;

	INSERT INTO ree_activites
	    ( 	codsg,
		code_activite,
		lib_activite,
		type
 		)
         VALUES ( 	TO_NUMBER(p_codsg),
         		p_code_activite,
         		p_lib_activite,
         		'N'
		);

     EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		pack_global.recuperer_message( 21005, NULL, NULL, NULL, l_msg);
               	p_message := l_msg;

        WHEN OTHERS THEN
               	raise_application_error( -20997, SQLERRM);
     END;

   END insert_activite;



   PROCEDURE update_activite ( 	p_codsg 	IN VARCHAR2,
				p_code_activite IN VARCHAR2,
				p_lib_activite 	IN VARCHAR2,
				p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                              ) IS

	l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- initialiser le message retour

	p_nbcurseur := 0;
	p_message := '';

	UPDATE ree_activites
	SET	lib_activite=p_lib_activite
	WHERE codsg = TO_NUMBER(p_codsg) and code_activite = p_code_activite;


	IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      	ELSE

	   pack_global.recuperer_message( 21007, '%s1', p_code_activite, NULL, l_msg);
	   p_message := l_msg;

      END IF;

   END update_activite;


   PROCEDURE delete_activite ( 	p_codsg 	IN VARCHAR2,
				p_code_activite IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2
                              ) IS


	l_msg VARCHAR2(1024);
      	referential_integrity EXCEPTION;
      	PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN

	DELETE FROM ree_activites
	WHERE codsg = TO_NUMBER(p_codsg) and code_activite = p_code_activite;

         EXCEPTION

		WHEN referential_integrity THEN

               -- habiller le msg erreur

               pack_global.recuperation_integrite(-2292);

		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE

	   pack_global.recuperer_message( 21008, '%s1', p_code_activite, NULL, l_msg);
	   p_message := l_msg;

      END IF;

   END delete_activite;



   PROCEDURE select_activite_liste ( 	p_codsg 	IN VARCHAR2,
   					p_global 	IN VARCHAR2,
                               		p_curactivite 	IN OUT activiteCurType_Char ,
                               		p_nbcurseur   	OUT INTEGER,
                               		p_message     	OUT VARCHAR2
                              		) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
	p_nbcurseur := 1;
      	p_message := '';

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_global)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

	BEGIN
        	OPEN   p_curactivite FOR
              	SELECT 	codsg,
              		code_activite,
              		lib_activite
              	FROM  ree_activites
              	WHERE codsg = TO_NUMBER(p_codsg) and type = 'N';

      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
       END;
        END IF;
     END IF;

     p_message := l_msg;

   END select_activite_liste;

   PROCEDURE select_activite_act ( 	p_codsg 	IN VARCHAR2,
					p_code_activite IN VARCHAR2,
                               		p_curactivite 	IN OUT activiteCurType_Char ,
                               		p_nbcurseur   	OUT INTEGER,
                               		p_message     	OUT VARCHAR2
                              		) IS

	l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

       -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN   p_curactivite FOR
              SELECT 	codsg,
              		code_activite,
              		lib_activite
              FROM  ree_activites
              WHERE codsg = TO_NUMBER(p_codsg) and code_activite = p_code_activite;


      EXCEPTION
	WHEN NO_DATA_FOUND THEN
		pack_global.recuperer_message( 21006, NULL, NULL, NULL, l_msg);
         	p_message := l_msg;
        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;

   END select_activite_act;

END pack_activite;
/
CREATE OR REPLACE PACKAGE pack_activite_ligne AS

   -- Définition curseur sur la table activite_ligne

   TYPE activite_ligne_ViewType IS RECORD ( 	codsg 		ree_activites.codsg%TYPE,
   						code_activite	ree_activites.code_activite%TYPE,
   						lib_activite 	VARCHAR2(4),
   						pid 		VARCHAR2(4),
						lib_pid 	VARCHAR2(30)
					);


   TYPE activite_ligneCurType_Char IS REF CURSOR RETURN activite_ligne_ViewType;

   FUNCTION str_act_ligne 	(	p_string     IN  VARCHAR2,
                           		p_occurence  IN  NUMBER
                          	  ) return VARCHAR2;


   PROCEDURE insert_activite_ligne ( 	p_string 	IN VARCHAR2,
                                	p_nbcurseur  	OUT INTEGER,
                                	p_message    	OUT VARCHAR2
                                );


   PROCEDURE select_activite_ligne ( 	p_codsg 		IN VARCHAR2,
   					p_code_activite		IN VARCHAR2,
   					p_global		IN VARCHAR2,
                               		p_curactivite_ligne 	IN OUT activite_ligneCurType_Char ,
                               		p_nbcurseur   		OUT INTEGER,
                               		p_message     		OUT VARCHAR2,
   					p_lib_activite		OUT VARCHAR2
                                );

   PROCEDURE select_ligne ( 	p_pid 		IN VARCHAR2,
   				p_pnom		OUT VARCHAR2
                           );

END pack_activite_ligne;
/

CREATE OR REPLACE PACKAGE BODY pack_activite_ligne AS


   FUNCTION str_act_ligne (	p_string     IN  VARCHAR2,
                           	p_occurence  IN  NUMBER
                          	) return VARCHAR2 IS
   pos1 NUMBER(6);
   pos2 NUMBER(6);
   str  VARCHAR2(111);

   BEGIN

      pos1 := INSTR(p_string,';',1,p_occurence);
      pos2 := INSTR(p_string,';',1,p_occurence+1);

      IF pos2 != 1 THEN
         str := SUBSTR( p_string, pos1+1, pos2-pos1-1);
         return str;
      ELSE
         return '0';
      END IF;

   END str_act_ligne;

  PROCEDURE insert_activite_ligne ( 	p_string 	IN VARCHAR2,
                                	p_nbcurseur  	OUT INTEGER,
                                	p_message    	OUT VARCHAR2
                              ) IS

   l_msg 		VARCHAR2(1024);
   l_cpt    		NUMBER(7);
   l_codsg  		ree_activites_ligne_bip.codsg%TYPE;
   l_code_activite    	ree_activites_ligne_bip.code_activite%TYPE;
   l_pid  		ree_activites_ligne_bip.pid%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message   := '';
      -- Prise en compte de l'année
      l_cpt       := 1;
      l_codsg := TO_NUMBER(pack_activite_ligne.str_act_ligne(p_string,l_cpt));
      -- Prise en compte de du clicode
      l_cpt       := 2;
      l_code_activite := pack_activite_ligne.str_act_ligne(p_string,l_cpt);
      -- Position de départ pour la boucle
      l_cpt       := 3;

	BEGIN
		delete from ree_activites_ligne_bip
		where codsg = l_codsg and code_activite = l_code_activite;
	END;

      WHILE l_cpt != 0 LOOP

	l_pid := pack_activite_ligne.str_act_ligne(p_string,l_cpt);

	IF l_pid != '-1' THEN
		BEGIN
		INSERT INTO ree_activites_ligne_bip (codsg, code_activite, pid)
		VALUES (l_codsg,
			l_code_activite,
			l_pid);
		END;
		l_cpt := l_cpt + 1;
         ELSE
            l_cpt :=0;
         END IF;
	 dbms_output.put_line('l_cpt:'||l_cpt);
      END LOOP;

   pack_global.recuperer_message( 20366 , '%s1', 'Activité - Lignes BIP rattachées', '', p_message);

   END insert_activite_ligne;

   PROCEDURE select_activite_ligne ( 	p_codsg 		IN VARCHAR2,
   					p_code_activite		IN VARCHAR2,
   					p_global		IN VARCHAR2,
                               		p_curactivite_ligne 	IN OUT activite_ligneCurType_Char ,
                               		p_nbcurseur   		OUT INTEGER,
                               		p_message     		OUT VARCHAR2,
   					p_lib_activite		OUT VARCHAR2
                              		) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
	p_nbcurseur := 1;
      	p_message := '';

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_global)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

	BEGIN
        	OPEN   p_curactivite_ligne FOR
              	SELECT 	lpad(to_char(ral.CODSG), 7,'0'),
			ral.CODE_ACTIVITE,
			ral.LIB_ACTIVITE,
              		ralb.pid,
              		lb.pnom
              	FROM  	ree_activites ral,
              		ree_activites_ligne_bip ralb,
              		ligne_bip lb
              	WHERE ral.codsg = TO_NUMBER(p_codsg)
              	and ral.type = 'N'
              	and ral.codsg = ralb.codsg
              	and ral.code_activite = ralb.code_activite
              	and ral.code_activite = p_code_activite
              	and ralb.pid = lb.pid;

      		EXCEPTION
      			WHEN NO_DATA_FOUND THEN
      				pack_global.recuperer_message(20901, NULL, NULL, NULL, l_msg);
				raise_application_error(-20901,l_msg);
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
       END;

       BEGIN
        	SELECT 	ral.lib_activite INTO p_lib_activite
              	FROM  	ree_activites ral
              	WHERE ral.codsg = TO_NUMBER(p_codsg)
              	and ral.type = 'N'
              	and ral.code_activite = p_code_activite;

      		EXCEPTION
      			WHEN NO_DATA_FOUND THEN
      				pack_global.recuperer_message(20901, NULL, NULL, NULL, l_msg);
				raise_application_error(-20901,l_msg);
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
       END;
        END IF;
     END IF;

     p_message := l_msg;

   END select_activite_ligne;

   PROCEDURE select_ligne ( 	p_pid 		IN VARCHAR2,
   				p_pnom		OUT VARCHAR2
                           ) IS

   BEGIN
        	SELECT 	pnom INTO p_pnom
              	FROM  	ligne_bip
              	WHERE pid = p_pid;

      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);

   END select_ligne;

END pack_activite_ligne;
/
CREATE OR REPLACE PACKAGE pack_actu AS

   -- Définition curseur sur la table actualite

   TYPE actualite_ViewType IS RECORD ( code_actu  actualite.code_actu%TYPE,
					titre actualite.titre%TYPE,
					texte actualite.texte%TYPE,
					date_affiche VARCHAR2(20),
					date_debut VARCHAR2(20),
					date_fin VARCHAR2(20),
					valide actualite.valide%TYPE,
					url actualite.url%TYPE,
					derniere_minute actualite.derniere_minute%TYPE,
					nom_fichier actualite.nom_fichier%TYPE,
					mime_fichier actualite.mime_fichier%TYPE,
					size_fichier actualite.size_fichier%TYPE

					 	);


   TYPE actualiteCurType_Char IS REF CURSOR RETURN actualite_ViewType;


   PROCEDURE insert_actualite (
					p_titre IN VARCHAR2,
					p_texte IN VARCHAR2,
					p_date_affiche IN VARCHAR2,
					p_date_debut IN VARCHAR2,
					p_date_fin IN VARCHAR2,
					p_valide IN VARCHAR2,
					p_url IN VARCHAR2,
					p_derniere_minute IN VARCHAR2,
					p_string_menus IN VARCHAR2,
					p_nom_fichier IN VARCHAR2,
					p_mime_fichier IN VARCHAR2,
					p_size_fichier IN VARCHAR2,
                                  	p_userid     	IN  VARCHAR2,
                                  	p_code_actu OUT VARCHAR2,
                                  	p_nbcurseur  	OUT INTEGER,
                                  	p_message    	OUT VARCHAR2
                                );

   PROCEDURE update_actualite ( 	p_code_actu IN VARCHAR2,
					p_titre IN VARCHAR2,
					p_texte IN VARCHAR2,
					p_date_affiche IN VARCHAR2,
					p_date_debut IN VARCHAR2,
					p_date_fin IN VARCHAR2,
					p_valide IN VARCHAR2,
					p_url IN VARCHAR2,
					p_derniere_minute IN VARCHAR2,
					p_string_menus IN VARCHAR2,
					p_nom_fichier IN VARCHAR2,
					p_mime_fichier IN VARCHAR2,
					p_size_fichier IN VARCHAR2,
					p_top_update_fichier IN VARCHAR2,
				  	p_userid     	IN  VARCHAR2,
				  	p_nbcurseur  	OUT INTEGER,
                                  	p_message    	OUT VARCHAR2
                              );

   PROCEDURE delete_actualite ( p_code_actu     IN  VARCHAR2,
                                  p_userid    IN  VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                              );

   PROCEDURE select_actualite ( p_code_actu	   IN VARCHAR2,
                                  p_userid         IN VARCHAR2,
                                  p_curactualite IN OUT actualiteCurType_Char ,
                                  p_nbcurseur         OUT INTEGER,
                                  p_message           OUT VARCHAR2
                                );

END pack_actu;
/

CREATE OR REPLACE PACKAGE BODY pack_actu AS

  PROCEDURE insert_actualite (
					p_titre IN VARCHAR2,
					p_texte IN VARCHAR2,
					p_date_affiche IN VARCHAR2,
					p_date_debut IN VARCHAR2,
					p_date_fin IN VARCHAR2,
					p_valide IN VARCHAR2,
					p_url IN VARCHAR2,
					p_derniere_minute IN VARCHAR2,
					p_string_menus IN VARCHAR2,
					p_nom_fichier IN VARCHAR2,
					p_mime_fichier IN VARCHAR2,
					p_size_fichier IN VARCHAR2,
                                  	p_userid	IN VARCHAR2,
                                  	p_code_actu OUT VARCHAR2,
                                  	p_nbcurseur	OUT INTEGER,
                                  	p_message	OUT VARCHAR2
                              ) IS

     l_msg VARCHAR2(1024);
     l_msg_alert VARCHAR2(1024);
     l_code_actu actualite.code_actu%TYPE;
 	l_string_menus VARCHAR2(1000);
	l_menu VARCHAR2(1000);
     l_count number;




   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

---------------------------------------------------------------------------
-- La date de debut est toujours inférieure à la date de fin
---------------------------------------------------------------------------
 	BEGIN
	 IF to_date(p_date_debut,'DD/MM/YYYY') > to_date(p_date_fin,'DD/MM/YYYY') THEN
         pack_global.recuperer_message( 20366 , '%s1', 'date incompatible', '', l_msg);
         raise_application_error(-20366, l_msg);
      	END IF;
	END;


--Insert
	BEGIN


	select max(code_actu)+1 into l_code_actu
		from actualite;
	if l_code_actu is null then l_code_actu :=1;
	end if ;
	p_code_actu := l_code_actu;

     	   INSERT INTO actualite
	    ( code_actu,
		titre,
		texte,
		date_affiche,
		date_debut,
		date_fin,
		valide,
		url,
		fichier,
		nom_fichier,
		mime_fichier,
		size_fichier,
		derniere_minute
 		)
         VALUES ( TO_NUMBER(l_code_actu),
         		p_titre,
         		p_texte,
         		to_date(p_date_affiche,'DD/MM/YYYY'),
         		to_date(p_date_debut,'DD/MM/YYYY'),
         		to_date(p_date_fin,'DD/MM/YYYY'),
         		p_valide,
         		p_url,
         		empty_blob(),
         		p_nom_fichier,
         		p_mime_fichier,
         		to_number(p_size_fichier),
         		p_derniere_minute

		);


	   	-- 'Actualité  p_code_actu créée'

		-- et  si derniere minute ne doit chevaucher avec un autre profil


	 IF p_derniere_minute = 'O' THEN
        	select count (*) into l_count
		from
		actualite a,
		lien_profil_actu l
		where
		derniere_minute=p_derniere_minute
		and a.code_actu = l.code_actu
		and
		((p_date_debut between date_debut and date_fin)
		or  (p_date_fin between date_debut and date_fin)
		or (date_debut between p_date_debut and p_date_fin)
		or  (date_fin between p_date_debut and p_date_fin))
		AND INSTR( p_string_menus, l.CODE_PROFIL)>0;
         	IF l_count > 0 then
         		pack_global.recuperer_message( 20366 , '%s1', 'Attention l actualite créée chevauche une autre actualite de type derniere minute', '', l_msg);
	  		p_message:=l_msg;
         	else
        	 	pack_global.recuperer_message( 21000, '%s1', p_code_actu, NULL, l_msg);
			p_message:=l_msg;
         	end if;
      	else
         	pack_global.recuperer_message( 21000, '%s1', p_code_actu, NULL, l_msg);
		p_message:=l_msg;
	END IF;



     EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		   pack_global.recuperer_message( 21001, NULL, NULL, NULL, l_msg);
               raise_application_error( -21001, l_msg );

            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);
     END;
	BEGIN

		l_string_menus := p_string_menus;
		if (l_string_menus is not null or l_string_menus != '') THEN
		LOOP
		l_menu := SUBSTR(l_string_menus,1,INSTR( l_string_menus, ',', 1, 1)-1);
		INSERT INTO LIEN_PROFIL_ACTU
		    ( code_actu,
		      code_profil
			)
     	    VALUES ( TO_NUMBER(l_code_actu),
      	   		LOWER(l_menu)
			);


		l_string_menus := SUBSTR(l_string_menus,INSTR( l_string_menus, ',', 1, 1)+1);
		EXIT WHEN l_string_menus is null;
		END LOOP;
		END IF;
		EXCEPTION
		WHEN OTHERS THEN
		        raise_application_error( -21002, l_msg );
		END;
   END insert_actualite;



   PROCEDURE update_actualite ( 	p_code_actu IN VARCHAR2,
					p_titre IN VARCHAR2,
					p_texte IN VARCHAR2,
					p_date_affiche IN VARCHAR2,
					p_date_debut IN VARCHAR2,
					p_date_fin IN VARCHAR2,
					p_valide IN VARCHAR2,
					p_url IN VARCHAR2,
					p_derniere_minute IN VARCHAR2,
					p_string_menus IN VARCHAR2,
					p_nom_fichier IN VARCHAR2,
					p_mime_fichier IN VARCHAR2,
					p_size_fichier IN VARCHAR2,
					p_top_update_fichier IN VARCHAR2,
				  	p_userid     	IN  VARCHAR2,
				  	p_nbcurseur  	OUT INTEGER,
                                  	p_message    	OUT VARCHAR2
                              ) IS

	l_msg VARCHAR2(1024);
	l_string_menus VARCHAR2(1000);
	l_menu VARCHAR2(1000);
	l_count NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- initialiser le message retour

	p_nbcurseur := 0;
	p_message := '';


	BEGIN
	 IF to_date(p_date_debut,'DD/MM/YYYY') > to_date(p_date_fin,'DD/MM/YYYY') THEN
         pack_global.recuperer_message( 20366 , '%s1', 'date incompatible', '', l_msg);
         raise_application_error(-20366, l_msg);
      	END IF;
	END;

	BEGIN

	l_string_menus := p_string_menus;
	DELETE FROM LIEN_PROFIL_ACTU
	WHERE code_actu = TO_NUMBER(p_code_actu);

	if (l_string_menus is not null or l_string_menus != '') THEN
	LOOP
	l_menu := SUBSTR(l_string_menus,1,INSTR( l_string_menus, ',', 1, 1)-1);
	INSERT INTO LIEN_PROFIL_ACTU
	    ( code_actu,
	      code_profil
		)
         VALUES ( TO_NUMBER(p_code_actu),
         		LOWER(l_menu)
		);

	l_string_menus := SUBSTR(l_string_menus,INSTR( l_string_menus, ',', 1, 1)+1);
	EXIT WHEN l_string_menus is null;
	END LOOP;
	END IF;
	EXCEPTION
	WHEN OTHERS THEN
	        raise_application_error( -21002, l_msg );
	END;


	BEGIN


         UPDATE actualite
		SET	 		titre=p_titre,
					texte=p_texte,
					date_affiche=to_date(p_date_affiche,'DD/MM/YYYY'),
					date_debut=to_date(p_date_debut,'DD/MM/YYYY'),
					date_fin=to_date(p_date_fin,'DD/MM/YYYY'),
					valide=p_valide,
					url=p_url,
					derniere_minute=p_derniere_minute
		  WHERE code_actu 	= TO_NUMBER(p_code_actu);
          IF (p_top_update_fichier != 'N') THEN
          UPDATE actualite
		SET	 		nom_fichier=p_nom_fichier,
					mime_fichier=p_mime_fichier,
					size_fichier = to_number(p_size_fichier)

		  WHERE code_actu 	= TO_NUMBER(p_code_actu);
	END IF;
	   EXCEPTION

		WHEN OTHERS THEN
	        raise_application_error( -21002, l_msg );

	--	   raise_application_error( -20997, SQLERRM);
	END;


      	IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	 pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE

 -- 'Le pôle p_code_actu a été modifié'
	 IF p_derniere_minute = 'O' THEN
        	select count (*) into l_count
		from
		actualite a,
		lien_profil_actu l
		where
		derniere_minute=p_derniere_minute
		and a.code_actu = l.code_actu
		and a.code_actu <> p_code_actu
		and
		((p_date_debut between date_debut and date_fin)
		or  (p_date_fin between date_debut and date_fin)
		or (date_debut between p_date_debut and p_date_fin)
		or  (date_fin between p_date_debut and p_date_fin))
		AND INSTR( p_string_menus, l.CODE_PROFIL)>0;
         	IF l_count > 0 then
         		pack_global.recuperer_message( 20366 , '%s1', 'Attention l actualite modifiée chevauche une autre actualite de type derniere minute', '', l_msg);
	  		p_message:=l_msg;
         	else
        	 	pack_global.recuperer_message( 21003, '%s1', p_code_actu, NULL, l_msg);
	   		p_message:=l_msg;
         	end if;
      	else
         	pack_global.recuperer_message( 21003, '%s1', p_code_actu, NULL, l_msg);
	   	p_message:=l_msg;
	END IF;
	   -- 'Le pôle p_code_actu a été modifié'

	  -- pack_global.recuperer_message( 21003, '%s1', p_code_actu, NULL, l_msg);
	  -- p_message:=l_msg;



      END IF;

   END update_actualite;


   PROCEDURE delete_actualite ( p_code_actu     IN  VARCHAR2,

                                  p_userid    IN  VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                              ) IS


	l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN

	   DELETE FROM actualite
		    WHERE code_actu = TO_NUMBER(p_code_actu)
			;

         EXCEPTION

		WHEN referential_integrity THEN

               -- habiller le msg erreur

               pack_global.recuperation_integrite(-2292);

		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE

	   -- 'Le pôle p_code_actu a été supprimé'

	   pack_global.recuperer_message( 21004, '%s1', p_code_actu, NULL, l_msg);
	   p_message := l_msg;

      END IF;

   END delete_actualite;



   PROCEDURE select_actualite ( p_code_actu      IN VARCHAR2,
                                  p_userid       IN VARCHAR2,
                                  p_curactualite IN OUT actualiteCurType_Char,
                                  p_nbcurseur    OUT INTEGER,
                                 p_message      OUT VARCHAR2
                              ) IS

	l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';



-- dbms_output.put_line('p_code_actu = ' || p_code_actu || ' --- p_userid = ' || p_userid );

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN   p_curactualite FOR
              SELECT 	code_actu,
              titre,
              texte,
		to_char(date_affiche,'DD/MM/YYYY'),
		to_char(date_debut,'DD/MM/YYYY'),
		to_char(date_fin,'DD/MM/YYYY'),
		valide,
		url,
		derniere_minute,
		nom_fichier,
		mime_fichier,
		size_fichier

              FROM  actualite
              WHERE code_actu = TO_NUMBER(p_code_actu);

         -- en cas absence
	   -- 'Actualité p_code_actu inexistant'

         pack_global.recuperer_message( 21002, '%s1', p_code_actu, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION

        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;

   END select_actualite;

END pack_actu;
/
CREATE OR REPLACE PACKAGE pack_agence AS

   TYPE agenceCurType IS REF CURSOR RETURN agence%ROWTYPE;

   PROCEDURE insert_agence ( p_soccode   IN agence.soccode%TYPE,
                             p_socfour   IN agence.socfour%TYPE,
			     p_socflib   IN agence.socflib%TYPE,
                             p_global    IN VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            );

   PROCEDURE update_agence ( p_soccode      IN agence.soccode%TYPE,
                             p_socfour      IN agence.socfour%TYPE,
                             p_socfour_sav  IN agence.socfour%TYPE,
			     p_socflib      IN agence.socflib%TYPE,
                             p_flaglock     IN NUMBER,
                             p_global       IN VARCHAR2,
                             p_nbcurseur    OUT INTEGER,
                             p_message      OUT VARCHAR2
                           );

   PROCEDURE delete_agence ( p_soccode   IN agence.soccode%TYPE,
                             p_socfour   IN agence.socfour%TYPE,
		             p_socflib   IN agence.socflib%TYPE,
                             p_flaglock  IN NUMBER,
                             p_global    IN VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                           );

   PROCEDURE select_agence ( p_soccode   IN agence.soccode%TYPE,
                             p_socfour   IN agence.socfour%TYPE,
                             p_global    IN VARCHAR2,
                             p_curAgence IN OUT agenceCurType,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            );

END pack_agence;
/

CREATE OR REPLACE PACKAGE BODY pack_agence AS

   PROCEDURE insert_agence ( p_soccode   IN agence.soccode%TYPE,
                             p_socfour   IN agence.socfour%TYPE,
			     p_socflib   IN agence.socflib%TYPE,
                             p_global    IN VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            ) IS
      -- Variables locales

      l_msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO agence ( soccode,
                              socfour,
		   		      socflib)
         VALUES ( p_soccode,
			p_socfour,
                  p_socflib
                );

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN

	      -- 'Code fournisseur déjà créé.'

            pack_global.recuperer_message( 20307, NULL, NULL, NULL, l_msg);

            raise_application_error( -20307, l_msg);

	   WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      -- 'Le fournisseur ' || p_socflib || ' a été créé.';

      pack_global.recuperer_message( 3004, '%s1', p_socflib,
                                     NULL, l_msg);
      p_message := l_msg;

   END insert_agence;


   PROCEDURE update_agence ( p_soccode     IN agence.soccode%TYPE,
                             p_socfour     IN agence.socfour%TYPE,
                             p_socfour_sav IN agence.socfour%TYPE,
			     p_socflib     IN agence.socflib%TYPE,
                             p_flaglock    IN NUMBER,
                             p_global      IN VARCHAR2,
                             p_nbcurseur   OUT INTEGER,
                             p_message     OUT VARCHAR2
                            ) IS
      -- Variables locales

      l_msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         UPDATE agence
         SET socfour  = p_socfour,
             socflib  = p_socflib,
             flaglock = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE ltrim(rtrim(socfour))= p_socfour_sav
         AND   soccode = p_soccode
         AND   flaglock = p_flaglock;

	EXCEPTION

         WHEN DUP_VAL_ON_INDEX THEN

	      -- 'Code fournisseur déjà créé.'
            pack_global.recuperer_message( 20307, NULL, NULL, NULL, l_msg);
            raise_application_error( -20307, l_msg);

	 WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         -- 'Accès concurrent'
         pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
	   -- message 'Le fournisseur %s1 a été modifié.'
         pack_global.recuperer_message( 3005, '%s1', p_socflib,
                                        NULL, l_msg);
         p_message := l_msg;
      END IF;
   END update_agence;

   PROCEDURE delete_agence ( p_soccode   IN agence.soccode%TYPE,
                             p_socfour   IN agence.socfour%TYPE,
		             p_socflib   IN agence.socflib%TYPE,
                             p_flaglock  IN NUMBER,
                             p_global    IN VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            ) IS
      l_msg   VARCHAR(1024);
      referential_integrity   EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM agence
         WHERE ltrim(rtrim(socfour)) = p_socfour
         AND   soccode  = p_soccode
         AND   flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

         -- 'Accès concurrent'

         pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);

         raise_application_error( -20999, l_msg );
      ELSE

	   -- 'Le fournisseur %s1 a été supprimé.'

         pack_global.recuperer_message( 3006, '%s1', p_socflib,
                                        NULL, l_msg);
         p_message := l_msg;
      END IF;

   END delete_agence;

   PROCEDURE select_agence ( p_soccode   IN agence.soccode%TYPE,
                             p_socfour   IN agence.socfour%TYPE,
                             p_global    IN VARCHAR2,
                             p_curAgence IN OUT agenceCurType,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            ) IS
      l_msg VARCHAR2( 1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      OPEN p_curAgence FOR
           SELECT *
           FROM agence
           WHERE socfour = p_socfour
           AND   soccode = p_soccode;

      -- en cas absence
      -- p_message := 'Code fournisseur inexistant.';
      -- Ce message est utilisé comme message APPLICATIF et
      -- message d'exception. => Il porte un numéro d'EXCEPTION

      pack_global.recuperer_message( 20308, NULL, NULL, NULL, l_msg);
      p_message := l_msg;

   END select_agence;

END pack_agence;
/
CREATE OR REPLACE PACKAGE pack_alphados AS

   -- ------------------------------------------------------------------------
  -- Nom        :  verif_alphados
  -- Auteur     :  Equipe SOPRA
  -- Decription :  vérifie l'existence de la chaine de caractere à rechercher
  -- Paramètres :  p_param6 (IN) VARCHAR2(50): libellé selectionné
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------
PROCEDURE  verif_alphados(p_param6 IN VARCHAR2,
			 p_message OUT VARCHAR2);


  -- ------------------------------------------------------------------------
  -- Nom        :  verif_alphaappli
  -- Auteur     : MMC
  -- Decription :  vérifie l'existence de la chaine de caractere à rechercher
  -- Paramètres :  p_param6 (IN) VARCHAR2(50): libellé selectionné
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------
PROCEDURE  verif_alphaappli(p_param6 IN VARCHAR2,
			 p_message OUT VARCHAR2);

 -- ------------------------------------------------------------------------
  -- Nom        :  verif_alphaproj
  -- Auteur     : MMC
  -- Decription :  vérifie l'existence de la chaine de caractere à rechercher
  -- Paramètres :  p_param6 (IN) VARCHAR2(50): libellé selectionné
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------
PROCEDURE  verif_alphaproj(p_param6 IN VARCHAR2,
			 p_message OUT VARCHAR2);
END pack_alphados;
/

CREATE OR REPLACE PACKAGE BODY pack_alphados AS
   -- ------------------------------------------------------------------------
  -- Nom        :  verif_libelle
  -- Auteur     :  Equipe SOPRA
  -- Decription :  vérifie l'existence de la chaine de caractere à rechercher
  -- Paramètres :  p_param6 (IN) VARCHAR2(50): libellé selectionné
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------

PROCEDURE  verif_alphados(p_param6 IN VARCHAR2,
			 p_message OUT VARCHAR2) IS
   l_msg VARCHAR2(1024) :='';
   l_ret VARCHAR2(50);
BEGIN

-- replace(p_param6,''',' ')
	SELECT  count(dplib)     INTO l_ret
	FROM dossier_projet
	WHERE  upper( dplib) like upper('%'||p_param6||'%' );
if l_ret<1 then
	pack_global.recuperer_message(20316, NULL, NULL, 'p_param6', l_msg);
      	p_message := l_msg;
      	raise_application_error(-20316, l_msg);
	else
	p_message := l_msg;
end if;


EXCEPTION
   WHEN no_data_found then
      pack_global.recuperer_message(20316, NULL, NULL, 'p_param6', l_msg);
      p_message := l_msg;
      raise_application_error(-20316, l_msg);
      p_message := l_msg;
END verif_alphados;

/*
 PROCEDURE qui recherche une chaine de  caractere dans le libelle d'une application
*/
PROCEDURE  verif_alphaappli(p_param6 IN VARCHAR2,
			 p_message OUT VARCHAR2) IS
   l_msg VARCHAR2(1024) :='';
   l_ret VARCHAR2(50);
BEGIN

-- replace(p_param6,''',' ')
	SELECT  count(alibel)     INTO l_ret
	FROM application
	WHERE  upper( alibel) like upper('%'||p_param6||'%' );
if l_ret<1 then
	pack_global.recuperer_message(20316, NULL, NULL, 'p_param6', l_msg);
      	p_message := l_msg;
      	raise_application_error(-20316, l_msg);
	else
	p_message := l_msg;
end if;


EXCEPTION
   WHEN no_data_found then
      pack_global.recuperer_message(20316, NULL, NULL, 'p_param6', l_msg);
      p_message := l_msg;
      raise_application_error(-20316, l_msg);
      p_message := l_msg;
END verif_alphaappli;

/*
 PROCEDURE qui recherche une chaine de  caractere dans le libelle d'un projet
*/
PROCEDURE  verif_alphaproj(p_param6 IN VARCHAR2,
			 p_message OUT VARCHAR2) IS
   l_msg VARCHAR2(1024) :='';
   l_ret VARCHAR2(50);
BEGIN

-- replace(p_param6,''',' ')
	SELECT  count(ilibel)     INTO l_ret
	FROM proj_info
	WHERE  upper( ilibel) like upper('%'||p_param6||'%' );
if l_ret<1 then
	pack_global.recuperer_message(20316, NULL, NULL, 'p_param6', l_msg);
      	p_message := l_msg;
      	raise_application_error(-20316, l_msg);
	else
	p_message := l_msg;
end if;


EXCEPTION
   WHEN no_data_found then
      pack_global.recuperer_message(20316, NULL, NULL, 'p_param6', l_msg);
      p_message := l_msg;
      raise_application_error(-20316, l_msg);
      p_message := l_msg;
END verif_alphaproj;


END pack_alphados;
/
CREATE OR REPLACE PACKAGE pack_appli AS

------------------------------------------------------------
-- Cette procedure modifie les donnees concernant le niveau
-- present dans la situation de la ressource
------------------------------------------------------------
	PROCEDURE alim_appli;

END pack_appli;
/

CREATE OR REPLACE PACKAGE BODY pack_appli AS

PROCEDURE alim_appli IS

	L_STATEMENT varchar2(64);
BEGIN

--on vide la table des erreurs
L_STATEMENT := 'On vide la table temporaire';
DELETE FROM  TMP_APPLI_REJET;
COMMIT;
TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'lignes supprimees');
--Gestion des anomalies : A inserer dans une TABLE des erreurs


/*L_STATEMENT := 'Insertion dans table temporaire pour code MO inexistant';
-- le code client MO n'existe pas dans la Bip
INSERT INTO TMP_APPLI_REJET
	(SELECT DISTINCT a.AIRT ,a.ALIBEL,a.ALIBCOURT ,a.AMNEMO ,a.ACDAREG ,a.CODSG ,a.ACME ,a.CLICODE ,a.AMOP ,a.CODGAPPLI ,a.AGAPPLI,
 			a.ADESCR1 ,a.ADESCR2 ,a.ADESCR3,a.ADESCR4,a.ADESCR5,a.ADESCR6,'Code client MO inexistant'
	 FROM TMP_APPLI a
 	 WHERE NOT EXISTS (SELECT 1 FROM CLIENT_MO c WHERE c.clicode=a.clicode)
 	 AND a.clicode is not null
 	 AND a.clicode <> 'S.O.'
 	 AND a.clicode <> 'S.O'
);
COMMIT;
TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'lignes inserees');

L_STATEMENT := 'Insertion dans table temporaire pour code gest inexistant';
-- le code gestionnaire n'existe pas dans la Bip
INSERT INTO TMP_APPLI_REJET
	(SELECT DISTINCT a.AIRT ,a.ALIBEL,a.ALIBCOURT ,a.AMNEMO ,a.ACDAREG ,a.CODSG ,a.ACME ,a.CLICODE ,a.AMOP ,a.CODGAPPLI ,a.AGAPPLI,
 			a.ADESCR1 ,a.ADESCR2 ,a.ADESCR3,a.ADESCR4,a.ADESCR5,a.ADESCR6,'Code gestionnaire inexistant'
	 FROM TMP_APPLI a
 	 WHERE NOT EXISTS (SELECT 1 FROM CLIENT_MO c WHERE c.clicode=a.CODGAPPLI)
 	 AND a.CODGAPPLI is not null
 	 AND a.CODGAPPLI <> 'S.O.'
 	 AND a.CODGAPPLI <> 'S.O'
);
COMMIT;
TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'lignes inserees');

L_STATEMENT := 'Insertion dans table temporaire pour code DPG inexistant';
-- le code DPG n'existe pas dans la Bip
INSERT INTO TMP_APPLI_REJET
	(SELECT DISTINCT a.AIRT ,a.ALIBEL,a.ALIBCOURT ,a.AMNEMO ,a.ACDAREG ,a.CODSG ,a.ACME ,a.CLICODE ,a.AMOP ,a.CODGAPPLI ,a.AGAPPLI,
 			a.ADESCR1 ,a.ADESCR2 ,a.ADESCR3,a.ADESCR4,a.ADESCR5,a.ADESCR6,'Code DPG inexistant'
	 FROM TMP_APPLI a
 	 WHERE NOT EXISTS (SELECT 1 FROM STRUCT_INFO s WHERE to_char(s.codsg)=a.codsg)
 	 AND a.CODSG is not null
 	 AND a.CODSG <> 'S.O.'
 	 AND a.CODSG <> 'S.O'
 	 );
COMMIT;
TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'lignes inserees');
*/

L_STATEMENT := 'Insertion dans table temporaire pour code appli reg inexistant';
-- le code application de regroupement n'existe pas dans la Bip
INSERT INTO TMP_APPLI_REJET
	(SELECT DISTINCT a.AIRT ,
		replace(replace(a.ALIBEL,'"',' '),';','.'),
		a.ALIBCOURT ,a.AMNEMO ,a.ACDAREG ,a.CODSG ,a.ACME ,a.CLICODE ,a.AMOP ,a.CODGAPPLI ,a.AGAPPLI,
 		replace(replace(a.ADESCR1,'"',' '),';','.'),
		replace(replace(a.ADESCR2,'"',' '),';','.'),
		replace(replace(a.ADESCR3,'"',' '),';','.'),
		replace(replace(a.ADESCR4,'"',' '),';','.'),
		replace(replace(a.ADESCR5,'"',' '),';','.'),
		replace(replace(a.ADESCR6,'"',' '),';','.'),
		'Code appli regroupement inexistant'
	 FROM TMP_APPLI a
 	 WHERE NOT EXISTS (SELECT 1 FROM APPLICATION ap WHERE ap.airt=a.acdareg)
 	 AND a.ACDAREG is not null
 	 AND a.ACDAREG <> 'S.O.'
 	 AND a.ACDAREG <> 'S.O'
 	 AND a.airt <> a.acdareg
 	 );
COMMIT;
TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'lignes inserees');

L_STATEMENT := 'Suppression codes appli regroupement errones';
DELETE FROM TMP_APPLI a
	 WHERE a.airt in (SELECT rej.airt from tmp_appli_rejet rej where rej.rejet='Code appli regroupement inexistant')
	;
	COMMIT;
	TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'ligens supprimees');


BEGIN
	L_STATEMENT := 'Mise à jour de APPLICATION';
	UPDATE application ap
		SET (ALIBEL,ALIBCOURT ,AMNEMO ,ACDAREG ,ACME , AMOP,AGAPPLI,
 			ADESCR1 ,ADESCR2 ,ADESCR3,ADESCR4,ADESCR5,ADESCR6) =
 		(SELECT	replace(replace(a.ALIBEL,'"',' '),';','.'),
 		a.ALIBCOURT ,a.AMNEMO ,nvl(a.ACDAREG,a.airt),a.ACME,a.AMOP,a.AGAPPLI,
 		replace(replace(a.ADESCR1,'"',' '),';','.'),
		replace(replace(a.ADESCR2,'"',' '),';','.'),
		replace(replace(a.ADESCR3,'"',' '),';','.'),
		replace(replace(a.ADESCR4,'"',' '),';','.'),
		replace(replace(a.ADESCR5,'"',' '),';','.'),
		replace(replace(a.ADESCR6,'"',' '),';','.')
 			FROM TMP_APPLI a
 			WHERE a.airt=ap.airt
 			)
 		WHERE ap.airt IN (SELECT t.airt FROM TMP_APPLI t,application ap WHERE t.airt=ap.airt)
 		;
		COMMIT;
	TRCLOG.TRCLOG(null,  L_STATEMENT || ' : ' || sql%rowcount || ' lignes maj' );

	L_STATEMENT := 'Insertion dans APPLICATION';
	--Le code appli n existe pas, on le crée
	INSERT INTO application (AIRT ,ALIBEL,ALIBCOURT ,AMNEMO ,ACDAREG ,ACME ,AMOP ,AGAPPLI,ADESCR1 ,ADESCR2 ,ADESCR3,ADESCR4,ADESCR5,ADESCR6,FLAGLOCK)
		 (SELECT a.AIRT,
		 replace(replace(a.ALIBEL,'"',' '),';','.'),
		 a.ALIBCOURT,a.AMNEMO ,nvl(a.ACDAREG,a.AIRT),a.ACME,a.AMOP ,a.AGAPPLI,
		 replace(replace(a.ADESCR1,'"',' '),';','.'),
		replace(replace(a.ADESCR2,'"',' '),';','.'),
		replace(replace(a.ADESCR3,'"',' '),';','.'),
		replace(replace(a.ADESCR4,'"',' '),';','.'),
		replace(replace(a.ADESCR5,'"',' '),';','.'),
		replace(replace(a.ADESCR6,'"',' '),';','.'),0
		 FROM TMP_APPLI a
 			WHERE NOT EXISTS (select 1 from application ap WHERE ap.airt=a.airt)
 		);
		COMMIT;
	TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'lignes inserees');

	/*L_STATEMENT := 'Maj code MO dans APPLICATION';
	-- avec client MO inexistant
	UPDATE application ap
		SET (CLICODE) =
 		(SELECT	decode(err.rejet,'Code client MO inexistant',null,decode(a.clicode,'S.O.',null,decode(a.clicode,'S.O',null,a.CLICODE)))
 			FROM TMP_APPLI a, TMP_APPLI_REJET err
 			WHERE a.airt=ap.airt
 			AND a.airt=err.airt (+)
 			AND err.rejet(+)='Code client MO inexistant'
 			)
 		WHERE ap.airt IN (SELECT t.airt FROM TMP_APPLI t,application ap WHERE t.airt=ap.airt)
 		;
		COMMIT;
	TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'lignes maj');

	L_STATEMENT := 'Maj code gestionnaire dans APPLICATION';
	-- avec code gestionnaire inexistant
	UPDATE application ap
		SET (CODGAPPLI) =
 		(SELECT	decode(err.rejet,'Code gestionnaire inexistant',null,decode(a.codgappli,'S.O.',null,decode(a.codgappli,'S.O',null,a.CODGAPPLI)))
 			FROM TMP_APPLI a, TMP_APPLI_REJET err
 			WHERE a.airt=ap.airt
 			AND a.airt=err.airt (+)
 			AND err.rejet(+)='Code gestionnaire inexistant'
 			)
 		WHERE ap.airt IN (SELECT t.airt FROM TMP_APPLI t,application ap WHERE t.airt=ap.airt)
 		;
		COMMIT;
	TRCLOG.TRCLOG(null,  L_STATEMENT ||'-'|| sql%rowcount || 'lignes maj');
	*/

	END;
END alim_appli;



END pack_appli;
/
CREATE OR REPLACE PACKAGE pack_application AS



   TYPE applicationCurType IS REF CURSOR RETURN application%ROWTYPE;



   PROCEDURE insert_application (p_airt      IN  application.airt%TYPE,
                                 p_alibel    IN  application.alibel%TYPE,
				 p_alibcourt IN  application.alibcourt%TYPE,
                                 p_adescr1   IN  application.adescr1%TYPE,
                                 p_adescr2   IN  application.adescr2%TYPE,
                                 p_adescr3   IN  application.adescr3%TYPE,
                                 p_adescr4   IN  application.adescr4%TYPE,
                                 p_adescr5   IN  application.adescr5%TYPE,
                                 p_adescr6   IN  application.adescr6%TYPE,
                                 p_clicode   IN  application.clicode%TYPE,
                                 p_amop      IN  application.amop%TYPE,
                                 p_codsg     IN  VARCHAR2,
                                 p_acme      IN  application.acme%TYPE,
                                 p_codgappli IN  application.codgappli%TYPE,
                                 p_agappli   IN  application.agappli%TYPE,
                                 p_amnemo    IN  application.amnemo%TYPE,
                                 p_acdareg   IN  application.acdareg%TYPE,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );



   PROCEDURE update_application (p_airt      IN  application.airt%TYPE,
                                 p_alibel    IN  application.alibel%TYPE,
				 p_alibcourt IN  application.alibcourt%TYPE,
                                 p_adescr1   IN  application.adescr1%TYPE,
                                 p_adescr2   IN  application.adescr2%TYPE,
                                 p_adescr3   IN  application.adescr3%TYPE,
                                 p_adescr4   IN  application.adescr4%TYPE,
                                 p_adescr5   IN  application.adescr5%TYPE,
                                 p_adescr6   IN  application.adescr6%TYPE,
                                 p_clicode   IN  application.clicode%TYPE,
                                 p_amop      IN  application.amop%TYPE,
                                 p_codsg     IN  VARCHAR2,
                                 p_acme      IN  application.acme%TYPE,
                                 p_codgappli IN  application.codgappli%TYPE,
                                 p_agappli   IN  application.agappli%TYPE,
				 p_amnemo    IN  application.amnemo%TYPE,
                                 p_acdareg   IN  application.acdareg%TYPE,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );



   PROCEDURE delete_application (p_airt      IN  application.airt%TYPE,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );



   PROCEDURE select_application (p_airt           IN application.airt%TYPE,
                                 p_userid         IN VARCHAR2,
                                 p_curapplication IN OUT applicationCurType,
                                 p_nbcurseur         OUT INTEGER,
                                 p_message           OUT VARCHAR2
                                );
END pack_application;
/

CREATE OR REPLACE PACKAGE BODY pack_application AS



   PROCEDURE insert_application (p_airt      IN  application.airt%TYPE,
                                 p_alibel    IN  application.alibel%TYPE,
				 p_alibcourt IN  application.alibcourt%TYPE,
                                 p_adescr1   IN  application.adescr1%TYPE,
                                 p_adescr2   IN  application.adescr2%TYPE,
                                 p_adescr3   IN  application.adescr3%TYPE,
                                 p_adescr4   IN  application.adescr4%TYPE,
                                 p_adescr5   IN  application.adescr5%TYPE,
                                 p_adescr6   IN  application.adescr6%TYPE,
                                 p_clicode   IN  application.clicode%TYPE,
                                 p_amop      IN  application.amop%TYPE,
                                 p_codsg     IN  VARCHAR2,
                                 p_acme      IN  application.acme%TYPE,
                                 p_codgappli IN  application.codgappli%TYPE,
                                 p_agappli   IN  application.agappli%TYPE,
                                 p_amnemo    IN  application.amnemo%TYPE,
                                 p_acdareg   IN  application.acdareg%TYPE,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);


   BEGIN


      -- Positionner le nb de curseurs ==> 0

      -- Initialiser le message retour


      p_nbcurseur := 0;

      p_message := '';


      BEGIN
         INSERT INTO application (acme,
				  amnemo,
                                  adescr1,
                                  adescr2,
                                  adescr3,
                                  adescr4,
                                  adescr5,
                                  adescr6,
                                  agappli,
                                  airt,
                                  alibel,
                                  amop,
                                  clicode,
                                  codgappli,
                                  codsg,
                                  alibcourt,
                                  acdareg
                                 )
                VALUES (p_acme,
			p_amnemo,
                        p_adescr1,
                        p_adescr2,
                        p_adescr3,
                        p_adescr4,
                        p_adescr5,
                        p_adescr6,
                        p_agappli,
                        p_airt,
                        p_alibel,
                        p_amop,
                        p_clicode,
                        p_codgappli,
                        TO_NUMBER(p_codsg),
                        p_alibcourt,
                        p_acdareg
                       );


         -- 'L'application ' || p_airt || ' a été créé.';


         pack_global.recuperer_message(2024,'%s1',p_airt, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message(20205, NULL, NULL, NULL, l_msg);
            raise_application_error( -20205, l_msg );
         WHEN referential_integrity THEN
            -- habiller le msg erreur
            pack_global.recuperation_integrite(-2291);


          WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;
   END insert_application;




   PROCEDURE update_application (p_airt      IN  application.airt%TYPE,
                                 p_alibel    IN  application.alibel%TYPE,
				 p_alibcourt IN  application.alibcourt%TYPE,
                                 p_adescr1   IN  application.adescr1%TYPE,
                                 p_adescr2   IN  application.adescr2%TYPE,
                                 p_adescr3   IN  application.adescr3%TYPE,
                                 p_adescr4   IN  application.adescr4%TYPE,
                                 p_adescr5   IN  application.adescr5%TYPE,
                                 p_adescr6   IN  application.adescr6%TYPE,
                                 p_clicode   IN  application.clicode%TYPE,
                                 p_amop      IN  application.amop%TYPE,
                                 p_codsg     IN  VARCHAR2,
                                 p_acme      IN  application.acme%TYPE,
                                 p_codgappli IN  application.codgappli%TYPE,
                                 p_agappli   IN  application.agappli%TYPE,
                                 p_amnemo    IN  application.amnemo%TYPE,
                                 p_acdareg   IN  application.acdareg%TYPE,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS


      l_msg VARCHAR(1024);

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- Positionner le nb de curseurs ==> 0

      -- Initialiser le message retour


      p_nbcurseur := 0;

      p_message := '';


      BEGIN
         UPDATE application SET acme      = p_acme,
				amnemo    = p_amnemo,
                                adescr1   = p_adescr1,
                                adescr2   = p_adescr2,
                                adescr3   = p_adescr3,
                                adescr4   = p_adescr4,
                                adescr5   = p_adescr5,
                                adescr6   = p_adescr6,
                                agappli   = p_agappli,
                                airt      = p_airt,
                                alibel    = p_alibel,
                                amop      = p_amop,
                                clicode   = p_clicode,
                                codgappli = p_codgappli,
                                codsg     = TO_NUMBER(p_codsg),
                                alibcourt = p_alibcourt,
                                acdareg   = p_acdareg,
                                flaglock  = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE airt = p_airt
         AND flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2291);




         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;


      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2025, '%s1', p_airt, NULL, l_msg);
         p_message := l_msg;
      END IF;
   END update_application;





   PROCEDURE delete_application (p_airt      IN  application.airt%TYPE,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS


      l_msg VARCHAR2(1024);

      referential_integrity EXCEPTION;

      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0

      -- Initialiser le message retour


      p_nbcurseur := 0;

      p_message := '';


      BEGIN

         DELETE FROM application
                WHERE airt = p_airt
                AND flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2026, '%s1', p_airt, NULL, l_msg);
         p_message := l_msg;
      END IF;


   END delete_application;




   PROCEDURE select_application (p_airt           IN application.airt%TYPE,
                                 p_userid         IN VARCHAR2,
                                 p_curapplication IN OUT applicationCurType,
                                 p_nbcurseur         OUT INTEGER,
                                 p_message           OUT VARCHAR2
                                ) IS
      l_msg VARCHAR2(1024);
      l_airt application.airt%TYPE;
   BEGIN

      -- Positionner le nb de curseurs ==> 1

      -- Initialiser le message retour


      p_nbcurseur := 1;

      p_message := '';


	-- Test pour savoir si le premier caractere de airt est un 'A'

	l_airt := SUBSTR(p_airt, 0, 1);
	IF (l_airt != 'A') THEN
        pack_global.recuperer_message(20206, NULL, NULL, NULL, l_msg);
	  raise_application_error( -20206, l_msg );
	END IF;


      -- Attention ordre des colonnes doit correspondre a l ordre

      -- de declaration dans la table ORACLE (a cause de ROWTYPE)

      -- ou selectionner toutes les colonnes par *


      BEGIN
         OPEN p_curapplication FOR
              SELECT *
              FROM APPLICATION
              WHERE airt = p_airt;

      EXCEPTION
         WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
      END;

      -- en cas absence

      -- 'Le centre d'activité n'existe pas';


      pack_global.recuperer_message(2027, '%s1',p_airt, NULL, l_msg);
      p_message := l_msg;
   END select_application;
END pack_application;
/
CREATE OR REPLACE PACKAGE pack_archive_archives IS
-- ##################################################################################
--	PROCEDURE de purge des tables d'archive
-- ##################################################################################
	PROCEDURE archive_archives(
		P_LOGDIR	IN VARCHAR2
	);

END pack_archive_archives;
/

CREATE OR REPLACE PACKAGE BODY pack_archive_archives IS
-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !


-- ##################################################################################
--	PROCEDURE de purge des tables d'archive
-- ##################################################################################

	PROCEDURE archive_archives(
		P_LOGDIR	IN VARCHAR2
	) IS
	L_PROCNAME  varchar2(16) := 'ARCHIVE_ARCHIVES';
	L_HFILE     utl_file.file_type;
	L_RETCOD    number;
	L_STATEMENT varchar2(128);
	L_ANNEE5ANS NUMBER(4); 			-- Année moins 5 ans
	L_ANNEE10ANS NUMBER(4); 		-- Année moins 10 ans
	L_MOINS1AN  DATE; 				-- Date moins 1 an
	L_MOINS5ANS DATE; 				-- Date moins 5 ans
	L_MOINS10ANS DATE; 				-- Date moins 10 ans
	L_TOTAL    NUMBER :=0;          -- Compteur utilisé pour gérer le commit

	BEGIN

	-----------------------------------------------------
	--  Init de la trace
	-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                        'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

    	TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

	-----------------------------------------------------
	--  Positionne les dates
	-----------------------------------------------------

		SELECT  TO_NUMBER( TO_CHAR(add_months(datdebex,-60),'YYYY')),
				TO_NUMBER( TO_CHAR(add_months(datdebex,-120),'YYYY')),
				add_months(datdebex,-12), add_months(datdebex,-60), add_months(datdebex,-120)
		INTO L_ANNEE5ANS, L_ANNEE10ANS, L_MOINS1AN, L_MOINS5ANS, L_MOINS10ANS
		FROM datdebex;

	-----------------------------------------------------
	--  table ARCHIVE_CONS_SSTACHE_RES_MOIS
	--
	--  Purger si DATE_DEMANDE < DATDEBEX - 10 ans
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_cons_sstache_res_mois';
    	TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_CONS_SSTACHE_RES_MOIS : Laisse 10 ans en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_cons_sstache_res_mois
			-- fait un commit tous les 10000 enregistrements
			--
			DELETE FROM ARCHIVE_CONS_SSTACHE_RES_MOIS@biparch
			WHERE cdeb < L_MOINS10ANS
			AND   ROWNUM <= 10000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 10000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 10000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_cons_sstache_res_mois';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_CUMUL_CONSO
	--
	--	Purger  si ANNEE < Annee(DATDEBEX - 10 ans)
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_CUMUL_CONSO : Laisse 10 ans en archive ');

		DELETE FROM ARCHIVE_CUMUL_CONSO@biparch WHERE annee < L_ANNEE10ANS   ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table archive_cumul_conso';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_HISTO_STOCK_FI
	--
	--  Purger si CDEB < DATDEBEX - 10 ans
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_histo_stock_fi';

   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_HISTO_STOCK_FI : Laisse 10 ans en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_histo_stock_fi
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM ARCHIVE_HISTO_STOCK_FI@biparch
			WHERE cdeb < L_MOINS10ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_histo_stock_fi';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_HISTO_STOCK_IMMO
	--
	--  Purger si CDEB < DATDEBEX - 10 ans
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_histo_stock_immo';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_HISTO_STOCK_IMMO : Laisse 10 ans en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_histo_stock_immo
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM ARCHIVE_HISTO_STOCK_IMMO@biparch
			WHERE cdeb < L_MOINS10ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_histo_stock_immo';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_ISAC_CONSOMME
	--
	--  Purger si CDEB < DATDEBEX - 1 an
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_isac_consomme';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_ISAC_CONSOMME : Laisse 1 an en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_isac_consomme
			-- fait un commit tous les 10000 enregistrements
			--
			DELETE FROM ARCHIVE_ISAC_CONSOMME@biparch
			WHERE cdeb < L_MOINS1AN
			AND   ROWNUM <= 10000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 10000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 10000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_isac_consomme';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_PROPLUS
	--
	--  Purger si CDEB < DATDEBEX - 10 ans
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_proplus';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_PROPLUS : Laisse 10 ans en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_proplus
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM ARCHIVE_PROPLUS@biparch
			WHERE cdeb < L_MOINS10ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_proplus';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_REE_REESTIME
	--
	--  Purger si CDEB < DATDEBEX - 1 an
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_ree_reestime';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_REE_REESTIME : Laisse 1 an en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_ree_reestime
			-- fait un commit tous les 10000 enregistrements
			--
			DELETE FROM ARCHIVE_REE_REESTIME@biparch
			WHERE cdeb < L_MOINS1AN
			AND   ROWNUM <= 10000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 10000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 10000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_ree_reestime';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_STOCK_RA
	--
	--  Purger si CDEB < DATDEBEX - 1 an
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_stock_ra';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_STOCK_RA : Laisse 1 an en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_stock_ra
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM ARCHIVE_STOCK_RA@biparch
			WHERE cdeb < L_MOINS1AN
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_stock_ra';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_SYNTHESE_ACTIVITE
	--
	--  Purger si ANNEE < Annee(DATDEBEX - 10 ans)
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_synthese_activite';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_SYNTHESE_ACTIVITE : Laisse 10 ans en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_synthese_activite
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM ARCHIVE_SYNTHESE_ACTIVITE@biparch
			WHERE annee < L_ANNEE10ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_synthese_activite';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_SYNTHESE_ACTIVITE_MOIS
	--
	--  Purger si CDEB < DATDEBEX - 1 an
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_synthese_activite_mois';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_SYNTHESE_ACTIVITE_MOIS : Laisse 5 ans en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_synthese_activite_mois
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM ARCHIVE_SYNTHESE_ACTIVITE_MOIS@biparch
			WHERE cdeb < L_MOINS5ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_synthese_activite_mois';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ARCHIVE_SYNTHESE_FIN
	--
	--  Purger si ANNEE < Annee(DATDEBEX - 5 ans)
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_synthese_fin';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_SYNTHESE_FIN : Laisse 5 ans en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_synthese_fin
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM ARCHIVE_SYNTHESE_FIN@biparch
			WHERE annee < L_ANNEE5ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_synthese_fin';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );


	-----------------------------------------------------
	--  table ARCHIVE_SYNTHESE_FIN_BIP
	--
	--  Purger si ANNEE < Annee(DATDEBEX - 10 ans)
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table archive_synthese_fin_bip';
   		TRCLOG.TRCLOG( L_HFILE, 'ARCHIVE_SYNTHESE_FIN_BIP : Laisse 10 ans en archive ');

		LOOP
			--
			-- On supprime les données dans la table archive_synthese_fin_bip
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM ARCHIVE_SYNTHESE_FIN_BIP@biparch
			WHERE annee < L_ANNEE10ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table archive_synthese_fin_bip';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME );

	EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

	END archive_archives;

END pack_archive_archives;
/
CREATE OR REPLACE PACKAGE pack_archive_purge IS
-- ##################################################################################
--	PROCEDURE de purge des tables lancée lors de l'archivage
-- ##################################################################################
	PROCEDURE archive_purge(
		P_LOGDIR	IN VARCHAR2
	);

END pack_archive_purge;
/

CREATE OR REPLACE PACKAGE BODY pack_archive_purge IS
-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !


-- ##################################################################################
--	PROCEDURE de purge des tables lancée lors de l'archivage
-- ##################################################################################

	PROCEDURE archive_purge(
		P_LOGDIR	IN VARCHAR2
	) IS
	L_PROCNAME  varchar2(16) := 'ARCHIVE_PURGE';
	L_HFILE     utl_file.file_type;
	L_RETCOD    number;
	L_STATEMENT varchar2(128);
	L_MOINS1AN  DATE; 				-- Date moins 1 an
	L_MOINS3ANS DATE; 				-- Date moins 3 ans
	L_TOTAL    NUMBER :=0;          -- Compteur utilisé pour gérer le commit

	BEGIN

	-----------------------------------------------------
	--  Init de la trace
	-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                        'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

    	TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

	-----------------------------------------------------
	--  Positionne les dates
	-----------------------------------------------------

		SELECT  add_months(datdebex,-12),add_months(datdebex,-36)
		INTO L_MOINS1AN,L_MOINS3ANS
		FROM datdebex;

	-----------------------------------------------------
	--  table AUDIT_STATUT
	--
	--  Purger si DATE_DEMANDE < DATDEBEX - 3ans
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'AUDIT_STATUT : Laisse 3 ans en ligne ');

		DELETE FROM AUDIT_STATUT WHERE DATE_DEMANDE < L_MOINS3ANS ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table audit_statut';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ISAC_AFFECTATION
	--
	--	Vider les lignes sur des ressources qui ne sont plus la
	--	Purger s'il n'existe pas de ligne dans SITU_RESS avec IDENT et DATDEP null ou DATDEP>= DATDEBEX - 1 an
	--	Vider les lignes sur les lignes BIP fermées
	--	Purger si PID tel que ADATESTATUT de la ligne BIP < DATDEBEX - 1 an
	-----------------------------------------------------

   		TRCLOG.TRCLOG( L_HFILE, 'ISAC_AFFECTATION : Vider les lignes sur des ressources qui ne sont plus la depuis 1 an ');

		DELETE FROM ISAC_AFFECTATION WHERE
				NOT EXISTS ( SELECT IDENT FROM SITU_RESS
				             WHERE SITU_RESS.IDENT=ISAC_AFFECTATION.IDENT
				             AND ( SITU_RESS.DATDEP IS NULL OR SITU_RESS.DATDEP >= L_MOINS1AN )
				            ) ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table isac_affectation';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

   		TRCLOG.TRCLOG( L_HFILE, 'ISAC_AFFECTATION : Vider les lignes sur les lignes BIP fermées depuis 1 an ');

		DELETE FROM ISAC_AFFECTATION WHERE
				NOT EXISTS ( SELECT PID FROM LIGNE_BIP
				             WHERE LIGNE_BIP.PID=ISAC_AFFECTATION.PID
				             AND ( LIGNE_BIP.ADATESTATUT IS NULL OR LIGNE_BIP.ADATESTATUT >= L_MOINS1AN )
				            ) ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table isac_affectation';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ISAC_SOUS_TACHE
	--
	--	Vider les lignes sur les lignes BIP fermées
	--	Purger si PID tel que ADATESTATUT de la ligne BIP < DATDEBEX - 1 an
	-----------------------------------------------------

   		TRCLOG.TRCLOG( L_HFILE, 'ISAC_SOUS_TACHE : Vider les lignes sur les lignes BIP fermées depuis 1 an ');

		DELETE FROM ISAC_SOUS_TACHE WHERE
				NOT EXISTS ( SELECT PID FROM LIGNE_BIP
				             WHERE LIGNE_BIP.PID=ISAC_SOUS_TACHE.PID
				             AND ( LIGNE_BIP.ADATESTATUT IS NULL OR LIGNE_BIP.ADATESTATUT >= L_MOINS1AN )
				            ) ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table isac_sous_tache';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ISAC_TACHE
	--
	--	Vider les lignes sur les lignes BIP fermées
	--	Purger si PID tel que ADATESTATUT de la ligne BIP < DATDEBEX - 1 an
	-----------------------------------------------------

   		TRCLOG.TRCLOG( L_HFILE, 'ISAC_TACHE : Vider les lignes sur les lignes BIP fermées depuis 1 an ');

		DELETE FROM ISAC_TACHE WHERE
				NOT EXISTS ( SELECT PID FROM LIGNE_BIP
				             WHERE LIGNE_BIP.PID=ISAC_TACHE.PID
				             AND ( LIGNE_BIP.ADATESTATUT IS NULL OR LIGNE_BIP.ADATESTATUT >= L_MOINS1AN )
				            ) ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table isac_tache';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table ISAC_ETAPE
	--
	--	Vider les lignes sur les lignes BIP fermées
	--	Purger si PID tel que ADATESTATUT de la ligne BIP < DATDEBEX - 1 an
	-----------------------------------------------------

   		TRCLOG.TRCLOG( L_HFILE, 'ISAC_ETAPE : Vider les lignes sur les lignes BIP fermées depuis 1 an ');

		DELETE FROM ISAC_ETAPE WHERE
				NOT EXISTS ( SELECT PID FROM LIGNE_BIP
				             WHERE LIGNE_BIP.PID=ISAC_ETAPE.PID
				             AND ( LIGNE_BIP.ADATESTATUT IS NULL OR LIGNE_BIP.ADATESTATUT >= L_MOINS1AN )
				            ) ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table isac_etape';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table LIGNE_BIP_LOGS
	--
	--  Purger si DATE_LOG < DATDEBEX - 3 ans
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table ligne_bip_logs';
   		TRCLOG.TRCLOG( L_HFILE, 'LIGNE_BIP_LOGS : Laisse 3 ans en ligne ');

		LOOP
			--
			-- On supprime les données dans la table ligne_bip_logs
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM LIGNE_BIP_LOGS
			WHERE date_log < L_MOINS3ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table ligne_bip_logs';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table REPORT_LOG
	--
	--  Purger si DATE_LOG < DATDEBEX - 3 ans
	-----------------------------------------------------

		L_TOTAL := 0;
		L_STATEMENT := 'Suppression dans la table report_log';
   		TRCLOG.TRCLOG( L_HFILE, 'REPORT_LOG : Laisse 3 ans en ligne ');

		LOOP
			--
			-- On supprime les données dans la table report_log
			-- fait un commit tous les 5000 enregistrements
			--
			DELETE FROM REPORT_LOG
			WHERE date_log < L_MOINS3ANS
			AND   ROWNUM <= 5000;

			L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

			-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
			EXIT WHEN SQL%ROWCOUNT < 5000;
			COMMIT;

		END LOOP;
		COMMIT;

		L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table report_log';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME );

	EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

	END archive_purge;

END pack_archive_purge;
/
CREATE OR REPLACE PACKAGE pack_archive_ressources IS
-- ##################################################################################
--	PROCEDURE d'archivage des ressources
-- ##################################################################################
	PROCEDURE archive_ressources(
		P_LOGDIR	IN VARCHAR2
	);

---	-----------------------------------------------------
---	Procédures appelées dans le corps du traitement
---	-----------------------------------------------------
	PROCEDURE copie_situation(
		p_borne		IN DATE,
		p_logfile	IN utl_file.file_type	);

	PROCEDURE copie_facture(
		p_borne		IN DATE,
		p_logfile	IN utl_file.file_type);

	PROCEDURE copie_contrat(
		p_borne		IN DATE,
		p_logfile	IN utl_file.file_type);

	PROCEDURE copie_consomme(
		p_borne		IN DATE,
		p_logfile	IN utl_file.file_type);

	PROCEDURE copie_ressource(
		p_logfile	IN utl_file.file_type);

	PROCEDURE restaure_situation(
		p_logfile	IN utl_file.file_type);

	PROCEDURE change_chef_projet(
		p_logfile	IN utl_file.file_type);

END pack_archive_ressources;
/

CREATE OR REPLACE PACKAGE BODY pack_archive_ressources IS
-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !


-- ##################################################################################
--	PROCEDURE d'archivage des ressources
-- ##################################################################################

	PROCEDURE archive_ressources(
		P_LOGDIR	IN VARCHAR2
	) IS
	L_PROCNAME  varchar2(20) := 'ARCHIVE_RESSOURCES';
	L_HFILE     utl_file.file_type;
	L_RETCOD    number;
	L_STATEMENT varchar2(128);
	L_MOINS5ANS DATE; 				-- Date moins 5 ans

	BEGIN

	-----------------------------------------------------
	--  Init de la trace
	-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                        'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

    	TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

	-----------------------------------------------------
	--  Positionne les dates
	-----------------------------------------------------

		SELECT  add_months(datdebex,-60) INTO L_MOINS5ANS FROM datdebex;

	-----------------------------------------------------
	--  Appelle les fonctions d'archivage
	-----------------------------------------------------

		copie_situation(L_MOINS5ANS, L_HFILE);
		copie_facture(	L_MOINS5ANS, L_HFILE);
		copie_contrat(	L_MOINS5ANS, L_HFILE);
		copie_consomme(	L_MOINS5ANS, L_HFILE);
		copie_ressource(L_HFILE);
		restaure_situation( L_HFILE) ;
		change_chef_projet(L_HFILE);

    	TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME );

	EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

	END archive_ressources;

	-----------------------------------------------------
	--  Table SITU_RESS
	--  Archive les situations dont la date de départ a de plus de 5 Ans d'ancienneté
	-----------------------------------------------------

	PROCEDURE copie_situation(
		p_borne		IN DATE,
		p_logfile	IN utl_file.file_type
	) IS
		l_compteur	INTEGER;
	BEGIN
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Debut de la procedure d''archivage des situations pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));

		INSERT INTO archive_situ_ress@biparch(DATSITU, DATDEP, CPIDENT, COUT, DISPO, MARSG2, RMCOMP, PRESTATION
						, DPREST, IDENT, SOCCODE, CODSG, NIVEAU, MONTANT_MENSUEL)
			SELECT DATSITU, DATDEP, CPIDENT, COUT, DISPO, MARSG2, RMCOMP, PRESTATION
						, DPREST, IDENT, SOCCODE, CODSG, NIVEAU, MONTANT_MENSUEL
			FROM situ_ress
			WHERE datdep<p_borne;

		DELETE situ_ress
			WHERE datdep<p_borne;
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(l_compteur) || ' situations anciennes archives.');


		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Fin de la procedure d''archivage des situations pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));
	END copie_situation;

	-----------------------------------------------------
	--  Tables LIGNE_FACT et FACTURE
	--  Archive les lignes factures dont la date a de plus de 5 Ans d'ancienneté
	--  Archive les factures qui n'ont plus de lignes de factures (toutes ont ete archivees)
	-----------------------------------------------------

	PROCEDURE copie_facture(
		p_borne		IN DATE,
		p_logfile	IN utl_file.file_type
	) IS
		l_compteur	INTEGER;
	BEGIN
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Debut de la procedure d''archivage des factures pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des lignes de factures pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));
		INSERT INTO archive_ligne_fact@biparch(LNUM, LMONTHT, LPREST, LSECTEUR, LCODFINALI, LCODCOMPTA, LDEPPOLE
				, LIDAVFACT, LCODJH, LCODESTINA, LMOISPREST, SOCFACT, TYPFACT, DATFACT, NUMFACT
				, TVA, IDENT, CODCAMO, PID, LRAPPROCHT)
			SELECT LNUM, LMONTHT, LPREST, LSECTEUR, LCODFINALI, LCODCOMPTA, LDEPPOLE
				, LIDAVFACT, LCODJH, LCODESTINA, LMOISPREST, SOCFACT, TYPFACT, DATFACT, NUMFACT
				, TVA, IDENT, CODCAMO, PID, LRAPPROCHT
			FROM ligne_fact
			WHERE datfact<p_borne;

		DELETE ligne_fact
			WHERE datfact<p_borne;
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' lignes de facture archivees.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des factures qui n''ont plus de lignes de factures (toutes ont ete archivees)');
		INSERT INTO archive_facture@biparch(SOCFACT, NUMFACT, TYPFACT, DATFACT, FNOM, FNUMASN, FNUMORDRE, FORDRECHEQ, FENVSEC
					, FPROVSDFF1, FPROVSDFF2, FPROVSEGL1, FPROVSEGL2, FREGCOMPTA, LLIBANALYT, FSTEGLE, FCDSG
					, FLIVRAISON, FMODREGLT, FMOIACOMPTA, FMONTHT, FMONTTTC, FECRITCPTAB, FNMRAPPROCHT, FCODUSER
					, FCENTREFRAIS, FDATMAJ, FDATSAI, FDATSUP, FENRCOMPTA, FBURDISTR, FCODEPOST, FSTATUT1, FSTATUT2
					, FACCSEC, FSOCFOUR, FADRESSE1, FADRESSE2, FADRESSE3, FTVA, FCODCOMPTA, FDEPPOLE, FLAGLOCK
					, SOCCONT, CAV, NUMCONT, FDATRECEP, NUM_SMS)
			SELECT SOCFACT, NUMFACT, TYPFACT, DATFACT, FNOM, FNUMASN, FNUMORDRE, FORDRECHEQ, FENVSEC
					, FPROVSDFF1, FPROVSDFF2, FPROVSEGL1, FPROVSEGL2, FREGCOMPTA, LLIBANALYT, FSTEGLE, FCDSG
					, FLIVRAISON, FMODREGLT, FMOIACOMPTA, FMONTHT, FMONTTTC, FECRITCPTAB, FNMRAPPROCHT, FCODUSER
					, FCENTREFRAIS, FDATMAJ, FDATSAI, FDATSUP, FENRCOMPTA, FBURDISTR, FCODEPOST, FSTATUT1, FSTATUT2
					, FACCSEC, FSOCFOUR, FADRESSE1, FADRESSE2, FADRESSE3, FTVA, FCODCOMPTA, FDEPPOLE, FLAGLOCK
					, SOCCONT, CAV, NUMCONT, FDATRECEP, NUM_SMS
			FROM facture
			WHERE NOT EXISTS (SELECT 1 FROM ligne_fact
					WHERE facture.numfact = ligne_fact.numfact
	  				AND facture.socfact = ligne_fact.socfact
	  				AND facture.datfact = ligne_fact.datfact
	  				AND facture.typfact = ligne_fact.typfact );


		DELETE facture
		WHERE NOT EXISTS (SELECT 1 FROM ligne_fact
				WHERE facture.numfact = ligne_fact.numfact
	  			AND facture.socfact = ligne_fact.socfact
	  			AND facture.datfact = ligne_fact.datfact
	  			AND facture.typfact = ligne_fact.typfact );
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' factures archivees.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Fin de la procedure d''archivage des factures pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));
	END copie_facture;

	-----------------------------------------------------
	--  Tables LIGNE_CONT et CONTRAT
	--  Archivage des lignes de contrats pour lesquelles il n'existe pas de facture
	--    et il n'existe pas de contrat ou d'avenant dont la date de fin a moins de 5 ans d'ancienneté
	--  Archive les contrats qui n'ont plus de lignes de contrats (toutes ont ete archivees)
	-----------------------------------------------------

	PROCEDURE copie_contrat(
		p_borne		IN DATE,
		p_logfile	IN utl_file.file_type
	) IS
		l_compteur	INTEGER;
	BEGIN
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));

		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Debut de la procedure d''archivage des contrat pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des lignes de contrats pour lesquelles il n''existe pas de facture');
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      et il n''existe pas de contrat ou d''avenant dont la date de fin est supérieure à la borne ');

		INSERT INTO archive_ligne_cont@biparch(LCNUM, LFRAISDEP, LASTREINTE, LHEURSUP, LRESDEB, LRESFIN, LCDATACT, LCCOUACT
						, LCCOUINIT, LCPREST, SOCCONT, CAV, NUMCONT, IDENT, PROPORIG)
			SELECT LCNUM, LFRAISDEP, LASTREINTE, LHEURSUP, LRESDEB, LRESFIN, LCDATACT, LCCOUACT
						, LCCOUINIT, LCPREST, SOCCONT, CAV, NUMCONT, IDENT, PROPORIG
			FROM ligne_cont

			WHERE NOT EXISTS	(SELECT 1 FROM contrat c WHERE c.soccont=ligne_cont.soccont
						AND c.numcont=ligne_cont.numcont and c.cdatfin>=p_borne)

			AND NOT EXISTS  	( SELECT 1 FROM facture WHERE facture.numcont = ligne_cont.numcont
						AND facture.socfact = ligne_cont.soccont );


		DELETE ligne_cont
			WHERE NOT EXISTS	(SELECT 1 FROM contrat c WHERE c.soccont=ligne_cont.soccont
						AND c.numcont=ligne_cont.numcont and c.cdatfin>=p_borne)

			AND NOT EXISTS  	( SELECT 1 FROM facture WHERE facture.numcont = ligne_cont.numcont
						AND facture.socfact = ligne_cont.soccont );
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' lignes de contrats archivees.');


		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des contrats qui n''ont plus de lignes de contrats (toutes ont ete archivees)');
		INSERT INTO archive_contrat@biparch(NUMCONT, CCHTSOC, CTYPFACT, COBJET1, COBJET2, COBJET3, CREM, CANTFACT, CMOIDERFAC, CMMENS
						, CCHARESTI, CECARTHT, CEVAINIT, CNAFFAIR, CAGREMENT, CRANG, CANTCONS, CCOUTHT, CDATANNUL
						, CDATARR, CDATCLOT, CDATDEB, CDATSOCE, CDATFIN, CDATMAJ, CDATDIR, CDATBILQ, CDATRPOL
						, CDATSOCR, CDATSAI, CDUREE, FLAGLOCK, SOCCONT, CAV, FILCODE, COMCODE, NICHE, CODSG
						, CCENTREFRAIS)
			SELECT NUMCONT, CCHTSOC, CTYPFACT, COBJET1, COBJET2, COBJET3, CREM, CANTFACT, CMOIDERFAC, CMMENS
						, CCHARESTI, CECARTHT, CEVAINIT, CNAFFAIR, CAGREMENT, CRANG, CANTCONS, CCOUTHT, CDATANNUL
						, CDATARR, CDATCLOT, CDATDEB, CDATSOCE, CDATFIN, CDATMAJ, CDATDIR, CDATBILQ, CDATRPOL
						, CDATSOCR, CDATSAI, CDUREE, FLAGLOCK, SOCCONT, CAV, FILCODE, COMCODE, NICHE, CODSG
						, CCENTREFRAIS
			FROM contrat
			WHERE NOT EXISTS (SELECT 1 FROM ligne_cont
					WHERE contrat.numcont = ligne_cont.numcont
	  				AND contrat.soccont = ligne_cont.soccont
	  				AND contrat.cav = ligne_cont.cav );
		DELETE contrat
			WHERE NOT EXISTS (SELECT 1 FROM ligne_cont
					WHERE contrat.numcont = ligne_cont.numcont
	  				AND contrat.soccont = ligne_cont.soccont
	  				AND contrat.cav = ligne_cont.cav );

		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' contrats archivees.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Fin de la procedure d''archivage des contrats pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));
	END copie_contrat;

	-----------------------------------------------------
	--  Tables CONS_SSTACHE_RES_MOIS et PROPLUS
	--  Archivage des lignes de CONS_SSTACHE_RES_MOIS attaches a des ressources sans situations
	--  Archive les lignes de CONS_SSTACHE_RES_MOIS dont la date a de plus de 5 Ans d'ancienneté
	--  Archivage des lignes de PROPLUS attaches a des ressources sans situations
	--  Archive les lignes de PROPLUS dont la date a de plus de 5 Ans d'ancienneté
	-----------------------------------------------------

	PROCEDURE copie_consomme(
		p_borne		IN DATE,
		p_logfile	IN utl_file.file_type
	) IS
		l_compteur	INTEGER;
	BEGIN
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Debut de la procedure d''archivage des consommes pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des cons_sstache_res_mois attaches a des ressources sans situations');
		INSERT INTO archive_cons_sstache_res_mois@biparch(CDEB, CDUR, CUSAG, CHRAF, CHINIT, PID, ECET, ACTA, ACST, IDENT)
			SELECT CDEB, CDUR, CUSAG, CHRAF, CHINIT, PID, ECET, ACTA, ACST, IDENT
			FROM cons_sstache_res_mois
			WHERE NOT EXISTS (SELECT 1 FROM situ_ress
					WHERE cons_sstache_res_mois.ident =  situ_ress.ident);

		DELETE cons_sstache_res_mois
			WHERE NOT EXISTS (SELECT 1 FROM situ_ress
					WHERE cons_sstache_res_mois.ident =  situ_ress.ident);
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' CONS_SSTACHE_RES_MOIS archives.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des cons_sstache_res_mois pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));
		INSERT INTO archive_cons_sstache_res_mois@biparch(CDEB, CDUR, CUSAG, CHRAF, CHINIT, PID, ECET, ACTA, ACST, IDENT)
			SELECT CDEB, CDUR, CUSAG, CHRAF, CHINIT, PID, ECET, ACTA, ACST, IDENT
			FROM cons_sstache_res_mois
			WHERE cdeb<p_borne;

		DELETE cons_sstache_res_mois
			WHERE cdeb<p_borne;
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' CONS_SSTACHE_RES_MOIS archives.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des PROPLUS attaches a des ressources sans situations');
		INSERT INTO archive_proplus@biparch(FACTPID, PID, AIST, AISTTY, TIRES, CDEB, PTYPE, FACTPTY, PNOM, FACTPNO, PDSG, FACTPDSG
						, PCPI, FACTPCP, PCMOUVRA, FACTPCM, PNMOUVRA, PDATDEBPRE, CUSAG, RNOM, RPRENOM
						, DATDEP, DIVSECGROU, CPIDENT, COUT, MATRICULE, SOCIETE, QUALIF, DISPO, CHINIT, CHRAF, RTYPE)
			SELECT FACTPID, PID, AIST, AISTTY, TIRES, CDEB, PTYPE, FACTPTY, PNOM, FACTPNO, PDSG, FACTPDSG
						, PCPI, FACTPCP, PCMOUVRA, FACTPCM, PNMOUVRA, PDATDEBPRE, CUSAG, RNOM, RPRENOM
						, DATDEP, DIVSECGROU, CPIDENT, COUT, MATRICULE, SOCIETE, QUALIF, DISPO, CHINIT, CHRAF, RTYPE
			FROM proplus
			WHERE NOT EXISTS (SELECT 1 FROM situ_ress
					WHERE proplus.tires =  situ_ress.ident);
		DELETE proplus
			WHERE NOT EXISTS (SELECT 1 FROM situ_ress
					WHERE proplus.tires =  situ_ress.ident);

		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' PROPLUS archives.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des PROPLUS pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));
		INSERT INTO archive_proplus@biparch(FACTPID, PID, AIST, AISTTY, TIRES, CDEB, PTYPE, FACTPTY, PNOM, FACTPNO, PDSG, FACTPDSG
						, PCPI, FACTPCP, PCMOUVRA, FACTPCM, PNMOUVRA, PDATDEBPRE, CUSAG, RNOM, RPRENOM
						, DATDEP, DIVSECGROU, CPIDENT, COUT, MATRICULE, SOCIETE, QUALIF, DISPO, CHINIT, CHRAF, RTYPE)
			SELECT FACTPID, PID, AIST, AISTTY, TIRES, CDEB, PTYPE, FACTPTY, PNOM, FACTPNO, PDSG, FACTPDSG
						, PCPI, FACTPCP, PCMOUVRA, FACTPCM, PNMOUVRA, PDATDEBPRE, CUSAG, RNOM, RPRENOM
						, DATDEP, DIVSECGROU, CPIDENT, COUT, MATRICULE, SOCIETE, QUALIF, DISPO, CHINIT, CHRAF, RTYPE
			FROM proplus
			WHERE cdeb<p_borne;

		DELETE proplus
			WHERE cdeb<p_borne;
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' PROPLUS archives.');



		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Fin de la procedure d''archivage des consommes pour la borne ' || TO_CHAR(p_borne, 'dd/mm/yyyy'));
	END copie_consomme;

	-----------------------------------------------------
	--  Tables CONS_SSTACHE_RES et RESSOURCE
	--  Archivage des lignes de CONS_SSTACHE_RES attachées a des ressources sans situations
	--       et qui n'ont pas de lignes factures, lignes contrats ni cons_sstaches_res_mois
	--  Archivage des lignes de RESSOURCES sans situations
	--       et qui n'ont pas de lignes factures, lignes contrats ni cons_sstaches_res_mois
	-----------------------------------------------------


	PROCEDURE copie_ressource(
		p_logfile	IN utl_file.file_type
	) IS
		l_compteur	INTEGER;
	BEGIN
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Debut de la procedure d''archivage des ressources');

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des CONS_SSTACHE_RES pour les ressources qui n''ont pas de lignes fatures, lignes contrats ni cons_sstaches_res_mois (toutes ont ete archivees)');
		INSERT INTO archive_cons_sstache_res@biparch(TPLAN, TACTU, TEST, PID, ECET, ACTA, ACST, IDENT)
			SELECT TPLAN, TACTU, TEST, PID, ECET, ACTA, ACST, IDENT
			FROM cons_sstache_res
			WHERE ident IN
				(SELECT ident FROM ressource
					WHERE NOT EXISTS (SELECT 1 FROM situ_ress WHERE situ_ress.ident=ressource.ident)
						AND NOT EXISTS (SELECT 1 FROM cons_sstache_res_mois WHERE cons_sstache_res_mois.ident=ressource.ident)
						AND NOT EXISTS (SELECT 1 FROM ligne_cont WHERE ligne_cont.ident=ressource.ident)
						AND NOT EXISTS (SELECT 1 FROM ligne_fact WHERE ligne_fact.ident=ressource.ident)
				);
		DELETE cons_sstache_res
			WHERE ident IN
				(SELECT ident FROM ressource
					WHERE NOT EXISTS (SELECT 1 FROM situ_ress WHERE situ_ress.ident=ressource.ident)
						AND NOT EXISTS (SELECT 1 FROM cons_sstache_res_mois WHERE cons_sstache_res_mois.ident=ressource.ident)
						AND NOT EXISTS (SELECT 1 FROM ligne_cont WHERE ligne_cont.ident=ressource.ident)
						AND NOT EXISTS (SELECT 1 FROM ligne_fact WHERE ligne_fact.ident=ressource.ident)
				);
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' CONS_SSTACHE_RES archives.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Archivage des ressources qui n''ont pas de lignes fatures, lignes contrats ni cons_sstaches_res_mois (toutes ont ete archivees)');
		INSERT INTO archive_ressource@biparch(IDENT, RNOM, RPRENOM, MATRICULE, COUTOT, RTEL, BATIMENT, ETAGE, BUREAU, FLAGLOCK, RTYPE, ICODIMM)
			SELECT IDENT, RNOM, RPRENOM, MATRICULE, COUTOT, RTEL, BATIMENT, ETAGE, BUREAU, FLAGLOCK, RTYPE, ICODIMM
			FROM ressource
			WHERE NOT EXISTS (SELECT 1 FROM situ_ress WHERE situ_ress.ident=ressource.ident)
				AND NOT EXISTS (SELECT 1 FROM cons_sstache_res_mois WHERE cons_sstache_res_mois.ident=ressource.ident)
				AND NOT EXISTS (SELECT 1 FROM ligne_cont WHERE ligne_cont.ident=ressource.ident)
				AND NOT EXISTS (SELECT 1 FROM ligne_fact WHERE ligne_fact.ident=ressource.ident);

		DELETE ressource
			WHERE NOT EXISTS (SELECT 1 FROM situ_ress WHERE situ_ress.ident=ressource.ident)
				AND NOT EXISTS (SELECT 1 FROM cons_sstache_res_mois WHERE cons_sstache_res_mois.ident=ressource.ident)
				AND NOT EXISTS (SELECT 1 FROM ligne_cont WHERE ligne_cont.ident=ressource.ident)
				AND NOT EXISTS (SELECT 1 FROM ligne_fact WHERE ligne_fact.ident=ressource.ident);
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' ressources archivees.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Fin de la procedure d''archivage des ressources');
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
	END copie_ressource;

	-----------------------------------------------------
	-- Restaure les situations qui ont été archivées à tort car elles concernent
	-- une ressource qui n'a pas été archivée car il reste un contrat ou une facture
	-- la concernant
	-----------------------------------------------------

	PROCEDURE restaure_situation(
			p_logfile	IN utl_file.file_type
	) IS
		l_compteur	INTEGER;
	BEGIN
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Debut de la procedure de restauration des situations ');

		UPDATE archive_situ_ress@biparch
			SET MARSG2 = 'O'
		WHERE 	EXISTS (SELECT 1 FROM ressource WHERE archive_situ_ress.ident=ressource.ident)
			AND NOT EXISTS (SELECT 1 FROM situ_ress WHERE archive_situ_ress.ident=situ_ress.ident)
			AND DATDEP = ( SELECT MAX(a.DATDEP) FROM archive_situ_ress@biparch a WHERE a.ident = archive_situ_ress.ident ) ;

		INSERT INTO situ_ress(DATSITU, DATDEP, CPIDENT, COUT, DISPO, MARSG2, RMCOMP, PRESTATION
						, DPREST, IDENT, SOCCODE, CODSG, NIVEAU, MONTANT_MENSUEL)
			SELECT DATSITU, DATDEP, CPIDENT, COUT, DISPO, '' , RMCOMP, PRESTATION
						, DPREST, IDENT, SOCCODE, CODSG, NIVEAU, MONTANT_MENSUEL
			FROM archive_situ_ress@biparch
			WHERE MARSG2 = 'O' ;

		DELETE archive_situ_ress@biparch
			WHERE MARSG2 = 'O' ;

		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(l_compteur) || ' situations restaurées.');


		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Fin de la procedure de restauration des situations ');
	END restaure_situation;

	-----------------------------------------------------
	-- Mise à jours des chefs de projet de lignes BIP qui ont ete archives
	-- Fait pointer les lignes bip et les ressources rattachées sur la ressource 17351 : RESS_REGROUPEMENT
	-----------------------------------------------------

	PROCEDURE change_chef_projet(
		p_logfile	IN utl_file.file_type
	) IS
		l_compteur	INTEGER;
	BEGIN
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Debut de la procedure de modifications des chefs de projet pour les ressources archivees');

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Mise à jours des chefs de projet de lignes BIP qui ont ete archives');
		UPDATE ligne_bip
			SET pcpi=17351
			WHERE NOT EXISTS (SELECT 1 FROM ressource WHERE ligne_bip.pcpi=ressource.ident);
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' chefs de projet de lignes BIP mis a jour.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, '    - Mise à jours des chefs de projet de ressources qui ont ete archives');
		UPDATE situ_ress
			SET cpident=17351
			WHERE NOT EXISTS (SELECT 1 FROM ressource WHERE situ_ress.cpident=ressource.ident);
		l_compteur := SQL%ROWCOUNT;
		COMMIT;
		PACK_GLOBAL.WRITE_STRING(p_logfile, '      ' || TO_CHAR(l_compteur) || ' chefs de projet de ressources mis a jour.');

		PACK_GLOBAL.WRITE_STRING(p_logfile, 'Fin de la procedure de modifications des chefs de projet pour les ressources archivees');
		PACK_GLOBAL.WRITE_STRING(p_logfile, TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss'));
	END change_chef_projet;



END pack_archive_ressources;
/
CREATE OR REPLACE PACKAGE pack_archive_tables IS
-- ##################################################################################
--	PROCEDURE d'archivage des tables
-- ##################################################################################
	PROCEDURE archive_tables(
		P_LOGDIR	IN VARCHAR2
	);

END pack_archive_tables;
/

CREATE OR REPLACE PACKAGE BODY pack_archive_tables IS
-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !


-- ##################################################################################
--	PROCEDURE d'archivage des tables
-- ##################################################################################

	PROCEDURE archive_tables(
		P_LOGDIR	IN VARCHAR2
	) IS
	L_PROCNAME  varchar2(16) := 'ARCHIVE_TABLES';
	L_HFILE     utl_file.file_type;
	L_RETCOD    number;
	L_STATEMENT varchar2(128);
	L_ANNEE1AN  NUMBER(4); 				-- Année moins 1 an
	L_ANNEE3ANS NUMBER(4); 				-- Année moins 3 ans
	L_ANNEE5ANS NUMBER(4); 				-- Année moins 5 ans
	L_MOINS0ANS DATE; 					-- Date moins 0 ans (donc datdebex)
	L_MOINS1AN  DATE; 					-- Date moins 1 an
	L_MOINS3ANS DATE; 					-- Date moins 3 ans
	L_MOINS5ANS DATE; 					-- Date moins 5 ans
	L_COMPTEUR NUMBER :=0;              -- Compteur utilisé pour gérer le commit
	L_TOTAL    NUMBER :=0;              -- Compteur utilisé pour gérer le commit

	BEGIN

	-----------------------------------------------------
	--  Init de la trace
	-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                        'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

    	TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

	-----------------------------------------------------
	--  Positionne les dates
	-----------------------------------------------------

		SELECT  TO_NUMBER( TO_CHAR(add_months(datdebex,-12),'YYYY')),
				TO_NUMBER( TO_CHAR(add_months(datdebex,-36),'YYYY')),
				TO_NUMBER( TO_CHAR(add_months(datdebex,-60),'YYYY')),
				datdebex,
				add_months(datdebex,-12),
				add_months(datdebex,-36),
		        add_months(datdebex,-60)
		INTO L_ANNEE1AN ,L_ANNEE3ANS ,L_ANNEE5ANS ,L_MOINS0ANS ,L_MOINS1AN ,L_MOINS3ANS , L_MOINS5ANS
		FROM datdebex;

	-----------------------------------------------------
	--  table BUDGET
	--
	--  On garde 5 ans en ligne dans Budget, le reste va dans Archive_Budget qui ne sera pas purgé
	--  Déplacer dans ARCHIVE_BUDGET si ANNEE < Année(DATDEBEX - 5 ans )
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'BUDGET : Laisse 5 ans en ligne ');

		INSERT INTO ARCHIVE_BUDGET@biparch
		(annee, pid, bnmont, bpmontme,
		bpmontme2, anmont, bpdate, reserve,
		apdate, apmont, bpmontmo, reestime,
		flaglock)
		SELECT
		annee, pid, bnmont, bpmontme,
		bpmontme2, anmont, bpdate, reserve,
		apdate, apmont, bpmontmo, reestime,
		flaglock
		FROM BUDGET
		WHERE annee < L_ANNEE5ANS ;
		COMMIT;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes copiées dans la table archive_budget';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

		DELETE FROM BUDGET WHERE annee < L_ANNEE5ANS  ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table budget';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );


	-----------------------------------------------------
	--  table CALENDRIER
	--
	--  On garde 5 ans en ligne dans Calendrier, le reste va dans Archive_Calendrier qui ne sera pas purgé
	--  Déplacer dans ARCHIVE_CALENDRIER si CALANMOIS < DATDEBEX - 5 ans
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'CALENDRIER : Laisse 5 ans en ligne ');

		INSERT INTO ARCHIVE_CALENDRIER@biparch
		(calanmois, ccloture, cafin, cpremens2,
		cmensuelle, cjours, cpremens1, flaglock,
		nb_travail_sg, nb_travail_ssii)
		SELECT
		calanmois, ccloture, cafin, cpremens2,
		cmensuelle, cjours, cpremens1, flaglock,
		nb_travail_sg, nb_travail_ssii
		FROM CALENDRIER
		WHERE calanmois < L_MOINS5ANS ;

		COMMIT;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes copiées dans la table archive_calendrier';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

		DELETE FROM CALENDRIER WHERE calanmois < L_MOINS5ANS  ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table calendrier';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );


	-----------------------------------------------------
	--  table CONSOMME
	--
	--  On garde 5 ans en ligne dans Consomme, le reste va dans Archive_Consomme qui ne sera pas purgé
	--  Déplacer dans ARCHIVE_CONSOMME si ANNEE < Année(DATDEBEX - 5 ans ) et CUSAG<>0
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'CONSOMME : Laisse 5 ans en ligne, n''archive pas les consommés à O ');

		INSERT INTO ARCHIVE_CONSOMME@biparch
		(annee, pid, cusag, xcusag)
		SELECT
		annee, pid, cusag, xcusag
		FROM CONSOMME
		WHERE annee < L_ANNEE5ANS
		AND cusag <> 0 ;
		COMMIT;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes copiées dans la table archive_consomme';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

		DELETE FROM CONSOMME WHERE annee < L_ANNEE5ANS  ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table consomme';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table CONS_SSTACHE_RES
	--
	--  Archivage des données correspondant à des lignes BIP fermées depuis + 5 ans( ADATESTATUT < DATDEBEX-5ans)
    --  Déplacer dans ARCHIVE_CONS_SSTACHE_RES dans ces cas
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'CONS_SSTACHE_RES : Archivage des données correspondant à des lignes BIP fermées depuis + 5 ans ');

		INSERT INTO ARCHIVE_CONS_SSTACHE_RES@biparch
		(tplan, tactu, test, pid, ecet, acta, acst, ident)
		SELECT
		tplan, tactu, test, pid, ecet, acta, acst, ident
		FROM CONS_SSTACHE_RES
			WHERE pid IN
				(SELECT pid FROM LIGNE_BIP
					WHERE ADATESTATUT < L_MOINS5ANS
				);

		COMMIT;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes copiées dans la table archive_cons_sstache_res';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

		DELETE FROM CONS_SSTACHE_RES
			WHERE pid IN
				(SELECT pid FROM LIGNE_BIP
					WHERE ADATESTATUT < L_MOINS5ANS
				);
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table cons_sstache_res';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table CONS_SSTACHE_RES_MOIS_ARCHIVE
	--
	-- 	On garde 3 ans en ligne dans CONS_SSTACHE_RES_MOIS_ARCHIVE ,
	--	le reste va dans ARCHIVE_CONS_SSTACHE_RES_MOIS qui sera gardé 7 ans de plus
	--  Déplacer dans ARCHIVE_CONS_SSTACHE_RES_MOIS  si CDEB < DATDEBEX - 3 ans
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'CONS_SSTACHE_RES_MOIS_ARCHIVE : Garde 3 ans en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_cons_sstache_res_mois';


		DECLARE
			CURSOR c_cons_archive IS
				SELECT	cdeb, cdur, cusag, chraf, chinit, pid, ecet, acta, acst, ident
				FROM CONS_SSTACHE_RES_MOIS_ARCHIVE
				WHERE cdeb < L_MOINS3ANS;

		BEGIN
			FOR un_cons IN c_cons_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_cons_sstache_res_mois avant de la supprimer
				--
				INSERT INTO ARCHIVE_CONS_SSTACHE_RES_MOIS@biparch
				(cdeb, cdur, cusag, chraf, chinit, pid, ecet, acta, acst, ident)
				VALUES
				( un_cons.cdeb, un_cons.cdur, un_cons.cusag, un_cons.chraf, un_cons.chinit,
				  un_cons.pid, un_cons.ecet, un_cons.acta, un_cons.acst, un_cons.ident );

				-- Gère un commit tous les 10000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=10000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_cons_sstache_res_mois';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table cons_sstache_res_mois_archive';

			LOOP
				--
				-- On supprime les données dans la table cons_sstache_res_mois_archive
				-- fait un commit tous les 10000 enregistrements
				--
				DELETE FROM CONS_SSTACHE_RES_MOIS_ARCHIVE
				WHERE cdeb < L_MOINS3ANS
				AND   ROWNUM <= 10000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 10000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 10000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table cons_sstache_res_mois_archive';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;

	-----------------------------------------------------
	--  table COUT_STD_SG
	--
	--  On garde 3 ans en ligne dans Cout_std_sg, le reste va dans Archive_Cout_std_sg qui ne sera pas purgé
    --  Déplacer dans ARCHIVE_COUT_STD_SG si ANNEE < Annee(DATDEBEX - 3 ans)
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'COUT_STD_SG : Laisse 3 ans en ligne ');

		INSERT INTO ARCHIVE_COUT_STD_SG@biparch
		(annee, niveau, metier, cout_sg,
		dpg_haut, dpg_bas, flaglock)
		SELECT
		annee, niveau, metier, cout_sg,
		dpg_haut, dpg_bas, flaglock
		FROM COUT_STD_SG
		WHERE annee < L_ANNEE3ANS ;

		COMMIT;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes copiées dans la table archive_Cout_std_sg';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

		DELETE FROM COUT_STD_SG WHERE annee < L_ANNEE3ANS   ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table Cout_std_sg';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table CUMUL_CONSO
	--
	-- 	On garde 1 an en ligne dans Cumul_conso , le reste va dans Archive_Cumul_conso qui sera gardé 10 ans.
	--	Déplacer dans ARCHIVE_CUMUL_CONSO  si ANNEE < Annee(DATDEBEX - 1 an)
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'CUMUL_CONSO : Laisse 1 an en ligne ');

		INSERT INTO ARCHIVE_CUMUL_CONSO@biparch
		(annee, pid, ftsg, ftssii,
		envsg, envssii)
		SELECT
		annee, pid, ftsg, ftssii,
		envsg, envssii
		FROM CUMUL_CONSO
		WHERE annee < L_ANNEE1AN ;

		COMMIT;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes copiées dans la table archive_cumul_conso';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

		DELETE FROM CUMUL_CONSO WHERE annee < L_ANNEE1AN   ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table cumul_conso';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );


	-----------------------------------------------------
	--  table HISTO_STOCK_FI
	--
	-- 	On garde 3 ans en ligne dans HISTO_STOCK_FI ,
	--	le reste va dans ARCHIVE_HISTO_STOCK_FI qui sera gardé 7 ans de plus
	--  Déplacer dans ARCHIVE_HISTO_STOCK_FI  si CDEB < DATDEBEX - 3 ans
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'HISTO_STOCK_FI : Garde 3 ans en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_histo_stock_fi';


		DECLARE
			CURSOR c_fi_archive IS
				SELECT
				cdeb, pid, ident, typproj,
				metier, pnom, codsg, dpcode,
				icpi, codcamo, clibrca, cafi,
				codsgress, libdsg, rnom, rtype,
				prestation, niveau, soccode, cada,
				coutftht, coutft, coutenv, consojhimmo,
				nconsojhimmo, consoft, consoenvimmo, nconsoenvimmo,
				a_consojhimmo, a_nconsojhimmo, a_consoft, a_consoenvimmo,
				a_nconsoenvimmo, fi1
				FROM HISTO_STOCK_FI
				WHERE cdeb < L_MOINS3ANS;

		BEGIN
			FOR un_cons IN c_fi_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_histo_stock_fi avant de la supprimer
				--
				INSERT INTO ARCHIVE_HISTO_STOCK_FI@biparch
				(cdeb, pid, ident, typproj,
				metier, pnom, codsg, dpcode,
				icpi, codcamo, clibrca, cafi,
				codsgress, libdsg, rnom, rtype,
				prestation, niveau, soccode, cada,
				coutftht, coutft, coutenv, consojhimmo,
				nconsojhimmo, consoft, consoenvimmo, nconsoenvimmo,
				a_consojhimmo, a_nconsojhimmo, a_consoft, a_consoenvimmo,
				a_nconsoenvimmo, fi1)
				VALUES
				( un_cons.cdeb, un_cons.pid, un_cons.ident, un_cons.typproj,
				un_cons.metier, un_cons.pnom, un_cons.codsg, un_cons.dpcode,
				un_cons.icpi, un_cons.codcamo, un_cons.clibrca, un_cons.cafi,
				un_cons.codsgress, un_cons.libdsg, un_cons.rnom, un_cons.rtype,
				un_cons.prestation, un_cons.niveau, un_cons.soccode, un_cons.cada,
				un_cons.coutftht, un_cons.coutft, un_cons.coutenv, un_cons.consojhimmo,
				un_cons.nconsojhimmo, un_cons.consoft, un_cons.consoenvimmo, un_cons.nconsoenvimmo,
				un_cons.a_consojhimmo, un_cons.a_nconsojhimmo, un_cons.a_consoft, un_cons.a_consoenvimmo,
				un_cons.a_nconsoenvimmo, un_cons.fi1);


				-- Gère un commit tous les 5000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=5000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_histo_stock_fi';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table histo_stock_fi';

			LOOP
				--
				-- On supprime les données dans la table histo_stock_fi
				-- fait un commit tous les 5000 enregistrements
				--
				DELETE FROM HISTO_STOCK_FI
				WHERE cdeb < L_MOINS3ANS
				AND   ROWNUM <= 5000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 5000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table histo_stock_fi';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;


	-----------------------------------------------------
	--  table HISTO_STOCK_IMMO
	--
	-- 	On garde 3 ans en ligne dans HISTO_STOCK_IMMO ,
	--	le reste va dans ARCHIVE_HISTO_STOCK_IMMO qui sera gardé 7 ans de plus
	--  Déplacer dans ARCHIVE_HISTO_STOCK_IMMO  si CDEB < DATDEBEX - 3 ans
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'HISTO_STOCK_IMMO : Garde 3 ans en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_histo_stock_immo';


		DECLARE
			CURSOR c_immo_archive IS
				SELECT
				cdeb, pid, ident, typproj,
				metier, pnom, codsg, dpcode,
				icpi, codcamo, clibrca, cafi,
				codsgress, libdsg, rnom, rtype,
				prestation, niveau, soccode, cada,
				coutftht, coutft, consojh, consoft,
				a_consojh, a_consoft, immo1
				FROM HISTO_STOCK_IMMO
				WHERE cdeb < L_MOINS3ANS;

		BEGIN
			FOR un_cons IN c_immo_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_histo_stock_immo avant de la supprimer
				--
				INSERT INTO ARCHIVE_HISTO_STOCK_IMMO@biparch
				(cdeb, pid, ident, typproj,
				metier, pnom, codsg, dpcode,
				icpi, codcamo, clibrca, cafi,
				codsgress, libdsg, rnom, rtype,
				prestation, niveau, soccode, cada,
				coutftht, coutft, consojh, consoft,
				a_consojh, a_consoft, immo1)
				VALUES
				( un_cons.cdeb, un_cons.pid, un_cons.ident, un_cons.typproj,
				un_cons.metier, un_cons.pnom, un_cons.codsg, un_cons.dpcode,
				un_cons.icpi, un_cons.codcamo, un_cons.clibrca, un_cons.cafi,
				un_cons.codsgress, un_cons.libdsg, un_cons.rnom, un_cons.rtype,
				un_cons.prestation, un_cons.niveau, un_cons.soccode, un_cons.cada,
				un_cons.coutftht, un_cons.coutft, un_cons.consojh, un_cons.consoft,
				un_cons.a_consojh, un_cons.a_consoft,  un_cons.immo1);


				-- Gère un commit tous les 5000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=5000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_histo_stock_immo';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table histo_stock_immo';

			LOOP
				--
				-- On supprime les données dans la table histo_stock_immo
				-- fait un commit tous les 5000 enregistrements
				--
				DELETE FROM HISTO_STOCK_IMMO
				WHERE cdeb < L_MOINS3ANS
				AND   ROWNUM <= 5000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 5000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table histo_stock_immo';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;

	-----------------------------------------------------
	--  table ISAC_CONSOMME
	--
	-- 	On garde en ligne que l'année en cours dans Isac_Consomme ,
	--    le reste va dans Archive_Isac_Consomme qui sera gardé 1 ans de plus
	--  Déplacer dans ARCHIVE_ISAC_CONSOMME  si CDEB < DATDEBEX
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'ISAC_CONSOMME : Garde 0 ans en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_isac_consomme';

		DECLARE
			CURSOR c_isac_archive IS
				SELECT	ident, sous_tache, cdeb, cusag, pid, etape, tache
				FROM ISAC_CONSOMME
				WHERE cdeb < L_MOINS0ANS;

		BEGIN
			FOR un_cons IN c_isac_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_isac_consomme avant de la supprimer
				--
				INSERT INTO ARCHIVE_ISAC_CONSOMME@biparch
				(ident, sous_tache, cdeb, cusag, pid, etape, tache)
				VALUES
				( un_cons.ident, un_cons.sous_tache, un_cons.cdeb, un_cons.cusag,
				  un_cons.pid, un_cons.etape, un_cons.tache );

				-- Gère un commit tous les 10000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=10000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_isac_consomme';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table isac_consomme';

			LOOP
				--
				-- On supprime les données dans la table isac_consomme
				-- fait un commit tous les 10000 enregistrements
				--
				DELETE FROM ISAC_CONSOMME
				WHERE cdeb < L_MOINS0ANS
				AND   ROWNUM <= 10000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 10000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 10000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table isac_consomme';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;

	-----------------------------------------------------
	--  table PROPLUS
	--
	-- 	On garde 1 an en ligne dans PROPLUS ,
	--    le reste va dans ARCHIVE_PROPLUS qui sera gardé 9 ans de plus
	--  Déplacer dans ARCHIVE_PROPLUS  si CDEB < DATDEBEX - 1 an
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'PROPLUS : Garde 1 an en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_proplus';

		DECLARE
			CURSOR c_proplus_archive IS
				SELECT
				factpid, pid, aist, aistty,
				tires, cdeb, ptype, factpty,
				pnom, factpno, pdsg, factpdsg,
				pcpi, factpcp, pcmouvra, factpcm,
				pnmouvra, pdatdebpre, cusag, rnom,
				rprenom, datdep, divsecgrou, cpident,
				cout, matricule, societe, qualif,
				dispo, chinit, chraf, rtype
				FROM PROPLUS
				WHERE cdeb < L_MOINS1AN;

		BEGIN
			FOR un_cons IN c_proplus_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_proplus avant de la supprimer
				--
				INSERT INTO ARCHIVE_PROPLUS@biparch
				(factpid, pid, aist, aistty,
				tires, cdeb, ptype, factpty,
				pnom, factpno, pdsg, factpdsg,
				pcpi, factpcp, pcmouvra, factpcm,
				pnmouvra, pdatdebpre, cusag, rnom,
				rprenom, datdep, divsecgrou, cpident,
				cout, matricule, societe, qualif,
				dispo, chinit, chraf, rtype)
				VALUES
				( un_cons.factpid, un_cons.pid, un_cons.aist, un_cons.aistty,
				un_cons.tires, un_cons.cdeb, un_cons.ptype, un_cons.factpty,
				un_cons.pnom, un_cons.factpno, un_cons.pdsg, un_cons.factpdsg,
				un_cons.pcpi, un_cons.factpcp, un_cons.pcmouvra, un_cons.factpcm,
				un_cons.pnmouvra, un_cons.pdatdebpre, un_cons.cusag, un_cons.rnom,
				un_cons.rprenom, un_cons.datdep, un_cons.divsecgrou, un_cons.cpident,
				un_cons.cout, un_cons.matricule, un_cons.societe, un_cons.qualif,
				un_cons.dispo, un_cons.chinit, un_cons.chraf, un_cons.rtype );

				-- Gère un commit tous les 5000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=5000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_proplus';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table proplus';

			LOOP
				--
				-- On supprime les données dans la table proplus
				-- fait un commit tous les 5000 enregistrements
				--
				DELETE FROM PROPLUS
				WHERE cdeb < L_MOINS1AN
				AND   ROWNUM <= 5000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 5000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table proplus';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;

	-----------------------------------------------------
	--  table REE_REESTIME
	--
	-- 	On garde en ligne que l'année en cours dans REE_REESTIME ,
	--    le reste va dans ARCHIVE_REE_REESTIME qui sera gardé 1 ans de plus
	--  Déplacer dans ARCHIVE_REE_REESTIME  si CDEB < DATDEBEX
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'REE_REESTIME : Laisse 0 an en ligne ');

		INSERT INTO ARCHIVE_REE_REESTIME@biparch
		(codsg, code_scenario, cdeb, type,
		ident, code_activite, conso_prevu)
		SELECT
		codsg, code_scenario, cdeb, type,
		ident, code_activite, conso_prevu
		FROM REE_REESTIME
		WHERE cdeb < L_MOINS0ANS ;

		COMMIT;
		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes copiées dans la table archive_ree_reestime';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

		DELETE FROM REE_REESTIME WHERE cdeb < L_MOINS0ANS   ;
		COMMIT;

		L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table ree_reestime';
		TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	--  table STOCK_RA
	--
	-- 	On garde en ligne que l'année en cours dans STOCK_RA ,
	--    le reste va dans ARCHIVE_STOCK_RA qui sera gardé 1 ans de plus
	--  Déplacer dans ARCHIVE_STOCK_RA  si CDEB < DATDEBEX
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'STOCK_RA : Garde 0 ans en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_stock_ra';

		DECLARE
			CURSOR c_ra_archive IS
				SELECT	factpid, pid, cdeb, typproj,
				metier, pnom, codsg, dpcode,
				icpi, cada, codcamo, ecet,
				typetap, acta, acst, aist,
				asnom, cafi, codsgress, ident,
				rtype, niveau, prestation, soccode,
				coutftht, coutfthtr, coutenv, consojh,
				consoft, consoenv, a_consojh, a_consoft,
				a_consoenv, flag_ra
				FROM STOCK_RA
				WHERE cdeb < L_MOINS0ANS;

		BEGIN
			FOR un_cons IN c_ra_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_stock_ra avant de la supprimer
				--
				INSERT INTO ARCHIVE_STOCK_RA@biparch
				(factpid, pid, cdeb, typproj,
				metier, pnom, codsg, dpcode,
				icpi, cada, codcamo, ecet,
				typetap, acta, acst, aist,
				asnom, cafi, codsgress, ident,
				rtype, niveau, prestation, soccode,
				coutftht, coutfthtr, coutenv, consojh,
				consoft, consoenv, a_consojh, a_consoft,
				a_consoenv, flag_ra)
				VALUES
				( un_cons.factpid, un_cons.pid, un_cons.cdeb, un_cons.typproj,
				un_cons.metier, un_cons.pnom, un_cons.codsg, un_cons.dpcode,
				un_cons.icpi, un_cons.cada, un_cons.codcamo, un_cons.ecet,
				un_cons.typetap, un_cons.acta, un_cons.acst, un_cons.aist,
				un_cons.asnom, un_cons.cafi, un_cons.codsgress, un_cons.ident,
				un_cons.rtype, un_cons.niveau, un_cons.prestation, un_cons.soccode,
				un_cons.coutftht, un_cons.coutfthtr, un_cons.coutenv, un_cons.consojh,
				un_cons.consoft, un_cons.consoenv, un_cons.a_consojh, un_cons.a_consoft,
				un_cons.a_consoenv, un_cons.flag_ra );

				-- Gère un commit tous les 5000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=5000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_stock_ra';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table stock_ra';

			LOOP
				--
				-- On supprime les données dans la table stock_ra
				-- fait un commit tous les 5000 enregistrements
				--
				DELETE FROM STOCK_RA
				WHERE cdeb < L_MOINS0ANS
				AND   ROWNUM <= 5000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 5000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table stock_ra';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;
	-----------------------------------------------------
	--  table SYNTHESE_ACTIVITE
	--
	-- 	On garde 1 an en ligne dans SYNTHESE_ACTIVITE ,
	--    le reste va dans ARCHIVE_SYNTHESE_ACTIVITE qui sera gardé 9 ans de plus
	--  Déplacer dans ARCHIVE_SYNTHESE_ACTIVITE   si ANNEE < Annee(DATDEBEX - 1 an)
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'SYNTHESE_ACTIVITE : Garde 1 an en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_synthese_activite';

		DECLARE
			CURSOR c_sa_archive IS
				SELECT
				pid, annee, typproj, metier,
				pnom, codsg, dpcode, icpi,
				codcamo, consojh_sg, consojh_ssii, consoft_sg,
				consoft_ssii, consoenv_sg, consoenv_ssii
				FROM SYNTHESE_ACTIVITE
				WHERE annee < L_ANNEE1AN;

		BEGIN
			FOR un_cons IN c_sa_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_synthese_activite avant de la supprimer
				--
				INSERT INTO ARCHIVE_SYNTHESE_ACTIVITE@biparch
				(pid, annee, typproj, metier,
				pnom, codsg, dpcode, icpi,
				codcamo, consojh_sg, consojh_ssii, consoft_sg,
				consoft_ssii, consoenv_sg, consoenv_ssii)
				VALUES
				( un_cons.pid, un_cons.annee, un_cons.typproj, un_cons.metier,
				un_cons.pnom, un_cons.codsg, un_cons.dpcode, un_cons.icpi,
				un_cons.codcamo, un_cons.consojh_sg, un_cons.consojh_ssii, un_cons.consoft_sg,
				un_cons.consoft_ssii, un_cons.consoenv_sg, un_cons.consoenv_ssii );

				-- Gère un commit tous les 5000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=5000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_synthese_activite';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table synthese_activite';

			LOOP
				--
				-- On supprime les données dans la table synthese_activite
				-- fait un commit tous les 5000 enregistrements
				--
				DELETE FROM SYNTHESE_ACTIVITE
				WHERE annee < L_ANNEE1AN
				AND   ROWNUM <= 5000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 5000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table synthese_activite';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;


	-----------------------------------------------------
	--  table SYNTHESE_ACTIVITE_MOIS
	--
	-- 	On garde 1 an en ligne dans SYNTHESE_ACTIVITE_MOIS ,
	--    le reste va dans ARCHIVE_SYNTHESE_ACTIVITE_MOIS qui sera gardé 4 ans de plus
	--  Déplacer dans ARCHIVE_SYNTHESE_ACTIVITE_MOIS   si CDEB < DATDEBEX - 1 an
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'SYNTHESE_ACTIVITE_MOIS : Garde 1 ans en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_synthese_activite_mois';

		DECLARE
			CURSOR c_sam_archive IS
				SELECT
				pid, cdeb, typproj, metier,
				pnom, codsg, dpcode, icpi,
				codcamo, consojh_sg, consojh_ssii, consoft_sg,
				consoft_ssii, consoenv_sg, consoenv_ssii
				FROM SYNTHESE_ACTIVITE_MOIS
				WHERE cdeb < L_MOINS1AN;

		BEGIN
			FOR un_cons IN c_sam_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_synthese_activite_mois avant de la supprimer
				--
				INSERT INTO ARCHIVE_SYNTHESE_ACTIVITE_MOIS@biparch
				(pid, cdeb, typproj, metier,
				pnom, codsg, dpcode, icpi,
				codcamo, consojh_sg, consojh_ssii, consoft_sg,
				consoft_ssii, consoenv_sg, consoenv_ssii)
				VALUES
				( un_cons.pid, un_cons.cdeb, un_cons.typproj, un_cons.metier,
				un_cons.pnom, un_cons.codsg, un_cons.dpcode, un_cons.icpi,
				un_cons.codcamo, un_cons.consojh_sg, un_cons.consojh_ssii, un_cons.consoft_sg,
				un_cons.consoft_ssii, un_cons.consoenv_sg, un_cons.consoenv_ssii );

				-- Gère un commit tous les 5000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=5000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_synthese_activite_mois';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table synthese_activite_mois';

			LOOP
				--
				-- On supprime les données dans la table synthese_activite_mois
				-- fait un commit tous les 5000 enregistrements
				--
				DELETE FROM SYNTHESE_ACTIVITE_MOIS
				WHERE cdeb < L_MOINS1AN
				AND   ROWNUM <= 5000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 5000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table synthese_activite_mois';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;

	-----------------------------------------------------
	--  table SYNTHESE_FIN
	--
	-- 	On garde 1 an en ligne dans SYNTHESE_FIN ,
	--    le reste va dans ARCHIVE_SYNTHESE_FIN qui sera gardé 4 ans de plus
	--  Déplacer dans ARCHIVE_SYNTHESE_FIN   si ANNEE < Annee(DATDEBEX - 1 an)
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'SYNTHESE_FIN : Garde 1 an en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_synthese_fin';

		DECLARE
			CURSOR c_sf_archive IS
				SELECT
				annee, pid, codsg, codcamo,
				cafi, codsgress, cada, consojhsg_im,
				consojhssii_im, consoftsg_im, consoftssii_im, consojhsg_fi,
				consojhssii_fi, consoftsg_fi, consoftssii_fi, consoenvsg_ni,
				consoenvssii_ni, consoenvsg_im, consoenvssii_im, d_consojhsg_fi,
				d_consojhssii_fi, d_consoftsg_fi, d_consoftssii_fi, d_consoenvsg_ni,
				d_consoenvssii_ni, d_consoenvsg_im, d_consoenvssii_im, m_consojhsg_im,
				m_consojhssii_im, m_consoftsg_im, m_consoftssii_im, m_consojhsg_fi,
				m_consojhssii_fi, m_consoftsg_fi, m_consoftssii_fi, m_consoenvsg_ni,
				m_consoenvssii_ni, m_consoenvsg_im, m_consoenvssii_im, a_consojh_im,
				a_consoft_im, a_consojh_fi, a_consoft_fi, a_consoenv_ni,
				a_consoenv_im
				FROM SYNTHESE_FIN
				WHERE annee < L_ANNEE1AN;

		BEGIN
			FOR un_cons IN c_sf_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_synthese_fin avant de la supprimer
				--
				INSERT INTO ARCHIVE_SYNTHESE_FIN@biparch
				(annee, pid, codsg, codcamo,
				cafi, codsgress, cada, consojhsg_im,
				consojhssii_im, consoftsg_im, consoftssii_im, consojhsg_fi,
				consojhssii_fi, consoftsg_fi, consoftssii_fi, consoenvsg_ni,
				consoenvssii_ni, consoenvsg_im, consoenvssii_im, d_consojhsg_fi,
				d_consojhssii_fi, d_consoftsg_fi, d_consoftssii_fi, d_consoenvsg_ni,
				d_consoenvssii_ni, d_consoenvsg_im, d_consoenvssii_im, m_consojhsg_im,
				m_consojhssii_im, m_consoftsg_im, m_consoftssii_im, m_consojhsg_fi,
				m_consojhssii_fi, m_consoftsg_fi, m_consoftssii_fi, m_consoenvsg_ni,
				m_consoenvssii_ni, m_consoenvsg_im, m_consoenvssii_im, a_consojh_im,
				a_consoft_im, a_consojh_fi, a_consoft_fi, a_consoenv_ni,
				a_consoenv_im)
				VALUES
				( un_cons.annee, un_cons.pid, un_cons.codsg, un_cons.codcamo,
				un_cons.cafi, un_cons.codsgress, un_cons.cada, un_cons.consojhsg_im,
				un_cons.consojhssii_im, un_cons.consoftsg_im, un_cons.consoftssii_im, un_cons.consojhsg_fi,
				un_cons.consojhssii_fi, un_cons.consoftsg_fi, un_cons.consoftssii_fi, un_cons.consoenvsg_ni,
				un_cons.consoenvssii_ni, un_cons.consoenvsg_im, un_cons.consoenvssii_im, un_cons.d_consojhsg_fi,
				un_cons.d_consojhssii_fi, un_cons.d_consoftsg_fi, un_cons.d_consoftssii_fi, un_cons.d_consoenvsg_ni,
				un_cons.d_consoenvssii_ni, un_cons.d_consoenvsg_im, un_cons.d_consoenvssii_im, un_cons.m_consojhsg_im,
				un_cons.m_consojhssii_im, un_cons.m_consoftsg_im, un_cons.m_consoftssii_im, un_cons.m_consojhsg_fi,
				un_cons.m_consojhssii_fi, un_cons.m_consoftsg_fi, un_cons.m_consoftssii_fi, un_cons.m_consoenvsg_ni,
				un_cons.m_consoenvssii_ni, un_cons.m_consoenvsg_im, un_cons.m_consoenvssii_im, un_cons.a_consojh_im,
				un_cons.a_consoft_im, un_cons.a_consojh_fi, un_cons.a_consoft_fi, un_cons.a_consoenv_ni,
				un_cons.a_consoenv_im );

				-- Gère un commit tous les 5000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=5000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_synthese_fin';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table synthese_fin';

			LOOP
				--
				-- On supprime les données dans la table synthese_fin
				-- fait un commit tous les 5000 enregistrements
				--
				DELETE FROM SYNTHESE_FIN
				WHERE annee < L_ANNEE1AN
				AND   ROWNUM <= 5000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 5000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table synthese_fin';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;

	-----------------------------------------------------
	--  table SYNTHESE_FIN_BIP
	--
	-- 	On garde 1 an en ligne dans SYNTHESE_FIN_BIP ,
	--    le reste va dans ARCHIVE_SYNTHESE_FIN_BIP qui sera gardé 9 ans de plus
	--  Déplacer dans ARCHIVE_SYNTHESE_FIN_BIP   si ANNEE < Annee(DATDEBEX - 1 an)
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'SYNTHESE_FIN_BIP : Garde 1 an en ligne ');
		L_COMPTEUR := 0;
		L_TOTAL := 0;
		L_STATEMENT := 'Sauvegarde Des données dans la table archive_synthese_fin_bip';

		DECLARE
			CURSOR c_sfb_archive IS
				SELECT
				annee, pid, consoftsg_im, consoftssii_im,
				consosg_fi, consossii_fi, d_consosg_fi, d_consossii_fi,
				m_consosg_fi, m_consossii_fi
				FROM SYNTHESE_FIN_BIP
				WHERE annee < L_ANNEE1AN;

		BEGIN
			FOR un_cons IN c_sfb_archive LOOP
				--
				-- On sauvegarde les données dans la table archive_synthese_fin_bip avant de la supprimer
				--
				INSERT INTO ARCHIVE_SYNTHESE_FIN_BIP@biparch
				(annee, pid, consoftsg_im, consoftssii_im,
				consosg_fi, consossii_fi, d_consosg_fi, d_consossii_fi,
				m_consosg_fi, m_consossii_fi)
				VALUES
				( un_cons.annee, un_cons.pid, un_cons.consoftsg_im, un_cons.consoftssii_im,
				un_cons.consosg_fi, un_cons.consossii_fi, un_cons.d_consosg_fi, un_cons.d_consossii_fi,
				un_cons.m_consosg_fi, un_cons.m_consossii_fi );

				-- Gère un commit tous les 5000 enregistrements
				L_COMPTEUR:= L_COMPTEUR+1;
				IF L_COMPTEUR>=5000 THEN
					COMMIT;
					L_TOTAL := L_TOTAL + L_COMPTEUR ;
					L_COMPTEUR:=0;
				END IF;

			END LOOP;
			COMMIT;

			L_TOTAL := L_TOTAL + L_COMPTEUR ;
			L_STATEMENT := '-> '||L_TOTAL ||' lignes copiées dans la table archive_synthese_fin_bip';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

			L_TOTAL := 0;
			L_STATEMENT := 'Suppression dans la table synthese_fin_bip';

			LOOP
				--
				-- On supprime les données dans la table synthese_fin_bip
				-- fait un commit tous les 5000 enregistrements
				--
				DELETE FROM SYNTHESE_FIN_BIP
				WHERE annee < L_ANNEE1AN
				AND   ROWNUM <= 5000;

				L_TOTAL := L_TOTAL + SQL%ROWCOUNT ;

				-- On sort de la boucle si on a supprimé moins de 5000 enregistrements
				EXIT WHEN SQL%ROWCOUNT < 5000;
				COMMIT;

			END LOOP;
			COMMIT;

			L_STATEMENT := '-> '||L_TOTAL||' lignes supprimées dans la table synthese_fin_bip';
			TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
		EXCEPTION
			when others then
			    rollback;
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				raise CALLEE_FAILED;
		END;


	-----------------------------------------------------
	-----------------------------------------------------

    	TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME );

	EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;

	END archive_tables;

END pack_archive_tables;
/
CREATE OR REPLACE PACKAGE pack_asynchrone AS

   TYPE asyncRecType IS RECORD (titre         trait_asynchrone.titre%TYPE,
                                nom_fichier   varchar2(200),
                                statut        varchar2(100),
                                date          varchar2(20),
                                reportid      trait_asynchrone.REPORTID%TYPE
					 );

   TYPE asyncCurType IS REF CURSOR RETURN asyncRecType ;

   FUNCTION getStatut_async( p_statut IN INTEGER ) RETURN VARCHAR2 ;

   FUNCTION getURL_async( 	p_type        IN VARCHAR2,
				p_statut      IN INTEGER,
				p_nom_fichier IN VARCHAR2 ) RETURN VARCHAR2 ;
   --
   --    WNDS   means "writes no database state" (does not modify database tables).
   --
   --    WNPS   means "writes no package state" (does not change the values of packaged variables).
   --
   --    RNDS   means "reads no database state" (does not query database tables).
   --
   --    RNPS   means "reads no package state" (does not reference the values of packaged variables).
   --
   PRAGMA RESTRICT_REFERENCES (getStatut_async, WNDS, WNPS, RNDS, RNPS);
   PRAGMA RESTRICT_REFERENCES (getURL_async, WNDS, WNPS, RNDS, RNPS);


   --
   -- Gestion des extractions
   --
   PROCEDURE update_async( 	p_global      IN VARCHAR2,
                           	p_type        IN VARCHAR2,
			        p_titre       IN VARCHAR2,
			        p_nom_fichier IN VARCHAR2,
			        p_statut      IN INTEGER,
			        p_reportid    IN VARCHAR2,
			        p_message     OUT VARCHAR2
			       );

   --
   -- Gestion des éditions
   --
   PROCEDURE update_async( p_global                IN VARCHAR2,
                           p_type                  IN VARCHAR2,
                           p_titre                 IN VARCHAR2,
                           p_nom_fichier_initial   IN VARCHAR2,
                           p_date                  IN DATE,
                           p_nom_fichier_final     IN VARCHAR2,
                           p_statut                IN INTEGER,
			        	   p_reportid    		   IN VARCHAR2,
                           p_message               OUT VARCHAR2
                         );

   PROCEDURE select_async( p_type        IN VARCHAR2,
                           p_global      IN VARCHAR2,
                           p_curseur     IN OUT asyncCurType,
			   p_message     OUT VARCHAR2
			       );
   PROCEDURE delete_async(
			   p_type        IN VARCHAR2,
			   p_global      IN VARCHAR2,
			   p_message     OUT VARCHAR2
			   );

   PROCEDURE purge_async(  p_delai       IN INTEGER,
			   p_type        IN VARCHAR2
			       );


   PROCEDURE liste_delete_async( p_type        IN VARCHAR2,
                           		 p_global      IN VARCHAR2,
                           		 p_curseur     IN OUT asyncCurType,
			   			   		 p_message     OUT VARCHAR2
			       		 		 );

END pack_asynchrone ;
/

CREATE OR REPLACE PACKAGE BODY pack_asynchrone AS

-------------------------------------------------------------------
--
------------------------------------------------------------------

   FUNCTION getStatut_async( p_statut IN INTEGER ) RETURN VARCHAR2 IS

      l_statut varchar2(100);

   BEGIN
	IF (p_statut = -1) THEN
	   l_statut := 'Erreur';

	ELSIF (p_statut = 0) THEN
	   l_statut := 'En cours';

	ELSIF (p_statut = 1) THEN
	   l_statut := 'Terminé';

	ELSIF (p_statut = 2) THEN
	   l_statut := 'Terminé';

	ELSE
	   l_statut := '';

	END IF;

	RETURN l_statut;

   END getStatut_async;


-------------------------------------------------------------------
--
------------------------------------------------------------------

   FUNCTION getURL_async( p_type        IN VARCHAR2,
			  p_statut      IN INTEGER,
			  p_nom_fichier IN VARCHAR2 ) RETURN VARCHAR2 IS

	l_pos1	integer;
	l_pos2	integer;
	l_base_name trait_asynchrone.nom_fichier%TYPE;
      l_URL		varchar2(1024);
	l_image	varchar2(50) := '<img src="images/fileatt.gif" border=0>';

   BEGIN
	IF (p_type = 'E') THEN
	   --
	   -- Edition, p_nom_fichier ~= http://192.16.238.123:8000/reports/35690393.htm
	   --
	   IF (p_statut = 1) THEN
		l_URL := '<a href="' || p_nom_fichier || '">' || l_image || '</a>';
	   ELSE
		l_URL := '';
	   END IF;

	   RETURN l_URL;

	ELSIF (p_type = 'X') THEN
	   --
	   -- Extraction, p_nom_fichier ~= S935710.BIPTACHE.DOC
	   --
	   l_pos1 := INSTR( p_nom_fichier, '.', 1, 1);

         l_pos2 := INSTR( p_nom_fichier, '.', 1, 2);

         l_base_name := SUBSTR( p_nom_fichier, l_pos1 + 1, l_pos2 - l_pos1 - 1);		-- BIPTACHE

	   IF (p_statut = 1) THEN
		l_URL := '<a href="download.htm?File=' || p_nom_fichier || '">' || l_image || '<br>' || l_base_name || '</a>' ;
	   ELSE
		l_URL := l_base_name;
	   END IF;

	   RETURN l_URL;

	ELSIF (p_type = 'U') THEN
	   --
	   -- Upload, p_nom_fichier ~= ???
	   --
	   RETURN '';

	ELSE
	   RETURN '';

	END IF;

   END getURL_async;


-------------------------------------------------------------------
--
-------------------------------------------------------------------

   PROCEDURE update_async( p_global      IN VARCHAR2,
                           p_type        IN VARCHAR2,
			   p_titre       IN VARCHAR2,
			   p_nom_fichier IN VARCHAR2,
			   p_statut      IN INTEGER,
	           p_reportid    IN VARCHAR2,
			   p_message     OUT VARCHAR2
			       ) IS

	l_msg       VARCHAR2(1024);
	l_idarpege  VARCHAR2(255);
	l_nb        NUMBER;
	l_titre	trait_asynchrone.titre%TYPE;
   BEGIN

	-- Initialiser le message retour

	p_message  := '';

	l_idarpege := pack_global.lire_globaldata(p_global).idarpege;

	l_titre    := pack_conversion.unescape(p_titre);

	BEGIN
	   SELECT count(statut)
	   INTO   l_nb
	   FROM   trait_asynchrone
	   WHERE  userid      = l_idarpege
	   AND    type        = p_type
	   AND    titre       = l_titre
	   AND    nom_fichier = p_nom_fichier;

	   IF ( (l_nb IS NULL) OR (l_nb = 0) ) THEN
		--
		-- Pas de ligne, donc INSERT
		--
		BEGIN
		   INSERT INTO trait_asynchrone( userid,
							   type,
							   titre,
							   nom_fichier,
							   statut,
							   date_trait,
							   reportid
							 )
		   VALUES ( l_idarpege,
				p_type,
				l_titre,
				p_nom_fichier,
				p_statut,
				sysdate,
				p_reportid
			     );
		COMMIT;

		EXCEPTION
		   WHEN OTHERS THEN
			raise_application_error( -20997, SQLERRM);
		END;
	   ELSE
		--
		-- Ligne existante, donc UPDATE
		--
		BEGIN
		   UPDATE trait_asynchrone
			SET statut     = p_statut,
			    date_trait = sysdate
		   WHERE  userid      = l_idarpege
		   AND    type        = p_type
		   AND    titre       = l_titre
		   AND    nom_fichier = p_nom_fichier;

		   COMMIT;

		EXCEPTION
		   WHEN OTHERS THEN
			raise_application_error( -20997, SQLERRM);
		END;
	   END IF;


	EXCEPTION
	   WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM);

	END;

   END update_async;


-------------------------------------------------------------------
--
-------------------------------------------------------------------

   PROCEDURE update_async( p_global                IN VARCHAR2,
                           p_type                  IN VARCHAR2,
                           p_titre                 IN VARCHAR2,
                           p_nom_fichier_initial   IN VARCHAR2,
                           p_date                  IN DATE,
                           p_nom_fichier_final     IN VARCHAR2,
                           p_statut                IN INTEGER,
						   p_reportid			   IN VARCHAR2,
                           p_message               OUT VARCHAR2
                         ) IS

	l_msg           VARCHAR2(1024);
	l_idarpege      VARCHAR2(255);
	l_nb            NUMBER;
	l_titre         trait_asynchrone.titre%TYPE;
	l_nom_fichier   trait_asynchrone.nom_fichier%TYPE;

	--L_RETCOD	NUMBER;
	--L_HFILE	utl_file.file_type;
	BEGIN
		--L_RETCOD := TRCLOG.INITTRCLOG( '/projet/bip/devwl/bipdata/batch' , 'ZZZZZZZ', L_HFILE );
		-- Initialiser le message retour
		p_message     := '';

		l_idarpege    := pack_global.lire_globaldata(p_global).idarpege;

		l_titre       := pack_conversion.unescape(p_titre);

		l_nom_fichier := p_nom_fichier_initial || '@' || p_date;

		BEGIN
			IF ( p_statut = 0 ) THEN
			--
			-- Lancement de l'edition, donc INSERT
			--
				BEGIN
					INSERT INTO trait_asynchrone(	userid,
													type,
													titre,
													nom_fichier,
													statut,
													date_trait,
													reportid )
					VALUES (	l_idarpege,
								p_type,
								l_titre,
								l_nom_fichier,
								p_statut,
								P_DATE,
								p_reportid);
					COMMIT;

					EXCEPTION
					WHEN OTHERS THEN
					raise_application_error( -20997, SQLERRM);
				END;
			ELSE
    	--
		-- Edition terminee ou en erreur, donc UPDATE
		--
			BEGIN
--				TRCLOG.TRCLOG( L_HFILE, 'P_GLOBAL : ' || P_GLOBAL);
--				TRCLOG.TRCLOG( L_HFILE, 'P_TYPE : ' || P_TYPE);
--				TRCLOG.TRCLOG( L_HFILE, 'P_TITRE : ' || P_TITRE);
--				TRCLOG.TRCLOG( L_HFILE, 'P_NOM_FICHIER_INITIAL : ' || P_NOM_FICHIER_INITIAL);
--				TRCLOG.TRCLOG( L_HFILE, 'P_DATE : ' || P_DATE);
--				TRCLOG.TRCLOG( L_HFILE, 'P_NOM_FICHIER_FINAL : ' || P_NOM_FICHIER_FINAL);
--				TRCLOG.TRCLOG( L_HFILE, 'P_STATUT : ' || P_STATUT);
--				TRCLOG.TRCLOG( L_HFILE, 'L_NOM_FICHIER : ' || L_NOM_FICHIER);
				UPDATE trait_asynchrone
					SET
						statut	= p_statut,
						date_trait	= sysdate,
						nom_fichier	= p_nom_fichier_final
					WHERE
						userid	= l_idarpege
					AND type	= p_type
					AND titre	= l_titre
					AND nom_fichier = l_nom_fichier;

				--TRCLOG.TRCLOG( L_HFILE, 'nb enr : ' || SQL%ROWCOUNT);
				COMMIT;

				--TRCLOG.CLOSETRCLOG( L_HFILE );
				EXCEPTION
					WHEN OTHERS THEN
						--TRCLOG.CLOSETRCLOG( L_HFILE );
						raise_application_error( -20997, SQLERRM);
	            END;

			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				--TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( -20997, SQLERRM);
		END;

	END update_async;

-------------------------------------------------------------------
--
------------------------------------------------------------------

   PROCEDURE select_async( p_type        IN VARCHAR2,
                           p_global      IN VARCHAR2,
                           p_curseur     IN OUT asyncCurType,
			   p_message     OUT VARCHAR2
			       ) IS

	l_idarpege  VARCHAR2(255);

   BEGIN

	-- Initialiser le message retour

	p_message := '';

	l_idarpege := pack_global.lire_globaldata(p_global).idarpege;

	OPEN p_curseur FOR

	SELECT	titre,
			--pack_asynchrone.getURL_async( type, statut, nom_fichier ),
			nom_fichier,
			pack_asynchrone.getStatut_async( statut ),
			to_char(date_trait,'DD/MM/YYYY HH24:MI'),
			reportid
	FROM		trait_asynchrone
	WHERE		userid = l_idarpege
	  AND		type   = p_type
	ORDER BY	date_trait desc;

   END select_async;

-------------------------------------------------------------------
--
------------------------------------------------------------------

   PROCEDURE delete_async( p_type        IN VARCHAR2,
                           p_global      IN VARCHAR2,
			   p_message     OUT VARCHAR2
			 ) IS

	l_idarpege  VARCHAR2(255);
	l_sysdate DATE;
   BEGIN

	p_message := '';
	l_idarpege := pack_global.lire_globaldata(p_global).idarpege;
	l_sysdate := sysdate;
	BEGIN
	   DELETE trait_asynchrone
	   WHERE  type       = p_type
	   AND (statut = 1 or statut = -1)
	   AND date_trait < TRUNC(sysdate)
	   AND userid = l_idarpege;

	   COMMIT;

	EXCEPTION
	   WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM);
	END;



   END delete_async;

-------------------------------------------------------------------
--
------------------------------------------------------------------

   PROCEDURE purge_async( p_delai    IN INTEGER,
			  p_type     IN VARCHAR2
			      ) IS

   BEGIN

	BEGIN
	   DELETE trait_asynchrone
	   WHERE  type       = p_type
	   AND    date_trait < ( trunc(sysdate) - p_delai );

	   COMMIT;

	EXCEPTION
	   WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM);
	END;

   END purge_async;




-------------------------------------------------------------------
-- liste_delete_async : Fonction listant le fichier à supprimer
------------------------------------------------------------------

PROCEDURE liste_delete_async( p_type        IN VARCHAR2,
                           	  p_global      IN VARCHAR2,
                           	  p_curseur     IN OUT asyncCurType,
			   				  p_message     OUT VARCHAR2
			       			) IS
	l_idarpege  VARCHAR2(255);
BEGIN

	-- Initialiser le message retour
	p_message := '';
	l_idarpege := pack_global.lire_globaldata(p_global).idarpege;

	OPEN p_curseur FOR
		SELECT titre,
			   nom_fichier,
			   pack_asynchrone.getStatut_async( statut ),
			   to_char(date_trait,'DD/MM/YYYY HH24:MI'),
			   reportid
		  FROM trait_asynchrone
	     WHERE type = p_type
	   	   AND (statut = 1 or statut = -1)
	   	   AND date_trait < TRUNC(sysdate)
	   	   AND userid = l_idarpege
      ORDER BY date_trait desc;

END liste_delete_async;


END pack_asynchrone ;
/
CREATE OR REPLACE PACKAGE pack_batch_cloture AS

PROCEDURE cloture (p_logdir in varchar2);

--
-- Procedure de suppression des structures
--
PROCEDURE archive_structure (p_logdir in varchar2);

END pack_batch_cloture;
/

CREATE OR REPLACE PACKAGE BODY pack_batch_cloture  AS
-- ---------------------------------------------------

	CALLEE_FAILED exception;
	pragma exception_init( CALLEE_FAILED, -20000 );
	CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
	TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
	ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
	CONSTRAINT_VIOLATION exception;          -- pour clause when
	pragma exception_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère

PROCEDURE cloture(p_logdir IN VARCHAR2)
IS

l_retcod	number;
l_procname 	varchar2(16) := 'CLOTURE';
l_statement	varchar2(64);
l_hfile	utl_file.file_type;
nblig		varchar2(200);
l_datdebex date;

BEGIN


-- Init de la trace
-- ----------------
L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
if ( L_RETCOD <> 0 ) then
	raise_application_error( TRCLOG_FAILED_ID,'Erreur : Gestion du fichier LOG impossible',false );
end if;

-- Trace Start
-- -----------
TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

--SELECT trunc(sysdate,'YEAR') INTO l_datdebex from dual ;
UPDATE DATDEBEX SET DATDEBEX = TRUNC(ADD_MONTHS(datdebex,12),'YEAR') ;

TRCLOG.TRCLOG( l_hfile, 'Mise à jour Date Exercice DATDEBEX : ' || to_char(l_datdebex,'DD/MM/YYYY') );


L_STATEMENT := 'Maj de Ligne_bip';
-- MAZ des colonnes PREESANCOU, PCCONSN1
-- -------------------------------------

UPDATE ligne_bip set pconsn1 = 0;

TRCLOG.TRCLOG( L_HFILE, L_STATEMENT ||'-'||sql%rowcount);
commit;

-- vide RESSOURCE_ECART
PACKBATCH.DYNA_TRUNCATE('RESSOURCE_ECART');

TRCLOG.TRCLOG( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME );

-- Trace Stop
-- ----------
TRCLOG.CLOSETRCLOG( L_HFILE );

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		If  sqlcode <> -20001 and
	         	sqlcode <>  -20101 and
			sqlcode <>  -20102 and
			sqlcode <>  -20103 then
		   	TRCLOG.TRCLOG( l_hfile, l_procname ||' : '|| SQLERRM );
	     	end if;
	     	if sqlcode <> -20001 then
		  	TRCLOG.TRCLOG( l_hfile, 'Fin ANORMALE de ' || L_PROCNAME  );
		  	TRCLOG.CLOSETRCLOG( l_hfile );
		  	raise_application_error(-20000,
					 'Erreur : consulter le fichier LOG',false );
	     	else
		  	raise;
	     	end if;

END cloture;


PROCEDURE archive_structure (p_logdir IN VARCHAR2) IS

l_retcod	number;
l_procname 	varchar2(17) := 'ARCHIVE_STRUCTURE';
l_statement	varchar2(64);
l_hfile	utl_file.file_type;
nblig		varchar2(200);
l_datdebex date;
l_compteur number :=0;

BEGIN


-- Init de la trace
-- ----------------
L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
if ( L_RETCOD <> 0 ) then
	raise_application_error( TRCLOG_FAILED_ID,'Erreur : Gestion du fichier LOG impossible',false );
end if;

-- Trace Start
-- -----------
TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

SELECT datdebex INTO l_datdebex
FROM datdebex;

	--
	-- On supprime tous les consommes de cons_sstache_res_mois_archive qui pourrait etre sur
	-- l'anne suivante
	--
	BEGIN

		TRCLOG.TRCLOG( L_HFILE, 'Suppression des lignes dans cons_sstache_res_mois_archive');

		DELETE cons_sstache_res_mois_archive
		WHERE cdeb>=l_datdebex;

		IF SQL%NOTFOUND THEN
			TRCLOG.TRCLOG( L_HFILE, 'Pas d enregistrements pour posterieur à: '||l_datdebex);
		END IF;

		COMMIT;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			TRCLOG.TRCLOG( L_HFILE, 'Pas de donnees archivees sur l annee prochaine');
	END;


	DECLARE
		CURSOR c_archive IS
			SELECT c.pid,c.ecet,c.acta,c.acst,c.cdeb,c.ident,c.cusag,c.cdur,c.chraf,c.chinit,t.aist,t.asnom
			FROM tache t, cons_sstache_res_mois c
			WHERE c.pid=t.pid
			AND c.ecet=t.ecet
			AND c.acta=t.acta
			AND c.acst=t.acst
			AND c.cdeb>=l_datdebex;

	BEGIN

		TRCLOG.TRCLOG( L_HFILE, 'Insertion dans la table archive');


			FOR one_archive IN c_archive LOOP

			--
			-- On sauvegarde la structure dans la table cons_sstache_res_mois_archive avant de la supprimer
			--
				INSERT INTO cons_sstache_res_mois_archive(pid,ecet,acta,acst,cdeb,ident,cusag,cdur,chraf,chinit,aist,asnom)
				VALUES (one_archive.pid,
				one_archive.ecet,
				one_archive.acta,
				one_archive.acst,
				one_archive.cdeb,
				one_archive.ident,
				one_archive.cusag,
				one_archive.cdur,
				one_archive.chraf,
				one_archive.chinit,
				one_archive.aist,
				one_archive.asnom)
				;

				l_compteur:= l_compteur+1;
				IF l_compteur=500 THEN
					COMMIT;
					l_compteur:=0;
				END IF;


			END LOOP;


			-- On supprime tous les enregistrements dans cons_sstache_res_mois
			-- Le but est de ne pas conserver la structure des lignes d'une annee sur l'autre
			-- Lors du traitement mensuel, on ne supprime que les elements inexistants l'annee precedente...
			-- C'est pourquoi, il ne faut pas laisser de consommes....

			TRCLOG.TRCLOG( L_HFILE, 'Suppression des lignes dans cons_sstache_res_mois');

			DELETE cons_sstache_res_mois;

			COMMIT;

		EXCEPTION

			WHEN CONSTRAINT_VIOLATION THEN
				TRCLOG.TRCLOG( L_HFILE, 'Erreur dans la sauvegarde des structures ' || SQLERRM);

		END;


TRCLOG.TRCLOG( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME );

-- Trace Stop
-- ----------
TRCLOG.CLOSETRCLOG( L_HFILE );


EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
--		If  sqlcode <> -20001 and
--	         	sqlcode <>  -20101 and
--			sqlcode <>  -20102 and
--			sqlcode <>  -20103 then
		   	TRCLOG.TRCLOG( l_hfile, l_procname ||' : '|| SQLERRM );
--	     	end if;
--	     	if sqlcode <> -20001 then
		  	TRCLOG.TRCLOG( l_hfile, 'Fin ANORMALE de ' || L_PROCNAME  );
		  	TRCLOG.CLOSETRCLOG( l_hfile );
--		  	raise_application_error(-20000,
--					 'Erreur : consulter le fichier LOG',false );
--	     	else
--		  	raise;
--	     	end if;

END archive_structure;

END pack_batch_cloture;
/
CREATE OR REPLACE PACKAGE pack_batch_histo_cloture AS

  -- ------------------------------------------------------------------------
  -- Nom         :  amthist
  -- Auteur      :  P. JOSSE
  -- Description :  historisation des consommés immobilisés au cours de l'année d'exercice.
  -- 		    Sélection des enregistrements de STOCK_IMMO
  --
  --
  -- ------------------------------------------------------------------------
PROCEDURE cloture_exercice (P_LOGDIR in varchar2);

PROCEDURE cloture_fi_nov (P_LOGDIR in varchar2);

END pack_batch_histo_cloture;
/

CREATE OR REPLACE PACKAGE BODY pack_batch_histo_cloture AS
-- -------------------
-- Gestions exceptions
-- -------------------
   CALLEE_FAILED exception;
   pragma exception_init( CALLEE_FAILED, -20000 );
   CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
   TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
   ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
   CONSTRAINT_VIOLATION exception;          -- pour clause when
   pragma exception_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère



  -- ******************************************************************************************
PROCEDURE cloture_exercice (P_LOGDIR in varchar2) IS

   L_HFILE utl_file.file_type;
   L_RETCOD       number;
   L_PROCNAME     varchar2(64) := 'pack_batch_amthist.cloture_exercice';
   L_STATEMENT    varchar2(64);

   l_inserted     number:=0;


BEGIN
   -- ----------------
   -- Init de la trace
   -- ----------------
      L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
     if ( L_RETCOD <> 0 ) then
         raise_application_error( TRCLOG_FAILED_ID,
                   'Erreur : Gestion du fichier LOG impossible');
     end if;


   -- -----------
   -- Trace Start
   -- -----------
   TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

   L_STATEMENT := 'MISE A JOUR DE HISTO_STOCK_IMMO';

   -- -----------
   -- On insert toute les lignes de STOCK_IMMO dans la table
   -- En attendant d'avoir des specs plus précises
   -- -----------
   SELECT count(*) INTO l_inserted
   FROM STOCK_IMMO;

   INSERT INTO HISTO_STOCK_IMMO
   (SELECT * FROM STOCK_IMMO);

   TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || l_inserted||' rows inserted');

   COMMIT;
   -- ----------
   -- Trace Stop
   -- ----------
   TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME );
   TRCLOG.CLOSETRCLOG( L_HFILE );

EXCEPTION
   WHEN OTHERS THEN
      ROLLBACK;
      IF (sqlcode <> CALLEE_FAILED_ID) and  (sqlcode <> TRCLOG_FAILED_ID)
      THEN  TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' : '|| SQLERRM );
      END IF;

      IF sqlcode <> TRCLOG_FAILED_ID
      THEN  TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
            TRCLOG.CLOSETRCLOG( L_HFILE );
            raise_application_error( CALLEE_FAILED_ID,'Erreur : consulter le fichier LOG',false );
      ELSE  raise;
      END IF;

END cloture_exercice;

  -- ******************************************************************************************
PROCEDURE cloture_fi_nov (P_LOGDIR in varchar2) IS

   L_HFILE utl_file.file_type;
   L_RETCOD       number;
   L_PROCNAME     varchar2(64) := 'pack_batch_amthist.cloture_fi_nov';
   L_STATEMENT    varchar2(64);

   l_inserted     number:=0;


BEGIN
   -- ----------------
   -- Init de la trace
   -- ----------------
      L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
     if ( L_RETCOD <> 0 ) then
         raise_application_error( TRCLOG_FAILED_ID,
                   'Erreur : Gestion du fichier LOG impossible');
     end if;


   -- -----------
   -- Trace Start
   -- -----------
   TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

   L_STATEMENT := 'MISE A JOUR DE HISTO_STOCK_FI';

   -- -----------
   -- On insert toute les lignes de STOCK_FI de novembre dans la table
   -- En attendant d'avoir des specs plus précises
   -- -----------
   SELECT count(*) INTO l_inserted
   FROM STOCK_FI;

   INSERT INTO HISTO_STOCK_FI
   (SELECT * FROM STOCK_FI);

   TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || l_inserted||' rows inserted');

   COMMIT;
   -- ----------
   -- Trace Stop
   -- ----------
   TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME );
   TRCLOG.CLOSETRCLOG( L_HFILE );

EXCEPTION
   WHEN OTHERS THEN
      ROLLBACK;
      IF (sqlcode <> CALLEE_FAILED_ID) and  (sqlcode <> TRCLOG_FAILED_ID)
      THEN  TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' : '|| SQLERRM );
      END IF;

      IF sqlcode <> TRCLOG_FAILED_ID
      THEN  TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
            TRCLOG.CLOSETRCLOG( L_HFILE );
            raise_application_error( CALLEE_FAILED_ID,'Erreur : consulter le fichier LOG',false );
      ELSE  raise;
      END IF;

END cloture_fi_nov;

END pack_batch_histo_cloture;
/
CREATE OR REPLACE PACKAGE PACK_BATCH_REMONTEE AS

PROCEDURE build_fichier_remontee(	p_logdir			IN VARCHAR2,
									p_chemin_fichier	IN VARCHAR2,
                       				p_nom_fichier		IN VARCHAR2);

END PACK_BATCH_REMONTEE;
/

CREATE OR REPLACE PACKAGE BODY PACK_BATCH_REMONTEE AS
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !

PROCEDURE build_fichier_remontee(	p_logdir			IN VARCHAR2,
									p_chemin_fichier	IN VARCHAR2,
                       				p_nom_fichier		IN VARCHAR2)
IS
	l_file_log	utl_file.file_type;
	L_RETCOD	number;
	L_PROCNAME  varchar2(256) := 'rbip_extract';
	l_log		boolean := false;

	l_file_out	utl_file.file_type;
	l_CURSEUR	PACK_REMONTEE.remonteeCurType;
	cur_enr		PACK_REMONTEE.remonteeRecType;
	vBuffer		VARCHAR2 (32767);
	l_amount	BINARY_INTEGER := 32767;
	l_pos		PLS_INTEGER;
	l_clob_len	PLS_INTEGER;
	l_msg 		varchar2(1024);
	rBipClob	CLOB;
BEGIN
	-----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------

	L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, l_file_log );
	if ( L_RETCOD <> 0 )
	then
		raise_application_error( TRCLOG_FAILED_ID, 'Erreur : Gestion du fichier LOG impossible', false );
	end if;
	l_log := true;
	-----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------
	TRCLOG.TRCLOG( l_file_log, 'Debut de ' || L_PROCNAME );
	TRCLOG.TRCLOG( l_file_log, 'Le fichier de donnée est : ' || p_chemin_fichier || '/' || p_nom_fichier);
	-----------------------------------------------------

	l_file_out := UTL_FILE.FOPEN(p_chemin_fichier, p_nom_fichier, 'w', l_amount);
	-- on recupere la liste des fichiers valides dans l_CURSEUR
	TRCLOG.TRCLOG( l_file_log, 'On recupere la liste des fichiers valides ... ' || L_PROCNAME );
	PACK_REMONTEE.select_fichiers_statut(PACK_REMONTEE.STATUT_CONTROLE_OK, l_CURSEUR);
	TRCLOG.TRCLOG( l_file_log, '... fait' || L_PROCNAME );

	LOOP
		FETCH l_CURSEUR INTO cur_enr;
		EXIT WHEN l_CURSEUR%NOTFOUND;
		-- lecture du clob
		-- 	parcours du clob et ajout au fichier de sortie
		PACK_REMONTEE.get_data_fichier(cur_enr.PID, cur_enr.ID_REMONTEUR, rBipClob);
		l_clob_len := dbms_lob.getlength(rBipClob);
		TRCLOG.TRCLOG( l_file_log, ' - Traitement du fichier ' || cur_enr.FICHIER_DATA || ' ' || cur_enr.PID || ' ' || cur_enr.ID_REMONTEUR);


		--dbms_output.put_line('Recup de ' || cur_enr.PID || ' | ' || cur_enr.ID_REMONTEUR);
		l_pos := 1;
		WHILE l_pos < l_clob_len
		LOOP
			dbms_lob.read(rBipClob, l_amount, l_pos, vBuffer);

			IF vBuffer IS NOT NULL
			THEN
				UTL_FILE.PUT(l_file_out, vBuffer); --pas de retour à la ligne !!!!
			END IF;
			utl_file.fflush(l_file_out);
			l_pos := l_pos + l_amount;
		END LOOP;
		PACK_GLOBAL.WRITE_STRING( l_file_out, '');

		--on passe le fichier en statut 'CHARGE'
		TRCLOG.TRCLOG( l_file_log, '	Mise à jour du statut du fichier');
		PACK_REMONTEE.update_fichier(cur_enr.PID, cur_enr.ID_REMONTEUR, PACK_REMONTEE.STATUT_CHARGE, cur_enr.STATUT_INFO);
	end loop;

	TRCLOG.TRCLOG( l_file_log, 'Parcours terminé, on ferme le fichier ' || p_nom_fichier);
	PACK_GLOBAL.CLOSE_WRITE_FILE(l_file_out);

	-----------------------------------------------------
	-- Trace Stop
	-----------------------------------------------------
	TRCLOG.TRCLOG( l_file_log, 'Fin normale de ' || L_PROCNAME  );
	TRCLOG.CLOSETRCLOG( l_file_log );

	EXCEPTION
		WHEN OTHERS THEN
			if l_log = true
			then
				TRCLOG.TRCLOG( l_file_log, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( l_file_log );
				raise;
			end if;

END build_fichier_remontee;

END PACK_BATCH_REMONTEE;
/
CREATE OR REPLACE PACKAGE pack_batch_ressimmeub AS






--***********************************************************
-- Procédure de mise à jour les tables ressource et immeuble
-- à partir des tables TMP_PERSONNE et TMP_IMMEUBLE
--***********************************************************

PROCEDURE maj_ressource(P_LOGDIR          IN VARCHAR2)   ;







END pack_batch_ressimmeub;
/

CREATE OR REPLACE PACKAGE BODY pack_batch_ressimmeub AS


-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
pragma EXCEPTION_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère



--***********************************************************
-- Procédure de mise à jour les tables ressource et immeuble
-- à partir des tables TMP_PERSONNE et TMP_IMMEUBLE
--***********************************************************

PROCEDURE maj_ressource(P_LOGDIR          IN VARCHAR2)  IS


L_PROCNAME  varchar2(16) := 'MAJ_RESS_IMME';
L_STATEMENT varchar2(128);
L_HFILE     utl_file.file_type;
L_RETCOD    number;



CURSOR cur_re IS
SELECT *
FROM ressource
WHERE rtype='P';


v_MATRICULE tmp_personne.matricule%TYPE;
v_IADRABR   tmp_personne.iadrabr%TYPE;
v_BATIMENT  tmp_personne.batiment%TYPE;
v_ETAGE     tmp_personne.etage%TYPE;
v_BUREAU    tmp_personne.bureau%TYPE;
v_RTEL      tmp_personne.rtel%TYPE;
v_ICODIMM   tmp_immeuble.ICODIMM%TYPE;

v_FLAGLOCK 	tmp_immeuble.flaglock%TYPE;

l_ICODIMM   immeuble.ICODIMM%TYPE;


BEGIN


   -----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                        'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

    -----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------


    TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );




	FOR curseur IN cur_re LOOP
	 	BEGIN


		  SELECT MATRICULE, IADRABR, BATIMENT, ETAGE, BUREAU, RTEL
		        INTO v_MATRICULE, v_IADRABR, v_BATIMENT, v_ETAGE, v_BUREAU, v_RTEL
          FROM TMP_PERSONNE
   		  WHERE MATRICULE=curseur.MATRICULE;


		  SELECT ICODIMM, FLAGLOCK INTO v_ICODIMM, v_FLAGLOCK
		  FROM TMP_IMMEUBLE
	      WHERE IADRABR=v_IADRABR;




		  --si la ressource a changer d'immeuble
		  IF(curseur.icodimm <> v_ICODIMM)THEN
		  	BEGIN

			      SELECT ICODIMM INTO l_ICODIMM FROM IMMEUBLE WHERE ICODIMM = v_ICODIMM;

		    EXCEPTION

			 WHEN No_Data_Found THEN

				INSERT INTO immeuble
			    	   VALUES(v_ICODIMM,SUBSTR(v_IADRABR,1,10),v_FLAGLOCK);

			END;

		  END IF;


		  UPDATE ressource
			    SET  ICODIMM = v_ICODIMM,
				 	 BATIMENT = v_BATIMENT,
				  	 ETAGE = v_ETAGE,
					 BUREAU = v_BUREAU,
					 RTEL = v_RTEL
			  	WHERE matricule = curseur.matricule;


		  COMMIT;

		 DBMS_OUTPUT.PUT_LINE('bien :'||curseur.matricule);
		EXCEPTION

			 WHEN No_Data_Found THEN
			 	--UPDATE ressource
			    --SET  BUREAU = curseur.bureau
			  	--WHERE matricule = curseur.matricule;
				rollback;
				DBMS_OUTPUT.PUT_LINE('exception :'||curseur.matricule);

			 WHEN others then
	   			rollback;
				if sqlcode <> CALLEE_FAILED_ID then
				    TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
				end if;
		        TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		        raise CALLEE_FAILED;


        END;

	 END LOOP;





	 TRCLOG.TRCLOG( L_HFILE, 'Fin NORMALE de ' || L_PROCNAME);

EXCEPTION
	when others then
	    rollback;
		if sqlcode <> CALLEE_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' [' || L_STATEMENT ||'] : ' || SQLERRM );
		end if;
		TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		raise CALLEE_FAILED;


end maj_ressource;






END pack_batch_ressimmeub;
/
CREATE OR REPLACE PACKAGE pack_batch_suivfin IS
------------------------------------------------------------------------------
-- Procédure de sélection des lignes pour l'année en cours
------------------------------------------------------------------------------
   PROCEDURE selection(P_LOGDIR 	IN VARCHAR2) ;


END pack_batch_suivfin;
/

CREATE OR REPLACE PACKAGE BODY pack_batch_suivfin AS
-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
pragma EXCEPTION_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
pragma EXCEPTION_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère

PROCEDURE selection(P_LOGDIR          IN VARCHAR2) IS
L_HFILE     utl_file.file_type;
L_RETCOD    number;
L_PROCNAME  varchar2(256) := 'suivi_financier';
L_STATEMENT varchar2(256);
BEGIN
	-----------------------------------------------------
	-- Init de la trace
	-----------------------------------------------------
	L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
	if ( L_RETCOD <> 0 ) then
	raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
	end if;

	-----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------
	TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

	 --Suppression des lignes pour l'année courante
	L_STATEMENT := '* Suppression des lignes de l''année courante de CUMUL_CONSO';
	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	DELETE CUMUL_CONSO
	WHERE annee in (select to_number(to_char(datdebex,'YYYY')) from datdebex);
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes supprimées dans la table CUMUL_CONSO';
	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	COMMIT;

	L_STATEMENT := '* Insertion dans CUMUL_CONSO';
	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );
	INSERT INTO CUMUL_CONSO (annee,pid,ftsg,ftssii,envsg,envssii)
	SELECT
			to_number(to_char(d.datdebex,'YYYY')) annee,
 	   		lb.pid pid,
		 	sg.ftsg,
			ssii.ftssii,
		 	sgenv.envsg,
		 	ssii.envssii
	FROM
		datdebex d,
		ligne_bip lb,
	(SELECT
	  	sum(pr.cusag * DECODE(pr.rtype, 'L', c.cout_log,
	  				-- calcul de coûts HTR(au lieu de HT)
	  				pack_utile_cout.getCoutHTR(sr.soccode,r.rtype,to_number(TO_CHAR(pr.cdeb,'YYYY')),l.metier,sr.niveau,sr.codsg,sr.cout,TO_CHAR(pr.cdeb,'DD/MM/YYYY'),si1.filcode))) ftssii,
	  	sum(pr.cusag * decode(pr.rtype, 'E', 0,
	  					'L', 0,
	  					c.coutenv_ssii)) envssii, -- pas de cout ENV pour les forfaits HS et les logiciels
	  	pr.factpid pid
	FROM
		situ_ress_full sr,
		datdebex d,
		cout_std2 c,
		proplus pr,
		ressource r,
		ligne_Bip l,
		struct_info si1
	WHERE
		l.pid=pr.factpid
		-- Jointures entre proplus et situ_ress_full
		and pr.tires=sr.ident
		and r.ident=sr.ident
		--Année en cours
		and (pr.cdeb BETWEEN d.datdebex AND (ADD_MONTHS(d.datdebex, 12) - 1))
		-- ressource dont la prestation <>(IFO,MO ,GRA,INT,STA)
		and sr.prestation not in ('IFO','MO ','GRA','INT','STA')
		-- ressource SSII
		and sr.soccode<>'SG..'
		--Situation existante
		and (sr.datsitu <= pr.cdeb or sr.datsitu is null)
		and (sr.datdep >= pr.cdeb or sr.datdep is null)
		-- coût ENV
		and sr.codsg between c.dpg_bas and c.dpg_haut
		and c.annee = to_number(to_char(d.datdebex,'YYYY'))
		AND sr.codsg = si1.codsg

	GROUP BY pr.factpid ) ssii,

		(SELECT
	  	sum(pr.cusag * NVL(cg.cout_sg, 0)) ftsg,
	  	pr.factpid pid
	FROM
		situ_ress_full sr,
		datdebex d,
		cout_std_sg cg,
		ligne_bip lb,
		proplus pr
	WHERE
		-- Jointures entre proplus et situ_ress_full
	 	pr.tires = sr.ident
		--Année en cours
		and (pr.cdeb BETWEEN d.datdebex AND (ADD_MONTHS(d.datdebex, 12) - 1))
		-- ressource dont la prestation <> (IFO,MO ,GRA,INT,STA)
		and sr.prestation not in ('IFO','MO ','GRA','INT','STA')
		-- Personne SG
		and sr.soccode='SG..'
		--Situation existante
		and (sr.datsitu <= pr.cdeb or sr.datsitu is null)
		and (sr.datdep >= pr.cdeb or sr.datdep is null)
		and pr.rtype='P'
		and pr.factpid = lb.pid
		-- cout standard SG
		and rtrim(lb.metier) = cg.metier
		and DECODE(sr.niveau, 	'L', 'HC',
		 		'M', 'HC',
		 		'N', 'HC',
		 		sr.niveau)= cg.niveau
		and sr.codsg between cg.dpg_bas and cg.dpg_haut
		and cg.annee = to_number(to_char(d.datdebex,'YYYY'))

	GROUP BY pr.factpid) sg,

	(SELECT
	  	sum(pr.cusag * c.coutenv_sg) envsg,
	  	pr.factpid pid
	FROM
		situ_ress_full sr,
		datdebex d,
		cout_std2 c,
		ligne_bip lb,
		proplus pr
	WHERE
		-- Jointures entre proplus et situ_ress_full
	 	pr.tires = sr.ident
		--Année en cours
		and (pr.cdeb BETWEEN d.datdebex AND (ADD_MONTHS(d.datdebex, 12) - 1))
		-- ressource dont la prestation <> (IFO,MO ,GRA,INT,STA)
		and sr.prestation not in ('IFO','MO ','GRA','INT','STA')
		-- Personne SG
		and sr.soccode='SG..'
		--Situation existante
		and (sr.datsitu <= pr.cdeb or sr.datsitu is null)
		and (sr.datdep >= pr.cdeb or sr.datdep is null)
		and pr.rtype='P'
		and sr.codsg between c.dpg_bas and c.dpg_haut
		and c.annee = to_number(to_char(d.datdebex,'YYYY'))
		and pr.factpid = lb.pid

	GROUP BY pr.factpid) sgenv

	WHERE
		lb.pid = ssii.pid (+)
		AND lb.pid=sg.pid (+)
		AND lb.pid=sgenv.pid (+)
		-- type projet de 1 à 8
		AND lb.typproj<=8;
	commit;
	L_STATEMENT := '-> '||SQL%ROWCOUNT ||' lignes insérées dans la table CUMUL_CONSO';
	TRCLOG.TRCLOG( L_HFILE, L_STATEMENT );

	-----------------------------------------------------
	-- Trace Stop
	-----------------------------------------------------
	TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME  );
	TRCLOG.CLOSETRCLOG( L_HFILE );

	EXCEPTION
		when others then

			ROLLBACK;

			if sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( L_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

END selection;


END pack_batch_suivfin;
/
CREATE OR REPLACE PACKAGE pack_best_date AS
  FUNCTION best_date(
			  p_dateDebLC      IN DATE
			, p_dateFinLC      IN DATE
			, p_dateDebC       IN DATE
			, p_dateFinC       IN DATE
			, p_CoutContrat    IN NUMBER
			, p_CoutRess       IN NUMBER
			, p_DateReturn	   IN VARCHAR2 
		     ) RETURN DATE;
	PRAGMA restrict_references(best_date, wnds);
END pack_best_date;
/

CREATE OR REPLACE PACKAGE BODY pack_best_date AS
--==============================================================================================
-- Fonction de recherche de la meilleur DATE en fonction du nombre JH et de la durée du contrat
--==============================================================================================
FUNCTION best_date(
			  p_dateDebLC      IN DATE
			, p_dateFinLC      IN DATE
			, p_dateDebC       IN DATE
			, p_dateFinC       IN DATE
			, p_CoutContrat    IN NUMBER
			, p_CoutRess       IN NUMBER
			, p_DateReturn	   IN VARCHAR2 
			     ) RETURN DATE
IS
p_newdate	DATE;
p_nbrJH		number(11);
p_dureeLC	number(11);
p_dureeC 	number(11);
p_ecartC	number(11);
p_ecartLC 	number(11);
p_ecartMini	number(11);
BEGIN
--
-- Rechercher de la meilleur date
--
	p_nbrJH:=p_CoutContrat/p_CoutRess;
	p_dureeC:=p_dateFinC-p_dateDebC;
	p_dureeLC:=p_dateFinLC-p_dateDebLC;
	IF (p_dureeC-p_nbrJH) < 0  THEN
		IF (p_dureeLC-p_nbrJH) < 0 THEN
			p_ecartC := p_nbrJH-p_dureeC;
		ELSE
			p_ecartC := (p_dureeLC-p_nbrJH)*2;
		END IF;
	ELSE
		p_ecartC := p_dureeC-p_nbrJH;
	END IF;
	IF (p_dureeLC-p_nbrJH) < 0  THEN
		IF (p_dureeC-p_nbrJH) < 0 THEN
			p_ecartLC := p_nbrJH-p_dureeLC;
		ELSE
			p_ecartLC := (p_dureeC-p_nbrJH)*2;
		END IF;
	ELSE
		p_ecartLC := p_dureeLC-p_nbrJH;
	END IF;
	p_ecartMini :=  LEAST (p_ecartC, p_ecartLC);
	IF p_ecartMini = p_ecartC THEN
		IF p_DateReturn='DEBUT' THEN
			p_newdate := p_dateDebC;
		ELSE
			p_newdate := p_dateFinC	;
		END IF;
	ELSE
		IF p_DateReturn='DEBUT' THEN
			p_newdate := p_dateDebLC;
		ELSE
			p_newdate := p_dateFinLC;	
		END IF;
	END IF;	
	RETURN(p_newdate);
END best_date;
END pack_best_date;
/
CREATE OR REPLACE PACKAGE pack_bjh AS

------------------------------------------------------------
-- Cette procedure modifie les donnees recues de Gershwin
-- en eliminant les ressources qui ne concernent pas la BIP
-- (filtre sur le CA) et en convertissant le mofif
-- d'absence Gershwin en type d'absence BIP
------------------------------------------------------------
	PROCEDURE Filtre_Gershwin;

------------------------------------------------------------
-- Cette procedure recupere le consomme sur l'annee en cours.
------------------------------------------------------------
	PROCEDURE Import_consomme_BIP;

------------------------------------------------------------
-- Cette procedure recupere les ressources concernees par
-- le bouclage.
------------------------------------------------------------
	PROCEDURE Import_Ressource_BIP;

	PROCEDURE Compare_BIP_Gershwin;
END pack_bjh;
/

CREATE OR REPLACE PACKAGE BODY pack_bjh AS

        PROCEDURE Filtre_Gershwin IS
	BEGIN

-- Mis en commentaire par PPR le 12/07/2006
--		DELETE bjh_extgip
--		        WHERE bjh_extgip.gipca NOT IN (SELECT centractiv from struct_info where topfer='O');

		UPDATE bjh_extgip
		        SET bipabs= (SELECT bjh_type_absence.bipabs FROM bjh_type_absence WHERE bjh_type_absence.gipabs=bjh_extgip.motifabs);

-- on ajoute des espaces en fin de type d'absence dans la table Gershwin
-- car c'est du CHAR(6) qui pose entre autre des problemes avec RTT
                UPDATE bjh_extgip
                        SET bipabs=RPAD(bipabs, 6, ' ');
-- la meme chose a ete faite sur bjh_type_absence

		COMMIT;
	END Filtre_Gershwin;



	PROCEDURE Import_Consomme_BIP IS
	BEGIN


-- extraction depuis la BIP des consommes divers
		DELETE bjh_extbip;
		COMMIT;

		INSERT INTO bjh_extbip
			(matricule
			, mois
			, typsst
			, cusag)
		SELECT
			ressource.matricule
			, TO_NUMBER(TO_CHAR(proplus.cdeb,'MM'))
			, RPAD(proplus.aist, 6, ' ')
			, SUM(proplus.cusag)   cusag
		FROM proplus
			, ressource
			, datdebex
		WHERE  proplus.cdeb >= TRUNC(datdebex.datdebex, 'YEAR')
			AND proplus.societe = 'SG..'
			AND proplus.cusag > 0
			AND proplus.rtype    = 'P'
			AND (proplus.divsecgrou < 500000 OR proplus.divsecgrou > 519999)  -- pour retirer SGAM
			AND ressource.ident=proplus.tires
		GROUP BY ressource.matricule
			, RPAD(proplus.aist, 6, ' ')
			, TO_NUMBER(TO_CHAR(proplus.cdeb,'MM'));

		COMMIT;
	END Import_Consomme_BIP;


	PROCEDURE Import_Ressource_BIP IS
	BEGIN
-- extraction des ressources qui nous interessent
		DELETE bjh_ressource;
		COMMIT;

		INSERT INTO bjh_ressource
		(
			matricule,
			mois,
			codsg,
			nom,
			prenom,
			dep,
			pole,
			ident,
			activite
		)
		SELECT DISTINCT
			ressource.matricule
			, cal.mois
			, proplus.divsecgrou
			, ressource.rnom
			, ressource.rprenom
			, struct_info.sigdep
			, struct_info.sigpole
			, ressource.ident
			, struct_info.centractiv
		FROM proplus
			, (SELECT TO_CHAR(calanmois, 'MM') mois
					, cjours
					, calanmois
				FROM calendrier, datdebex
				WHERE TRUNC(calanmois, 'year')=TRUNC(datdebex)		-- annee courante
				AND calanmois<=moismens					-- en se limitant aux mois deja traites
			  ) cal
			, struct_info
			, ressource
		WHERE
			TRUNC(proplus.cdeb, 'MM')=TRUNC(cal.calanmois, 'MM')
			AND proplus.tires=ressource.ident
			AND proplus.divsecgrou=struct_info.codsg
			AND proplus.societe='SG..'					-- seulement les Societe Generale
			AND proplus.rtype='P'						-- ressource de type PERSONNE
			AND (proplus.divsecgrou<500000 OR proplus.divsecgrou>519999)	-- on retire SGAM
			AND ressource.matricule IS NOT NULL				-- on retire les ressources avec un
			AND ressource.matricule!='0000000';				-- matricule incoherent

-- suppression des doublons (meme matricule, ident diferent)
		DELETE bjh_ressource
		WHERE matricule IN
			(SELECT t1.matricule
				FROM bjh_ressource t1
					, bjh_ressource t2
				WHERE t1.matricule=t2.matricule
					AND t1.mois=t2.mois
					AND t1.ident!=t2.ident
			);
		COMMIT;


-- mise a jour des consommes des ressources (a partir de la BIP)
--	consomme total
--	consomme conge
--	consomme absence autre que conge
		UPDATE bjh_ressource
			SET conso_total=(SELECT NVL(SUM(cusag), 0)
								FROM bjh_extbip
								WHERE bjh_extbip.matricule=bjh_ressource.matricule
								AND bjh_extbip.mois=bjh_ressource.mois
							 )
				, conso_conge=(SELECT NVL(SUM(cusag), 0)
								FROM bjh_extbip
								WHERE bjh_extbip.matricule=bjh_ressource.matricule
								AND bjh_extbip.mois=bjh_ressource.mois
								AND bjh_extbip.typsst IN (SELECT bipabs FROM bjh_type_absence)
							 )
				, conso_autre=(SELECT NVL(SUM(cusag), 0)
								FROM bjh_extbip
								WHERE bjh_extbip.matricule=bjh_ressource.matricule
								AND bjh_extbip.mois=bjh_ressource.mois
								AND bjh_extbip.typsst IN ('ACCUEI','CLUBUT','COLOQU','DEMENA','MOBILI','SEMINA')
							 );
		COMMIT;




-- mise a jour du champ "Temps partiel" des ressources a partir de Gershwin
-- la condition ROWNUM=1 est une bidouille car on peut avoir plusieurs lignes pour une ressource et un mois
		UPDATE bjh_ressource
			SET tempart=(SELECT tempart
							FROM bjh_extgip
							WHERE bjh_ressource.mois=bjh_extgip.mois
							AND bjh_ressource.matricule=bjh_extgip.matricule
							AND ROWNUM=1
						);

		COMMIT;
	END Import_Ressource_BIP;





        PROCEDURE Compare_BIP_Gershwin IS
                CURSOR csr_anomalie IS
                        SELECT tmp.matricule    tmp_matricule
                                , ano.matricule		ano_matricule
                                , tmp.mois		mois
                                , tmp.typeabsence	typeabsence
                                , ano.coutgip		ano_coutgip
                                , ano.coutbip		ano_coutbip
                                , tmp.coutgip		tmp_coutgip
                                , tmp.coutbip		tmp_coutbip
				, NVL(ano.validation1, ano.validation2)	validation
				, ano.topdv		topdv
                        FROM bjh_anomalies ano
                                , bjh_anomalies_temp tmp
                        WHERE tmp.matricule=ano.matricule(+)
                                AND tmp.mois=ano.mois(+)
                                AND tmp.typeabsence=ano.typeabsence(+);
		l_moismens	datdebex.moismens%TYPE;
		l_topdv		bjh_anomalies.topdv%TYPE;
	BEGIN
-- alimentation de la table bjh_anomalies_temp qui contient toutes les anomalies BIP / Gershwin a l'instant donnee
		DELETE bjh_anomalies_temp;
		COMMIT;

-- premiere etape : une ligne par ressource, par mois et par type d'absence
		INSERT INTO bjh_anomalies_temp(matricule, mois, typeabsence)
			SELECT
				bjh_ressource.matricule
				, bjh_ressource.mois
				, bipabs
			FROM
				bjh_ressource
				, (SELECT DISTINCT bipabs FROM bjh_type_absence);
		COMMIT;



-- deuxieme etape : mise a jour du cumul pour BIP par ressource, mois, type absence
		UPDATE bjh_anomalies_temp
			SET coutbip=(SELECT NVL(SUM(cusag), 0)
							FROM bjh_extbip
							WHERE bjh_extbip.matricule=bjh_anomalies_temp.matricule
							AND bjh_extbip.mois=bjh_anomalies_temp.mois
							AND bjh_extbip.typsst=bjh_anomalies_temp.typeabsence
						)
			, coutgip=(SELECT NVL(SUM(intjour), 0)
							FROM bjh_extgip
							WHERE bjh_extgip.matricule=bjh_anomalies_temp.matricule
							AND bjh_extgip.mois=bjh_anomalies_temp.mois
							AND bjh_extgip.bipabs=bjh_anomalies_temp.typeabsence
						);
		COMMIT;


-- troisieme etape : suppression des lignes ou BIP = Gershwin
		DELETE bjh_anomalies_temp WHERE coutbip=coutgip;
		COMMIT;


-- quatrieme etape : supression des lignes sans Gershwin ni BIP
		DELETE bjh_anomalies_temp WHERE coutbip IS NULL AND coutgip IS NULL;





-- ################################################################
-- A ce niveau bjh_anomalies_temp contient les ecarts entre BIP et Gershwin.
-- Il faut maintenant mettre a jour bjh_anomalies, sans ecraser les
-- eventuelles validations.
-- La procedure pour cela est la suivante :
--		- suppresion des anomalies de bjh_anomalies qui n'existent
--		  pas dans bjh_anomalies_temp (anomalies corrigees)
--		- mise a jour des anomalies presentes dans les deux tables
--		  mais pour des valeurs differentes
--		  (suppression de la validation)
--		- ajout dans bjh_anomalies des nouvelles anomalies
-- ################################################################


		DELETE bjh_anomalies b
			WHERE (b.matricule,b.mois,b.typeabsence) NOT IN (SELECT matricule,mois,typeabsence FROM bjh_anomalies_temp);
		COMMIT;


-- toutes les anomalies devalidees le mois precedent redeviennent des anomalies non validees, sans plus
		SELECT moismens
			INTO l_moismens
			FROM datdebex;

		UPDATE bjh_anomalies
			SET topdv=NULL
			WHERE topdv<l_moismens;
		COMMIT;

-- on fait une boucle sur toutes les anomalies dans bjh_anomalies_temp
		FOR rec_anomalie IN csr_anomalie LOOP
			IF rec_anomalie.ano_matricule IS NULL THEN
-- l'anomalie n'existe que dans bjh_anomalies_temp : on l'ajoute dans bjh_anomalies
				INSERT INTO bjh_anomalies(
					matricule
					, mois
					, typeabsence
					, coutgip
					, coutbip
					, dateano
					, validation1
					, validation2
					, ecartcal
					, topdv
				)
				VALUES (
					rec_anomalie.tmp_matricule
					, rec_anomalie.mois
					, rec_anomalie.typeabsence
					, rec_anomalie.tmp_coutgip
					, rec_anomalie.tmp_coutbip
					, SYSDATE
					, NULL
					, NULL
					, 0
					, NULL);
			ELSE
-- l'anomalie existe : on ne modifie que si l'un au moins des couts est different
				IF rec_anomalie.tmp_coutbip!=rec_anomalie.ano_coutbip
						OR rec_anomalie.tmp_coutgip!=rec_anomalie.ano_coutgip THEN

					IF rec_anomalie.topdv=l_moismens THEN
-- l'ano a deja ete marquee devalidee ce mois-ci
						l_topdv:=l_moismens;
					ELSE
						IF rec_anomalie.validation IS NULL THEN
							l_topdv:=NULL;
						ELSE
							l_topdv:=l_moismens;
						END IF;
					END IF;

					UPDATE bjh_anomalies
						SET coutbip=rec_anomalie.tmp_coutbip
							, coutgip=rec_anomalie.tmp_coutgip
							, validation1 = NULL
							, validation2 = NULL
							, topdv=l_topdv
						WHERE matricule=rec_anomalie.tmp_matricule
							AND mois=rec_anomalie.mois
							AND typeabsence=rec_anomalie.typeabsence;
				END IF;
			END IF;

			COMMIT;
		END LOOP;

	END Compare_BIP_Gershwin;

END pack_bjh;
/
CREATE OR REPLACE PACKAGE pack_bjh_anomalies AS

   TYPE Bjh_anomalies_ViewType IS RECORD (matricule bjh_anomalies.matricule%TYPE,
					  nom bjh_ressource.nom%type,
					  prenom bjh_ressource.prenom%type
					);




   TYPE Bjh_une_ano_ViewType IS RECORD (  matricule bjh_anomalies.matricule%TYPE,
					  nom bjh_ressource.nom%type,
					  prenom bjh_ressource.prenom%TYPE,
					  mois bjh_anomalies.mois%TYPE,
					  typeabsence bjh_anomalies.typeabsence%TYPE,
					  coutgip VARCHAR2(20),
					  coutbip VARCHAR2(20),
					  dateano VARCHAR2(20),
					  diff VARCHAR2(20),
					  ecartcal VARCHAR2(20),
					  validation1 bjh_anomalies.validation1%TYPE,
					  validation2 bjh_anomalies.validation2%TYPE
					);


   TYPE bjh_anomaliesCurType_Char IS REF CURSOR RETURN Bjh_anomalies_ViewType;
   TYPE bjh_une_anoCurType_Char IS REF CURSOR RETURN Bjh_une_ano_ViewType;

  PROCEDURE update_bjh_anomalies(   p_nom IN VARCHAR2,
   				    p_matricule IN VARCHAR2,
				    p_prenom IN VARCHAR2,
				    p_mois IN VARCHAR2,
				    p_typeabsence IN VARCHAR2,
				    p_dateano       IN VARCHAR2,
				    p_coutbip          IN VARCHAR2,
				    p_coutgip       IN VARCHAR2,
				    p_diff IN VARCHAR2,
				    p_ecartcal IN VARCHAR2,
				    p_validation1   IN VARCHAR2,
				    p_validation2   IN VARCHAR2,
				    p_userid     IN  VARCHAR2,
				    p_nbcurseur  OUT INTEGER,
                	            p_message    OUT VARCHAR2
	                             );

   PROCEDURE delete_bjh_anomalies ( p_matricule IN VARCHAR2,
				    p_nom IN VARCHAR2,
				    p_prenom IN VARCHAR2,
				    p_mois IN VARCHAR2,
				    p_typeabsence IN VARCHAR2,
				    p_coutgip       IN VARCHAR2,
				    p_coutbip       IN VARCHAR2,
				    p_dateano       IN VARCHAR2,
				    p_validation1   IN VARCHAR2,
				    p_validation2   IN VARCHAR2,
				    p_userid    IN  VARCHAR2,
        	                    p_nbcurseur OUT INTEGER,
                	            p_message   OUT VARCHAR2);

   PROCEDURE select_bjh_anomalies ( 	p_matricule  IN VARCHAR2,
					p_ident      IN VARCHAR2,
					p_codsg      IN VARCHAR2,
				    	p_userid     IN VARCHAR2,
        	                    	p_curBjh_ano IN OUT bjh_anomaliesCurType_Char,
                	            	p_nbcurseur     OUT INTEGER,
                        	    	p_message       OUT VARCHAR2);

   PROCEDURE select_bjh_une_ano( p_matricule IN VARCHAR2,
				 p_rnom IN VARCHAR2,
				 p_prenom IN VARCHAR2,
				 p_cle IN VARCHAR2,
				 p_userid IN VARCHAR2,
        	                 p_curBjh_ano IN OUT bjh_une_anoCurType_Char,
                	         p_nbcurseur         OUT INTEGER,
                                 p_message           OUT VARCHAR2);


   PROCEDURE select_bjh_liste (	p_matricule  IN VARCHAR2,
				p_userid     IN VARCHAR2,
				p_curBjh_ano IN OUT bjh_anomaliesCurType_Char,
                	        p_nbcurseur     OUT INTEGER,
                        	p_message       OUT VARCHAR2);



END pack_bjh_anomalies;
/

CREATE OR REPLACE PACKAGE BODY pack_bjh_anomalies AS

   PROCEDURE update_bjh_anomalies(  p_nom IN VARCHAR2,
   				    p_matricule IN VARCHAR2,
				    p_prenom IN VARCHAR2,
				    p_mois IN VARCHAR2,
				    p_typeabsence IN VARCHAR2,
				    p_dateano       IN VARCHAR2,
				    p_coutbip          IN VARCHAR2,
				    p_coutgip       IN VARCHAR2,
				    p_diff IN VARCHAR2,
				    p_ecartcal IN VARCHAR2,
				    p_validation1   IN VARCHAR2,
				    p_validation2   IN VARCHAR2,
				    p_userid     IN  VARCHAR2,
				    p_nbcurseur  OUT INTEGER,
                	            p_message    OUT VARCHAR2
	                             ) IS

	l_msg VARCHAR2(1024);
	l_matricule bjh_anomalies.matricule%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- initialiser le message retour

	p_nbcurseur := 0;
	p_message := '';

      -- test si le type d'absence existe deja


	BEGIN
         UPDATE bjh_anomalies
		SET
			coutgip = to_number(p_coutgip),
		     	coutbip = to_number(p_coutbip),
			validation1 = p_validation1,
			validation2 = nvl(p_validation2,' ')
		WHERE matricule = p_matricule
		AND mois = p_mois
		AND rtrim(typeabsence,' ') =rtrim(p_typeabsence,' ');

	   EXCEPTION

		WHEN OTHERS THEN
	        raise_application_error( -20754, l_msg );

	--	   raise_application_error( -20997, SQLERRM);
	END;


      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      END IF;

   END update_bjh_anomalies;

   PROCEDURE delete_bjh_anomalies (p_matricule IN VARCHAR2,
				    p_nom IN VARCHAR2,
				    p_prenom IN VARCHAR2,
				    p_mois IN VARCHAR2,
				    p_typeabsence IN VARCHAR2,
				    p_coutgip       IN VARCHAR2,
				    p_coutbip       IN VARCHAR2,
				    p_dateano       IN VARCHAR2,
				    p_validation1   IN VARCHAR2,
				    p_validation2   IN VARCHAR2,
				    p_userid    IN  VARCHAR2,
        	                    p_nbcurseur OUT INTEGER,
                	            p_message   OUT VARCHAR2
                              ) IS


	l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
	   DELETE FROM bjh_anomalies
		    WHERE matricule = p_matricule
			AND mois = p_mois
			AND rtrim(typeabsence,' ') =rtrim(p_typeabsence,' ');

         EXCEPTION

		WHEN referential_integrity THEN

               -- habiller le msg erreur

               pack_global.recuperation_integrite(-2292);

		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      END IF;

   END delete_bjh_anomalies;

   PROCEDURE select_bjh_anomalies(  	p_matricule  IN VARCHAR2,
					p_ident      IN VARCHAR2,
					p_codsg      IN VARCHAR2,
				    	p_userid     IN VARCHAR2,
        	                    	p_curBjh_ano IN OUT bjh_anomaliesCurType_Char,
                	            	p_nbcurseur     OUT INTEGER,
                        	    	p_message       OUT VARCHAR2) IS
	l_msg VARCHAR2(1024);
	l_ges NUMBER(3);
	l_codsg VARCHAR2(7);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';
	BEGIN
		-- Le matricule est renseigné
		IF p_matricule is not null THEN
			SELECT distinct to_char(codsg, 'FM0000000') INTO l_codsg
			FROM bjh_ressource
			WHERE matricule = p_matricule
-- Bidouille pour que cette requete ne retourne qu'une seule ligne !
-- ODU 04/12/2001
				AND ROWNUM=1;
		ELSE
		-- Le code ressource est choisi
				SELECT distinct to_char(codsg, 'FM0000000') INTO l_codsg
				FROM bjh_ressource
				WHERE ident = to_number(p_ident)
-- Bidouille pour que cette requete ne retourne qu'une seule ligne !
-- ODU 04/12/2001
                                AND ROWNUM=1;
		END IF;
	EXCEPTION
  	    WHEN NO_DATA_FOUND THEN
		-- en cas absence
	 	-- 'Anomalie inexistante
			pack_global.recuperer_message(20330, '%s1', p_matricule, NULL, l_msg);
		 	raise_application_error( -20330, l_msg );

          WHEN OTHERS THEN
	            	raise_application_error( -20997,SQLERRM);
      END;



-- On verifie que l'utilisateur est habilite a acceder a cette ressource
-- Comme cette procedure est centrale dans les procedure du bouclage JH,
-- il n'est pas necessaire de le tester dans les autres.
pack_habilitation.verif_habili_me(l_codsg,p_userid,l_msg);

--             'à modifier la ressource ( matricule :' || p_matricule ||
--                                               ', code DPG :'|| l_codsg ||')', NULL);
	IF p_matricule is not null THEN
         	OPEN   p_curBjh_ano FOR
              SELECT a.MATRICULE,
			 BIP.NOM,
			 BIP.PRENOM
              FROM  bjh_anomalies a,(select distinct nom,prenom,matricule matricule1 from bjh_ressource) bip
              WHERE a.matricule = substr(p_matricule,1,7)
		AND a.matricule = bip.matricule1;
	ELSE

		OPEN   p_curBjh_ano FOR
              SELECT a.MATRICULE,
			 BIP.NOM,
			 BIP.PRENOM
              FROM  bjh_anomalies a,(select distinct nom,prenom,matricule,ident from bjh_ressource) bip
              WHERE bip.ident = to_number(p_ident)
		AND a.matricule = bip.matricule;


	END IF;


   END select_bjh_anomalies;

   PROCEDURE select_bjh_une_ano(    p_matricule IN VARCHAR2,
				    p_rnom IN VARCHAR2,
				    p_prenom IN VARCHAR2,
				    p_cle IN VARCHAR2,
				    p_userid IN VARCHAR2,
        	                    p_curBjh_ano IN OUT bjh_une_anoCurType_Char,
                	            p_nbcurseur         OUT INTEGER,
                        	    p_message           OUT VARCHAR2) IS

	l_msg VARCHAR2(1024);
	l_ges NUMBER(3);
	l_codsg VARCHAR(7);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      BEGIN
	SELECT distinct to_char(codsg, 'FM0000000') INTO l_codsg
	FROM bjh_ressource
	WHERE matricule = p_matricule
-- bidouille pour avoir un seul DPG ...
-- ODU : 11/01/2002
		AND ROWNUM=1;


         OPEN   p_curBjh_ano FOR
              SELECT a.MATRICULE,
			 BIP.NOM,
			 BIP.PRENOM,
			 a.MOIS,
			 a.TYPEABSENCE,
			 TO_CHAR(a.COUTGIP,'FM999D0'),
			 TO_CHAR(a.COUTBIP,'FM999D0'),
			 TO_CHAR(a.DATEANO,'DD/MM/YYYY'),
			 TO_CHAR(a.coutbip-a.coutgip,'FM999D0') DIFF,
			 TO_CHAR(a.ecartcal,'FM999D0'),
			 a.validation1,
			 a.validation2
              FROM  bjh_anomalies a,(select distinct nom,prenom,matricule matricule1 from bjh_ressource) bip
              WHERE a.matricule = substr(p_matricule,1,7)
                AND a.mois=SUBSTR(p_cle,1,2)
                AND a.typeabsence=SUBSTR(p_cle,3,6)
		AND a.matricule = bip.matricule1;

         -- en cas absence
	 -- 'Anomalie inexistante'



      EXCEPTION
	WHEN NO_DATA_FOUND THEN
	  pack_global.recuperer_message(20330, '%s1', p_matricule, NULL, l_msg);
	   p_message := l_msg;
        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);
      END;

   END select_bjh_une_ano;

  PROCEDURE select_bjh_liste ( 		p_matricule  IN VARCHAR2,
				    	p_userid     IN VARCHAR2,
					p_curBjh_ano IN OUT bjh_anomaliesCurType_Char,
                	            	p_nbcurseur     OUT INTEGER,
                        	    	p_message       OUT VARCHAR2) IS
  l_msg VARCHAR2(1024);

  BEGIN
	OPEN   p_curBjh_ano FOR
              SELECT a.MATRICULE,
			 BIP.NOM,
			 BIP.PRENOM
              FROM  bjh_anomalies a,(select distinct nom,prenom,matricule matricule1 from bjh_ressource) bip
              WHERE a.matricule = substr(p_matricule,1,7)
		AND a.matricule = bip.matricule1;




  END select_bjh_liste;

END pack_bjh_anomalies;
/
CREATE OR REPLACE PACKAGE pack_bjh_dpg AS

PROCEDURE select_bjh_dpg ( p_matricule IN VARCHAR2,
			   p_ident     IN VARCHAR2,
			   p_codsg     IN VARCHAR2,
			   p_userid    IN VARCHAR2,
        	           p_nbcurseur         OUT INTEGER,
                           p_message           OUT VARCHAR2);
END pack_bjh_dpg;
/

CREATE OR REPLACE PACKAGE BODY pack_bjh_dpg AS

PROCEDURE select_bjh_dpg ( p_matricule IN VARCHAR2,
			   p_ident     IN VARCHAR2,
			   p_codsg     IN VARCHAR2,
			   p_userid    IN VARCHAR2,
        	           p_nbcurseur         OUT INTEGER,
                           p_message           OUT VARCHAR2) IS
  l_msg VARCHAR2(1024);

  BEGIN
	pack_habilitation.verif_habili_me(p_codsg,p_userid,l_msg);

	p_message:=l_msg;

  END select_bjh_dpg;
END pack_bjh_dpg;
/
CREATE OR REPLACE PACKAGE pack_bjh_type_absence AS


   TYPE Bjh_type_absence_ViewType IS RECORD ( bipabs bjh_type_absence.bipabs%TYPE,
					      gipabs bjh_type_absence.bipabs%TYPE);

   TYPE bjh_type_absenceCurType_Char IS REF CURSOR RETURN Bjh_type_absence_ViewType;

   PROCEDURE insert_bjh_type_absence ( p_gipabs     IN VARCHAR2,
				       p_bipabs     IN bjh_type_absence.bipabs%TYPE,
                                       p_userid     IN VARCHAR2,
                           	       p_nbcurseur  OUT INTEGER,
                           	       p_message    OUT VARCHAR2);

   PROCEDURE update_bjh_type_absence (  p_gipabs    IN VARCHAR2,
				        p_bipabs    IN bjh_type_absence.bipabs%TYPE,
					p_userid    IN VARCHAR2,
					p_nbcurseur OUT INTEGER,
                	                p_message   OUT VARCHAR2);

   PROCEDURE delete_bjh_type_absence ( 	p_gipabs    IN VARCHAR2,
					p_bipabs    IN bjh_type_absence.bipabs%TYPE,
					p_userid    IN VARCHAR2,
        	                        p_nbcurseur OUT INTEGER,
                	                p_message   OUT VARCHAR2);

   PROCEDURE select_bjh_type_absence (   p_gipabs      IN VARCHAR2,
        	                         p_curBjh_typa IN OUT bjh_type_absenceCurType_Char,
                	                 p_nbcurseur         OUT INTEGER,
                        	         p_message           OUT VARCHAR2);
END pack_bjh_type_absence;
/

CREATE OR REPLACE PACKAGE BODY pack_bjh_type_absence AS

   PROCEDURE insert_bjh_type_absence ( p_gipabs    IN VARCHAR2,
	  			       p_bipabs    IN bjh_type_absence.bipabs%TYPE,
                                       p_userid	   IN VARCHAR2,
                                       p_nbcurseur OUT INTEGER,
                                       p_message   OUT VARCHAR2
                              ) IS

     l_msg VARCHAR2(1024);
     l_gipabs bjh_type_absence.gipabs%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


	BEGIN
     	   INSERT INTO bjh_type_absence
	    ( bipabs,
 		gipabs)
         VALUES (p_bipabs,
		 p_gipabs
		);
	   -- 'type d'absence p_gipabs cree'


     EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		   pack_global.recuperer_message( 20001, NULL, NULL, NULL, l_msg);
               raise_application_error( -20001, l_msg );

            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);
     END;

   END insert_bjh_type_absence;


   PROCEDURE update_bjh_type_absence(    p_gipabs     IN VARCHAR2,
					 p_bipabs     IN bjh_type_absence.bipabs%TYPE,
					 p_userid     IN VARCHAR2,
	                                 p_nbcurseur  OUT INTEGER,
                	                 p_message    OUT VARCHAR2
	                             ) IS

	l_msg VARCHAR2(1024);
	l_gipabs bjh_type_absence.gipabs%TYPE;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- initialiser le message retour
	p_nbcurseur := 0;
	p_message := '';
      -- test si le type d'absence existe deja

      BEGIN
        SELECT gipabs INTO l_gipabs
        FROM bjh_type_absence
        WHERE p_gipabs= gipabs;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
 	    pack_global.recuperer_message( 20754, NULL, NULL, NULL, l_msg);
          raise_application_error( -20754, l_msg );

        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;

	BEGIN
         UPDATE bjh_type_absence
		SET	bipabs  =   p_bipabs
		WHERE gipabs 	=   p_gipabs;

	   EXCEPTION

		WHEN OTHERS THEN
	        raise_application_error( -20754, l_msg );

--	   raise_application_error( -20997, SQLERRM);
	END;


      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      END IF;

   END update_bjh_type_absence;

   PROCEDURE delete_bjh_type_absence (p_gipabs    IN VARCHAR2,
				      p_bipabs    IN bjh_type_absence.bipabs%TYPE,
				      p_userid    IN VARCHAR2,
        	                      p_nbcurseur OUT INTEGER,
                	              p_message   OUT VARCHAR2
                              ) IS


      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
	   DELETE FROM bjh_type_absence
		    WHERE gipabs = p_gipabs;

         EXCEPTION

		WHEN referential_integrity THEN

               -- habiller le msg erreur
               pack_global.recuperation_integrite(-2292);

		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
           raise_application_error( -20999, l_msg );

      END IF;

   END delete_bjh_type_absence;


   PROCEDURE select_bjh_type_absence(     p_gipabs      IN VARCHAR2,
	                                  p_curbjh_typa IN OUT bjh_type_absenceCurType_Char,
                	                  p_nbcurseur      OUT INTEGER,
                        	          p_message        OUT VARCHAR2
                              		) IS

	l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

-- dbms_output.put_line('p_codsg = ' || p_codsg || ' --- p_userid = ' || p_userid );


      BEGIN
         OPEN   p_curbjh_typa FOR
              SELECT bipabs,
                     gipabs
              FROM  bjh_type_absence
              WHERE gipabs = p_gipabs;

         -- en cas absence
	   -- 'type d'absence inexistante'

         pack_global.recuperer_message( 20331, '%s1', p_gipabs, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION

        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;

   END select_bjh_type_absence;

END pack_bjh_type_absence;
/
CREATE OR REPLACE PACKAGE pack_budactjh AS

FUNCTION str_budactjh 	(	p_string     IN  VARCHAR2,
                           		p_occurence  IN  NUMBER
                          	  ) return VARCHAR2;

PROCEDURE select_budactjh  	 (	p_annee		IN  VARCHAR2,
   					p_clicode      	IN  client_mo.clicode%TYPE,
   					p_clisigle     	OUT  client_mo.clisigle%TYPE,
                               		p_nbpages	OUT VARCHAR2,
                               		p_numpage 	OUT VARCHAR2,
                               		p_nbcurseur	OUT INTEGER,
                               		p_message	OUT VARCHAR2
                               	);

PROCEDURE update_budactjh(		p_string    IN  VARCHAR2,
                              		p_nbcurseur OUT INTEGER,
                              		p_message   OUT VARCHAR2
                             );


END pack_budactjh;
/

CREATE OR REPLACE PACKAGE BODY pack_budactjh AS

   FUNCTION str_budactjh (	p_string     IN  VARCHAR2,
                           	p_occurence  IN  NUMBER
                          	) return VARCHAR2 IS
   pos1 NUMBER(6);
   pos2 NUMBER(6);
   str  VARCHAR2(111);

   BEGIN

      pos1 := INSTR(p_string,';',1,p_occurence);
      pos2 := INSTR(p_string,';',1,p_occurence+1);

      IF pos2 != 1 THEN
         str := SUBSTR( p_string, pos1+1, pos2-pos1-1);
         IF str = 'null' THEN
	    str := '-1' ;
	 END IF ;
         return str;
      ELSE
         return '0';
      END IF;

   END str_budactjh;

PROCEDURE select_budactjh  	 (	p_annee		IN  VARCHAR2,
   					p_clicode      	IN  client_mo.clicode%TYPE,
   					p_clisigle     	OUT  client_mo.clisigle%TYPE,
                               		p_nbpages	OUT VARCHAR2,
                               		p_numpage 	OUT VARCHAR2,
                               		p_nbcurseur	OUT INTEGER,
                               		p_message	OUT VARCHAR2
                               	) IS

      NB_LIGNES_MAXI 	NUMBER(5);
      NB_LIGNES_PAGES   NUMBER(2);
      l_msg	VARCHAR2(1024);
      l_nbpages	NUMBER(5);

      BEGIN
	    -- Nombres de lignes BIP retournées Maxis :
	    NB_LIGNES_MAXI := 500;
	    -- Nombre de lignes BIP maxi par pages
	    NB_LIGNES_PAGES := 10;

	    -- Positionner le nb de curseurs ==> 1
	    -- Initialiser le message retour
	    p_nbcurseur := 1;
	    p_message := '';

	    p_numpage := 'NumPage#1';

	    -- Compte le nombre de lignes
	    SELECT count(distinct dp.DPCODE) INTO l_nbpages
	    FROM dossier_projet dp,
	    	ligne_bip lb
	    WHERE dp.ACTIF = 'O'
	    and lb.CLICODE in (
	    	select clicoderatt
	    	from vue_clicode_hierarchie
	    	where clicode = p_clicode )
	    and dp.DPCODE = lb.DPCODE;

	    SELECT clisigle INTO p_clisigle
	    FROM client_mo
	    WHERE clicode = p_clicode;

	    IF (l_nbpages = 0) THEN
	       pack_global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
	       raise_application_error(-20373 , l_msg);
	     ELSIF (l_nbpages > NB_LIGNES_MAXI) THEN
	       pack_global.recuperer_message( 20381 , '%s1', p_clicode, 'clicode', l_msg);
	       raise_application_error(-20381 , l_msg);
	     END IF;

	     l_nbpages := CEIL(l_nbpages/NB_LIGNES_PAGES);
	     p_nbpages := 'NbPages#'|| l_nbpages;
	EXCEPTION
	   WHEN NO_DATA_FOUND THEN
	       pack_global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
	       raise_application_error(-20373 , l_msg);

	   WHEN OTHERS THEN
	     raise_application_error( -20997, SQLERRM);

      p_message := l_msg;

  END select_budactjh;

  PROCEDURE update_budactjh(		p_string    IN  VARCHAR2,
                              		p_nbcurseur OUT INTEGER,
                              		p_message   OUT VARCHAR2
                             	) IS

   l_msg    	VARCHAR2(10000);
   l_cpt    	NUMBER(7);
   l_annee  	budget_dp.annee%TYPE;
   l_dpcode    	budget_dp.dpcode%TYPE;
   l_clicode  	budget_dp.clicode%TYPE;
   l_budgethtr  budget_dp.budgethtr%TYPE;
   l_exist 	NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message   := '';
      -- Prise en compte de l'année
      l_cpt       := 1;
      l_annee := TO_NUMBER(pack_budactjh.str_budactjh(p_string,l_cpt));
      -- Prise en compte de du clicode
      l_cpt       := 2;
      l_clicode := TO_NUMBER(pack_budactjh.str_budactjh(p_string,l_cpt));
      -- Position de départ pour la boucle
      l_cpt       := 3;

      WHILE l_cpt != 0 LOOP

	l_dpcode := pack_budactjh.str_budactjh(p_string,l_cpt);
        l_budgethtr := TO_NUMBER(NVL(pack_budactjh.str_budactjh(p_string,l_cpt+1),-1));

	IF l_dpcode != '-1' THEN
	        IF l_budgethtr != '-1' THEN

		  -- Existence de la ligne dans budget_dp
	             BEGIN
			select 1 into l_exist
			from budget_dp
			where clicode = l_clicode
			and annee = l_annee
			and dpcode = l_dpcode;
	             EXCEPTION
			WHEN NO_DATA_FOUND THEN
			--Création de la ligne dans la table BUDGET_DP
			INSERT INTO budget_dp (annee, dpcode, clicode, budgethtr)
			VALUES (l_annee,
				l_dpcode,
				l_clicode,
				l_budgethtr);

		     END;

		    IF l_exist=1 THEN
			 --Mise à jour de la table budget_dp
	             	UPDATE budget_dp SET
	                        	budgethtr  = l_budgethtr
	             	where clicode = l_clicode
			and annee = l_annee
			and dpcode = l_dpcode;

		     END IF;

		END IF;
		-- pris en compte de l'année au début de la chaîne {;annee;clicode;dpcode;budgethtr;..;}
		l_cpt := l_cpt + 2;
         ELSE
            l_cpt :=0;
         END IF;
	 dbms_output.put_line('l_cpt:'||l_cpt);
      END LOOP;

   pack_global.recuperer_message( 20972 , '%s1', 'Budget de l''année', '', p_message);

   END update_budactjh;
END pack_budactjh;
/
CREATE OR REPLACE PACKAGE pack_budget IS
	PROCEDURE Delete_budgetprop(
			p_annee		IN	budget.annee%TYPE,
			p_pid	IN	budget.pid%TYPE
	);
PROCEDURE Delete_budgetnot(
			p_annee		IN	budget.annee%TYPE,
			p_pid	IN	budget.pid%TYPE
	);
PROCEDURE Delete_budgetarbprop(
			p_annee		IN	budget.annee%TYPE,
			p_pid	IN	budget.pid%TYPE
	);
PROCEDURE Delete_budgetarbnot(
			p_annee		IN	budget.annee%TYPE,
			p_pid	IN	budget.pid%TYPE
	);
	PROCEDURE Insert_budgetprop(
			p_annee		IN	budget.annee%TYPE,
			p_pid	IN	budget.pid%TYPE,
			p_bpmontme	IN	budget.bpmontme%TYPE,
			p_bpmontme2     IN      budget.bpmontme2%TYPE,
			p_bpdate       IN      budget.bpdate%TYPE,
                	p_reserve          IN      budget.reserve%TYPE,
                	p_bpmontmo        IN      budget.bpmontmo%TYPE
	);
	PROCEDURE Update_budgetprop(
			p_annee		IN	budget.annee%TYPE,
			p_pid	IN	budget.pid%TYPE,
			p_bpmontme	IN	budget.bpmontme%TYPE,
			p_bpmontme2     IN      budget.bpmontme2%TYPE,
			p_bpdate       IN      budget.bpdate%TYPE,
                	p_reserve          IN      budget.reserve%TYPE,
                	p_bpmontmo        IN      budget.bpmontmo%TYPE
	);
	PROCEDURE Insert_budgetnot(
	p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_bnmont	IN	budget.bnmont%TYPE
	);
	PROCEDURE Update_budgetnot(
				p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_bnmont	IN	budget.bnmont%TYPE
	);
PROCEDURE Insert_budgetarbprop(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_apdate	IN	budget.apdate%TYPE,
		p_apmont	IN	budget.apmont%TYPE
	);
	PROCEDURE Update_budgetarbprop(
					p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_apdate	IN	budget.apdate%TYPE,
		p_apmont	IN	budget.apmont%TYPE
	);
PROCEDURE Insert_budgetarbnot(
	p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_anmont	IN	budget.anmont%TYPE
	);
	PROCEDURE Update_budgetarbnot(
			p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_anmont	IN	budget.anmont%TYPE
	);
	PROCEDURE Update_lignebip(
		p_pid	IN	budget.pid%TYPE,
		p_preesancou_old	IN	budget.reestime%TYPE,
		p_preesancou_new        IN      budget.reestime%TYPE
	);
END pack_budget;
/

CREATE OR REPLACE PACKAGE BODY pack_budget IS
	PROCEDURE Delete_budgetprop(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE
	) IS
	BEGIN
        	UPDATE budget set bpmontme = NULL,
					bpmontme2 = NULL,
					bpdate = NULL,
					reserve = NULL,
					bpmontmo = NULL
        	WHERE annee = p_annee
        	AND   pid = p_pid;
	END Delete_budgetprop;
PROCEDURE Delete_budgetarbprop(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE
	) IS
	BEGIN
        	raise_application_error(-20000,'Déclenchement du trigger delete_budgproparb');
	END Delete_budgetarbprop;
	PROCEDURE Delete_budgetarbnot(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE
	) IS
	BEGIN
        	raise_application_error(-20000,'Déclenchement du trigger delete_budgnotarb');
	END Delete_budgetarbnot;
PROCEDURE Delete_budgetnot(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE
	) IS
	BEGIN
        	raise_application_error(-20000,'Déclenchement du trigger delete_budgnot');
	END Delete_budgetnot;
	PROCEDURE Insert_budgetprop(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_bpmontme	IN	budget.bpmontme%TYPE,
		p_bpmontme2     IN      budget.bpmontme2%TYPE,
		p_bpdate       IN      budget.bpdate%TYPE,
                p_reserve          IN      budget.reserve%TYPE,
                p_bpmontmo        IN      budget.bpmontmo%TYPE
               ) IS
	BEGIN
                INSERT INTO BUDGET
						(annee,
			 pid,
			 bnmont,
			 bpmontme,
			 bpmontme2,
			 anmont,
			 bpdate,
			 reserve,
                   apdate,
                   apmont,
			 bpmontmo,
			 reestime,
			 flaglock)
		VALUES (p_annee,
						p_pid,
						NULL,
						p_bpmontme,
						p_bpmontme2,
						NULL,
						p_bpdate,
						p_reserve,
						NULL,
						NULL,
						p_bpmontmo,
						NULL,
						0);
	EXCEPTION
			WHEN DUP_VAL_ON_INDEX THEN
			update_budgetprop(p_annee,p_pid,p_bpmontme,p_bpmontme2,p_bpdate,p_reserve,p_bpmontmo);
	END Insert_budgetprop;
	PROCEDURE Insert_budgetnot(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_bnmont	IN	budget.bnmont%TYPE
               ) IS
	BEGIN
                INSERT INTO BUDGET
						(annee,
			 pid,
			 bnmont,
			 bpmontme,
			 bpmontme2,
			 anmont,
			 bpdate,
			 reserve,
                   apdate,
                   apmont,
			 bpmontmo,
			reestime,
			 flaglock)
		VALUES (p_annee,
						p_pid,
						p_bnmont,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						0);
	EXCEPTION
			WHEN DUP_VAL_ON_INDEX THEN
				update_budgetnot(p_annee,p_pid,p_bnmont);
	END Insert_budgetnot;
PROCEDURE Insert_budgetarbprop(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_apdate	IN	budget.apdate%TYPE,
		p_apmont	IN	budget.apmont%TYPE
               ) IS
	BEGIN
                INSERT INTO BUDGET
						(annee,
			 pid,
			 bnmont,
			 bpmontme,
			 bpmontme2,
			 anmont,
			 bpdate,
			 reserve,
                   apdate,
                   apmont,
			 bpmontmo,
			 reestime,
			 flaglock)
		VALUES (p_annee,
						p_pid,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						p_apdate,
						p_apmont,
						NULL,
						NULL,
						0);
	EXCEPTION
			WHEN DUP_VAL_ON_INDEX THEN
				update_budgetarbprop(p_annee,p_pid,p_apdate,p_apmont);
	END Insert_budgetarbprop;
PROCEDURE Insert_budgetarbnot(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_anmont	IN	budget.anmont%TYPE
               ) IS
	BEGIN
                INSERT INTO BUDGET
						(annee,
			 pid,
			 bnmont,
			 bpmontme,
			 bpmontme2,
			 anmont,
			 bpdate,
			 reserve,
                   apdate,
                   apmont,
			 bpmontmo,
			 reestime,
			 flaglock)
		VALUES (p_annee,
						p_pid,
						NULL,
						NULL,
						NULL,
						p_anmont,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						0);
	EXCEPTION
			WHEN DUP_VAL_ON_INDEX THEN
				update_budgetarbnot(p_annee,p_pid,p_anmont);
	END Insert_budgetarbnot;
	PROCEDURE Update_budgetprop(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_bpmontme	IN	budget.bpmontme%TYPE,
		p_bpmontme2     IN      budget.bpmontme2%TYPE,
		p_bpdate       IN      budget.bpdate%TYPE,
                p_reserve          IN      budget.reserve%TYPE,
                p_bpmontmo        IN      budget.bpmontmo%TYPE
	) IS
	BEGIN
                 	UPDATE BUDGET SET bpdate = p_bpdate,
							bpmontme  = p_bpmontme,
							bpmontme2 = p_bpmontme2,
							reserve = p_reserve,
							bpmontmo = p_bpmontmo
				WHERE annee = p_annee AND pid = p_pid;
	END Update_budgetprop;
	PROCEDURE Update_budgetnot(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_bnmont	IN	budget.bnmont%TYPE
	) IS
	BEGIN
                 	UPDATE BUDGET SET bnmont = p_bnmont
				WHERE annee = p_annee AND pid = p_pid;
	END Update_budgetnot;
	PROCEDURE Update_budgetarbnot(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_anmont	IN	budget.anmont%TYPE
	) IS
	BEGIN
                 	UPDATE BUDGET SET anmont = p_anmont
				WHERE annee = p_annee AND pid = p_pid;
	END Update_budgetarbnot;
	PROCEDURE Update_budgetarbprop(
		p_annee		IN	budget.annee%TYPE,
		p_pid	IN	budget.pid%TYPE,
		p_apdate	IN	budget.apdate%TYPE,
		p_apmont	IN	budget.apmont%TYPE
	) IS
	BEGIN
                 	UPDATE BUDGET SET apdate = p_apdate,
						apmont = p_apmont
				WHERE annee = p_annee AND pid = p_pid;
	END Update_budgetarbprop;
	PROCEDURE Update_lignebip(
		p_pid	IN	budget.pid%TYPE,
		p_preesancou_old	IN	budget.reestime%TYPE,
		p_preesancou_new        IN      budget.reestime%TYPE
	)IS
	BEGIN
		UPDATE BUDGET SET reestime = p_preesancou_new
		WHERE pid = p_pid
		AND annee = (select to_number(to_char(datdebex.datdebex,'YYYY')) from datdebex);
		IF (SQL%ROWCOUNT = 0) THEN
			INSERT INTO BUDGET
				(annee,
				pid,
				bnmont,
				bpmontme,
				bpmontme2,
				anmont,
				bpdate,
				reserve,
				apdate,
				apmont,
				bpmontmo,
				reestime,
				flaglock)
			 (SELECT TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY')),
				p_pid,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				p_preesancou_new,
				0
				FROM datdebex);
	 	END IF;
	END Update_lignebip;
END pack_budget;
/
CREATE OR REPLACE PACKAGE Pack_Calendrier AS

TYPE calendrier_RecType IS RECORD (cafin      	VARCHAR2(20),
                                   calanmois  	VARCHAR2(20),
                                   ccloture   	VARCHAR2(20),
                                   cjours     	VARCHAR2(20),
                                   cnbjourssg   VARCHAR2(20),
                                   cnbjoursssii VARCHAR2(20),
                                   cmensuelle 	VARCHAR2(20),
                                   cpremens1  	VARCHAR2(20),
                                   cpremens2  	VARCHAR2(20),
                                   flaglock   	NUMBER,
								   theorique   	NUMBER
                                  );

   TYPE calendrierCurType IS REF CURSOR RETURN calendrier_RecType;

   PROCEDURE insert_calendrier (p_calanmois  	IN  VARCHAR2,
                                p_cpremens1  	IN  VARCHAR2,
                                p_cpremens2  	IN  VARCHAR2,
                                p_cmensuelle 	IN  VARCHAR2,
                                p_ccloture   	IN  VARCHAR2,
                                p_cafin      	IN  VARCHAR2,
                                p_cjours     	IN  VARCHAR2,
                                p_cnbjourssg 	IN  VARCHAR2,
                                p_cnbjoursssii 	IN  VARCHAR2,
                                p_userid     	IN  VARCHAR2,
								p_theorique   	IN  VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                               );

   PROCEDURE update_calendrier (p_calanmois  	IN  VARCHAR2,
                                p_cpremens1  	IN  VARCHAR2,
                                p_cpremens2  	IN  VARCHAR2,
                                p_cmensuelle 	IN  VARCHAR2,
                                p_ccloture   	IN  VARCHAR2,
                                p_cafin      	IN  VARCHAR2,
                                p_cjours     	IN  VARCHAR2,
                                p_cnbjourssg 	IN  VARCHAR2,
                                p_cnbjoursssii 	IN  VARCHAR2,
                                p_flaglock   	IN  NUMBER,
                                p_userid     	IN  VARCHAR2,
								p_theorique     	IN  VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                               );

   PROCEDURE select_calendrier (p_calanmois     IN  VARCHAR2,
                                p_userid        IN  VARCHAR2,
                                p_cafin         OUT VARCHAR2,
                                p_cal           OUT VARCHAR2,
                                p_ccloture      OUT VARCHAR2,
                                p_cjours        OUT VARCHAR2,
                                p_cnbjourssg 	OUT  VARCHAR2,
                                p_cnbjoursssii 	OUT  VARCHAR2,
                                p_cmensuelle    OUT VARCHAR2,
                                p_cpremens1     OUT VARCHAR2,
                                p_cpremens2     OUT VARCHAR2,
                                p_mode          OUT VARCHAR2,
                                p_flaglock      OUT VARCHAR2,
								p_theorique      OUT VARCHAR2,
                                p_nbcurseur     OUT INTEGER,
                                p_message       OUT VARCHAR2
                               );


   TYPE calendrierListe_ViewType IS RECORD ( MOIS          VARCHAR2(10),
                                           	 PREMENS1      VARCHAR2(30),
                                        	 PREMENS2      VARCHAR2(30),
                                        	 MENSUELLE     VARCHAR2(30),
                                        	 CJOURS        VARCHAR2(6),
											 CCLOTURE	   VARCHAR2(30),
                                           	 CSS_PREMENS1  NUMBER,
                                        	 CSS_PREMENS2  NUMBER,
                                        	 CSS_MENSUELLE NUMBER
									  	   );

   TYPE calendrierListeCurType IS REF CURSOR RETURN calendrierListe_ViewType;

   PROCEDURE liste_annee       (p_annee         IN  VARCHAR2,
                                p_curCalendrier IN OUT calendrierListeCurType,
                                p_nbcurseur     OUT INTEGER,
                                p_message       OUT VARCHAR2
                               );

   TYPE entete_ViewType IS RECORD ( IDFIC    FICHIER.IDFIC%TYPE,
                                    CONTENU  FICHIER.CONTENU%TYPE
								  );

   TYPE enteteCurType IS REF CURSOR RETURN entete_ViewType;

   PROCEDURE get_entete (  p_curEntete IN OUT enteteCurType,
                           p_nbcurseur    OUT INTEGER,
                           p_message      OUT VARCHAR2
						);

END Pack_Calendrier;
/

CREATE OR REPLACE PACKAGE BODY Pack_Calendrier AS

   PROCEDURE insert_calendrier (p_calanmois  	IN  VARCHAR2,
                                p_cpremens1  	IN  VARCHAR2,
                                p_cpremens2  	IN  VARCHAR2,
                                p_cmensuelle 	IN  VARCHAR2,
                                p_ccloture   	IN  VARCHAR2,
                                p_cafin      	IN  VARCHAR2,
                                p_cjours     	IN  VARCHAR2,
                                p_cnbjourssg 	IN  VARCHAR2,
                                p_cnbjoursssii 	IN  VARCHAR2,
                                p_userid     	IN  VARCHAR2,
								p_theorique      IN VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                               ) IS

   l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO CALENDRIER (calanmois,
                                 cpremens1,
                                 cpremens2,
                                 cmensuelle,
                                 ccloture,
                                 cafin,
                                 cjours,
                                 nb_travail_sg,
                                 nb_travail_ssii,
								 theorique
                                )
                VALUES (TO_DATE(p_calanmois,'mm/yyyy'),
                        TO_DATE(p_cpremens1, 'dd/mm/yyyy'),
                        TO_DATE(p_cpremens2, 'dd/mm/yyyy'),
                        TO_DATE(p_cmensuelle, 'dd/mm/yyyy'),
                        TO_DATE(p_ccloture, 'dd/mm/yyyy'),
                        TO_DATE(p_cafin, 'dd/mm/yyyy'),
                        TO_NUMBER(p_cjours, 'FM99D0'),
                        TO_NUMBER(p_cnbjourssg, 'FM99D0'),
                        TO_NUMBER(p_cnbjoursssii, 'FM99D0'),
			TO_NUMBER(p_theorique, 'FM999D0')
                       );

         -- 'Calendrier creee pour la date %s1';

         Pack_Global.recuperer_message(2071, '%s1', p_calanmois, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN
             Pack_Global.recuperer_message(20267,NULL, NULL, NULL, l_msg);
             RAISE_APPLICATION_ERROR( -20267, l_msg );

         WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM );

      END;
   END insert_calendrier;

   PROCEDURE update_calendrier (p_calanmois  	IN  VARCHAR2,
                                p_cpremens1  	IN  VARCHAR2,
                                p_cpremens2  	IN  VARCHAR2,
                                p_cmensuelle 	IN  VARCHAR2,
                                p_ccloture   	IN  VARCHAR2,
                                p_cafin      	IN  VARCHAR2,
                                p_cjours     	IN  VARCHAR2,
                                p_cnbjourssg 	IN  VARCHAR2,
                                p_cnbjoursssii 	IN  VARCHAR2,
                                p_flaglock   	IN  NUMBER,
                                p_userid     	IN  VARCHAR2,
								 p_theorique     	IN  VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                               ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
          UPDATE CALENDRIER SET calanmois  	= TO_DATE(p_calanmois,'mm/yyyy'),
                                cpremens1  	= TO_DATE(p_cpremens1, 'dd/mm/yyyy'),
                                cpremens2  	= TO_DATE(p_cpremens2, 'dd/mm/yyyy'),
                                cmensuelle 	= TO_DATE(p_cmensuelle, 'dd/mm/yyyy'),
                                ccloture   	= TO_DATE(p_ccloture, 'dd/mm/yyyy'),
                                cafin      	= TO_DATE(p_cafin, 'dd/mm/yyyy'),
                                cjours     	= TO_NUMBER(p_cjours, 'FM99D0'),
                                nb_travail_sg 	= TO_NUMBER(p_cnbjourssg, 'FM99D0'),
                                nb_travail_ssii	= TO_NUMBER(p_cnbjoursssii, 'FM99D0'),
								theorique	= TO_NUMBER(p_theorique, 'FM999D00'),
                                flaglock   	= DECODE( p_flaglock, 1000000, 0, p_flaglock + 1)
          WHERE TO_CHAR(calanmois, 'mm/yyyy') = p_calanmois
          AND flaglock = p_flaglock;

      EXCEPTION
           WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      ELSE
        Pack_Global.recuperer_message( 2072,'%s1', p_calanmois, NULL, l_msg);
        p_message := l_msg;
      END IF;

   END update_calendrier;


   PROCEDURE select_calendrier (p_calanmois     IN  VARCHAR2,
                                p_userid        IN  VARCHAR2,
                                p_cafin         OUT VARCHAR2,
                                p_cal           OUT VARCHAR2,
                                p_ccloture      OUT VARCHAR2,
                                p_cjours        OUT VARCHAR2,
                                p_cnbjourssg 	OUT  VARCHAR2,
                                p_cnbjoursssii 	OUT  VARCHAR2,
                                p_cmensuelle    OUT VARCHAR2,
                                p_cpremens1     OUT VARCHAR2,
                                p_cpremens2     OUT VARCHAR2,
                                p_mode          OUT VARCHAR2,
                                p_flaglock      OUT VARCHAR2,
								p_theorique     	OUT  VARCHAR2,
                                p_nbcurseur     OUT INTEGER,
                                p_message       OUT VARCHAR2
                               ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      p_mode :=  'update';

      BEGIN

           -- Si pas d'exception -> UPDATE

           SELECT TO_CHAR(cafin, 'dd/mm/yyyy'),
                  TO_CHAR(calanmois,'mm/yyyy'),
                  TO_CHAR(ccloture, 'dd/mm/yyyy'),
                  TO_CHAR(cjours, 'FM90D0'),
                  TO_CHAR(nb_travail_sg, 'FM90D0'),
                  TO_CHAR(nb_travail_ssii, 'FM90D0'),
                  TO_CHAR(cmensuelle, 'dd/mm/yyyy'),
                  TO_CHAR(cpremens1, 'dd/mm/yyyy'),
                  TO_CHAR(cpremens2, 'dd/mm/yyyy'),
                  flaglock,
				  TO_CHAR(theorique, 'FM990D00')
           INTO p_cafin, p_cal, p_ccloture, p_cjours,p_cnbjourssg,p_cnbjoursssii,p_cmensuelle, p_cpremens1, p_cpremens2, p_flaglock, p_theorique
           FROM CALENDRIER
           WHERE TO_CHAR(calanmois,'mm/yyyy') = p_calanmois;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN

            --INSERT

            p_cafin      	:= '';
            p_cal        	:= '';
            p_ccloture   	:= '';
            p_cjours     	:= '';
            p_cnbjourssg     	:= '';
            p_cnbjoursssii     	:= '';
            p_cmensuelle 	:= '';
            p_cpremens1  	:= '';
            p_cpremens2  	:= '';
            p_flaglock   	:= '';
            p_mode       	:= 'insert';
            NULL;

         WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR(-20997,SQLERRM);
      END;

   END select_calendrier;




PROCEDURE liste_annee ( p_annee         IN  VARCHAR2,
                        p_curCalendrier IN OUT calendrierListeCurType,
                        p_nbcurseur     OUT INTEGER,
                        p_message       OUT VARCHAR2
                      ) IS
	l_annee VARCHAR2(4);
BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	-- Si p_annee == NULL on prend l'année courante
	IF ( (p_annee IS NULL) OR (p_annee='') ) THEN
	    l_annee := TO_CHAR(SYSDATE(),'YYYY');
	ELSE
		l_annee := p_annee;
	END IF;

	BEGIN
		OPEN p_curCalendrier FOR
			SELECT TO_CHAR(calanmois,'Month') AS "libMois",
			       trim(TO_CHAR(cpremens1,'Day'))||' '||TO_CHAR(cpremens1,'DD/MM/YYYY') AS "cpremens1",
			       trim(TO_CHAR(cpremens2,'Day'))||' '||TO_CHAR(cpremens2,'DD/MM/YYYY') AS "cpremens2",
			       trim(TO_CHAR(cmensuelle,'Day'))||' '||TO_CHAR(cmensuelle,'DD/MM/YYYY') AS "cmensuelle",
				   TO_CHAR(cjours),
				   trim(TO_CHAR(ccloture,'Day'))||' '||TO_CHAR(ccloture,'DD/MM/YYYY') AS "ccloture",
				   trunc(cpremens1)-trunc(SYSDATE)  AS "css_cpremens1",
				   trunc(cpremens2)-trunc(SYSDATE)  AS "css_cpremens2",
				   trunc(cmensuelle)-trunc(SYSDATE) AS "css_cmensuelle"
			  FROM CALENDRIER
			 WHERE calanmois >= ADD_MONTHS(TO_DATE('01/01/'||l_annee, 'DD/MM/YYYY'),-1)
			   AND calanmois <= ADD_MONTHS(TO_DATE('01/01/'||l_annee, 'DD/MM/YYYY'),11)
			 ORDER BY calanmois;
    EXCEPTION
        WHEN OTHERS THEN
         	RAISE_APPLICATION_ERROR(-20997,SQLERRM);
    END;


END liste_annee;



PROCEDURE get_entete (  p_curEntete IN OUT enteteCurType,
                        p_nbcurseur    OUT INTEGER,
                        p_message      OUT VARCHAR2
                      ) IS
	l_annee VARCHAR2(4);
BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	BEGIN
		OPEN p_curEntete FOR
			SELECT idfic, contenu
			  FROM FICHIER
			 WHERE idfic LIKE 'enteteCal%'
			 ORDER BY idfic;
    EXCEPTION
        WHEN OTHERS THEN
         	RAISE_APPLICATION_ERROR(-20997,SQLERRM);
    END;


END get_entete;


END Pack_Calendrier;
/
CREATE OR REPLACE PACKAGE pack_centrefrais AS

   TYPE centrefrais_RecType IS RECORD (CODCFRAIS    VARCHAR2(3),
                                       LIBCFRAIS    VARCHAR2(30),
									   FILCODE      FILIALE_CLI.FILCODE%TYPE,
									   FILSIGLE     FILIALE_CLI.FILSIGLE%TYPE
									   );

   TYPE centrefrais_CurType IS REF CURSOR RETURN centrefrais_RecType;

PROCEDURE select_centrefrais( 	p_mode    IN VARCHAR2,
				p_codcfrais IN VARCHAR2,
				p_userid    IN VARCHAR2,
				p_curselect IN  OUT centrefrais_CurType,
		                p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
                           );

 PROCEDURE insert_centrefrais(	p_codcfrais IN VARCHAR2,
				p_libcfrais IN centre_frais.libcfrais%TYPE,
				p_filcode   IN filiale_cli.filcode%TYPE,
				p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
				);

PROCEDURE update_centrefrais( 	p_codcfrais IN VARCHAR2,
				p_libcfrais     IN  VARCHAR2,
				p_filcode       IN  VARCHAR2,
				p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
				);


 PROCEDURE delete_centrefrais( 	p_codcfrais IN VARCHAR2,
				p_libcfrais IN centre_frais.libcfrais%TYPE,
				p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
				);

 PROCEDURE update_struct_info(  p_mode       IN VARCHAR2,
				p_codcfrais    IN VARCHAR2,
				p_libcfrais    IN VARCHAR2,
				p_bddpg        IN VARCHAR2,
				p_habilitation IN VARCHAR2,
				p_userid       IN VARCHAR2,
				p_nbcurseur      OUT INTEGER,
				p_message        OUT VARCHAR2
				);

  PROCEDURE delete_struct_info(	p_mode    IN VARCHAR2,
				p_codcfrais IN VARCHAR2,
				p_libcfrais IN VARCHAR2,
				p_bddpg     IN VARCHAR2,
				p_userid    IN VARCHAR2,
			        p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
                           );



END pack_centrefrais;
/

CREATE OR REPLACE PACKAGE BODY pack_centrefrais AS

 PROCEDURE select_centrefrais( 	p_mode    IN VARCHAR2,
				p_codcfrais IN VARCHAR2,
				p_userid    IN VARCHAR2,
				p_curselect IN  OUT centrefrais_CurType,
		        p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
                           ) IS
l_exist number;

 BEGIN


       	BEGIN
		select 1 into l_exist
		from centre_frais
		where codcfrais= to_number(p_codcfrais);


   	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			IF p_mode!='insert' THEN
				-- le centre de frais n'existe pas
				pack_global.recuperer_message(20344,NULL, NULL, NULL,  p_message);
            			raise_application_error(-20344 ,  p_message );
			ELSE
				NULL;
			END IF;
   	END;

	IF l_exist=1 then
		IF p_mode='insert' then
		-- le centre de frais existe déjà
			pack_global.recuperer_message(20343,NULL, NULL, NULL,  p_message);
            		raise_application_error(-20343 ,  p_message );
		END IF;
	END IF;

  	OPEN p_curselect FOR
	SELECT to_char(codcfrais),
	       cf.libcfrais libcfrais,
	       f.filcode filcode,
	       f.filsigle filsigle
           FROM centre_frais cf, filiale_cli f
           WHERE to_char(cf.codcfrais)=p_codcfrais
           AND f.filcode=cf.FILCODE;


 END select_centrefrais ;

-- =====================================================================================
-- * * * * * * * * * * * * * CREATION D'UN CENTRE DE FRAIS * * * * * * * * * * * * * * *
-- =====================================================================================

PROCEDURE insert_centrefrais(	p_codcfrais IN VARCHAR2,
				p_libcfrais IN centre_frais.libcfrais%TYPE,
				p_filcode   IN filiale_cli.filcode%TYPE,
				p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
				)  IS



 BEGIN

	insert into centre_frais (codcfrais,libcfrais,filcode)
	values (to_number(p_codcfrais),
		    p_libcfrais,
		    p_filcode
	       );
        commit;
	-- Message Centre de frais crée
       pack_global.recuperer_message(20340,'%s1', p_codcfrais, NULL, p_message);


 EXCEPTION
	  WHEN DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message(20343,NULL, NULL, NULL,  p_message);
            raise_application_error(-20343 ,  p_message );


 END insert_centrefrais;


-- =====================================================================================
-- * * * * * * * * * * * * MODIFICATION D'UN CENTRE DE FRAIS * * * * * * * * * * * * * *
-- =====================================================================================

 PROCEDURE update_centrefrais( 	p_codcfrais IN VARCHAR2,
				p_libcfrais     IN VARCHAR2,
				p_filcode       IN VARCHAR2,
				p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
				) IS
 BEGIN
	update centre_frais
	set libcfrais = p_libcfrais, filcode = p_filcode
	where codcfrais = to_number(p_codcfrais);

        commit;
	-- Message Centre de frais modifié
       pack_global.recuperer_message(20341,'%s1', p_codcfrais, NULL, p_message);



 END update_centrefrais;

-- =====================================================================================
-- * * * * * * * * * * * * * SUPPRESSION D'UN CENTRE DE FRAIS * * * * * * * * * * * * *
-- =====================================================================================

 PROCEDURE delete_centrefrais( 	p_codcfrais IN VARCHAR2,
				p_libcfrais IN centre_frais.libcfrais%TYPE,
				p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
				) IS
 BEGIN

	delete compo_centre_frais
	where codcfrais = to_number(p_codcfrais);

	update struct_info set scentrefrais=NULL
	where scentrefrais=to_number(p_codcfrais);

	delete centre_frais
	where codcfrais = to_number(p_codcfrais);

	-- Message Centre de frais supprimé
       pack_global.recuperer_message(20342,'%s1', p_codcfrais, NULL, p_message);

  END delete_centrefrais;
-- =====================================================================================
-- * * * * * * * * RATTACHEMENT D'UN BDDPG A UN CENTRE DE FRAIS * * * * * * * * * * * *
-- =====================================================================================

PROCEDURE update_struct_info(   p_mode       IN VARCHAR2,
				p_codcfrais    IN VARCHAR2,
				p_libcfrais    IN VARCHAR2,
				p_bddpg        IN VARCHAR2,
				p_habilitation IN VARCHAR2,
				p_userid       IN VARCHAR2,
				p_nbcurseur      OUT INTEGER,
				p_message        OUT VARCHAR2
				) IS
 l_exist number;
 l_autre varchar2(10);
 l_codbddpg varchar2(15);
 l_lib varchar2(30);
 l_reste varchar2(11);
 l_codcfrais number;

 BEGIN

  -- ================================================================================================
  --            				NIVEAU BRANCHE
  -- ================================================================================================
    IF p_habilitation='br' THEN
	-- ******************************************************
	-- Existence de la branche
	-- ******************************************************
	l_codbddpg := lpad(p_bddpg,2,0);

	BEGIN
		select 1 into l_exist
		from struct_info s, directions d, branches b
		where s.coddir=d.coddir
		and d.codbr=b.codbr
		and b.codbr=to_number(p_bddpg)
		and rownum<2 ;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN -- Aucun code DPG pour la branche
			pack_global.recuperer_message(20349,'%s1','branche', '%s2',l_codbddpg, NULL, p_message);
            		raise_application_error(-20349 ,  p_message );

	END;

	BEGIN
		select  substr(codbddpg,3,9), codcfrais into l_reste,l_codcfrais
		from compo_centre_frais
		where substr(codbddpg,1,2)=l_codbddpg
		and rownum<2;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN null;
	END;

	IF l_reste='000000000' THEN
		-- -------------------------------------------------
		-- la branche est déjà rattachée au centre de frais
		-- ------------------------------------------------
		IF l_codcfrais=to_number(p_codcfrais) THEN
			pack_global.recuperer_message(20346,'%s1','branche','%s2',lpad(p_bddpg,2,0),
							'%s3', p_codcfrais, NULL, p_message);
            		raise_application_error(-20346 ,  p_message );
		ELSE
		-- ----------------------------------------------------
		-- la branche est rattachée à un autre centre de frais
		-- ----------------------------------------------------
			pack_global.recuperer_message(20346,'%s1','branche','%s2',lpad(p_bddpg,2,0),
							'%s3', to_char(l_codcfrais), NULL, p_message);
            		raise_application_error(-20346 ,  p_message );
		END IF;
	ELSE
		IF l_reste is not null THEN

			-- msg : Si vous voulez une habilitation niveau branche,
			-- il faudra d''abord supprimer les BDPPG  appartenant à cette branche
		     	pack_global.recuperer_message(20348,'%s1','branche','%s2',
				'directions, départements, pôles, groupes','%s3','cette branche', NULL, p_message);
            		raise_application_error(-20348 ,  p_message );

		END IF;
	END IF;



	-- **********************************************************
	-- Mise à jour des tables COMPO_CENTRE_FRAIS et STRUCT_INFO
 	-- **********************************************************
	BEGIN

		insert into compo_centre_frais
		 (select to_number(p_codcfrais),
				lpad(p_bddpg,2,0)||'000000000',
				'O',
				'br',
				libbr
		 from branches
	         where codbr=to_number(p_bddpg)
			);
	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
            	pack_global.recuperer_message(20346,'%s1','branche','%s2',lpad(p_bddpg,2,0),
							'%s3', p_codcfrais, NULL, p_message);
            	raise_application_error(-20346 ,  p_message );

	END;
       		update struct_info
		set scentrefrais=to_number(p_codcfrais)
		where codsg in (select s.codsg
				from struct_info s, directions d
				where s.coddir=d.coddir
				and  d.codbr=to_number(p_bddpg));

  -- ================================================================================================
  --            				NIVEAU DIRECTION
  -- ================================================================================================
    ELSIF p_habilitation='dir' THEN
	-- ********************************************
	-- Existence de DPG dans la direction
	-- ********************************************
	BEGIN
		select 1 into l_exist
		from struct_info s, directions d
		where s.coddir=d.coddir
		and d.coddir=to_number(p_bddpg)
		and rownum<2 ;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN -- Aucun code DPG pour la direction
			pack_global.recuperer_message(20349,'%s1','direction','%s2',lpad(p_bddpg,2,0), NULL, p_message);
            		raise_application_error(-20349 ,  p_message );

	END;


	-- *****************************************************************************************
	-- Vérifions qu'il n'y a pas un niveau d'habilitation superieur à la direction ie niveau branche
	-- ******************************************************************************************
	BEGIN
		select codbddpg,codcfrais into l_codbddpg,l_codcfrais
		from compo_centre_frais c,struct_info s, directions d
		where
		 s.coddir=d.coddir
	       	and d.coddir=to_number(p_bddpg)
		and (( substr(codbddpg,1,2)=lpad(d.codbr,2,0) and codhabili='br') or
		      (	substr(codbddpg,1,4)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0) and codhabili='dir')   )
		and rownum<2;

	EXCEPTION
			WHEN NO_DATA_FOUND THEN null;


	END ;
	IF l_codbddpg is not null then
		-- La direction est déjà rattachée au centre de frais
		pack_global.recuperer_message(20346,'%s1','direction','%s2',p_bddpg,
							'%s3', l_codcfrais, NULL, p_message);
		raise_application_error(-20346, p_message);
	END IF;
	l_codbddpg:=null;
       -- *****************************************************************************************
	-- Vérifions qu'il n'y a pas un niveau d'habilitation inférieur à la direction (dpt,pôle,groupe)
	-- ******************************************************************************************
	BEGIN
		select substr(codbddpg,5,7),codcfrais into l_codbddpg, l_codcfrais
		from compo_centre_frais c,struct_info s, directions d
		where s.coddir=d.coddir
	       	and d.coddir=to_number(p_bddpg)
		and substr(codbddpg,1,4)=lpad(d.codbr,2,0)||lpad(d.coddir,2,0)
		and rownum<2;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN null;
	END;
	IF l_codbddpg='0000000' THEN
		-- La direction est déjà rattachée au centre de frais
		pack_global.recuperer_message(20346,'%s1','direction','%s2',p_bddpg,
							'%s3', p_codcfrais, NULL, p_message);
		raise_application_error(-20346, p_message);
	ELSE
		IF l_codbddpg is not null THEN
			-- msg : Si vous voulez une habilitation niveau direction,
			-- il faudra d''abord supprimer les BDDPG appartenant à cette direction
		     	pack_global.recuperer_message(20348,'%s1','direction','%s2','départements, pôles, groupes',
								'%s3','cette direction', NULL, p_message);
            		raise_application_error(-20348 ,  p_message );

		END IF;
	END IF;

	-- **********************************************************
	-- Mise à jour des tables COMPO_CENTRE_FRAIS et STRUCT_INFO
 	-- **********************************************************
	insert into compo_centre_frais
		(select to_number(p_codcfrais),
			lpad(d.codbr,2,0)||lpad(p_bddpg,2,0)||'0000000',
			'O',
			'dir',
			libbr||'/'||libdir
		 from directions d,branches b
	         where d.codbr=b.codbr
	         and coddir=to_number(p_bddpg)
			);

       	update struct_info
	set scentrefrais=to_number(p_codcfrais)
	where codsg in (select s.codsg
			from struct_info s, directions d
			where s.coddir=d.coddir
			and  d.coddir=to_number(p_bddpg));

  -- ================================================================================================
  --            				NIVEAU DEPARTEMENT
  -- ================================================================================================
    ELSIF p_habilitation='dpt' THEN
	-- Remarque : p_bddpg = topfer||coddep||coddir

	-- *****************************************************************************************
	-- Vérifions qu'il n'y a pas un niveau d'habilitation superieur au département (branche,direction)
	-- ******************************************************************************************

	BEGIN
		select codbddpg, codcfrais into l_codbddpg, l_codcfrais
		from compo_centre_frais c,struct_info s, directions d
		where
 		 s.coddir=d.coddir
	       	and s.coddep=to_number(substr(p_bddpg,2,3))
		and c.topfer=substr(p_bddpg,1,1)
		and s.coddir=substr(p_bddpg,5,2)
 		and( ( substr(codbddpg,1,2)=lpad(d.codbr,2,0) and codhabili='br') or
			(substr(codbddpg,1,4)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)  and codhabili='dir') or
			(substr(codbddpg,1,7)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||lpad(s.coddep,3,0) and codhabili='dpt' ))
		and rownum<2;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN NULL;
	END;
	IF l_codbddpg is not null THEN

		-- Le département est déjà rattaché au centre de frais
		pack_global.recuperer_message(20345,'%s1','département','%s2',substr(p_bddpg,2,3),
							'%s3', l_codcfrais, NULL, p_message);
		raise_application_error(-20345, p_message);

	END IF;

	l_codbddpg:=null;
	-- *****************************************************************************************
	-- Vérifions qu'il n'y a pas un niveau d'habilitation inférieur au département (pole,groupe)
	-- ******************************************************************************************
	BEGIN
		select substr(codbddpg,8,4) into l_codbddpg
		from compo_centre_frais c,struct_info s, directions d
		where  s.coddir=d.coddir
	       	and s.coddep=to_number(substr(p_bddpg,2,3))
		and substr(codbddpg,1,7)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||lpad(s.coddep,3,0)
		and c.topfer=substr(p_bddpg,1,1)
		and s.coddir=substr(p_bddpg,5,2)
		and rownum<2;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN NULL;
	END;
	IF l_codbddpg is not null then
		-- msg : Si vous voulez une habilitation niveau département,
		-- il faudra d''abord supprimer les BDDPG appartenant à ce département
		pack_global.recuperer_message(20348,'%s1','département','%s2','pôles, groupes ',
								'%s3','ce département', NULL, p_message);
            	raise_application_error(-20348 ,  p_message );

	END IF;

	-- **********************************************************
	-- Mise à jour des tables COMPO_CENTRE_FRAIS et STRUCT_INFO
 	-- **********************************************************
	insert into compo_centre_frais
		(select distinct to_number(p_codcfrais),
			lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||lpad(substr(p_bddpg,2,3),3,0)||'0000',
			s.topfer,
			'dpt',
			b.libbr||'/'||d.libdir||'/'||s.sigdep
		from struct_info s, directions d, branches b
		where s.coddir=d.coddir
	       	and d.codbr=b.codbr
		and coddep=to_number(substr(p_bddpg,2,3))
		and  topfer=substr(p_bddpg,1,1)
		and s.coddir=substr(p_bddpg,5,2)
				);

        update struct_info
	set scentrefrais=to_number(p_codcfrais)
	where coddep=to_number(substr(p_bddpg,2,3))
	and topfer=substr(p_bddpg,1,1)
	and coddir=substr(p_bddpg,5,2);

  -- ================================================================================================
  --           					 NIVEAU POLE
  -- ================================================================================================
    ELSIF p_habilitation='pole' THEN
	-- Remarque : p_bddpg = topfer||coddep||codpole||coddir
	-- *****************************************************************************************
	-- Vérification qu'il n'y a pas un niveau d'habilitation superieur au pôle
	-- *****************************************************************************************
	BEGIN
		select codbddpg ,codcfrais into l_codbddpg,l_codcfrais
		from compo_centre_frais c,struct_info s, directions d
		where
		 s.coddir=d.coddir
	       	and  substr(lpad(codsg,7,0),1,5)=substr(p_bddpg,2,5)
		and s.coddir=substr(p_bddpg,7,2)
		and c.topfer=substr(p_bddpg,1,1)
		and (   ( substr(codbddpg,1,2)=lpad(d.codbr,2,0) and codhabili='br') or
			(substr(codbddpg,1,4)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)  and codhabili='dir') or
			(substr(codbddpg,1,7)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||substr(p_bddpg,2,3) and codhabili='dpt') or
 			( substr(codbddpg,1,9)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||substr(p_bddpg,2,5) and codhabili='pole'))
		and rownum<2;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN null;

	END;
	IF l_codbddpg is not null then
		-- Le pôle est déjà rattaché au centre de frais
		pack_global.recuperer_message(20345,'%s1','pôle','%s2',substr(p_bddpg,2,5),
							'%s3', l_codcfrais, NULL, p_message);
		raise_application_error(-20345,p_message);
	END IF;
	l_codbddpg:=null;
	-- *****************************************************************************************
	-- Vérification qu'il n'y a pas un niveau d'habilitation inférieur au pôle (groupe)
	-- *****************************************************************************************
	BEGIN
		select codbddpg into l_codbddpg
		from compo_centre_frais c,struct_info s, directions d
		where
 		substr(c.codbddpg,1,9)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||substr(p_bddpg,2,5)
		and s.coddir=d.coddir
	       	and  substr(lpad(codsg,7,0),1,5)=to_number(substr(p_bddpg,2,5))
		and s.coddir=substr(p_bddpg,7,2)
		and c.topfer=substr(p_bddpg,1,1)
		and rownum<2;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN null;
	END;
	IF l_codbddpg is not null then
	-- msg : Si vous voulez une habilitation niveau pôle,
		-- il faudra d''abord supprimer les BDDPG appartenant à ce pôle
		pack_global.recuperer_message(20348,'%s1','pôle','%s2','groupes',
								'%s3','ce pôle', NULL, p_message);
            	raise_application_error(-20348 ,  p_message );

	END IF;


	-- **********************************************************
	-- Mise à jour des tables COMPO_CENTRE_FRAIS et STRUCT_INFO
 	-- **********************************************************

	update struct_info
	set scentrefrais=to_number(p_codcfrais)
	where substr(lpad(codsg,7,0),1,5)=substr(p_bddpg,2,5)
	and topfer=substr(p_bddpg,1,1)
	and coddir=substr(p_bddpg,7,2);

	insert into compo_centre_frais
		(select distinct to_number(p_codcfrais),
			lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||lpad(substr(p_bddpg,2,5),5,'0')||'00',
			s.topfer,
			'pole',
			b.libbr||'/'||d.libdir||'/'||s.sigdep||'/'||s.sigpole
		 from struct_info s, directions d, branches b
		 where s.coddir=d.coddir
		 and d.codbr=b.codbr
		 and substr(lpad(codsg,7,0),1,5)=substr(p_bddpg,2,5)
		 and topfer=substr(p_bddpg,1,1)
		 and s.coddir=substr(p_bddpg,7,2));

    ELSE
  -- ================================================================================================
  --            				NIVEAU GROUPE
  -- ================================================================================================
	-- *********************************************
	-- Vérification de l'existence du groupe
	-- *********************************************

		BEGIN
			select 1 into l_exist
			from struct_info
			where codsg=to_number(p_bddpg);

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				--Code DPG inexistant
				pack_global.recuperer_message(20109,NULL, NULL, NULL,  p_message);
            			raise_application_error(-20109 ,  p_message );

		END;

	-- *****************************************************************************************
	-- Vérification qu'il n'y a pas un niveau d'habilitation superieur au groupe
	-- *****************************************************************************************
		BEGIN
			select codbddpg,codcfrais into l_codbddpg,l_codcfrais
			from compo_centre_frais c,struct_info s, directions d
			where
			 s.coddir=d.coddir
	        	and s.codsg=to_number(p_bddpg)
			and (   ( substr(codbddpg,1,2)=lpad(d.codbr,2,0) and codhabili='br') or
			(substr(codbddpg,1,4)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)  and codhabili='dir') or
			(substr(codbddpg,1,7)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||substr(p_bddpg,1,3) and codhabili='dpt') or
			(substr(codbddpg,1,9)=lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||substr(p_bddpg,1,5) and codhabili='pole') or
			( substr(codbddpg,5,7)=p_bddpg and codhabili='tout')
 			)
			and rownum<2;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN

				insert into compo_centre_frais
		 		(select distinct to_number(p_codcfrais),
			 		lpad(d.codbr,2,0)||lpad(s.coddir,2,0)||lpad(p_bddpg,7,0),
					s.topfer,
			 		'tout',
			 		libdsg
		 		from struct_info s, directions d
		 		where s.coddir=d.coddir
		 		and s.codsg=to_number(p_bddpg)
				);


				update struct_info
				set scentrefrais=to_number(p_codcfrais)
				where codsg=to_number(p_bddpg);



		END;
		IF l_codbddpg is not null then
		-- Le groupe est déjà rattaché au centre de frais
		pack_global.recuperer_message(20345,'%s1','groupe','%s2',p_bddpg,'%s3',to_char(l_codcfrais), NULL, p_message);
		raise_application_error(-20345,p_message);
		END IF;

    END IF;

 --pack_global.recuperer_message(20340,'%s1', p_bddpg, NULL, p_message);

   commit;
 END update_struct_info;

-- =====================================================================================
-- * * * * * * * * SUPPRESSION D'UN BDDPG A UN CENTRE DE FRAIS * * * * * * * * * * * *
-- =====================================================================================

 PROCEDURE delete_struct_info(	p_mode    IN VARCHAR2,
				p_codcfrais IN VARCHAR2,
				p_libcfrais IN VARCHAR2,
				p_bddpg     IN VARCHAR2,
				p_userid    IN VARCHAR2,
			        p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
                           ) IS
-- Remarque : p_bddpg est la concaténation de codbddpg||topfer

  l_habili VARCHAR2(10);

  BEGIN

	if p_mode='delete' then
		select codhabili into l_habili
		from compo_centre_frais
		where codbddpg=substr(p_bddpg,1,11)
		and topfer=substr(p_bddpg,12,1);

		IF l_habili='br' THEN		-- branche
			update struct_info
			set scentrefrais=NULL
			where codsg in (select s.codsg
					from struct_info s, directions d
					where s.coddir=d.coddir
					and  d.codbr=to_number(substr(p_bddpg,1,2))
					);

			delete compo_centre_frais
			where codbddpg=substr(p_bddpg,1,11);

		ELSIF l_habili='dir' THEN  	--direction
			update struct_info
			set scentrefrais=NULL
			where codsg in (select s.codsg
					from struct_info s, directions d
					where s.coddir=d.coddir
					and  d.coddir=to_number(substr(p_bddpg,3,2))
					and d.codbr=to_number(substr(p_bddpg,1,2))
					);

			delete compo_centre_frais
			where codbddpg=substr(p_bddpg,1,11);

		ELSIF l_habili='dpt' THEN  	--département
			update struct_info
			set scentrefrais=NULL
			where codsg in (select s.codsg
					from struct_info s, directions d
					where s.coddir=d.coddir
					and  d.coddir=to_number(substr(p_bddpg,3,2))
					and d.codbr=to_number(substr(p_bddpg,1,2))
					and s.coddep=to_number(substr(p_bddpg,5,3))
					and s.topfer=substr(p_bddpg,12,1)
					);

			delete compo_centre_frais
			where codbddpg=substr(p_bddpg,1,11)
			and topfer=substr(p_bddpg,12,1);


		ELSIF l_habili='pole' THEN  	--pôle
			update struct_info
			set scentrefrais=NULL
			where codsg  in (select s.codsg
					from struct_info s, directions d
					where s.coddir=d.coddir
					and  d.coddir=to_number(substr(p_bddpg,3,2))
					and d.codbr=to_number(substr(p_bddpg,1,2))
					and substr(TO_CHAR(s.codsg, 'FM0000000'),1,5)=substr(p_bddpg,5,5)
					and s.topfer=substr(p_bddpg,12,1)
					);

			delete compo_centre_frais
			where codbddpg=substr(p_bddpg,1,11)
			and topfer=substr(p_bddpg,12,1);

		ELSE 				--groupe
			update struct_info
			set scentrefrais=NULL
			where codsg  in (select s.codsg
					from struct_info s, directions d
					where s.coddir=d.coddir
					and  d.coddir=to_number(substr(p_bddpg,3,2))
					and d.codbr=to_number(substr(p_bddpg,1,2))
					and s.codsg=to_number(substr(p_bddpg,5,7))
					);

			delete compo_centre_frais
			where codbddpg=substr(p_bddpg,1,11);


		END IF;
		commit;
	end if;

  END delete_struct_info;

END pack_centrefrais;
/
CREATE OR REPLACE PACKAGE pack_centre_activite AS

   TYPE centre_activiteCurType IS REF CURSOR RETURN centre_activite%ROWTYPE;

   PROCEDURE insert_centre_activite (p_codcamo   IN  VARCHAR2,
                                     p_ctopact   IN  centre_activite.ctopact%TYPE,
                                     p_clibca    IN  centre_activite.clibca%TYPE,
                                     p_clibrca   IN  centre_activite.clibrca%TYPE,
                                     p_userid    IN  VARCHAR2,
                                     p_nbcurseur OUT INTEGER,
                                     p_message   OUT VARCHAR2
                                    );

   PROCEDURE update_centre_activite (p_codcamo   IN  VARCHAR2,
                                     p_ctopact   IN  centre_activite.ctopact%TYPE,
                                     p_clibca    IN  centre_activite.clibca%TYPE,
                                     p_clibrca   IN  centre_activite.clibrca%TYPE,
                                     p_flaglock  IN  NUMBER,
                                     p_userid    IN  VARCHAR2,
                                     p_nbcurseur OUT INTEGER,
                                     p_message   OUT VARCHAR2
                                   );

   PROCEDURE delete_centre_activite (p_codcamo   IN  VARCHAR2,
                                     p_flaglock  IN  NUMBER,
                                     p_userid    IN  VARCHAR2,
                                     p_nbcurseur OUT INTEGER,
                                     p_message   OUT VARCHAR2
                                    );

   PROCEDURE select_centre_activite (p_codcamo            IN VARCHAR2,
                                     p_userid             IN VARCHAR2,
                                     p_curcentre_activite IN OUT centre_activiteCurType,
                                     p_nbcurseur             OUT INTEGER,
                                     p_message               OUT VARCHAR2
                                    );

END pack_centre_activite;
/

CREATE OR REPLACE PACKAGE BODY pack_centre_activite AS

   PROCEDURE insert_centre_activite (p_codcamo   IN  VARCHAR2,
                                     p_ctopact   IN  centre_activite.ctopact%TYPE,
                                     p_clibca    IN  centre_activite.clibca%TYPE,
                                     p_clibrca   IN  centre_activite.clibrca%TYPE,
                                     p_userid    IN  VARCHAR2,
                                     p_nbcurseur OUT INTEGER,
                                     p_message   OUT VARCHAR2
                              ) IS

   l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO centre_activite (clibca,
                                      clibrca,
                                      codcamo,
                                      ctopact
                                     )
                VALUES (p_clibca,
                        p_clibrca,
                        TO_NUMBER(p_codcamo),
                        p_ctopact
                       );

         -- 'Le centre d'activité M.O. ' || p_codcamo ||  a été créé.';

         pack_global.recuperer_message(2004,'%s1',p_codcamo, NULL, l_msg);
         p_message := l_msg;

     EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN
             pack_global.recuperer_message(20001,NULL, NULL, NULL, l_msg);
             raise_application_error( -20001, l_msg );

         WHEN OTHERS THEN
              raise_application_error( -20997, SQLERRM );

     END;

   END insert_centre_activite;

   PROCEDURE update_centre_activite (p_codcamo   IN  VARCHAR2,
                                     p_ctopact   IN  centre_activite.ctopact%TYPE,
                                     p_clibca    IN  centre_activite.clibca%TYPE,
                                     p_clibrca   IN  centre_activite.clibrca%TYPE,
                                     p_flaglock  IN  NUMBER,
                                     p_userid    IN  VARCHAR2,
                                     p_nbcurseur OUT INTEGER,
                                     p_message   OUT VARCHAR2
                                    ) IS

      l_msg VARCHAR(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
          UPDATE centre_activite SET clibrca  = p_clibrca,
                                     ctopact  = p_ctopact,
                                     clibca   = p_clibca,
                                     flaglock = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
          WHERE codcamo = TO_NUMBER(p_codcamo)
           AND flaglock = p_flaglock;

      EXCEPTION
           WHEN OTHERS THEN
              raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
        pack_global.recuperer_message(2005, '%s1', p_codcamo, NULL, l_msg);
        p_message := l_msg;
      END IF;

   END update_centre_activite;


   PROCEDURE delete_centre_activite (p_codcamo   IN  VARCHAR2,
                                     p_flaglock  IN  NUMBER,
                                     p_userid    IN  VARCHAR2,
                                     p_nbcurseur OUT INTEGER,
                                     p_message   OUT VARCHAR2
                                    ) IS

      l_msg VARCHAR(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM centre_activite
                WHERE codcamo = TO_NUMBER(p_codcamo)
                 AND flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2006, '%s1', p_codcamo, NULL, l_msg);
	   p_message := l_msg;
      END IF;

   END delete_centre_activite;


   PROCEDURE select_centre_activite (p_codcamo            IN VARCHAR2,
                                     p_userid             IN VARCHAR2,
                                     p_curcentre_activite IN OUT centre_activiteCurType,
                                     p_nbcurseur             OUT INTEGER,
                                     p_message               OUT VARCHAR2
                                    ) IS

      l_msg VARCHAR(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curcentre_activite FOR
              SELECT *
              FROM CENTRE_ACTIVITE
              WHERE codcamo = TO_NUMBER(p_codcamo);

      EXCEPTION
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'Le centre d'activité n''existe pas';

      pack_global.recuperer_message(2007, '%s1', p_codcamo, NULL, l_msg);
      p_message := l_msg;

   END select_centre_activite;

END pack_centre_activite;
/
CREATE OR REPLACE PACKAGE pack_client_mo AS

   -- Définition curseur sur la table des clients

   --TYPE client_moCurType IS REF CURSOR RETURN client_mo%ROWTYPE;
   TYPE listeClientMo IS RECORD (	clicode		client_mo.clicode%TYPE,
	                                filcode		client_mo.filcode%TYPE,
	                                clilib		client_mo.clilib%TYPE,
	                                clisigle	client_mo.clisigle%TYPE,
									clidir		client_mo.clidir%TYPE,
									clidep		client_mo.clidep%TYPE,
									clipol		client_mo.clipol%TYPE,
									codcamo		client_mo.codcamo%TYPE,
									libcodcamo	centre_activite.clibca%TYPE,
	                                clitopf		client_mo.clitopf%TYPE,
	                                flaglock	client_mo.flaglock%TYPE);
	TYPE client_moCurType IS REF CURSOR RETURN listeClientMo;


   PROCEDURE insert_client_mo ( p_clicode   IN  client_mo.clicode%TYPE,
                                p_filcode   IN  client_mo.filcode%TYPE,
								p_clidir    IN	client_mo.clidir%TYPE,
								p_clidep	IN  client_mo.clidep%TYPE,
								p_clipol	IN  client_mo.clipol%TYPE,
								p_codcamo	IN	client_mo.codcamo%TYPE,
                                p_clilib    IN  client_mo.clilib%TYPE,
                                p_clisigle  IN  client_mo.clisigle%TYPE,
                                p_clitopf   IN  client_mo.clitopf%TYPE,
								p_userid    IN  VARCHAR2,
                                p_nbcurseur 	OUT INTEGER,
                                p_message	OUT VARCHAR2
                              );

   PROCEDURE update_client_mo ( p_clicode   IN  client_mo.clicode%TYPE,
                                p_filcode   IN  client_mo.filcode%TYPE,
								p_clidir    IN	client_mo.clidir%TYPE,
                                p_clidep	IN  client_mo.clidep%TYPE,
								p_clipol	IN  client_mo.clipol%TYPE,
								p_codcamo	IN	client_mo.codcamo%TYPE,
                                p_clilib    IN  client_mo.clilib%TYPE,
                                p_clisigle  IN  client_mo.clisigle%TYPE,
                                p_clitopf   IN  client_mo.clitopf%TYPE,
                                p_flaglock  IN  NUMBER,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur	OUT INTEGER,
                                p_message	OUT VARCHAR2
                              );

   PROCEDURE delete_client_mo ( p_clicode   IN  client_mo.clicode%TYPE,
								p_clilib    IN  client_mo.clilib%TYPE,
                                p_flaglock  IN  NUMBER,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur	OUT INTEGER,
                                p_message	OUT VARCHAR2
                              );

   PROCEDURE select_client_mo ( p_clicode       IN client_mo.clicode%TYPE,
                                p_userid        IN VARCHAR2,
                                p_curClient_mo  IN OUT client_moCurType,
                                p_nbcurseur	   OUT INTEGER,
                                p_message	   OUT VARCHAR2
                              );

END pack_client_mo;
/

CREATE OR REPLACE PACKAGE BODY pack_client_mo AS

   PROCEDURE insert_client_mo ( p_clicode   IN  client_mo.clicode%TYPE,
                                p_filcode   IN  client_mo.filcode%TYPE,
								p_clidir    IN	client_mo.clidir%TYPE,
                                p_clidep	IN  client_mo.clidep%TYPE,
								p_clipol	IN  client_mo.clipol%TYPE,
								p_codcamo	IN	client_mo.codcamo%TYPE,
                                p_clilib    IN  client_mo.clilib%TYPE,
                                p_clisigle  IN  client_mo.clisigle%TYPE,
                                p_clitopf   IN  client_mo.clitopf%TYPE,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur	OUT INTEGER,
                                p_message	OUT VARCHAR2
                              ) IS

      l_msg VARCHAR2(1024);
      l_exist NUMBER(1);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

	BEGIN
         INSERT INTO client_mo
		      ( clicode,
				filcode,
				clisigle,
				clilib,
				clitopf,
				clidir,
				clidep,
				clipol,
				codcamo
		       )
	   VALUES (	p_clicode,
	            p_filcode,
	            p_clisigle,
	            p_clilib,
	            p_clitopf,
		  		p_clidir,
		  		p_clidep,
		  		p_clipol,
		  		p_codcamo);

	   -- 'Le client ' || p_clilib || ' a été créé';

	   pack_global.recuperer_message( 1, '%s1', p_clilib, NULL, l_msg);


         EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN

		   -- 'Code client déjà créé

	         pack_global.recuperer_message( 20001, NULL, NULL, NULL, l_msg);
               raise_application_error( -20001, l_msg );

		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);

	END;

   END insert_client_mo;



   PROCEDURE update_client_mo ( p_clicode   IN  client_mo.clicode%TYPE,
                                p_filcode   IN  client_mo.filcode%TYPE,
								p_clidir    IN	client_mo.clidir%TYPE,
                                p_clidep	IN  client_mo.clidep%TYPE,
								p_clipol	IN  client_mo.clipol%TYPE,
								p_codcamo	IN	client_mo.codcamo%TYPE,
                                p_clilib    IN  client_mo.clilib%TYPE,
                                p_clisigle  IN  client_mo.clisigle%TYPE,
                                p_clitopf   IN  client_mo.clitopf%TYPE,
                                p_flaglock  IN  NUMBER,
                                p_userid    IN  VARCHAR2,
								p_nbcurseur	OUT INTEGER,
                                p_message   	OUT VARCHAR2
                              ) IS

      l_msg VARCHAR2(1024);
      l_exist NUMBER(1);
 BEGIN

-- dbms_output.put_line(p_clicode);



      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


-- test que le CAMO est valide - Cela peut être un CA de niveau 0, 1, 2, 3 ou 4
	BEGIN
			select
					distinct 1 into l_exist
				from
					centre_activite
				where
					codcamo=p_codcamo or p_codcamo is null or
					caniv1=p_codcamo or caniv2=p_codcamo or
					caniv3=p_codcamo or caniv4=p_codcamo ;
			EXCEPTION WHEN NO_DATA_FOUND
			THEN
				pack_global.recuperer_message( 2007, NULL, NULL, NULL, l_msg);
	         	raise_application_error( -20505, l_msg );
	END;
	BEGIN
	         UPDATE client_mo
		SET	filcode  = p_filcode,
			clisigle = p_clisigle,
			clilib   = p_clilib,
		 	clitopf  = p_clitopf,
			flaglock = DECODE( p_flaglock, 1000000, 0, p_flaglock + 1),
			clidir   = p_clidir,
			clidep	 = p_clidep,
			clipol	 = p_clipol,
			codcamo	 = p_codcamo
		WHERE clicode = p_clicode
              AND flaglock = p_flaglock;


	   EXCEPTION
		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);
	END;


      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE

	   -- 'Le client ' || p_clilib || ' a été modifié'

	   pack_global.recuperer_message( 2, '%s1', p_clilib , NULL, l_msg);
	   p_message := l_msg;

      END IF;

END update_client_mo;



   PROCEDURE delete_client_mo ( p_clicode   IN  client_mo.clicode%TYPE,
				p_clilib    IN  client_mo.clilib%TYPE,
                                p_flaglock  IN  NUMBER,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur	OUT INTEGER,
                                p_message	OUT VARCHAR2
                              ) IS

      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


	BEGIN
	   DELETE FROM client_mo
		WHERE clicode  = p_clicode
		  AND flaglock = p_flaglock ;

         EXCEPTION
		WHEN referential_integrity THEN

               -- habiller le msg erreur

               pack_global.recuperation_integrite(-2292);

		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE

	   -- 'Le client ' || p_clilib || ' a été supprimé'

	   pack_global.recuperer_message( 3, '%s1', p_clilib, NULL, l_msg);
	   p_message := l_msg;

      END IF;

   END delete_client_mo;

   PROCEDURE select_client_mo ( p_clicode       IN client_mo.clicode%TYPE,
                                p_userid        IN VARCHAR2,
                                p_curClient_mo  IN OUT client_moCurType,
                                p_nbcurseur        OUT INTEGER,
                                p_message          OUT VARCHAR2
                              ) IS
	l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN

		OPEN p_curClient_mo FOR
			SELECT
				cmo.clicode,
				cmo.filcode,
				cmo.clilib,
				cmo.clisigle,
				cmo.clidir,
				cmo.clidep,
				cmo.clipol,
				cmo.codcamo,
				ca_niv2.licoes,
				cmo.clitopf,
				cmo.flaglock
			FROM
				CLIENT_MO cmo,
				(select es.codcamo, es.licoes from ENTITE_STRUCTURE es where NIVEAU=2) ca_niv2
			WHERE
				cmo.CLICODE = p_clicode
			AND	cmo.CODCAMO = ca_niv2.CODCAMO(+);

      EXCEPTION

         WHEN OTHERS THEN
          raise_application_error(-20997,SQLERRM);
      END;

      -- en cas absence
	-- p_message := 'Code Client absent';

      pack_global.recuperer_message( 4, '%s1',p_clicode, NULL, l_msg);
      p_message := l_msg;


   END select_client_mo;

END pack_client_mo;
/
CREATE OR REPLACE PACKAGE pack_code_compt AS

   TYPE code_comptCurType IS REF CURSOR RETURN code_compt%ROWTYPE;

   PROCEDURE insert_code_compt (p_comcode   IN  code_compt.comcode%TYPE,
                                p_comlib    IN  code_compt.comlib%TYPE,
                                p_comtyp    IN  code_compt.comtyp%TYPE,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                               );

   PROCEDURE update_code_compt (p_comcode   IN  code_compt.comcode%TYPE,
                                p_comlib    IN  code_compt.comlib%TYPE,
                                p_comtyp    IN  code_compt.comtyp%TYPE,
                                p_flaglock  IN  NUMBER,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                               );

   PROCEDURE delete_code_compt (p_comcode   IN  code_compt.comcode%TYPE,
                                p_flaglock  IN  NUMBER,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                               );

   PROCEDURE select_code_compt (p_comcode       IN code_compt.comcode%TYPE,
                                p_userid        IN VARCHAR2,
                                p_curcode_compt IN OUT code_comptCurType,
                                p_nbcurseur        OUT INTEGER,
                                p_message          OUT VARCHAR2
                               );

END pack_code_compt;
/

CREATE OR REPLACE PACKAGE BODY pack_code_compt AS

    PROCEDURE insert_code_compt (p_comcode   IN  code_compt.comcode%TYPE,
                                 p_comlib    IN  code_compt.comlib%TYPE,
                                 p_comtyp    IN  code_compt.comtyp%TYPE,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS

       l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO code_compt (comcode,
                                 comlib,
                                 comtyp
                                )
             VALUES (p_comcode,
                     p_comlib,
                     p_comtyp
                    );

          -- 'Code comptable ' || p_comcode ||  ' a été créé.';

         pack_global.recuperer_message( 2020, '%s1', p_comcode, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION

         WHEN DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message(20001, NULL, NULL, NULL, l_msg);
            raise_application_error(-20001, l_msg);

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

   END insert_code_compt;

   PROCEDURE update_code_compt (p_comcode   IN  code_compt.comcode%TYPE,
                                p_comlib    IN  code_compt.comlib%TYPE,
                                p_comtyp    IN  code_compt.comtyp%TYPE,
                                p_flaglock  IN  NUMBER,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                               ) IS

       l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         UPDATE code_compt SET comcode  = p_comcode,
                               comlib   = p_comlib,
                               comtyp   = p_comtyp,
                               flaglock = decode(p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE comcode = p_comcode
          AND flaglock = p_flaglock;

      EXCEPTION

         WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
     ELSE
         pack_global.recuperer_message(2021, '%s1', p_comcode, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END update_code_compt;


   PROCEDURE delete_code_compt (p_comcode   IN  code_compt.comcode%TYPE,
                                p_flaglock  IN  NUMBER,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                               ) IS

      l_msg VARCHAR2(1024);

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

    BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM code_compt
                WHERE comcode = p_comcode
                 AND flaglock = p_flaglock;

      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

          WHEN OTHERS THEN
             raise_application_error( -20997,SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2022, '%s1', p_comcode, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END delete_code_compt;

   PROCEDURE select_code_compt (p_comcode       IN code_compt.comcode%TYPE,
                                p_userid        IN VARCHAR2,
                                p_curcode_compt IN OUT code_comptCurType,
                                p_nbcurseur        OUT INTEGER,
                                p_message          OUT VARCHAR2
                               ) IS

       l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN

         OPEN p_curcode_compt FOR
              SELECT *
              FROM CODE_COMPT
              WHERE comcode = p_comcode;

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);

      END;

      -- en cas absence
      -- 'Le code_compt p_comcode n'existe pas';

      pack_global.recuperer_message(2023, '%s1', p_comcode, NULL, l_msg);
      p_message := l_msg;

   END select_code_compt;

END pack_code_compt;
/
CREATE OR REPLACE PACKAGE PACK_CODE_CP AS

	procedure modifier_cp(	p_codsg in varchar2,
							p_pcpi in varchar2,
							p_nouveau_pcpi in varchar2,
							p_userid in varchar2,
							p_message out varchar2);

END PACK_CODE_CP;
/

CREATE OR REPLACE PACKAGE BODY PACK_CODE_CP AS

	procedure modifier_cp(	p_codsg in varchar2,
							p_pcpi in varchar2,
							p_nouveau_pcpi in varchar2,
							p_userid in varchar2,
							p_message out varchar2)
	IS
		l_msg VARCHAR2(1024);
		ldatsitu VARCHAR2(10);
		l_date_courante VARCHAR2(20);
		l_ident ressource.ident%TYPE;
		l_pcpi ligne_bip.pcpi%TYPE;
		l_ligbip_rowcount BINARY_INTEGER;
		l_situ_rowcount BINARY_INTEGER;
		l_test number(2);

		l_habilitation  VARCHAR2(10);
	BEGIN

		l_ligbip_rowcount := 0;
		l_situ_rowcount := 0;

		l_habilitation := pack_habilitation.fhabili_me( p_codsg, p_userid);
        IF l_habilitation='faux' THEN
                -- Vous n'êtes pas habilité à ce DPG 20364
                pack_global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', l_msg);
                raise_application_error(-20364, l_msg);
        END IF;

		--test si la situation du nouveau code cp p_nouveau_pcpi existe pour le DPG codsg

		BEGIN
			SELECT
				distinct sit.ident INTO l_ident
			FROM
				ligne_bip lig,
				struct_info str,
				ressource res,
				situ_ress sit
			WHERE
				str.codsg = lig.codsg
			AND str.codsg = sit.codsg
			AND res.ident = sit.ident
			AND sit.DATSITU <= TO_CHAR(sysdate, 'dd/mm/yyyy')
			AND (sit.DATDEP >= TO_CHAR(sysdate, 'dd/mm/yyyy') OR sit.DATDEP IS NULL)
			AND str.codsg=to_number(p_codsg)
			AND res.ident=to_number(p_nouveau_pcpi);

		EXCEPTION
			WHEN TOO_MANY_ROWS OR NO_DATA_FOUND THEN
				pack_global.recuperer_message(20978, '%s1', p_nouveau_pcpi, '%s2', p_codsg, NULL, l_msg);
				p_message := l_msg;
				raise_application_error( -20978, l_msg );

			WHEN OTHERS THEN
				raise_application_error( -20999, SQLERRM);
		END;

		-- test si l ancien CP existe et/ou a une situation
		BEGIN
			SELECT
				distinct sit.ident INTO l_ident
			FROM
				situ_ress sit
			WHERE
			sit.DATSITU <= TO_CHAR(sysdate, 'dd/mm/yyyy')
			AND (sit.DATDEP >= TO_CHAR(sysdate, 'dd/mm/yyyy') OR sit.DATDEP IS NULL)
			AND sit.ident=to_number(p_pcpi);

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				pack_global.recuperer_message(20979, '%s1', p_pcpi, NULL, l_msg);
				p_message := l_msg;
				raise_application_error( -20979, l_msg );

			WHEN OTHERS THEN
				raise_application_error( -20999, SQLERRM);
		END;

		BEGIN

			begin
				-- récupération de l'année en cours au sens date de traitement annuel
			select to_char(datdebex.datdebex, 'yyyy') into l_date_courante from datdebex;
			EXCEPTION WHEN OTHERS THEN
				raise_application_error( -20999, SQLERRM);
			end;

			-- maj des lignes bip avec le nouveau code p_nouveau_pcpi

			update ligne_bip set
				pcpi=to_number(p_nouveau_pcpi)
			where
				(adatestatut is null or  (adatestatut is not null and to_number(to_char(adatestatut, 'yyyy')) = to_number(l_date_courante)))
				and codsg = p_codsg
				and pcpi=p_pcpi;

		--	IF (SQL%NOTFOUND) THEN
				-- l'ancien code cp p_pcpi n'existe pas
		--		pack_global.recuperer_message(20979, '%s1', p_pcpi, NULL, l_msg);
		--		p_message := l_msg;
		--		raise_application_error( -20979, l_msg );

		--	ELSE
				l_ligbip_rowcount := SQL%ROWCOUNT;
		--	END IF;


			-- maj des situations actives avec le nouveau code p_nouveau_pcpi
			update situ_ress set
				cpident=to_number(p_nouveau_pcpi)
			where
				 -- situ en cours
  				(
 				(DATSITU <= TO_CHAR(sysdate, 'dd/mm/yyyy') AND (DATDEP >= TO_CHAR(sysdate, 'dd/mm/yyyy') OR DATDEP IS NULL))
				 -- situ future
 				OR
 				(DATSITU > TO_CHAR(sysdate, 'dd/mm/yyyy') AND (DATDEP >= TO_CHAR(sysdate, 'dd/mm/yyyy') OR DATDEP IS NULL))
 				)
				and codsg = p_codsg
				and cpident=p_pcpi
                                ;

			--IF (SQL%NOTFOUND) THEN
				--la ressource n existe pas ou n a pas de situation
				--pack_global.recuperer_message(20979, '%s1', p_pcpi, NULL, l_msg);
				--p_message := l_msg;
				--raise_application_error( -20979, l_msg );
			--ELSE
				l_situ_rowcount:= SQL%ROWCOUNT;
			--END IF;


			pack_global.recuperer_message(20980, '%s1', l_ligbip_rowcount, '%s2', l_situ_rowcount,NULL, l_msg);
			p_message := l_msg;

			--dbms_output.put_line('message: ' || p_message);
		END;

	END modifier_cp;

END PACK_CODE_CP;
/
CREATE OR REPLACE PACKAGE Pack_Compte AS

   -- Définition curseur sur la table struct_info

   TYPE Compte_ViewType IS RECORD ( codcompte     	COMPTE.CODCOMPTE%TYPE,
					 	                                                           libcompte     	  COMPTE.LIBCOMPTE%TYPE,
																				   TYPE    	             COMPTE.TYPE%TYPE,
                                  	 						 	                    flaglock   	          COMPTE.flaglock%TYPE
					 					                                          );

   TYPE CompteCurType_Char IS REF CURSOR RETURN Compte_ViewType;


   PROCEDURE insert_Compte ( 	p_codcompte     	IN COMPTE.CODCOMPTE%TYPE,
					 	                                            p_libcompte     	  IN COMPTE.LIBCOMPTE%TYPE,
																	p_TYPE    	         IN COMPTE.TYPE%TYPE,
                                  									p_userid     	    IN  VARCHAR2,
                                  									p_nbcurseur     OUT INTEGER,
                                  									p_message      OUT VARCHAR2
                                									) ;

	PROCEDURE update_compte ( 	p_codcompte     IN	COMPTE.CODCOMPTE%TYPE,
					 	                                               p_libcompte     	  IN COMPTE.LIBCOMPTE%TYPE,
																	   p_type    	            IN  COMPTE.TYPE%TYPE,
                                  	 						 	       p_flaglock   	     IN   COMPTE.flaglock%TYPE,
				  													   p_userid     	      IN  VARCHAR2,
				  													   p_nbcurseur  	  OUT INTEGER,
                                  									   p_message    	 OUT VARCHAR2
                              										);



	PROCEDURE delete_compte ( p_codcompte     IN  COMPTE.CODCOMPTE%TYPE,
                                   		  	  		   	   		  p_flaglock 	         IN  NUMBER,
                                  								  p_userid                IN  VARCHAR2,
                                  								  p_nbcurseur        OUT INTEGER,
                                  								  p_message         OUT VARCHAR2
                         										   );

	 PROCEDURE select_Compte ( 	p_codcompte     	IN COMPTE.CODCOMPTE%TYPE,
					 	                                          	 p_userid     	             IN  VARCHAR2,
																	 p_curCompte         IN OUT CompteCurType_Char ,
                                  									 p_nbcurseur            OUT INTEGER,
                                  									 p_message             OUT VARCHAR2
                                									) ;

END Pack_Compte;
/

CREATE OR REPLACE PACKAGE BODY Pack_Compte AS



  PROCEDURE insert_Compte ( 	p_codcompte     	IN COMPTE.CODCOMPTE%TYPE,
					 	                                            p_libcompte     	  IN COMPTE.LIBCOMPTE%TYPE,
																	p_TYPE    	         IN COMPTE.TYPE%TYPE,
                                  									p_userid     	    IN  VARCHAR2,
                                  									p_nbcurseur     OUT INTEGER,
                                  									p_message      OUT VARCHAR2
                                									) IS

     l_msg VARCHAR2(1024);
     l_msg_alert VARCHAR2(1024);
     l_exist NUMBER;


   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


	BEGIN
     	   INSERT INTO COMPTE
	       		  	   		 		   	                   ( codcompte,
 		  												     libcompte,
 		  												     TYPE,
 														     flaglock)
         VALUES ( TO_NUMBER(p_codcompte),
		   		  			  p_libcompte,
		  					  p_type,
		  			  	      0
		                     );

		COMMIT;

	  Pack_Global.recuperer_message( 20971, '%s1', p_codcompte, NULL, l_msg);

	 p_message := l_msg;

     EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		       Pack_Global.recuperer_message( 21058, NULL, NULL, NULL, l_msg);
               RAISE_APPLICATION_ERROR( -20001, l_msg );

     END;

   END insert_compte;



   PROCEDURE update_compte ( 	p_codcompte     IN	COMPTE.CODCOMPTE%TYPE,
					 	                                               p_libcompte     	  IN COMPTE.LIBCOMPTE%TYPE,
																	   p_type    	            IN  COMPTE.TYPE%TYPE,
                                  	 						 	       p_flaglock   	     IN   COMPTE.flaglock%TYPE,
				  													   p_userid     	      IN  VARCHAR2,
				  													   p_nbcurseur  	  OUT INTEGER,
                                  									   p_message    	 OUT VARCHAR2
                              										) IS

	 l_msg               VARCHAR2(1024);
	 l_type               VARCHAR2(10);
	 l_count             NUMBER;


   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- initialiser le message retour

	p_nbcurseur := 0;
	p_message := '';

      -- test si le un compte est utilisé

      BEGIN


	  IF(p_type = 'C')THEN

	   l_type := 'déditer';

        SELECT COUNT(*) INTO l_count
        FROM RUBRIQUE
        WHERE comptedeb = p_codcompte;

	ELSE

		l_type := 'créditer';

		SELECT COUNT(*) INTO l_count
        FROM RUBRIQUE
        WHERE comptecre = p_codcompte;

	END IF;

	IF(l_count != 0)THEN

		  Pack_Global.recuperer_message( 20953, '%s1',l_type, NULL, l_msg);
          RAISE_APPLICATION_ERROR( -20953, l_msg );


	END IF;



      END;



	BEGIN

         UPDATE COMPTE
		SET	libcompte = p_libcompte,
		    	  TYPE 	= p_type,
				 flaglock 	= DECODE( p_flaglock, 1000000, 0, p_flaglock + 1 )
				 WHERE codcompte 	= TO_NUMBER(p_codcompte)
                 AND flaglock 	= p_flaglock;

	EXCEPTION

		WHEN OTHERS THEN
	        RAISE_APPLICATION_ERROR( -20754, l_msg );

	END;


      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	      Pack_Global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );

      ELSE


	   -- 'Le compte p_codcompte a été modifié'

	         Pack_Global.recuperer_message( 20972, '%s1', p_codcompte, NULL, l_msg);
		  	 p_message := l_msg;
      END IF;

   END update_compte;


PROCEDURE delete_compte ( p_codcompte     IN  COMPTE.CODCOMPTE%TYPE,
                                   		  	  		   	   	   p_flaglock 	         IN  NUMBER,
                                  							   p_userid                IN  VARCHAR2,
                                  							   p_nbcurseur        OUT INTEGER,
                                  							   p_message         OUT VARCHAR2
                         								   ) IS


	  l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
	   DELETE FROM COMPTE
		    WHERE codcompte = TO_NUMBER(p_codcompte)
			AND flaglock = TO_NUMBER(p_flaglock);

         EXCEPTION
		WHEN referential_integrity THEN
		         Pack_Global.recuperer_message( 20954, NULL, NULL, NULL, l_msg);
                RAISE_APPLICATION_ERROR( -20954, l_msg );

		WHEN OTHERS THEN
				    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
		END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   Pack_Global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
      RAISE_APPLICATION_ERROR( -20999, l_msg );

      ELSE

	   -- ' p_codcompte a été supprimé'

	   Pack_Global.recuperer_message( 20973, '%s1', p_codcompte, NULL, l_msg);
	   p_message := l_msg;

      END IF;

   END delete_compte;



   PROCEDURE select_Compte ( 	p_codcompte     	IN COMPTE.CODCOMPTE%TYPE,
					 	                                          	 p_userid     	             IN  VARCHAR2,
																	 p_curCompte     IN OUT CompteCurType_Char ,
                                  									 p_nbcurseur            OUT INTEGER,
                                  									 p_message             OUT VARCHAR2
                                									)  IS


	l_msg VARCHAR2(1024);

   BEGIN

        -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         OPEN   p_curCompte FOR
              SELECT 	codcompte,
                     				libcompte,
                     				TYPE,
                     	          	flaglock
		     FROM  COMPTE
              WHERE codcompte = TO_NUMBER(p_codcompte);

         -- en cas absence
	   -- 'code codcompte  inexistant'

         Pack_Global.recuperer_message( 21034, '%s1', p_codcompte, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION

        WHEN OTHERS THEN
          RAISE_APPLICATION_ERROR( -20997, SQLERRM);

      END;

   END select_compte;

END Pack_Compte;
/
CREATE OR REPLACE PACKAGE pack_conconsh AS

   PROCEDURE select_conconsh (P_param6  IN VARCHAR2,
                              P_param7  IN VARCHAR2,
                              P_param8  IN VARCHAR2,
                              p_userid  IN  CHAR,
                              p_message OUT VARCHAR2
                             );

END pack_conconsh;
/

CREATE OR REPLACE PACKAGE BODY pack_conconsh AS

   PROCEDURE select_conconsh (P_param6  IN VARCHAR2,
                              P_param7  IN VARCHAR2,
                              P_param8  IN VARCHAR2,
                              p_userid  IN CHAR,
                              p_message OUT VARCHAR2
                             ) IS

      l_msg   VARCHAR2(1024);
      l_soccode societe.soccode%TYPE;
      l_numcont histo_contrat.numcont%TYPE;
      l_filcode filiale_cli.filcode%TYPE;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_ccentrefrais centre_frais.codcfrais%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_message := '';

      l_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- test d'existance de la societe dans la table des societe
      BEGIN

         SELECT soccode
         INTO   l_soccode
         FROM   societe
         WHERE  soccode = P_param6;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20749, NULL, NULL, NULL, l_msg);
            raise_application_error(-20749,l_msg);

         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      -- TEST existance du numero de contrat dans la table histo_contrat.

      BEGIN

         SELECT distinct numcont
         INTO   l_numcont
         FROM   histo_contrat
         WHERE  rtrim(numcont) = P_param7;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20280, NULL, NULL, NULL, l_msg);
            raise_application_error(-20280,l_msg);

         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      -- TEST existance du numero de contrat dans la table contrat.

      BEGIN

	 SELECT c.numcont
	   INTO   l_numcont
	   FROM   histo_contrat c,
	   societe s,
	   struct_info si,
	   histo_ligne_cont lc,
	   ressource r,
	   filiale_cli f
	   WHERE c.codsg   = si.codsg
	   AND  c.soccont  = lc.soccont
	   AND  c.numcont  = lc.numcont
	   AND  c.cav      = lc.cav
	   AND  lc.ident   = r.ident
	   AND  c.soccont  = s.soccode
	   AND  f.filcode  = c.filcode
	   AND  s.soccode  = P_param6
	   AND  rtrim(c.numcont)  = P_param7
	   AND  c.cav      = P_param8
	   AND  ROWNUM < 2;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20288, NULL, NULL, NULL, l_msg);
            raise_application_error(-20288,l_msg);

         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      -- test d'existance du contrat pour la filiale
      BEGIN
	 SELECT hco.numcont
	   INTO   l_numcont
	   FROM   histo_contrat hco
	   WHERE  hco.soccont  = P_param6
	   AND    rtrim(hco.numcont)  = P_param7
	   AND    hco.cav     = P_param8
	   AND    hco.filcode = l_filcode
	   AND ROWNUM < 2;

      EXCEPTION
	 WHEN NO_DATA_FOUND THEN
	   pack_global.recuperer_message(20289, NULL, NULL, NULL, l_msg);
	   raise_application_error(-20289,l_msg);
	 WHEN OTHERS THEN
	   raise_application_error(-20997,SQLERRM);
      END;

     -- 20/12/2000 :Contrôler que le contrat appartient au centre de frais de l'utilisateur
      -- On récupère le code centre de frais de l'utilisateur
            l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

     IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
        BEGIN
		select ccentrefrais into l_ccentrefrais
		from histo_contrat
        	where  rtrim(numcont) = P_param7
	 	and	soccont = P_param6
         	and    cav     = P_param8
		and    filcode = l_filcode;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN -- Ce contrat n'est rattaché à aucun centre de frais
			 pack_global.recuperer_message(20336,NULL,NULL,NULL, l_msg);
         		 raise_application_error(-20336, l_msg);

		WHEN OTHERS THEN
               		raise_application_error(-20997,SQLERRM);

	END;
	IF l_ccentrefrais is null  then
		-- Ce contrat n'est rattaché à aucun centre de frais
			 pack_global.recuperer_message(20336, NULL,NULL,NULL, l_msg);
         		 raise_application_error(-20336, l_msg);

	END IF;
  	IF l_ccentrefrais!=l_centre_frais then
		--Le contrat n'existe pas dans le centre de frais mais dans le centre %s2
		 pack_global.recuperer_message(20335, '%s1',to_char(l_centre_frais),'%s2',to_char(l_ccentrefrais),NULL, l_msg);
         	raise_application_error(-20335, l_msg);
	END IF;
     END IF;

   END select_conconsh;

END pack_conconsh;
/
CREATE OR REPLACE PACKAGE pack_conconsr AS

   PROCEDURE select_conconsr (P_param6  IN  VARCHAR2,
                              P_param7  IN  VARCHAR2,
                              P_param8  IN  VARCHAR2,
                              p_userid  IN  VARCHAR2,
                              p_message OUT VARCHAR2
                             );

END pack_conconsr;
/

CREATE OR REPLACE PACKAGE BODY pack_conconsr AS

   PROCEDURE select_conconsr (P_param6  IN VARCHAR2,
                              P_param7  IN VARCHAR2,
                              P_param8  IN VARCHAR2,
                              p_userid  IN VARCHAR2,
                              p_message OUT VARCHAR2
                             ) IS

      l_msg   		VARCHAR2(1024);
      l_soccode 	societe.soccode%TYPE;
      l_numcont 	contrat.numcont%TYPE;
      l_filcode 	filiale_cli.filcode%TYPE;
      l_centre_frais 	centre_frais.codcfrais%TYPE;
      l_ccentrefrais 	centre_frais.codcfrais%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_message := '';

      l_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- TEST existence de la societe dans la table societe.

      BEGIN

         SELECT soccode
         INTO   l_soccode
         FROM   societe
         WHERE  soccode = P_param6;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20749, NULL, NULL, NULL, l_msg);
            raise_application_error(-20749,l_msg);

         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      -- TEST existance du numero de contrat dans la table contrat.

      BEGIN

         SELECT distinct numcont
         INTO   l_numcont
         FROM   contrat
         WHERE  rtrim(numcont) = P_param7;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20280, NULL, NULL, NULL, l_msg);
            raise_application_error(-20280,l_msg);

         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      -- TEST existance du numero de contrat dans la table contrat.

      BEGIN

	 SELECT c.numcont
	   INTO l_numcont
	   FROM contrat c,
	   societe s,
	   struct_info si,
	   ligne_cont lc,
	   ressource r,
	   filiale_cli f
	   WHERE c.codsg = 	si.codsg
	   AND   c.soccont = 	lc.soccont
	   AND   c.numcont = 	lc.numcont
	   AND   c.cav = 	lc.cav
	   AND   lc.ident = 	r.ident
	   AND   c.soccont  = 	s.soccode
	   AND   f.filcode  = 	c.filcode
	   AND   s.soccode  = 	P_param6
	   AND   rtrim(c.numcont)  = P_param7
	   AND   c.cav      = 	P_param8
	   AND  ROWNUM < 2;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20287, NULL, NULL, NULL, l_msg);
            raise_application_error(-20287,l_msg);

         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      -- test d'existance du contrat pour la filiale

      BEGIN
	 SELECT con.numcont
	   INTO   l_numcont
	   FROM   contrat con
	   WHERE  con.soccont  = P_param6
	   AND    rtrim(con.numcont)  = P_param7
	   AND    con.cav     = P_param8
	   AND    con.filcode = l_filcode
	   AND ROWNUM < 2;

      EXCEPTION
	 WHEN NO_DATA_FOUND THEN
	   pack_global.recuperer_message(20290, NULL, NULL, NULL, l_msg);
	   raise_application_error(-20290,l_msg);
	 WHEN OTHERS THEN
	   raise_application_error(-20997,SQLERRM);
      END;

     -- 20/12/2000 :Contrôler que le contrat appartient au centre de frais de l'utilisateur
      -- On récupère le code centre de frais de l'utilisateur
            l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

     IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
        BEGIN
		select ccentrefrais into l_ccentrefrais
		from contrat
        	where  	rtrim(numcont) = P_param7
	 	and	soccont = P_param6
         	and    	cav     = P_param8
		and    	filcode = l_filcode;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN -- Ce contrat n'est rattaché à aucun centre de frais
			 pack_global.recuperer_message(20336, NULL,NULL,NULL, l_msg);
         		 raise_application_error(-20336, l_msg);

		WHEN OTHERS THEN
               		raise_application_error(-20997,SQLERRM);

	END;
	IF l_ccentrefrais is null  then
		-- Ce contrat n'est rattaché à aucun centre de frais
			 pack_global.recuperer_message(20336, NULL,NULL,NULL, l_msg);
         		 raise_application_error(-20336, l_msg);

	END IF;
  	IF l_ccentrefrais!=l_centre_frais then
		--Le contrat n'existe pas dans le centre de frais mais dans le centre %s2
		 pack_global.recuperer_message(20335, '%s1',to_char(l_centre_frais),'%s2',to_char(l_ccentrefrais),NULL, l_msg);
         	raise_application_error(-20335, l_msg);
	END IF;
     END IF;

   END select_conconsr;

END pack_conconsr;
/
CREATE OR REPLACE PACKAGE pack_contrat AS

   TYPE ContRecType IS RECORD (soccont      contrat.soccont%TYPE,
                               soclib       societe.soclib%TYPE,
                               numcont      contrat.numcont%TYPE,
                               cav          contrat.cav%TYPE,
                               cagrement    contrat.cagrement%TYPE,
                               niche        VARCHAR2(20),
                               cnaffair     contrat.cnaffair%TYPE,
                               crang        contrat.crang%TYPE,
                               cdatarr      VARCHAR2(20),
                               cobjet1      contrat.cobjet1%TYPE,
                               cobjet2      contrat.cobjet2%TYPE,
                               crem         contrat.crem%TYPE,
                               codsg        VARCHAR2(20),
                               comcode      VARCHAR2(20),
                               ctypfact     contrat.ctypfact%TYPE,
                               ccoutht      VARCHAR2(20),
                               ccharesti    VARCHAR2(20),
                               cdatdeb      VARCHAR2(10),
                               cdatfin      VARCHAR2(10),
                               flaglock     VARCHAR2(20)
                              );

   TYPE ContCurType IS REF CURSOR RETURN ContRecType;

   PROCEDURE insert_contrat (p_test     IN  VARCHAR2,
                             p_soccont   IN  contrat.soccont%TYPE,
                             p_soclib    IN  societe.soclib%TYPE,
                             p_numcont   IN  contrat.numcont%TYPE,
                             p_cav       IN  contrat.cav%TYPE,
                             p_cagrement IN  contrat.cagrement%TYPE,
                             p_niche     IN  VARCHAR2,
                             p_cnaffair  IN  contrat.cnaffair%TYPE,
                             p_crang     IN  contrat.crang%TYPE,
                             p_cdatarr   IN  VARCHAR2,
                             p_cobjet1   IN  contrat.cobjet1%TYPE,
                             p_cobjet2   IN  contrat.cobjet2%TYPE,
                             p_crem      IN  contrat.crem%TYPE,
                             p_codsg     IN  VARCHAR2,
                             p_comcode   IN  VARCHAR2,
                             p_ctypfact  IN  contrat.ctypfact%TYPE,
                             p_ccoutht   IN  VARCHAR2,
                             p_ccharesti IN  VARCHAR2,
                             p_cdatdeb   IN  VARCHAR2,
                             p_cdatfin   IN  VARCHAR2,
                             p_userid    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            );

   PROCEDURE update_contrat (p_test     IN  VARCHAR2,
                             p_soccont   IN  contrat.soccont%TYPE,
                             p_soclib    IN  societe.soclib%TYPE,
                             p_numcont   IN  contrat.numcont%TYPE,
                             p_cav       IN  contrat.cav%TYPE,
                             p_cagrement IN  contrat.cagrement%TYPE,
                             p_niche     IN  VARCHAR2,
                             p_cnaffair  IN  contrat.cnaffair%TYPE,
                             p_crang     IN  contrat.crang%TYPE,
                             p_cdatarr   IN  VARCHAR2,
                             p_cobjet1   IN  contrat.cobjet1%TYPE,
                             p_cobjet2   IN  contrat.cobjet2%TYPE,
                             p_crem      IN  contrat.crem%TYPE,
                             p_codsg     IN  VARCHAR2,
                             p_comcode   IN  VARCHAR2,
                             p_ctypfact  IN  contrat.ctypfact%TYPE,
                             p_ccoutht   IN  VARCHAR2,
                             p_ccharesti IN  VARCHAR2,
                             p_cdatdeb   IN  VARCHAR2,
                             p_cdatfin   IN  VARCHAR2,
                             p_flaglock  IN  NUMBER,
                             p_userid    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            );

   PROCEDURE delete_contrat (p_test     IN  VARCHAR2,
                             p_soccont   IN  contrat.soccont%TYPE,
                             p_soclib    IN  societe.soclib%TYPE,
                             p_numcont   IN  contrat.numcont%TYPE,
                             p_cav       IN  contrat.cav%TYPE,
                             p_cagrement IN  contrat.cagrement%TYPE,
                             p_niche     IN  VARCHAR2,
                             p_cnaffair  IN  contrat.cnaffair%TYPE,
                             p_crang     IN  contrat.crang%TYPE,
                             p_cdatarr   IN  VARCHAR2,
                             p_cobjet1   IN  contrat.cobjet1%TYPE,
                             p_cobjet2   IN  contrat.cobjet2%TYPE,
                             p_crem      IN  contrat.crem%TYPE,
                             p_codsg     IN  VARCHAR2,
                             p_comcode   IN  VARCHAR2,
                             p_ctypfact  IN  contrat.ctypfact%TYPE,
                             p_ccoutht   IN  VARCHAR2,
                             p_ccharesti IN  VARCHAR2,
                             p_cdatdeb   IN  VARCHAR2,
                             p_cdatfin   IN  VARCHAR2,
                             p_flaglock  IN  NUMBER,
                             p_userid    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            );

   PROCEDURE select_contrat (p_mode    IN VARCHAR2,
                             p_test     IN VARCHAR2,
                             p_soccont   IN contrat.soccont%TYPE,
                             p_numcont   IN contrat.numcont%TYPE,
                             p_cav       IN contrat.cav%TYPE,
                             p_userid    IN VARCHAR2,
                             p_curcont   IN OUT ContCurType,
                             p_socout       OUT VARCHAR2,
                             p_cavout       OUT VARCHAR2,
                             p_choixout     OUT VARCHAR2,
			     p_cnaffout     OUT VARCHAR2,
			     p_codsg        OUT VARCHAR2,
			     p_comcode      OUT VARCHAR2,
			     p_cobjet1      OUT VARCHAR2,
                             p_cobjet2      OUT VARCHAR2,
                             p_nbcurseur    OUT INTEGER,
                             p_message      OUT VARCHAR2
                            );

END pack_contrat;
/

CREATE OR REPLACE PACKAGE BODY pack_contrat AS

   PROCEDURE insert_contrat (p_test     IN  VARCHAR2,
                             p_soccont   IN  contrat.soccont%TYPE,
                             p_soclib    IN  societe.soclib%TYPE,
                             p_numcont   IN  contrat.numcont%TYPE,
                             p_cav       IN  contrat.cav%TYPE,
                             p_cagrement IN  contrat.cagrement%TYPE,
                             p_niche     IN  VARCHAR2,
                             p_cnaffair  IN  contrat.cnaffair%TYPE,
                             p_crang     IN  contrat.crang%TYPE,
                             p_cdatarr   IN  VARCHAR2,
                             p_cobjet1   IN  contrat.cobjet1%TYPE,
                             p_cobjet2   IN  contrat.cobjet2%TYPE,
                             p_crem      IN  contrat.crem%TYPE,
                             p_codsg     IN  VARCHAR2,
                             p_comcode   IN  VARCHAR2,
                             p_ctypfact  IN  contrat.ctypfact%TYPE,
                             p_ccoutht   IN  VARCHAR2,
                             p_ccharesti IN  VARCHAR2,
                             p_cdatdeb   IN  VARCHAR2,
                             p_cdatfin   IN  VARCHAR2,
                             p_userid    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            ) IS

   l_msg VARCHAR2(1024);
   l_cdatarr NUMBER;
   l_filcode filiale_cli.filcode%TYPE;
   l_topfer  struct_info.topfer%TYPE;
   l_centre_frais number(3);
   l_scentrefrais number(3);
   referential_integrity EXCEPTION;
   PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- On recupere le code filiale de l'utilisateur

      l_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- On récupère le code centre de frais de l'utilisateur
      l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;


      -- TEST date d'arrivee a GES/ACH doit etre > a date du jour

      SELECT to_number(MONTHS_BETWEEN(trunc(sysdate), trunc(to_date(p_cdatarr,'DD/MM/YYYY'))))
      INTO   l_cdatarr
      FROM   DUAL;

      IF l_cdatarr < 0 THEN
            pack_global.recuperer_message(20283,NULL, NULL,'CDATARR', l_msg);
            raise_application_error(-20283 , l_msg );
      END IF;

      -- Test le DPG non ouvert donc fermer

      BEGIN
         SELECT topfer , scentrefrais
         INTO   l_topfer, l_scentrefrais
         FROM   struct_info
         WHERE  codsg = TO_NUMBER(p_codsg);

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
            raise_application_error(-20203, l_msg);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF l_topfer = 'F' THEN
          pack_global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
          raise_application_error(-20274, l_msg);
      END IF;
     -- ===================================================================
     -- 19/12/2000 : Test si le DPG appartient bien au centre de frais
     -- ===================================================================
    IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
      	IF (l_scentrefrais is null)   then
		--msg : Le DPG n'est rattaché à aucun centre de frais
		pack_global.recuperer_message(20339, NULL,NULL,'CODSG', l_msg);
          	raise_application_error(-20339, l_msg);
	ELSE
		IF (l_scentrefrais!=l_centre_frais) then
			--msg:Ce DPG n'appartient pas à ce centre de frais
			pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'CODSG', l_msg);
          		raise_application_error(-20334, l_msg);
		END IF;
      	END IF;
    ELSE	-- l'utilisateur n'est pas affecté à un centre de frais réel: récupérer le centre de frais du DPG
	IF (l_scentrefrais is null) then
		--msg : Le DPG n'est rattaché à aucun centre de frais
		pack_global.recuperer_message(20339, NULL,NULL,'CODSG', l_msg);
          	raise_application_error(-20339, l_msg);

	ELSE
		-- le centre de frais du contrat est le centre de frais du DPG
		l_centre_frais := l_scentrefrais;
	END IF;
    END IF;


      -- TEST si la date de fin < date de debut ERROR

      IF to_date(p_cdatfin,'dd/mm/yyyy') < to_date(p_cdatdeb,'dd/mm/yyyy') THEN
         pack_global.recuperer_message(20284,NULL, NULL,'CDATDEB', l_msg);
         raise_application_error(-20284 , l_msg );
      END IF;

      BEGIN
         INSERT INTO contrat (filcode,
                              soccont,
                              numcont,
                              cav,
                              cagrement,
                              niche,
                              cnaffair,
                              crang,
                              cdatarr,
                              cobjet1,
                              cobjet2,
                              crem,
                              codsg,
                              comcode,
                              ctypfact,
                              ccoutht,
                              ccharesti,
                              cdatdeb,
                              cdatfin,
                              cdatsai,
                              cduree,
                              cmmens,
                              cantcons,
                              cantfact,
                              cecartht,
                              cevainit,
			     ccentrefrais,
			     cdatrpol,
			     cdatdir
                             )
         VALUES (l_filcode,
                 p_soccont,
                 p_numcont,
                 p_cav,
                 p_cagrement,
                 to_number(p_niche),
                 p_cnaffair,
                 p_crang,
                 to_date(p_cdatarr,'dd/mm/yyyy'),
                 p_cobjet1,
                 p_cobjet2,
                 p_crem,
                 to_number(p_codsg),
                 p_comcode,
                 p_ctypfact,
                 to_number(p_ccoutht,'FM9999999999D00'),
                 to_number(p_ccharesti,'FM9999D0'),
                 to_date(p_cdatdeb,'dd/mm/yyyy'),
                 to_date(p_cdatfin,'dd/mm/yyyy'),
                 trunc(sysdate), -- to_date(to_char(sysdate,'dd/mm/yyyy')),
                 to_number(MONTHS_BETWEEN(trunc(to_date(p_cdatfin,'DD/MM/YYYY'), 'MONTH'),
                                          trunc(to_date(p_cdatdeb,'DD/MM/YYYY'), 'MONTH'))),
                 round(to_number(p_ccoutht,'FM9999999999D00')/
                       decode(MONTHS_BETWEEN(trunc(to_date(p_cdatfin,'DD/MM/YYYY'), 'MONTH'),
					     trunc(to_date(p_cdatdeb,'DD/MM/YYYY'), 'MONTH')), 0, 1,
			      MONTHS_BETWEEN(trunc(to_date(p_cdatfin,'DD/MM/YYYY'), 'MONTH'),
					     trunc(to_date(p_cdatdeb,'DD/MM/YYYY'), 'MONTH')))
                      ),
                 0,
                 0,
                 0,
                 0,
		l_centre_frais,
		trunc(sysdate),
		trunc(sysdate)
                );

      EXCEPTION

        WHEN referential_integrity THEN

              -- habiller le msg erreur

              pack_global.recuperation_integrite(-2291);

         WHEN DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message(20285,NULL, NULL, NULL, l_msg);
            raise_application_error(-20285 , l_msg );

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM );
      END;

      IF p_cav = '00' THEN -- On cree un contrat

         -- MSG : 'Le contrat %s1 a ete creer'

         pack_global.recuperer_message(2087,'%s1',p_numcont, NULL, l_msg);

     ELSE

         -- MSG : 'L'avenant %s1 a ete creer pour le contrat %s2'

         pack_global.recuperer_message(2088,'%s1',p_cav,'%s2',p_numcont, NULL, l_msg);

     END IF;
     p_message := l_msg;

   END insert_contrat;

   PROCEDURE update_contrat (p_test     IN  VARCHAR2,
                             p_soccont   IN  contrat.soccont%TYPE,
                             p_soclib    IN  societe.soclib%TYPE,
                             p_numcont   IN  contrat.numcont%TYPE,
                             p_cav       IN  contrat.cav%TYPE,
                             p_cagrement IN  contrat.cagrement%TYPE,
                             p_niche     IN  VARCHAR2,
                             p_cnaffair  IN  contrat.cnaffair%TYPE,
                             p_crang     IN  contrat.crang%TYPE,
                             p_cdatarr   IN  VARCHAR2,
                             p_cobjet1   IN  contrat.cobjet1%TYPE,
                             p_cobjet2   IN  contrat.cobjet2%TYPE,
                             p_crem      IN  contrat.crem%TYPE,
                             p_codsg     IN  VARCHAR2,
                             p_comcode   IN  VARCHAR2,
                             p_ctypfact  IN  contrat.ctypfact%TYPE,
                             p_ccoutht   IN  VARCHAR2,
                             p_ccharesti IN  VARCHAR2,
                             p_cdatdeb   IN  VARCHAR2,
                             p_cdatfin   IN  VARCHAR2,
                             p_flaglock  IN  NUMBER,
                             p_userid    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);
      l_filcode filiale_cli.filcode%TYPE;
      l_topfer  struct_info.topfer%TYPE;
      l_cdatarr NUMBER;
      l_centre_frais number(3);
      l_scentrefrais number(3);

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      -- On recupere le code filiale de l'utilisateur
      l_filcode := pack_global.lire_globaldata(p_userid).filcode;

       -- On recupere le code centre de frais de l'utilisateur
      l_centre_frais:= pack_global.lire_globaldata(p_userid).codcfrais;




      -- Test le DPG non ouvert donc fermer

      BEGIN
         SELECT topfer , scentrefrais
         INTO   l_topfer, l_scentrefrais
         FROM   struct_info
         WHERE  codsg = TO_NUMBER(p_codsg);

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
            raise_application_error(-20203, l_msg);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF l_topfer = 'F' THEN
          pack_global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
          raise_application_error(-20274, l_msg);
      END IF;

     -- ===================================================================
     -- 19/12/2000 : Test si le DPG appartient bien au centre de frais
     -- ===================================================================
    IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
      	IF (l_scentrefrais is null)   then
		--msg : Le DPG n'est rattaché à aucun centre de frais
		pack_global.recuperer_message(20339, NULL,NULL,'CODSG', l_msg);
          	raise_application_error(-20339, l_msg);
	ELSE
		IF (l_scentrefrais!=l_centre_frais) then
			--msg:Ce DPG n'appartient pas à ce centre de frais
			pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'CODSG', l_msg);
          		raise_application_error(-20334, l_msg);
		END IF;
      	END IF;
    ELSE	-- l'utilisateur n'est pas affecté à un centre de frais réel: récupérer le centre de frais du DPG
	IF (l_scentrefrais is null) then
		--msg : Le DPG n'est rattaché à aucun centre de frais
		pack_global.recuperer_message(20339, NULL,NULL,'CODSG', l_msg);
          	raise_application_error(-20339, l_msg);

	ELSE
		-- le centre de frais du contrat est le centre de frais du DPG
		l_centre_frais := l_scentrefrais;
	END IF;
    END IF;

      -- TEST  coherence entre la date de debut et date de fin
      IF to_date(p_cdatdeb, 'DD/MM/YYYY') > to_date(p_cdatfin, 'DD/MM/YYYY') THEN
	 pack_global.recuperer_message(20284, NULL, NULL, 'CDATDEB', l_msg);
	 raise_application_error(-20284, l_msg);
      END IF;

      -- TEST date d'arrivee a GES/ACH doit etre > a date du jour

      SELECT to_number(MONTHS_BETWEEN(trunc(sysdate), trunc(to_date(p_cdatarr,'DD/MM/YYYY'))))
	INTO   l_cdatarr
	FROM   DUAL;

      IF l_cdatarr < 0 THEN
	 pack_global.recuperer_message(20283,NULL, NULL,'CDATARR', l_msg);
	 raise_application_error(-20283 , l_msg );
      END IF;

      -- UPDATE du contrat

      BEGIN
         UPDATE contrat
         SET soccont   = p_soccont,
             numcont   = p_numcont,
             cav       = p_cav,
             cagrement = p_cagrement,
             niche     = to_number(p_niche),
             cnaffair  = p_cnaffair,
             crang     = p_crang,
             cdatarr   = to_date(p_cdatarr,'DD/MM/YYYY'),
             cobjet1   = p_cobjet1,
             cobjet2   = p_cobjet2,
             crem      = p_crem,
             codsg     = to_number(p_codsg),
             comcode   = p_comcode,
             ctypfact  = p_ctypfact,
             ccoutht   = to_number(p_ccoutht,'FM9999999999D00'),
             ccharesti = to_number(p_ccharesti,'FM9999D0'),
             cdatdeb   = to_date(p_cdatdeb,'DD/MM/YYYY'),
             cdatfin   = to_date(p_cdatfin,'DD/MM/YYYY'),
             cdatmaj   = trunc(sysdate),
             flaglock  = decode( p_flaglock, 1000000, 0, p_flaglock + 1),
	     ccentrefrais=l_centre_frais
         WHERE soccont = p_soccont
         AND   filcode = l_filcode
         AND   numcont = p_numcont
         AND   cav     = p_cav
         AND   flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2291);

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2089,'%s1',p_numcont, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END update_contrat;


   PROCEDURE delete_contrat (p_test     IN  VARCHAR2,
                             p_soccont   IN  contrat.soccont%TYPE,
                             p_soclib    IN  societe.soclib%TYPE,
                             p_numcont   IN  contrat.numcont%TYPE,
                             p_cav       IN  contrat.cav%TYPE,
                             p_cagrement IN  contrat.cagrement%TYPE,
                             p_niche     IN  VARCHAR2,
                             p_cnaffair  IN  contrat.cnaffair%TYPE,
                             p_crang     IN  contrat.crang%TYPE,
                             p_cdatarr   IN  VARCHAR2,
                             p_cobjet1   IN  contrat.cobjet1%TYPE,
                             p_cobjet2   IN  contrat.cobjet2%TYPE,
                             p_crem      IN  contrat.crem%TYPE,
                             p_codsg     IN  VARCHAR2,
                             p_comcode   IN  VARCHAR2,
                             p_ctypfact  IN  contrat.ctypfact%TYPE,
                             p_ccoutht   IN  VARCHAR2,
                             p_ccharesti IN  VARCHAR2,
                             p_cdatdeb   IN  VARCHAR2,
                             p_cdatfin   IN  VARCHAR2,
                             p_flaglock  IN  NUMBER,
                             p_userid    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);
      l_filcode filiale_cli.filcode%TYPE;
      l_numcont contrat.numcont%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- On recupere le code filiale de l'utilisateur

      l_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- On test si le contrat supprimer possede une ou des factures
      -- Il n'y a pas de contrainte car elle doit etre sur contrat et histo_contrat
      BEGIN

	 SELECT  fac.numcont
	   INTO  l_numcont
	   FROM  facture fac
	   WHERE fac.numcont = p_numcont
	   AND   fac.soccont = p_soccont
	   AND   fac.cav     = p_cav
	   AND ROWNUM < 2;

      EXCEPTION
	 WHEN no_data_found THEN
	   NULL; -- Il n'existe pas de facture avec ce numero de contrat/avenant
	 WHEN OTHERS THEN
	   raise_application_error( -20997, SQLERRM );
      END;

      IF l_numcont IS NOT NULL THEN
	 pack_global.recuperer_message(20294 ,NULL, NULL, NULL, l_msg);
	 raise_application_error( -20294, l_msg );
      END IF;

      -- On test si le contrat supprimer possede une ou des factures historises
      -- Il n'y a pas de contrainte car elle doit etre sur contrat et histo_contrat
      BEGIN

	 SELECT  fac.numcont
	   INTO  l_numcont
	   FROM  histo_facture fac
	   WHERE fac.numcont = p_numcont
	   AND   fac.soccont = p_soccont
	   AND   fac.cav     = p_cav
	   AND ROWNUM < 2;

      EXCEPTION
	 WHEN no_data_found THEN
	   NULL;
	 WHEN OTHERS THEN
	   raise_application_error( -20997, SQLERRM );
      END;

      IF l_numcont IS NOT NULL THEN
	 pack_global.recuperer_message(20295 ,NULL, NULL, NULL, l_msg);
	 raise_application_error( -20294, l_msg );
      END IF;

     -- 2 cas : si l'avenant(p_cav) = 00 et != 00
     -- 1er cas avenat = 00 on efface tous les contrats:

     IF p_cav = '00' THEN
        BEGIN
           DELETE FROM contrat
           WHERE soccont  = p_soccont
           AND   filcode  = l_filcode
           AND   numcont  = p_numcont;

        EXCEPTION

           WHEN OTHERS THEN
              raise_application_error(-20997, SQLERRM);
        END;
     ELSE  -- on ne supprime que l'avenant sélectionné
        BEGIN
           DELETE FROM  contrat
           WHERE soccont  = p_soccont
           AND   filcode  = l_filcode
           AND   numcont  = p_numcont
           AND   cav      = p_cav
           AND   flaglock = p_flaglock;

        EXCEPTION
           WHEN referential_integrity THEN

              -- habiller le msg erreur : "Pas de suppression de contrat/avenant avec des factures liées"

              pack_global.recuperation_integrite(-2292);

           WHEN OTHERS THEN
              raise_application_error(-20997, SQLERRM);
        END;
     END IF;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
	 raise_application_error( -20999, l_msg );

      ELSIF (p_cav = '00') THEN

         -- On supprime un contrat

         pack_global.recuperer_message(2090,'%s1' , p_numcont , NULL, l_msg);
      ELSE

         -- On supprime un avenant

         pack_global.recuperer_message(2091,'%s1' , p_numcont , NULL, l_msg);
      END IF;
      p_message := l_msg;

   END delete_contrat;


   PROCEDURE select_contrat (p_mode    IN VARCHAR2,
                             p_test     IN VARCHAR2,
                             p_soccont   IN contrat.soccont%TYPE,
                             p_numcont   IN contrat.numcont%TYPE,
                             p_cav       IN contrat.cav%TYPE,
                             p_userid    IN VARCHAR2,
                             p_curcont   IN OUT ContCurType,
                             p_socout       OUT VARCHAR2,
                             p_cavout       OUT VARCHAR2,
                             p_choixout     OUT VARCHAR2,
			     p_cnaffout     OUT VARCHAR2,
			     p_codsg        OUT VARCHAR2,
			     p_comcode      OUT VARCHAR2,
			     p_cobjet1      OUT VARCHAR2,
                             p_cobjet2      OUT VARCHAR2,
                             p_nbcurseur    OUT INTEGER,
                             p_message      OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);
      l_soclib   societe.soclib%TYPE;
      l_soccont  contrat.soccont%TYPE;
      l_numcont  contrat.numcont%TYPE;
      l_filcode  filiale_cli.filcode%TYPE;
      l_cav      contrat.cav%TYPE;
      l_cav_hist contrat.cav%TYPE;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_ccentrefrais centre_frais.codcfrais%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- On recupere le code filiale de l'utilisateur

      l_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- TEST existance du code societe dans la table societe

      BEGIN
         SELECT soccode
         INTO   l_soccont
         FROM   societe
         WHERE  soccode = p_soccont;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN

             -- Erreur message "Code Societe inconnu"

             pack_global.recuperer_message(20306, NULL, NULL, NULL, l_msg);
             raise_application_error(-20306,l_msg);

         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;


      -- Positionne le tag <% CHOIX %> pour la page HTML

      p_choixout :=  p_test;


      -- TEST de cnaffair

      IF p_mode = 'insert' AND p_test != 'avenant' THEN
         p_cnaffout := 'OUI';
      END IF;

      -- Cas de la creation

      IF p_mode = 'insert' THEN

	   -- AJOUT du 26/05/2000 : Création impossible si societe fermée
	 BEGIN
         SELECT soccode
         INTO   l_soccont
         FROM   societe
         WHERE  soccode = p_soccont
	 AND (socfer is null or socfer='');

      	 EXCEPTION
          WHEN NO_DATA_FOUND THEN

             -- Erreur message "Création impossible, la societe n'existe plus"

             pack_global.recuperer_message(20325, NULL, NULL, NULL, l_msg);
             raise_application_error(-20325,l_msg);

          WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      	 END;


         -- On retourne le libelle de la societe

         SELECT  soclib
	   INTO  l_soclib
	   FROM  societe
	   WHERE soccode = p_soccont;

         p_socout :=  l_soclib;

         -- Différence entre creation d'un avenant et d'un contrat

         IF p_test = 'contrat' THEN
            p_cavout := '00';
         -- Test de l'existence du contrat dans la table histo_contrat pour la filiale utilisateur
         -- S'il n'exite pas OK sinon erreur

         BEGIN
	    SELECT distinct soccont
	      INTO   l_soccont
	      FROM   histo_contrat
	      WHERE  soccont = p_soccont
	      AND    filcode = l_filcode
	      AND    numcont = p_numcont;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL;
            WHEN OTHERS THEN
                raise_application_error(-20997,SQLERRM);
         END;

         IF SQL%FOUND THEN

                -- Erreur message "Le contrat existe deja dans histo_contrat"

                pack_global.recuperer_message(20281, NULL, NULL, NULL, l_msg);
                raise_application_error(-20281,l_msg);
         END IF;

         -- Test de l'existence du contrat dans la table histo_contrat pour une autre filiale

         BEGIN
            SELECT distinct soccont
	      INTO   l_soccont
	      FROM   histo_contrat
	      WHERE  soccont = p_soccont
	      AND    numcont = p_numcont
	      AND    filcode <> l_filcode;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL;
            WHEN OTHERS THEN
                raise_application_error(-20997,SQLERRM);
         END;

         IF SQL%FOUND THEN

             -- Erreur message "Le contrat existe deja pour une autre filiale"

             pack_global.recuperer_message(20286, NULL, NULL, NULL, l_msg);
             raise_application_error(-20286,l_msg);
         END IF;

         ELSE -- On cree un avenant

            -- On prend le cav max pour le contrat selectionne ensuite
            -- il devient un number pour ajouter 1 et retour
            -- au format caractere avec un affichage au format '09'


	    SELECT to_char((to_number(max(con.cav))+1), 'FM09')
	      INTO   l_cav
	      FROM   contrat con
	      WHERE  con.soccont = p_soccont
	      AND    con.filcode = l_filcode
	      AND    con.numcont = p_numcont;

	    -- Le dernier avenant n'existe pas dans contrats on doit le
	    -- prendre dans histo_contrat

	    IF l_cav IS NULL THEN

	       SELECT to_char((to_number(max(hc.cav))+1), 'FM09')
		 INTO   l_cav
		 FROM   histo_contrat hc
		 WHERE  hc.soccont = p_soccont
		 AND    hc.filcode = l_filcode
		 AND    hc.numcont = p_numcont;
	    END IF;

	    p_cavout := l_cav;

	    -- On recuperer le codsg et le code comptable du contrat
	    BEGIN
	       SELECT TO_CHAR(codsg, 'FM0000000'), comcode, cobjet1, cobjet2
		 INTO  p_codsg, p_comcode, p_cobjet1, p_cobjet2
		 FROM  contrat con
		 WHERE con.soccont = p_soccont
		 AND   con.numcont = p_numcont
		 AND   con.cav = ( 	SELECT max(cav)
					FROM contrat
					WHERE soccont = p_soccont
		 			AND   numcont = p_numcont);

	    EXCEPTION
	       WHEN no_data_found THEN
		 -- Cas ou le contrat se trouve dans histo_contrat1
		 BEGIN
  		   SELECT TO_CHAR(codsg, 'FM0000000'), comcode, cobjet1, cobjet2
		      INTO  p_codsg, p_comcode, p_cobjet1, p_cobjet2
		   FROM  histo_contrat hc
		   WHERE hc.soccont = p_soccont
		   AND   hc.numcont = p_numcont
		   --AND   hc.cav     = '00';
		   AND   hc.cav = ( 	SELECT max(cav)
					FROM histo_contrat
					WHERE soccont = p_soccont
		 			AND   numcont = p_numcont);
		 EXCEPTION
		    WHEN no_data_found THEN
		      NULL;
		    WHEN OTHERS THEN
		      raise_application_error(-20997,SQLERRM);
		 END;

	       WHEN OTHERS THEN
		 raise_application_error(-20997,SQLERRM);
	    END;
         END IF;



      END IF;  -- Fin du cas creation





      -- Test de l'existance du contrat dans la table contrat pour une autre filiale

      BEGIN
         SELECT distinct soccont
         INTO   l_soccont
         FROM   contrat
         WHERE  soccont = p_soccont
         AND    numcont = p_numcont
         AND    filcode <> l_filcode;

         IF SQL%FOUND THEN

             -- Erreur message "Le contrat existe deja pour une autre filiale"

             pack_global.recuperer_message(20286, NULL, NULL, NULL, l_msg);
             raise_application_error(-20286,l_msg);
         END IF;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
             NULL;
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      -- Cas Creation ou lignes on ne filtre pas sur cav

      --      IF (p_mode = 'insert' AND p_test = 'contrat') THEN
      IF (p_mode = 'insert' AND p_test = 'contrat') THEN

	 -- Attention ordre des colonnes doit correspondre a l ordre
         -- de declaration dans la table ORACLE (a cause de ROWTYPE)
         -- ou selectionner toutes les colonnes par *

         BEGIN
            OPEN p_curcont FOR
               SELECT soccont,
                      soc.soclib,
                      numcont,
                      cav,
                      cagrement,
                      to_char(niche),
                      cnaffair,
                      crang,
                      to_char(cdatarr,'dd/mm/yyyy'),
                      cobjet1,
                      cobjet2,
                      crem,
                      to_char(codsg, 'FM0000000'),
                      comcode,
                      ctypfact,
                      to_char(ccoutht,'FM9999999999D00'),
                      to_char(ccharesti,'FM9999D0'),
                      to_char(cdatdeb,'dd/mm/yyyy'),
                      to_char(cdatfin,'dd/mm/yyyy'),
                      to_char(contrat.flaglock)
--,to_char(contrat.ccentrefrais)
              FROM    contrat, societe soc
              WHERE   contrat.soccont = p_soccont
              AND     soc.soccode = p_soccont
              AND     filcode = l_filcode
              AND     numcont = p_numcont;

         EXCEPTION
            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
         END;

      -- Cas ou l'on veut créer un avenant
      -- On doit tester que le contrat existe
      -- On doit renvoyer un curseur vide
      -- Pbl.: car en creation un curseur avec une ligne declanche l'affichage du message "entite deja existante"
      -- Sol.: il faut tester que le contrat existe et renvoyer un curseur bidon avec zero ligne.

      ELSIF (p_mode = 'insert' AND p_test = 'avenant') THEN

         -- Test de l'existance d'un contrat dans la table contrat et histo_contrat

         BEGIN

            SELECT soccont
            INTO   l_soccont
            FROM   contrat
            WHERE  soccont = p_soccont
            AND    filcode = l_filcode
            AND    numcont = p_numcont
            AND    rownum < 2;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN

	      BEGIN
	      SELECT   soccont
		INTO   l_soccont
		FROM   histo_contrat
		WHERE  soccont = p_soccont
		AND    filcode = l_filcode
		AND    numcont = p_numcont
		AND    rownum < 2;

	      EXCEPTION
		 WHEN NO_DATA_FOUND THEN
		   -- Erreur message "Contrat inexistant"

		   pack_global.recuperer_message(20280, NULL, NULL, NULL, l_msg);
		   raise_application_error(-20280,l_msg);
	      END;

            WHEN OTHERS THEN
                raise_application_error(-20997,SQLERRM);

         END;

         -- La c'est, la super ouverture de curseur de la mort qui tue
         -- et qui retourne rien pour faire plaisir a HTML, overthetop

         BEGIN
            OPEN p_curcont FOR
               SELECT soccont                           ,
                      soc.soclib                        ,
                      numcont                           ,
                      cav                               ,
                      cagrement                         ,
                      to_char(niche)                    ,
                      cnaffair                          ,
                      crang                             ,
                      to_char(cdatarr,'dd/mm/yyyy')     ,
                      cobjet1                           ,
                      cobjet2                           ,
                      crem                              ,
                      to_char(codsg, 'FM0000000')       ,
                      comcode                           ,
                      ctypfact                          ,
                      to_char(ccoutht,'FM9999999999D00'),
                      to_char(ccharesti,'FM9999D0')     ,
                      to_char(cdatdeb,'dd/mm/yyyy')     ,
                      to_char(cdatfin,'dd/mm/yyyy')     ,
                      to_char(contrat.flaglock)
--,to_char(contrat.ccentrefrais)
              FROM    contrat, societe soc
              WHERE   contrat.soccont is NULL
              AND     soc.soccode is NULL;

         EXCEPTION
            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
         END;

      ELSE

	 -- Cas modification ou suppression on filtre sur cav
	 -- modif. + cas lignes


	-- Contrôler que le contrat appartient au centre de frais de l'utilisateur
	 -- On récupère le code centre de frais de l'utilisateur
	l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

        BEGIN
		select numcont, ccentrefrais
		into l_numcont, l_ccentrefrais
		from contrat
        	where  	numcont = p_numcont
	 	and	soccont = p_soccont
         	and    cav     = p_cav
		and    filcode = l_filcode;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN 	--Le contrat n'existe pas
			 IF p_test = 'contrat' THEN
	 			pack_global.recuperer_message(2086, NULL, NULL, NULL, l_msg);
      			ELSE
	 			pack_global.recuperer_message(2092, NULL, NULL, NULL, l_msg);
      			END IF;

		WHEN OTHERS THEN
               		raise_application_error(-20997,SQLERRM);

	END;
        IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
        	IF (l_ccentrefrais is null  and l_numcont is not null ) then
		-- Ce contrat n'est rattaché à aucun centre de frais
			pack_global.recuperer_message(20336,NULL,NULL,NULL, l_msg);
         	 	raise_application_error(-20336, l_msg);
		END IF;

  		IF l_ccentrefrais!=l_centre_frais then
		--Le contrat n'existe pas dans le centre de frais mais dans le centre %s2
		 pack_global.recuperer_message(20335, '%s1',to_char(l_centre_frais),'%s2',to_char(l_ccentrefrais),NULL, l_msg);
         	raise_application_error(-20335, l_msg);
		END IF;
	END IF;

         BEGIN
            OPEN p_curcont FOR
               SELECT soccont                           ,
                      soc.soclib                        ,
                      numcont                           ,
                      cav                               ,
                      cagrement                         ,
                      to_char(niche)                    ,
                      cnaffair                          ,
                      crang                             ,
                      to_char(cdatarr,'dd/mm/yyyy')     ,
                      cobjet1                           ,
                      cobjet2                           ,
                      crem                              ,
                      to_char(codsg, 'FM0000000')       ,
                      comcode                           ,
                      ctypfact                          ,
                      to_char(ccoutht,'FM9999999999D00'),
                      to_char(ccharesti,'FM9999D0')     ,
                      to_char(cdatdeb,'dd/mm/yyyy')     ,
                      to_char(cdatfin,'dd/mm/yyyy')     ,
                      to_char(contrat.flaglock)
              FROM    contrat, societe soc
              WHERE   contrat.soccont = p_soccont
              AND     soc.soccode = p_soccont
              AND     filcode = l_filcode
              AND     numcont = p_numcont
              AND     cav     = p_cav;


          EXCEPTION
            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
         END;
      END IF;


      -- en cas absence
      -- p_message := "Le contrat n'existe pas";
      p_message := l_msg;

   END select_contrat;

END pack_contrat;
/
CREATE OR REPLACE PACKAGE pack_conversion AS

   FUNCTION unescape( p_chaine IN VARCHAR2) RETURN VARCHAR2 ;

   FUNCTION Base10_To_BaseB( p_nombre IN INTEGER, p_base IN INTEGER ) RETURN VARCHAR2 ;

   FUNCTION BaseB_To_Base10( p_nombre IN VARCHAR2, p_base IN INTEGER ) RETURN INTEGER ;
   --
   --    WNDS   means "writes no database state" (does not modify database tables).
   --
   --    WNPS   means "writes no package state" (does not change the values of packaged variables).
   --
   --    RNDS   means "reads no database state" (does not query database tables).
   --
   --    RNPS   means "reads no package state" (does not reference the values of packaged variables).
   --
   PRAGMA RESTRICT_REFERENCES (Base10_To_BaseB, WNDS, WNPS, RNDS, RNPS);
   PRAGMA RESTRICT_REFERENCES (BaseB_To_Base10, WNDS, WNPS, RNDS, RNPS);

END pack_conversion ;
/

CREATE OR REPLACE PACKAGE BODY pack_conversion AS

-------------------------------------------------------------------
--
------------------------------------------------------------------

   FUNCTION unescape( p_chaine IN VARCHAR2) RETURN VARCHAR2 IS

      l_pos     integer;
	l_chaine  varchar2(2000);
	l_rep     varchar2(10);
	l_by      char(1);
   BEGIN
	l_chaine := REPLACE( p_chaine, '+', ' ');

	l_pos    := INSTR( p_chaine, '%', 1, 1);
	WHILE l_pos > 0 LOOP
	   l_rep    := SUBSTR( l_chaine, l_pos, 3);
	   l_by     := CHR( pack_conversion.BaseB_To_Base10( SUBSTR( l_chaine, l_pos+1, 2) , 16) );
	   l_chaine := REPLACE(	l_chaine, l_rep, l_by );
	   l_pos    := INSTR( l_chaine, '%', 1, 1);
	END LOOP;

	RETURN l_chaine;

   END unescape;


-------------------------------------------------------------------
--
------------------------------------------------------------------
   FUNCTION Base10_To_BaseB( p_nombre IN INTEGER, p_base IN INTEGER ) RETURN VARCHAR2 IS

	i		binary_integer;
	quotient	integer;
	reste		integer;
	val		varchar2(100);
	base36	constant char(36) := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
   BEGIN
	quotient := p_nombre;
	WHILE (quotient >= p_base) LOOP
	   reste    := MOD(quotient,p_base);
	   quotient := FLOOR(quotient/p_base);
	   val      := SUBSTR( base36, reste + 1,1 ) || val ;
	END LOOP;

	val := SUBSTR( base36, quotient + 1,1 ) || val ;

	RETURN val;

   END Base10_To_BaseB;


-------------------------------------------------------------------
--
------------------------------------------------------------------
   FUNCTION BaseB_To_Base10( p_nombre IN VARCHAR2, p_base IN INTEGER ) RETURN INTEGER IS

	i        integer;
	N	   constant integer := LENGTH(p_nombre);
	chiffre  char;
	num      integer := 0;
	base36   constant char(36) := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
   BEGIN
	FOR i IN 1..N LOOP
	   chiffre := SUBSTR(p_nombre, i, 1);
	   num     := num + POWER(p_base,N-i) * (INSTR(base36,chiffre,1) - 1) ;
	END LOOP;

	RETURN num ;

   END BaseB_To_Base10;



-------------------------------------------------------------------
--
------------------------------------------------------------------


END pack_conversion ;
/
CREATE OR REPLACE PACKAGE Pack_Cout_Prestation AS

TYPE cout_prestation_Type IS RECORD (   CODPREST       		 PRESTATION.PRESTATION%TYPE,
						  	 												   			LIBPREST    			PRESTATION.libprest%TYPE,
                                        												CODE_DOMAINE  PRESTATION.code_domaine%TYPE,
																						CODE_ACHA          PRESTATION.code_acha%TYPE,
																						RTYPE                      PRESTATION.rtype%TYPE,
																						TOP_ACTIF             PRESTATION.top_actif%TYPE,
																						FLAGLOCK              PRESTATION.flaglock%TYPE
																						);


   TYPE cout_prestationCurType IS REF CURSOR RETURN cout_prestation_type;

   PROCEDURE insert_cout_prestation (
                                       				  							p_codprest   			 IN  CHAR,
                                       											p_libprest     				IN  VARCHAR2,
                                       											p_code_domaine   IN  VARCHAR2,
									   											p_code_acha 	  	  IN  VARCHAR2,
									   											p_rtype 			      	  IN  VARCHAR2,
                                       											p_top_actif                 IN  CHAR,
                                       											p_userid                     IN  VARCHAR2,
                                       											p_nbcurseur             OUT INTEGER,
                                       											p_message              OUT VARCHAR2
                                     );

   PROCEDURE update_cout_prestation (
   			 						 		 		   		 	   		  		p_codprest   			 IN  CHAR,
                                       											p_libprest     				IN  VARCHAR2,
                                       											p_code_domaine   IN  VARCHAR2,
									   											p_code_acha 	  	  IN  VARCHAR2,
									   											p_rtype 			      	   IN  VARCHAR2,
                                       											p_top_actif                 IN  CHAR,
																				p_flaglock                  IN  NUMBER,
                                       											p_userid                     IN  VARCHAR2,
																				p_nbcurseur             OUT INTEGER,
                                       											p_message              OUT VARCHAR2
                                    );

   PROCEDURE delete_cout_prestation (
                                     p_codprest   IN  CHAR,
                                     p_flaglock   IN  NUMBER,
                                     p_userid     IN  VARCHAR2,
                                     p_nbcurseur  OUT INTEGER,
                                     p_message    OUT VARCHAR2
                                    );

   PROCEDURE select_cout_prestation (
                                     p_codprest           IN CHAR,
                                     p_userid             IN VARCHAR2,
                                     p_curcout_prestation IN OUT cout_prestationCurType,
                                     p_nbcurseur          OUT INTEGER,
                                     p_message            OUT VARCHAR2
                                    );

END Pack_Cout_Prestation;
/

CREATE OR REPLACE PACKAGE BODY Pack_Cout_Prestation AS

    PROCEDURE insert_cout_prestation (
                                       				  							p_codprest   			 IN  CHAR,
                                       											p_libprest     				IN  VARCHAR2,
                                       											p_code_domaine   IN  VARCHAR2,
									   											p_code_acha 	  	  IN  VARCHAR2,
									   											p_rtype 			      	  IN  VARCHAR2,
                                       											p_top_actif                 IN  CHAR,
                                       											p_userid                     IN  VARCHAR2,
                                       											p_nbcurseur             OUT INTEGER,
                                       											p_message              OUT VARCHAR2
                                     ) IS
     l_msg VARCHAR2(1024);
     l_cod VARCHAR2(10);

	 l_codacha NUMBER;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


	  SELECT COUNT(*) INTO l_codacha
	                    FROM PRESTATION
                        WHERE UPPER(code_acha)=UPPER(p_code_acha)
						AND TOP_ACTIF='O';

		-- En cas de l'existence du code d'acha
		IF(l_codacha<>0)THEN

                    Pack_Global.recuperer_message( 21043, '%s1', p_code_acha, NULL, l_msg);
                 	RAISE_APPLICATION_ERROR( -20001, l_msg );

		END IF;

      BEGIN
         INSERT INTO PRESTATION (     PRESTATION,
         				                                                   libprest,
																		   code_domaine,
																		   code_acha,
																		   rtype,
                                    									   top_actif
                                    							   )
         VALUES (p_codprest,
         	                 p_libprest,
                             p_code_domaine,
							 p_code_acha,
							 p_rtype,
                             p_top_actif
                            );

          --'La prestation ' || p_codprest || ' de l'année '
          --|| p_anneeprest || ' a été créé.';

         Pack_Global.recuperer_message(20375, '%s1',p_codprest,NULL, l_msg);
         p_message := l_msg;

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN
            Pack_Global.recuperer_message(20001, NULL, NULL, NULL, l_msg);
            RAISE_APPLICATION_ERROR( -20001, l_msg );

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM );

      END;

   END insert_cout_prestation;


   PROCEDURE update_cout_prestation (
   			 						 		 		   		 	   		  		p_codprest   			 IN  CHAR,
                                       											p_libprest     				IN  VARCHAR2,
                                       											p_code_domaine   IN  VARCHAR2,
									   											p_code_acha 	  	  IN  VARCHAR2,
									   											p_rtype 			      	   IN  VARCHAR2,
                                       											p_top_actif                 IN  CHAR,
																				p_flaglock                  IN  NUMBER,
                                       											p_userid                     IN  VARCHAR2,
																				p_nbcurseur             OUT INTEGER,
                                       											p_message              OUT VARCHAR2
                                    ) IS
     l_msg VARCHAR2(1024);
     l_cod VARCHAR2(10);

	 l_codacha NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

	  SELECT COUNT(*) INTO l_codacha
	                    FROM PRESTATION
                        WHERE PRESTATION<>p_codprest
						AND UPPER(code_acha)=UPPER(p_code_acha)
						AND TOP_ACTIF='O';

		-- En cas de l'existence du code d'acha
		IF(l_codacha<>0)THEN

                    Pack_Global.recuperer_message( 21043, '%s1', p_code_acha, NULL, l_msg);
                 	RAISE_APPLICATION_ERROR( -20001, l_msg );

		END IF;

      BEGIN
          UPDATE PRESTATION SET libprest = p_libprest,
          			                                                  code_domaine = p_code_domaine,
																	  code_acha = p_code_acha,
																	  rtype = p_rtype,
          			                                                  top_actif=p_top_actif,
                                                                      flaglock = DECODE( p_flaglock, 1000000,0, p_flaglock + 1)
          WHERE PRESTATION = p_codprest
              AND flaglock = p_flaglock;

      EXCEPTION
          WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997,SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
      -- accès concurrent
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      ELSE
      -- prestation modifiée
         Pack_Global.recuperer_message(20376, '%s1', p_codprest, NULL, l_msg);
 	   p_message := l_msg;
      END IF;

   END update_cout_prestation;


   PROCEDURE delete_cout_prestation (
                                     p_codprest   IN  CHAR,
                                     p_flaglock   IN  NUMBER,
                                     p_userid     IN  VARCHAR2,
                                     p_nbcurseur  OUT INTEGER,
                                     p_message    OUT VARCHAR2
                                    ) IS

      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
    BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN

         DELETE FROM PRESTATION
                WHERE PRESTATION = p_codprest
                    AND flaglock = p_flaglock;

      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            Pack_Global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      ELSE
         Pack_Global.recuperer_message(20377, '%s1',p_codprest, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END delete_cout_prestation;


   PROCEDURE select_cout_prestation (
	                                 p_codprest           IN CHAR,
                                     p_userid             IN VARCHAR2,
                                     p_curcout_prestation IN OUT cout_prestationCurType,
                                     p_nbcurseur          OUT INTEGER,
                                     p_message            OUT VARCHAR2
                                    ) IS

      l_msg VARCHAR2(1024);
      l_date_courante VARCHAR2(10);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';


      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curcout_prestation FOR
              SELECT PRESTATION,
              		            libprest,
                                code_domaine,
								code_acha,
								rtype,
                                top_actif,
                                flaglock
              FROM PRESTATION
              WHERE PRESTATION = p_codprest;

      EXCEPTION
         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20997, SQLERRM);

      END;

      -- en cas absence
      -- p_message := 'La prestation n'existe pas';

      Pack_Global.recuperer_message(2003, '%s1', p_codprest, '%s2', NULL, NULL, l_msg);
      p_message := l_msg;

   END select_cout_prestation;
END Pack_Cout_Prestation;
/
CREATE OR REPLACE PACKAGE pack_cout_standard AS

TYPE cout_Type IS RECORD ( 	annee varchar2(4),
						 dpg_bas varchar2(7),
						 dpg_haut varchar2(7),
                		 cout_log varchar2(7),
						 coutenv_sg varchar2(7),
						 coutenv_ssii varchar2(7),
			             FLAGLOCK   cout_std_sg.flaglock%TYPE
                  );
TYPE coutCurType IS REF CURSOR RETURN cout_Type;

TYPE cout_sg_Type IS RECORD ( 	annee varchar2(4),
					dpg_bas varchar2(7),
					dpg_haut varchar2(7),
                				me varchar2(7),
		 			mo varchar2(7),
		 			hom varchar2(7),
		 			gap varchar2(7),
					niveau varchar2(2),
		 			longueur number(1),
			                        FLAGLOCK   cout_std_sg.flaglock%TYPE
                  );

      TYPE coutSgCurType IS REF CURSOR RETURN cout_sg_Type;

PROCEDURE insert_cout_standard(
		p_couann    	IN  VARCHAR2,
                       p_codsg_bas 	IN  VARCHAR2,
		p_codsg_haut  IN  VARCHAR2,
		p_chaine	 IN  VARCHAR2,
		p_choix	IN  VARCHAR2,
		p_coulog	IN  VARCHAR2,
		p_coutenv_sg	IN  VARCHAR2,
		p_coutenv_ssii	IN  VARCHAR2,
  		p_nbcurseur 	OUT INTEGER,
                       p_message   	OUT VARCHAR2
);
PROCEDURE update_cout_standard (
			p_couann    	IN  VARCHAR2,
			p_codsg_bas_old IN  VARCHAR2,
		       	p_codsg_bas_new IN  VARCHAR2,
		       	p_codsg_haut 	IN  VARCHAR2,
                       	p_chaine	 IN  VARCHAR2,
			p_choix	IN  VARCHAR2,
			p_coulog	IN  VARCHAR2,
			p_coutenv_sg	IN  VARCHAR2,
			p_coutenv_ssii	IN  VARCHAR2,
                       	p_flaglock  	IN  NUMBER,
                       	p_userid    	IN  VARCHAR2,
                       	p_nbcurseur 	OUT INTEGER,
                       	p_message   	OUT VARCHAR2
                      );

PROCEDURE delete_cout_standard (p_couann    IN  VARCHAR2,
				p_codsg_bas IN  VARCHAR2,
                       		p_flaglock  IN  NUMBER,
				p_choix	IN  VARCHAR2,
                       		p_userid    IN  VARCHAR2,
                       		p_nbcurseur OUT INTEGER,
                       		p_message   OUT VARCHAR2
                      );

PROCEDURE select_cout_standard (p_couann    IN VARCHAR2,
		       		p_codsg_bas IN VARCHAR2,
                       		p_userid    IN VARCHAR2,
                       		p_curcout   IN OUT coutCurType,
                       		p_nbcurseur OUT INTEGER,
                       		p_message   OUT VARCHAR2
                      );

PROCEDURE select_cout_standard_sg (p_couann    IN VARCHAR2,
		       		p_codsg_bas IN VARCHAR2,
                       		p_userid    IN VARCHAR2,
                       		p_curcout   IN OUT coutSgCurType,
                       		p_nbcurseur    OUT INTEGER,
                       		p_message      OUT VARCHAR2
                      ) ;

PROCEDURE controle_cout_standard (	p_couann    IN VARCHAR2,
                       		  		p_userid    IN VARCHAR2,
                     		 			p_message   OUT VARCHAR2
                      );
PROCEDURE controle_cout_standard_sg (p_couann    IN  VARCHAR2,
                       		 		p_userid    IN  VARCHAR2,
                       		 		p_message   OUT VARCHAR2);

FUNCTION get_coutstandard_sg (p_anneestd   	 IN VARCHAR2,
						p_dpg_bas      IN VARCHAR2,
						p_niveau  	IN VARCHAR2,
						p_metier  	IN VARCHAR2)

RETURN NUMBER;
END pack_cout_standard;
/

CREATE OR REPLACE PACKAGE BODY pack_cout_standard AS
PROCEDURE insert_cout_standard(
		p_couann    	IN  VARCHAR2,
                       p_codsg_bas 	IN  VARCHAR2,
		p_codsg_haut  IN  VARCHAR2,
		p_chaine	 IN  VARCHAR2,
		p_choix	IN  VARCHAR2,
		p_coulog	IN  VARCHAR2,
		p_coutenv_sg	IN  VARCHAR2,
		p_coutenv_ssii	IN  VARCHAR2,
  		p_nbcurseur 	OUT INTEGER,
                       p_message   	OUT VARCHAR2
)  IS
l_length NUMBER(10);
l_pos NUMBER(10);
l_ligne VARCHAR2(50);
l_chaine VARCHAR2(5000);
l_egal NUMBER(10);
l_lib VARCHAR2(50);
l_cout VARCHAR2(50);
l_niveau COUT_STD_SG.niveau%TYPE;
l_metier COUT_STD_SG.metier%TYPE;
l_underscore NUMBER(10);
l_exist NUMBER(1);
BEGIN
	l_length := LENGTH(p_chaine);
	l_chaine:=p_chaine;

	if (p_choix='SG') then
	  --Tester si le DPG BAS existe déjà
	Begin
		select 1 into l_exist
		from  COUT_STD_SG
		where annee = to_number(p_couann)
		and dpg_bas = to_number(p_codsg_bas)
		and rownum<=1;

		if (l_exist=1) then
			--Message d'erreur : Le codsg bas existe déjà
			pack_global.recuperer_message(20370, NULL, NULL, NULL, p_message);
           		raise_application_error( -20370, p_message );
		end if;
		Exception
			When no_data_found then
				null;

	End;

             WHILE  l_chaine is not null LOOP

               	 l_pos := INSTR(l_chaine,';',1);
		--dbms_output.put_line('  l_pos:'||  l_pos);
	   	 l_ligne :=SUBSTR(l_chaine,1,l_pos-1);
		--position du =
		 l_egal := INSTR(l_ligne,'=',1);
		l_lib := SUBSTR(l_ligne,1,l_egal-1);
		--dbms_output.put_line(' l_lib:'|| l_lib);
		--récupérer le niveau et le métier
		l_underscore := INSTR(l_lib,'_',1);
		l_niveau := SUBSTR(l_lib,1,l_underscore-1);
		l_metier := SUBSTR(l_lib, l_underscore+1,l_length-l_underscore);
		dbms_output.put_line('l_niveau:'||l_niveau);
		dbms_output.put_line('l_metier:'||l_metier);

		l_cout := SUBSTR(l_ligne, l_egal+1,l_length-l_egal);
		dbms_output.put_line(' l_cout:'|| l_cout);
		--dbms_output.put_line(' l_ligne:'|| l_ligne);
	  	l_chaine :=SUBSTR(l_chaine, l_pos+1,l_length-l_pos);
		--dbms_output.put_line(' l_chaine:'||  l_chaine);
		--Insertion de chaque ligne dans la table COUT_STD_SG

			insert into COUT_STD_SG (annee, niveau, metier, dpg_haut, dpg_bas, cout_sg, flaglock)
			values (to_number(p_couann),
				upper(l_niveau),
				upper(l_metier),
				to_number(p_codsg_haut),
				to_number(p_codsg_bas),
				to_number(l_cout),
				0);

			IF upper(l_metier)='GAP' THEN
				insert into COUT_STD_SG (annee, niveau, metier, dpg_haut, dpg_bas, cout_sg, flaglock)
				values (to_number(p_couann),
					upper(l_niveau),
					'EXP',
					to_number(p_codsg_haut),
					to_number(p_codsg_bas),
					to_number(l_cout),
					0);
				insert into COUT_STD_SG (annee, niveau, metier, dpg_haut, dpg_bas, cout_sg, flaglock)
				values (to_number(p_couann),
					upper(l_niveau),
					'SAU',
					to_number(p_codsg_haut),
					to_number(p_codsg_bas),
					to_number(l_cout),
					0);
				insert into COUT_STD_SG (annee, niveau, metier, dpg_haut, dpg_bas, cout_sg, flaglock)
				values (to_number(p_couann),
					upper(l_niveau),
					'FOR',
					to_number(p_codsg_haut),
					to_number(p_codsg_bas),
					to_number(l_cout),
					0);
			END IF;


	  END LOOP;
	else
			--Tester si le DPG BAS existe déjà
		Begin
			select 1 into l_exist
			from  COUT_STD2
			where annee = to_number(p_couann)
			and dpg_bas = to_number(p_codsg_bas)
			and rownum<=1;

			if (l_exist=1) then
			--Message d'erreur : Le codsg bas existe déjà
			pack_global.recuperer_message(20370, NULL, NULL, NULL, p_message);
           		raise_application_error( -20370, p_message );
			end if;
		Exception
			When no_data_found then
				null;

		End;


			insert into COUT_STD2 (annee,cout_log,coutenv_sg,coutenv_ssii, dpg_haut, dpg_bas,  flaglock)
			values (to_number(p_couann),
				to_number(p_coulog),
				to_number(p_coutenv_sg),
				to_number(p_coutenv_ssii),
				to_number(p_codsg_haut),
				to_number(p_codsg_bas),
				0);

	end if;
  	 -- 'Coût Standard ' || p_couann ||  ' a été créé.';
         	pack_global.recuperer_message(2016, '%s1', p_couann, NULL, p_message);

	EXCEPTION
         			WHEN DUP_VAL_ON_INDEX THEN
				rollback;
				pack_global.recuperer_message(20370, NULL, NULL, NULL, p_message);
           			raise_application_error( -20370, p_message );

         			WHEN OTHERS THEN
				rollback;
				raise_application_error( -20997, SQLERRM );




END insert_cout_standard;


PROCEDURE update_cout_standard (p_couann    	IN  VARCHAR2,
		       		p_codsg_bas_old IN  VARCHAR2,
		       		p_codsg_bas_new IN  VARCHAR2,
		      		p_codsg_haut 	IN  VARCHAR2,
		       		p_chaine	 IN  VARCHAR2,
				p_choix	IN  VARCHAR2,
				p_coulog	IN  VARCHAR2,
				p_coutenv_sg	IN  VARCHAR2,
				p_coutenv_ssii	IN  VARCHAR2,
	                       		p_flaglock  	IN  NUMBER,
                       		p_userid    	IN  VARCHAR2,
                       		p_nbcurseur 	OUT INTEGER,
                       		p_message   	OUT VARCHAR2
                      ) IS

     l_msg VARCHAR(1024);
l_length NUMBER(10);
l_pos NUMBER(10);
l_ligne VARCHAR2(50);
l_chaine VARCHAR2(5000);
l_egal NUMBER(10);
l_lib VARCHAR2(50);
l_cout VARCHAR2(50);
l_niveau COUT_STD_SG.niveau%TYPE;
l_metier COUT_STD_SG.metier%TYPE;
l_underscore NUMBER(10);
l_exist NUMBER(1);
BEGIN
	l_length := LENGTH(p_chaine);
	l_chaine:=p_chaine;

    -- Positionner le nb de curseurs ==> 0
   -- Initialiser le message retour
   p_nbcurseur := 0;
   p_message   := '';
          --Tester si le DPG BAS existe déjà
	 if (p_codsg_bas_old!=p_codsg_bas_new) then
	  Begin

		select 1 into l_exist
		from  COUT_STD_SG
		where annee = to_number(p_couann)
		and dpg_bas = to_number(p_codsg_bas_new)
		and rownum<=1;

		if (l_exist=1) then
			--Message d'erreur : Le codsg bas existe déjà
			pack_global.recuperer_message(20370, NULL, NULL, NULL, p_message);
           		raise_application_error( -20370, p_message );
		end if;
		Exception
			When no_data_found then
				null;

	  End;
	end if;
         If (p_choix='SG') then
     	WHILE  l_chaine is not null LOOP

               	 l_pos := INSTR(l_chaine,';',1);
		--dbms_output.put_line('  l_pos:'||  l_pos);
	   	 l_ligne :=SUBSTR(l_chaine,1,l_pos-1);
		--position du =
		 l_egal := INSTR(l_ligne,'=',1);
		l_lib := SUBSTR(l_ligne,1,l_egal-1);
		--dbms_output.put_line(' l_lib:'|| l_lib);
		--récupérer le niveau et le métier
		l_underscore := INSTR(l_lib,'_',1);
		l_niveau := SUBSTR(l_lib,1,l_underscore-1);
		l_metier := SUBSTR(l_lib, l_underscore+1,l_length-l_underscore);
		l_metier := upper(l_metier);
		dbms_output.put_line('l_niveau:'||l_niveau);
		dbms_output.put_line('l_metier:'||l_metier);

		l_cout := SUBSTR(l_ligne, l_egal+1,l_length-l_egal);
		dbms_output.put_line(' l_cout:'|| l_cout);
		--dbms_output.put_line(' l_ligne:'|| l_ligne);
	  	l_chaine :=SUBSTR(l_chaine, l_pos+1,l_length-l_pos);
		--dbms_output.put_line(' l_chaine:'||  l_chaine);
		--modification de chaque ligne de la table COUT_STD_SG
		BEGIN
			UPDATE COUT_STD_SG SET
		      		dpg_bas  = TO_NUMBER(p_codsg_bas_new),
		     		dpg_haut = TO_NUMBER(p_codsg_haut),
				cout_sg = l_cout,
				flaglock   = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
			WHERE annee = TO_NUMBER(p_couann)
			AND dpg_bas = TO_NUMBER(p_codsg_bas_old)
      			and flaglock = p_flaglock
			and niveau = upper(l_niveau)
			and metier = upper(l_metier);


		 IF SQL%NOTFOUND THEN
        			pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         			raise_application_error( -20999, l_msg );
      		ELSE
         			pack_global.recuperer_message(2017, '%s1', p_couann, NULL, l_msg);
 	  		p_message := l_msg;
      		END IF;

		IF upper(l_metier)='GAP' THEN
			UPDATE COUT_STD_SG SET
		      		dpg_bas  = TO_NUMBER(p_codsg_bas_new),
		     		dpg_haut = TO_NUMBER(p_codsg_haut),
				cout_sg = l_cout,
				flaglock   = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
			WHERE annee = TO_NUMBER(p_couann)
			AND dpg_bas = TO_NUMBER(p_codsg_bas_old)
			and niveau = upper(l_niveau)
			and ( metier = 'EXP' or metier = 'SAU' or metier = 'FOR' ) ;

			 IF SQL%NOTFOUND THEN
        			pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         			raise_application_error( -20999, l_msg );
      			 ELSE
         			pack_global.recuperer_message(2017, '%s1', p_couann, NULL, l_msg);
 	  			p_message := l_msg;
      			 END IF;
		END IF;



         		 EXCEPTION
         			WHEN OTHERS THEN
				rollback;
           			 raise_application_error( -20997, SQLERRM );

		END;


	  END LOOP;
	else --Cas autre

		UPDATE COUT_STD2 SET
		      		dpg_bas  = TO_NUMBER(p_codsg_bas_new),
		     		dpg_haut = TO_NUMBER(p_codsg_haut),
				cout_log = TO_NUMBER(p_coulog),
				coutenv_sg= TO_NUMBER(p_coutenv_sg),
				coutenv_ssii= TO_NUMBER(p_coutenv_ssii),
				flaglock   = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
			WHERE annee = TO_NUMBER(p_couann)
			AND dpg_bas = TO_NUMBER(p_codsg_bas_old)
      			and flaglock = p_flaglock ;


		 IF SQL%NOTFOUND THEN
        			pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         			raise_application_error( -20999, l_msg );
      		ELSE
         			pack_global.recuperer_message(2017, '%s1', p_couann, NULL, l_msg);
 	  		p_message := l_msg;
      		END IF;



	end if;

	commit;

  END update_cout_standard;


   PROCEDURE delete_cout_standard (p_couann    IN  VARCHAR2,
			  	   p_codsg_bas IN  VARCHAR2,
                       		   p_flaglock  IN  NUMBER,
				   p_choix	IN  VARCHAR2,
                       		   p_userid    IN  VARCHAR2,
                       		   p_nbcurseur OUT INTEGER,
                       		   p_message   OUT VARCHAR2
                         ) IS

      l_msg VARCHAR(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

    BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
	if (p_choix='SG') then
         		DELETE FROM cout_std_sg
        		 WHERE annee = TO_NUMBER(p_couann)
			and dpg_bas = to_number(p_codsg_bas);

	else
		DELETE FROM cout_std2
        		 WHERE annee  = TO_NUMBER(p_couann)
			and dpg_bas = to_number(p_codsg_bas);


	end if;
      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM );
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2018, '%s1', p_couann, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END delete_cout_standard;

PROCEDURE select_cout_standard (p_couann    IN VARCHAR2,
		       		p_codsg_bas IN VARCHAR2,
                       		p_userid    IN VARCHAR2,
                       		p_curcout   IN OUT coutCurType,
                       		p_nbcurseur    OUT INTEGER,
                       		p_message      OUT VARCHAR2
                      ) IS

     l_msg VARCHAR(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- TEST p_couann > 1900 et < 3000


      IF TO_NUMBER(p_couann) < 1900 OR TO_NUMBER(p_couann) > 3000 THEN
         pack_global.recuperer_message(20242, NULL, NULL, NULL, l_msg);
         raise_application_error( -20242, l_msg);
      END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curcout FOR

            select
		 to_char(annee),
		to_char(dpg_bas,'FM0000000'),
		to_char(dpg_haut,'FM0000000'),
		to_char(cout_log,'FM9999D00'),
		to_char(coutenv_sg,'FM9999D00'),
		to_char(coutenv_ssii,'FM9999D00'),
		flaglock
	from cout_std2
	where annee = to_number(p_couann)
	and dpg_bas = to_number(p_codsg_bas);


      EXCEPTION

         WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM );
      END;

      -- en cas absence
      -- p_message := 'Le cout n'existe pas';

         pack_global.recuperer_message(2019, '%s1', p_couann, NULL, l_msg);
         p_message := l_msg;

   END select_cout_standard;

PROCEDURE select_cout_standard_sg (p_couann    IN VARCHAR2,
		       		p_codsg_bas IN VARCHAR2,
                       		p_userid    IN VARCHAR2,
                       		p_curcout   IN OUT coutSgCurType,
                       		p_nbcurseur    OUT INTEGER,
                       		p_message      OUT VARCHAR2
                      ) IS

     l_msg VARCHAR(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- TEST p_couann > 1900 et < 3000


      IF TO_NUMBER(p_couann) < 1900 OR TO_NUMBER(p_couann) > 3000 THEN
         pack_global.recuperer_message(20242, NULL, NULL, NULL, l_msg);
         raise_application_error( -20242, l_msg);
      END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curcout FOR

            select distinct
		 to_char(annee),
		to_char(dpg_bas,'FM0000000'),
		to_char(dpg_haut,'FM0000000'),
		to_char(get_coutstandard_sg (p_couann ,p_codsg_bas,niveau,'ME'),'FM9999D00')  me,
		to_char(get_coutstandard_sg (p_couann ,p_codsg_bas,niveau,'MO'),'FM9999D00')  mo,
		to_char(get_coutstandard_sg (p_couann ,p_codsg_bas,niveau,'HOM'),'FM9999D00') hom,
		to_char(get_coutstandard_sg (p_couann ,p_codsg_bas,niveau,'GAP'),'FM9999D00') gap,
		niveau,
		length(niveau) longueur,
		flaglock
	from cout_std_sg
	where annee = to_number(p_couann)
	and dpg_bas = to_number(p_codsg_bas)
	order by length(niveau),niveau	;

      EXCEPTION

         WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM );
      END;

      -- en cas absence
      -- p_message := 'Le cout n'existe pas';

         pack_global.recuperer_message(2019, '%s1', p_couann, NULL, l_msg);
         p_message := l_msg;

   END select_cout_standard_sg;



PROCEDURE controle_cout_standard (	p_couann    IN  VARCHAR2,
                       		 		p_userid    IN  VARCHAR2,
                       		 		p_message   OUT VARCHAR2
                      ) IS

     l_msg VARCHAR(1024);
     dpg_bas_old cout_std2.dpg_bas%TYPE;
     dpg_haut_old cout_std2.dpg_haut%TYPE;

     dpg_bas_first cout_std2.dpg_bas%TYPE;
     flag_dpg_max number(1);


     CURSOR curs_coutstd IS
     SELECT annee couann,
	    dpg_bas codsg_bas,
	    dpg_haut codsg_haut
     FROM cout_std2
     WHERE annee = TO_NUMBER(p_couann)
     order by 1,2,3;

     curs_coutstd_enreg curs_coutstd%ROWTYPE;

   BEGIN

      -- Initialiser le message retour et flag
	    p_message := ' ';
	    flag_dpg_max := 0;
      -- TEST p_couann > 1900 et < 3000



      IF TO_NUMBER(p_couann) < 1900 OR TO_NUMBER(p_couann) > 3000 THEN
         pack_global.recuperer_message(20242, NULL, NULL, NULL, l_msg);
         raise_application_error( -20242, l_msg);
      END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

	   BEGIN

	  OPEN curs_coutstd;

	  FETCH curs_coutstd INTO curs_coutstd_enreg;

	  IF curs_coutstd%FOUND THEN
		dpg_bas_first := curs_coutstd_enreg.codsg_bas;

	  	dpg_bas_old := curs_coutstd_enreg.codsg_bas;
	  	dpg_haut_old := curs_coutstd_enreg.codsg_haut;
		if(dpg_haut_old = 9999999) then flag_dpg_max := 1;
		end if;
	  ELSE
		p_message := 'Aucune tranche de DPG pour l''année ' || p_couann || '.';
	  END IF;

          FETCH curs_coutstd INTO curs_coutstd_enreg;

	  WHILE curs_coutstd%FOUND LOOP

		IF (curs_coutstd_enreg.codsg_bas <= dpg_haut_old) THEN

			p_message :=p_message || ' Recouvrement entre les tranches DPG : '|| to_char(dpg_bas_old,'0000000') ||'-'|| to_char(dpg_haut_old,'0000000') || ' et ' || to_char(curs_coutstd_enreg.codsg_bas,'0000000') ||'-'||to_char(curs_coutstd_enreg.codsg_haut,'0000000') || '.';

			dpg_bas_old := curs_coutstd_enreg.codsg_bas;
	  		dpg_haut_old := curs_coutstd_enreg.codsg_haut;
			if(dpg_haut_old = 9999999) then flag_dpg_max := 1;
			end if;

		ELSIF (curs_coutstd_enreg.codsg_bas > dpg_haut_old+1) THEN

			p_message := p_message || ' Vide entre les tranches DPG : ' || to_char(dpg_bas_old,'0000000') || '-' || to_char(dpg_haut_old,'0000000') || ' et ' ||	to_char(curs_coutstd_enreg.codsg_bas,'0000000') || '-' || to_char(curs_coutstd_enreg.codsg_haut,'0000000') ||'.';

			dpg_bas_old := curs_coutstd_enreg.codsg_bas;
	  		dpg_haut_old := curs_coutstd_enreg.codsg_haut;
			if(dpg_haut_old = 9999999) then flag_dpg_max := 1;
			end if;

		ELSE
			dpg_bas_old := curs_coutstd_enreg.codsg_bas;
			dpg_haut_old := curs_coutstd_enreg.codsg_haut;
			if(dpg_haut_old = 9999999) then flag_dpg_max := 1;
			end if;
		END IF;

	  	FETCH curs_coutstd INTO curs_coutstd_enreg;

	  END LOOP;

	  CLOSE curs_coutstd;
	   END;

	IF (dpg_bas_first <> 0000000 OR flag_dpg_max <> 1) THEN
		p_message :=  p_message || ' Tranches de DPG incomplètes.' ;
	END IF;
	IF (p_message = ' ') THEN
		p_message := 'Les tranches de codes DPG sont ok pour l''année ' || p_couann || ' Pas de recouvrement ni de vide.';
	END IF;

   END controle_cout_standard;
PROCEDURE controle_cout_standard_sg (p_couann    IN  VARCHAR2,
                       		 		p_userid    IN  VARCHAR2,
                       		 		p_message   OUT VARCHAR2
                      ) IS

     l_msg VARCHAR(1024);
     dpg_bas_old cout_std_sg.dpg_bas%TYPE;
     dpg_haut_old cout_std_sg.dpg_haut%TYPE;

     dpg_bas_first cout_std_sg.dpg_bas%TYPE;
     flag_dpg_max number(1);


     CURSOR curs_coutstd_sg IS
     SELECT distinct annee couann,
	    dpg_bas codsg_bas,
	    dpg_haut codsg_haut
     FROM cout_std_sg
     WHERE annee = TO_NUMBER(p_couann)
     order by 1,2,3;

     curs_coutstd_enreg_sg curs_coutstd_sg%ROWTYPE;

   BEGIN

      -- Initialiser le message retour et flag
	    p_message := ' ';
	    flag_dpg_max := 0;
      -- TEST p_couann > 1900 et < 3000



      IF TO_NUMBER(p_couann) < 1900 OR TO_NUMBER(p_couann) > 3000 THEN
         pack_global.recuperer_message(20242, NULL, NULL, NULL, l_msg);
         raise_application_error( -20242, l_msg);
      END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

	   BEGIN

	  OPEN curs_coutstd_sg;

	  FETCH curs_coutstd_sg INTO curs_coutstd_enreg_sg;

	  IF curs_coutstd_sg%FOUND THEN
		dpg_bas_first := curs_coutstd_enreg_sg.codsg_bas;

	  	dpg_bas_old := curs_coutstd_enreg_sg.codsg_bas;
	  	dpg_haut_old := curs_coutstd_enreg_sg.codsg_haut;
		if(dpg_haut_old = 9999999) then flag_dpg_max := 1;
		end if;
	  ELSE
		p_message := 'Aucune tranche de DPG pour l''année ' || p_couann || '.';
	  END IF;

          FETCH curs_coutstd_sg INTO curs_coutstd_enreg_sg;

	  WHILE curs_coutstd_sg%FOUND LOOP

		IF (curs_coutstd_enreg_sg.codsg_bas <= dpg_haut_old) THEN

			p_message :=p_message || ' Recouvrement entre les tranches DPG : '|| to_char(dpg_bas_old,'0000000') ||'-'|| to_char(dpg_haut_old,'0000000') || ' et ' || to_char(curs_coutstd_enreg_sg.codsg_bas,'0000000') ||'-'||to_char(curs_coutstd_enreg_sg.codsg_haut,'0000000') || '.';

			dpg_bas_old := curs_coutstd_enreg_sg.codsg_bas;
	  		dpg_haut_old := curs_coutstd_enreg_sg.codsg_haut;
			if(dpg_haut_old = 9999999) then flag_dpg_max := 1;
			end if;

		ELSIF (curs_coutstd_enreg_sg.codsg_bas > dpg_haut_old+1) THEN

			p_message := p_message || ' Vide entre les tranches DPG : ' || to_char(dpg_bas_old,'0000000') || '-' || to_char(dpg_haut_old,'0000000') || ' et ' ||	to_char(curs_coutstd_enreg_sg.codsg_bas,'0000000') || '-' || to_char(curs_coutstd_enreg_sg.codsg_haut,'0000000') ||'.';

			dpg_bas_old := curs_coutstd_enreg_sg.codsg_bas;
	  		dpg_haut_old := curs_coutstd_enreg_sg.codsg_haut;
			if(dpg_haut_old = 9999999) then flag_dpg_max := 1;
			end if;

		ELSE
			dpg_bas_old := curs_coutstd_enreg_sg.codsg_bas;
			dpg_haut_old := curs_coutstd_enreg_sg.codsg_haut;
			if(dpg_haut_old = 9999999) then flag_dpg_max := 1;
			end if;
		END IF;

	  	FETCH curs_coutstd_sg INTO curs_coutstd_enreg_sg;

	  END LOOP;

	  CLOSE curs_coutstd_sg;
	   END;

	IF (dpg_bas_first <> 0000000 OR flag_dpg_max <> 1) THEN
		p_message :=  p_message || ' Tranches de DPG incomplètes.' ;
	END IF;
	IF (p_message = ' ') THEN
		p_message := 'Les tranches de codes DPG sont ok pour l''année ' || p_couann || ' Pas de recouvrement ni de vide.';
	END IF;

   END controle_cout_standard_sg;

 FUNCTION get_coutstandard_sg (p_anneestd   	 IN VARCHAR2,
					p_dpg_bas      IN VARCHAR2,
					p_niveau  	IN VARCHAR2,
					p_metier  	IN VARCHAR2)
RETURN NUMBER IS
l_cout NUMBER(6,2);
BEGIN
	select cout_sg into l_cout
	from cout_std_sg
	where annee = to_number(p_anneestd)
	and dpg_bas = to_number(p_dpg_bas)
	and RTRIM(niveau)=RTRIM(p_niveau)
	and RTRIM(metier)=RTRIM(p_metier) ;

 RETURN l_cout;

 EXCEPTION
         WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM );

END get_coutstandard_sg;

END pack_cout_standard;
/
CREATE OR REPLACE PACKAGE pack_ctl_FE65 IS

-- Fonction qui retourne le libelle des colonnes en fonction de numéro de la colonne (1 à 5)
-- Concerne l'édition FE65
   function f_entetecol(
                       p_num NUMBER
                       ) RETURN VARCHAR2;
   PRAGMA RESTRICT_REFERENCES(f_entetecol,WNDS,WNPS);

-- Procedure qui controle les parametre d'entrées

   PROCEDURE select_fe65(
                 p_datdeb  IN VARCHAR2,         -- date
                 p_datfin  IN VARCHAR2,         -- date
                 p_userid  IN  VARCHAR2,
                 P_message OUT VARCHAR2
                 );

END pack_ctl_FE65;
/

CREATE OR REPLACE PACKAGE BODY pack_ctl_FE65 IS
-- ------------------------------------
function f_entetecol(
                    p_num NUMBER
                    ) RETURN VARCHAR2
                    IS
BEGIN
 	IF (p_num = 1) THEN
   		RETURN '1NB Factures    entregistrées';
 	END IF ;
 	IF (p_num = 2) THEN
   		RETURN '2NB Factures    réglées';
 	END IF ;
 	IF (p_num = 3) THEN
   		RETURN '3NB Factures    sans contrat';
 	END IF ;
 	IF (p_num = 4) THEN
   		RETURN '4Nb tot. fact.  en att./periode';
 	END IF ;
 	IF (p_num = 5) THEN
   		RETURN '5Nb tot. fact.  en attente';
 	END IF ;

END f_entetecol;

-- ---------------------------------------------
PROCEDURE select_fe65(
                 p_datdeb  IN  VARCHAR2,         -- date
                 p_datfin  IN  VARCHAR2,         -- date
                 p_userid  IN  VARCHAR2,
                 P_message OUT VARCHAR2
                 ) is

      l_message   VARCHAR2(1024);
BEGIN
      pack_ctl_lstcontl.select_periode (p_datdeb, p_datfin, 'P_param6', TRUE, l_message);
      p_message := l_message;
END select_fe65;

END pack_ctl_FE65;
/
CREATE OR REPLACE PACKAGE pack_ctl_lstcontl AS
-- ---------------------------------------------
      PROCEDURE select_lstcontl(
                 p_inutile   	IN  VARCHAR2,       		--  inutilisé
                 p_SOCCODE 	IN  societe.SOCCODE%TYPE, 	-- CHAR(4)
                 p_codsg   	IN  VARCHAR2,       		--  NUMBER(7)
                 p_IDENT 	IN  VARCHAR2,          		--  NUMBER(5)
                 p_ctypfact 	IN  contrat.ctypfact%TYPE,     	--  Sans utilité
                 p_datdeb 	IN  VARCHAR2,         		-- date
                 p_datfin 	IN  VARCHAR2,         		-- date
                 p_ccoutht	IN  VARCHAR2,        		--  Sans utilité
                 p_userid  	IN  VARCHAR2,
                 P_message 	OUT VARCHAR2
                 );

	PROCEDURE select_dpg (	p_userid  IN  VARCHAR2,
			 	p_codsg   IN  VARCHAR2,
                         	p_focus   IN  VARCHAR2,
                         	p_msg     OUT VARCHAR2
                 );

      PROCEDURE select_societe
                (p_SOCCODE IN  societe.SOCCODE%TYPE,
                 p_focus   IN  VARCHAR2,
                 p_msg     OUT VARCHAR2
                 );


      PROCEDURE select_ressource
                (p_IDENT IN  VARCHAR2,
                 p_focus IN  VARCHAR2,
                 p_msg   OUT VARCHAR2
                 );
      PROCEDURE select_periode (
                    p_datdeb IN VARCHAR2,
                    p_datfin IN VARCHAR2,
                    p_focus  IN VARCHAR2,
                    p_msg    OUT VARCHAR2
                    );

      PROCEDURE select_periode (
                    p_datdeb IN VARCHAR2,
                    p_datfin IN VARCHAR2,
                    p_focus  IN VARCHAR2,
                    p_oblige IN BOOLEAN,
                    p_msg    OUT VARCHAR2
                    );

      PROCEDURE select_periode (
                    p_datdeb   IN  VARCHAR2,
                    p_datfin   IN  VARCHAR2,
                    p_focusDeb IN  VARCHAR2,
                    p_focusFin IN  VARCHAR2,
                    p_msg      OUT VARCHAR2
                    );

      l_msg   VARCHAR2(1024);


END pack_ctl_lstcontl;
/

CREATE OR REPLACE PACKAGE BODY pack_ctl_lstcontl AS

-- ------------------------------------------------
   PROCEDURE select_lstcontl(
                 p_inutile   IN  VARCHAR2,       	-- inutilisé
                 p_SOCCODE   IN  societe.SOCCODE%TYPE, 	-- CHAR(4)
                 p_codsg     IN  VARCHAR2,       	-- NUMBER(7)
                 p_IDENT     IN  VARCHAR2,          	-- NUMBER(5)
                 p_ctypfact  IN  contrat.ctypfact%TYPE, -- Sans utilité
                 p_datdeb    IN  VARCHAR2,         	-- date
                 p_datfin    IN  VARCHAR2,         	-- date
                 p_ccoutht   IN  VARCHAR2,        	-- Sans utilité
                 p_userid    IN  VARCHAR2,
                 P_message   OUT VARCHAR2
                 ) is
      l_message   VARCHAR2(1024);
   BEGIN
      l_message := '';
      if (p_SOCCODE is not null) then
      	select_societe (p_SOCCODE,'P_param7', l_message);
      end if;
      if (l_message is null) and (p_codsg is not null ) then
         select_dpg (p_userid,p_codsg,'P_param8', l_message);
      end if;
      if (l_message is null) and (p_ident is not null) then
         select_ressource (p_ident,'P_param9', l_message);
      end if;
      -- Controle de la periode
      if (l_message is null) then
		select_periode (p_datdeb, p_datfin, 'P_param11', l_message);
      end if;
      p_message := l_message;
   END select_lstcontl;
-- ------------------
   PROCEDURE select_dpg (p_userid  IN  VARCHAR2,
			 p_codsg   IN  VARCHAR2,
                         p_focus   IN  VARCHAR2,
                         p_msg     OUT VARCHAR2
                        ) IS
      	l_msg   	VARCHAR2(1024);
      	l_codsg 	VARCHAR2(7);
	l_codsg2 	struct_info.codsg%TYPE;
  	l_meta 		CHAR(1);
      	l_where 	VARCHAR2(100);
      	l_centre_frais 	centre_frais.codcfrais%TYPE;
      	l_scentrefrais 	centre_frais.codcfrais%TYPE;
   BEGIN
      -- P_codsg peut avoir une valeur = '01313**' ou '0131312' ou '01312  ' (avec des blancs)
      -- S'il possed un metacaractere (' ', '*'), on va le supprimer
      -- Puis former la condition Where du Select en fonction du longueur de P_codsg
      l_codsg := LPAD(P_codsg, 7, '0');
      l_meta := SUBSTR(P_codsg, LENGTH(P_codsg) ,1);   -- dernier caractère
      IF (l_meta = ' ') or (l_meta = '*') THEN
          l_codsg := RTRIM(LPAD(p_codsg, 7, '0'),l_meta);
  	END IF;
      -- Initialiser le message retour
      l_msg := '';
      BEGIN
            IF LENGTH(l_codsg) = 3 THEN
               SELECT codsg,scentrefrais
		INTO l_codsg2,l_scentrefrais
               FROM   struct_info
               WHERE  SUBSTR(TO_CHAR(codsg, 'FM0000000'),1,3) = l_codsg;
            ELSIF LENGTH(l_codsg)= 5 THEN
               SELECT codsg,scentrefrais
		INTO l_codsg2,l_scentrefrais
               FROM   struct_info
               WHERE  SUBSTR(TO_CHAR(codsg, 'FM0000000'),1,5) = l_codsg;
            ELSIF LENGTH(l_codsg)= 7 THEN
               SELECT codsg,scentrefrais
		INTO l_codsg2,l_scentrefrais
               FROM   struct_info
               WHERE  codsg = TO_NUMBER(l_codsg);
           else
               -- Code Département/Pôle/Groupe invalide
               pack_global.recuperer_message(20430, '%s1', p_codsg, p_focus, l_msg);
               raise_application_error(-20430, l_msg);
            END IF;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
             -- Code Département/Pôle/Groupe %s1 inexistant
            pack_global.recuperer_message(2064, '%s1',l_codsg, p_focus, l_msg);
         WHEN TOO_MANY_ROWS THEN
            NULL;
         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;


     -- ===================================================================
     -- 22/12/2000 : Test si le DPG appartient bien au centre de frais
     -- ===================================================================
     -- On récupère le code centre de frais de l'utilisateur
	l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

	IF l_scentrefrais is null then
		--msg : Le DPG n'est rattaché à aucun centre de frais
			pack_global.recuperer_message(20339, NULL,NULL,'P_param8', l_msg);
          		raise_application_error(-20339, l_msg);
	END IF;

     IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
		IF (l_scentrefrais!=l_centre_frais) then
			--msg:Ce DPG n'appartient pas à ce centre de frais
			pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'P_param8', l_msg);
          		raise_application_error(-20334, l_msg);
		END IF;
      END IF;
      p_msg := l_msg;
   END select_dpg;
-- -------------
   PROCEDURE select_societe
                (p_SOCCODE IN  societe.SOCCODE%TYPE,
                 p_focus   IN  VARCHAR2,
                 p_msg     OUT VARCHAR2
                 ) IS
      l_msg   VARCHAR2(1024);
      l_soccode societe.soccode%TYPE;
    BEGIN
      l_msg := '';
      BEGIN
            SELECT soccode INTO l_soccode
            FROM   societe
            WHERE  soccode = p_soccode;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            -- Code société inexistant
            pack_global.recuperer_message(4000, '%s1', p_soccode , p_focus, l_msg);
         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;
      p_msg := l_msg;
   END select_societe;
-- ------------------
   PROCEDURE select_ressource (p_IDENT IN VARCHAR2,
                               p_focus IN  VARCHAR2,
                               p_msg OUT VARCHAR2
                              ) IS
      l_msg   VARCHAR2(1024);
      l_IDENT Ressource.IDENT%TYPE;
    BEGIN
      l_msg := '';
      BEGIN
            SELECT IDENT INTO l_IDENT
            FROM   Ressource
            WHERE  IDENT = to_number(p_IDENT);
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            -- Code Ressource %s1 inexistant
            pack_global.recuperer_message(4001, '%s1' , P_IDENT , p_focus, l_msg);
         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;
      p_msg := l_msg;
   END select_ressource;
-- ----------------------------------------------------------------------------
-- Procedure select_periode. Cette procedure est surchargée
-- Role : controle d'une periode.
-- Particularite de ce surchagre : la saisie des deux dates simultanement ne
-- sont pas obligatoires, mais la saisie de l'une oblige la saisie de l'autre.
-- ----------------------------------------------------------------------------
   PROCEDURE select_periode (
                    p_datdeb IN  VARCHAR2,
                    p_datfin IN  VARCHAR2,
                    p_focus  IN  VARCHAR2,
                    p_msg    OUT VARCHAR2
                    ) IS
      l_msg   VARCHAR2(1024);
    BEGIN
         if ((p_datdeb is not null) and (p_datfin is null)) or
            ((p_datdeb is null) and (p_datfin is not null)) then
               -- Période erronée
               pack_global.recuperer_message(20431, null, null, p_focus, l_msg);
               raise_application_error(-20431, l_msg);
         elsif (to_date(p_datdeb,'dd/mm/yyyy') > to_date(p_datfin,'dd/mm/yyyy')) then
               -- La date de fin doit être supérieure ou égale à la date de début
               pack_global.recuperer_message(20284, null, null, p_focus, l_msg);
               raise_application_error(-20284, l_msg);
         end if;
    END select_periode;
-- ----------------------------------------------------------------------------
-- Procedure select_periode. Cette procedure est surchargée
-- Role : controle d'une periode.
-- Particularite de ce surchagre : la saisie des deux dates (date de debut et
-- date de fin) est obligatoire
-- ----------------------------------------------------------------------------
   PROCEDURE select_periode (
                    p_datdeb IN VARCHAR2,
                    p_datfin IN VARCHAR2,
                    p_focus  IN VARCHAR2,
                    p_oblige IN BOOLEAN,
                    p_msg    OUT VARCHAR2
                    ) IS
      l_msg   VARCHAR2(1024);
    BEGIN
      l_msg := '';
      IF (p_datdeb is null) AND (p_datfin is null) THEN
               -- Période Obligatoire;
               pack_global.recuperer_message(4002, null, null, p_focus, l_msg);
      ELSIF (p_datdeb is null) or (p_datfin is null) THEN
               -- Période erronée
               pack_global.recuperer_message(20431, null, null, p_focus, l_msg);
               raise_application_error(-20431, l_msg);
      ELSIF (to_date(p_datdeb,'dd/mm/yyyy') > to_date(p_datfin,'dd/mm/yyyy')) then
               -- La date de fin doit être supérieure ou égale à la date de début
               pack_global.recuperer_message(20284, null, null, p_focus, l_msg);
               raise_application_error(-20284, l_msg);
      END IF;
      p_msg := l_msg;
    END select_periode;
-- ----------------------------------------------------------------------------
-- Procedure select_periode. Cette procedure est surchargée
-- Role : controle d'une periode.
-- Particularite de ce surchagre : idem au premier surcharge mais ici les
-- message sont plus explicites et le focus est gere plus precisement.
-- ----------------------------------------------------------------------------
   PROCEDURE select_periode (
                    p_datdeb   IN  VARCHAR2,
                    p_datfin   IN  VARCHAR2,
                    p_focusDeb IN  VARCHAR2,
                    p_focusFin IN  VARCHAR2,
                    p_msg      OUT VARCHAR2
                    ) IS
      l_msg   VARCHAR2(1024);
    BEGIN
      	IF (p_datdeb is null) and (p_datfin is not null) THEN
               -- Date de debut obligatoire.
               pack_global.recuperer_message(20440, null, null, p_focusDeb, l_msg);
               raise_application_error(-20440, l_msg);
            ELSIF (p_datdeb is not null) and (p_datfin is null) THEN
               -- Date de fin obligatoire.
               pack_global.recuperer_message(20441, null, null, P_focusFin, l_msg);
               raise_application_error(-20441, l_msg);
      	ELSIF (p_datdeb is not null) and (p_datfin is not null)
                  and (to_date(p_datdeb,'dd/mm/yyyy') > to_date(p_datfin,'dd/mm/yyyy')) then
               -- La date de fin doit être supérieure ou égale à la date de début
               pack_global.recuperer_message(20284, null, null, p_focusDeb, l_msg);
               raise_application_error(-20284, l_msg);
      	END IF;
    END select_periode;
END pack_ctl_lstcontl;
/
CREATE OR REPLACE PACKAGE pack_datesuiv_fact AS

   TYPE FactRecType IS RECORD (soclib       societe.soclib%TYPE,
                               socfact      facture.socfact%TYPE,
                               numfact      facture.numfact%TYPE,
                               typfact      facture.typfact%TYPE,
                               datfact      varchar2(20),
                               fnom         facture.fnom%TYPE,
                               fordrecheq   facture.fordrecheq%TYPE,
                               fenvsec      varchar2(20),      -- date reglmt souhaite
                               fregcompta   varchar2(20),
                               fmodreglt    varchar2(20),
                               fenrcompta   varchar2(20),
                               fburdistr    facture.fburdistr%TYPE,
                               fcodepost    varchar2(20),
                               fstatut2     facture.fstatut2%TYPE,
                               faccsec      varchar2(20),
                               fadresse1    facture.fadresse1%TYPE,
                               fadresse2    facture.fadresse2%TYPE,
                               fadresse3    facture.fadresse3%TYPE,
                               flaglock     VARCHAR2(20)
                               );

   TYPE FactSelectCur IS REF CURSOR RETURN FactRecType;


   PROCEDURE update_datesuiv_fact   (p_socfact        IN facture.socfact%TYPE,
                                     p_soclib         IN societe.soclib%TYPE,
                                     p_numfact        IN facture.numfact%TYPE,
                                     p_typfact        IN facture.typfact%TYPE,
                                     p_datfact        IN VARCHAR2,
                                     p_fenrcompta     IN VARCHAR2,
                                     p_faccsec        IN VARCHAR2,
                                     p_fregcompta     IN VARCHAR2,
                                     p_fenvsec        IN VARCHAR2,
                                     p_fstatut2       IN facture.fstatut2%TYPE,
                                     p_fmodreglt      IN VARCHAR2,
                                     p_fordrecheq     IN facture.fordrecheq%TYPE,
                                     p_fnom           IN facture.fnom%TYPE,
                                     p_fadresse1      IN facture.fadresse1%TYPE,
                                     p_fadresse2      IN facture.fadresse2%TYPE,
                                     p_fadresse3      IN facture.fadresse3%TYPE,
                                     p_fcodepost      IN VARCHAR2,
                                     p_fburdistr      IN facture.fburdistr%TYPE,
                                     p_flaglock       IN VARCHAR2,
                                     p_userid         IN VARCHAR2,
                                     p_nbcurseur         OUT INTEGER,
                                     p_message           OUT VARCHAR2
                                    );


   PROCEDURE select_datesuiv_fact   (p_socfact        IN facture.socfact%TYPE,
                                     p_numfact        IN facture.numfact%TYPE,
                                     p_typfact        IN facture.typfact%TYPE,
                                     p_datfact        IN VARCHAR2,
                                     p_userid         IN VARCHAR2,
                                     p_curselect      IN OUT FactSelectCur,
                                     p_msg_info          OUT VARCHAR2,
                                     p_nbcurseur         OUT INTEGER,
                                     p_message           OUT VARCHAR2
                                    );

END pack_datesuiv_fact;
/

CREATE OR REPLACE PACKAGE BODY pack_datesuiv_fact AS

-- ********************************************************************************************************
-- ********************************************************************************************************
--
-- UPDATE_FACTURE   - possible que si fstatut1 = 'AE' ou 'SE' déjà contrôlé lors du select_datesuiv_fact
--
-- ********************************************************************************************************
-- ********************************************************************************************************
   PROCEDURE update_datesuiv_fact   (p_socfact        IN facture.socfact%TYPE,
                                     p_soclib         IN societe.soclib%TYPE,
                                     p_numfact        IN facture.numfact%TYPE,
                                     p_typfact        IN facture.typfact%TYPE,
                                     p_datfact        IN VARCHAR2,
                                     p_fenrcompta     IN VARCHAR2,
                                     p_faccsec        IN VARCHAR2,
                                     p_fregcompta     IN VARCHAR2,
                                     p_fenvsec        IN VARCHAR2,
                                     p_fstatut2       IN facture.fstatut2%TYPE,
                                     p_fmodreglt      IN VARCHAR2,
                                     p_fordrecheq     IN facture.fordrecheq%TYPE,
                                     p_fnom           IN facture.fnom%TYPE,
                                     p_fadresse1      IN facture.fadresse1%TYPE,
                                     p_fadresse2      IN facture.fadresse2%TYPE,
                                     p_fadresse3      IN facture.fadresse3%TYPE,
                                     p_fcodepost      IN VARCHAR2,
                                     p_fburdistr      IN facture.fburdistr%TYPE,
                                     p_flaglock       IN VARCHAR2,
                                     p_userid         IN VARCHAR2,
                                     p_nbcurseur         OUT INTEGER,
                                     p_message           OUT VARCHAR2
                                    ) IS

      l_msg        VARCHAR2(1024);
      l_filcode    filiale_cli.filcode%TYPE;
      p_filcode    filiale_cli.filcode%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA       EXCEPTION_INIT(referential_integrity, -2292);
      l_soccont    facture.soccont%TYPE;
      l_cav        facture.cav%TYPE;
      l_numcont    facture.numcont%TYPE;
      l_llibanalyt facture.llibanalyt%TYPE;
      l_date       DATE;
      l_fsocfour   facture.fsocfour%TYPE;


   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      --  On recupere le code filiale de l'utilisateur
      p_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- =======================================
      -- Test Dates
      -- =======================================
      DECLARE
         l_datejour DATE;
      BEGIN
         SELECT SYSDATE INTO l_datejour FROM   dual;


      -- OK si Dates Enreg Compta <= date du jour
         IF l_datejour < to_date(p_fenrcompta,'DD/MM/YYYY') THEN
               -- Msg La date d'envoi à l'enreg Compta ne peut pas être postérieure à aujourd'hui
            pack_global.recuperer_message(20115,NULL,NULL,'FENRCOMPTA',l_msg);
            raise_application_error(-20115,l_msg);
         END IF;

      -- OK si Dates Enreg Compta <= Dates Accord Pole <= date du jour
         IF l_datejour < to_date(p_faccsec,'DD/MM/YYYY') THEN
               -- Msg La date d'accord Pole ne peut être postérieure à aujourd'hui
               pack_global.recuperer_message(20116,NULL,NULL,'FACCSEC',l_msg);
               raise_application_error(-20116,l_msg);

         ELSIF ( to_date(p_fenrcompta,'DD/MM/YYYY') > to_date(p_faccsec,'DD/MM/YYYY') ) THEN
               -- Msg La date d'accord Pole ne peut pas être antérieure à la date d'envoi à l'enreg. Compta
            pack_global.recuperer_message(20117,NULL,NULL,'FACCSEC',l_msg);
            raise_application_error(-20117,l_msg);
         END IF;


      -- Dates Reglement Compta <= Date du jour
         IF l_datejour < to_date(p_fregcompta,'DD/MM/YYYY') THEN
               -- Msg La date d'envoi au règlement Compta ne peut pas être postérieure à aujourd'hui
            pack_global.recuperer_message(20118,NULL,NULL,'FREGCOMPTA',l_msg);
            raise_application_error(-20118,l_msg);
         END IF;

      -- Dates Reglement Demandé > Date de facture
         IF to_date(p_fenvsec,'DD/MM/YYYY') <= to_date(p_datfact,'DD/MM/YYYY') THEN
               -- Msg La date de réglement demandée ne peut être antérieure ou égale à la date de facture
            pack_global.recuperer_message(20119,NULL,NULL,'FENVSEC',l_msg);
            raise_application_error(-20119,l_msg);
         END IF;


      END;

      -- ==============================================================
      --  Test si p_fmodreglt = 3 (cheque) alors il faut saisir les zones
      -- ==============================================================

      IF p_fmodreglt = 3 THEN
         BEGIN
			IF p_fordrecheq IS NULL THEN
					pack_global.recuperer_message(20123,NULL, NULL, 'FORDRECHEQ', l_msg);
					raise_application_error( -20123, l_msg );
			END IF;
			IF p_fnom       IS NULL THEN
					pack_global.recuperer_message(20124,NULL, NULL, 'FNOM', l_msg);
					raise_application_error( -20124, l_msg );
			END IF;
			IF p_fadresse1  IS NULL THEN
					pack_global.recuperer_message(20125,NULL, NULL, 'FADRESSE1', l_msg);
					raise_application_error( -20125, l_msg );
			END IF;
			IF p_fcodepost  = '0'  THEN
					pack_global.recuperer_message(20126,NULL, NULL, 'FCODEPOST', l_msg);
					raise_application_error( -20126, l_msg );
			END IF;
			IF p_fburdistr  IS NULL THEN
					pack_global.recuperer_message(20127,NULL, NULL, 'FBURDISTR', l_msg);
					raise_application_error( -20127, l_msg );
			END IF;
			END;
		END IF;

      -- ==============================================================
      --  TEST si Fsocfour = 9999999999 alors p_fmodreglt doit <> 1
      -- ==============================================================

      BEGIN
         SELECT   f.fsocfour   INTO l_fsocfour  FROM facture f
         WHERE  socfact  = p_socfact
           AND  numfact  = p_numfact
           AND  typfact  = p_typfact
           AND  datfact  = to_date(p_datfact,'DD/MM/YYYY')
           AND  flaglock = to_number(p_flaglock,'9999999');

			IF SQL%NOTFOUND THEN			-- Acces concurrent
				pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
				raise_application_error( -20999, l_msg );
			END IF;

			IF ( (l_fsocfour = '9999999999' or  l_fsocfour = '9999999' or  l_fsocfour = '999999 ')
				and p_fstatut2!='SE')		THEN
				IF p_fmodreglt = 1 THEN
				   -- Erreur Msg Pour le code fournisseur 9999999999, le mode de regl doit différent de 1(virement)
						pack_global.recuperer_message(20122,NULL, NULL, 'FMODREGL', l_msg);
						raise_application_error( -20122, l_msg );
				END IF;
			END IF;

      EXCEPTION
           WHEN NO_DATA_FOUND THEN  -- Acces concurrent
					pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
					raise_application_error( -20999, l_msg );
           WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);

      END;


      -- ==============================================================
      --   OK : Modifier
      -- ==============================================================

      BEGIN
         UPDATE FACTURE
         SET   fnom        = p_fnom,
               fordrecheq  = p_fordrecheq,
               fenvsec     = to_date(p_fenvsec,'DD/MM/YYYY'),
               fregcompta  = to_date(p_fregcompta,'dd/mm/yyyy'),
               fmodreglt   = to_number(p_fmodreglt,'99'),
               fenrcompta  = to_date(p_fenrcompta,'dd/mm/yyyy'),
               fburdistr   = p_fburdistr,
               fcodepost   = to_number(p_fcodepost,'99999'),
               fstatut2    = p_fstatut2,
               fdatmaj     = sysdate,
               faccsec     = to_date(p_faccsec,'dd/mm/yyyy'),
               fadresse1   = p_fadresse1,
               fadresse2   = p_fadresse2,
               fadresse3   = p_fadresse3,
               flaglock    = decode(p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  socfact  = p_socfact
           AND  numfact  = p_numfact
           AND  typfact  = p_typfact
           AND  datfact  = to_date(p_datfact,'DD/MM/YYYY')
           AND  flaglock = to_number(p_flaglock,'9999999');

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2292);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN  -- Acces concurrent
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE                 -- Msg Dates enregistrées pour la facture numfact
         pack_global.recuperer_message(2206,'%s1',p_numfact, NULL, l_msg);
         p_message := l_msg;
      END IF;

END update_datesuiv_fact;


-- ********************************************************************************************
-- ********************************************************************************************
--
-- select_datesuiv_fact   : un seul cas
--
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE select_datesuiv_fact(
                               p_socfact   IN facture.socfact%TYPE,
                               p_numfact   IN facture.numfact%TYPE,
                               p_typfact   IN facture.typfact%TYPE,
                               p_datfact   IN VARCHAR2,
                               p_userid    IN VARCHAR2,
                               p_curselect IN  OUT FactSelectCur,
                               p_msg_info      OUT VARCHAR2,
			       p_nbcurseur     OUT INTEGER,
                               p_message       OUT VARCHAR2
                              ) IS

      l_msg          VARCHAR2(1024) ;
      l_soclib       societe.soclib%TYPE ;
      l_socfact      facture.socfact%TYPE ;
      p_filcode      filiale_cli.filcode%TYPE ;
      l_fprovsegl1   facture.fprovsegl1%TYPE;
      l_fprovsegl2   facture.fprovsegl2%TYPE;
      l_fmodreglt    facture.fmodreglt%TYPE;
      l_fstatut1     facture.fstatut1%TYPE;
      l_fstatut2     facture.fstatut2%TYPE;
      l_soccont      facture.soccont%TYPE;
      l_cav          facture.cav%TYPE;
      l_numcont      facture.numcont%TYPE;
      l_filcode	     contrat.filcode%TYPE;
      l_codsg        contrat.codsg%TYPE;
      l_comcode      contrat.comcode%TYPE;
      l_msg_cont     VARCHAR2(200);
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_fcentrefrais centre_frais.codcfrais%TYPE;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur   := 0;
      p_message     := '';

         --DBMS_OUTPUT.PUT_LINE(p_bouton || '-;-' || p_socfact || '-;-' || p_numcont || '-;-'
         --  || p_rnom || '-;-' || p_numfact || '-;-' || p_typfact || '-;-' || p_datfact || '-;-'
         --  || p_choixfsc || '-;-' || p_userid || '-;;') ;

      --  On recupere le code filiale de l'utilisateur
      p_filcode := pack_global.lire_globaldata(p_userid).filcode;


      -- =======================================================================
      -- Test existence du CODE SOCIETE : on recupere en meme temps son libelle
      -- =======================================================================
      BEGIN
         SELECT soccode
         INTO   l_socfact
         FROM   societe
         WHERE  soccode = p_socfact;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN       -- Erreur message "Code Societe inexistant"
             pack_global.recuperer_message(20306, NULL, NULL, NULL, l_msg);
             raise_application_error(-20306,l_msg);
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;


   BEGIN
      -- ============================================================
      -- Test existence de la facture
      -- Si existe Alors
      --       Pour Modifier ou Lignes AUTORISER Si fstatut1 = AE ou SE   -> (ajout 31/1/2000 ) ou VA
      --       Pour Supprimer INTERDIRE Si fstatut1 = VA et fprovsegl1 = 1
      --                                et fstatut2 = VA et fprovsegl2 = 1 et fmodreglt = 1
      --       La liste des lignes de factures sera obtenue par lister_ligne_fact
      -- EXCEPTION si facture inexistante
      -- ============================================================
      BEGIN
         SELECT   f.fprovsegl1,f.fprovsegl2,f.fmodreglt,f.fstatut1,f.fstatut2,f.soccont,f.cav,f.numcont,f.fcentrefrais
         INTO     l_fprovsegl1,l_fprovsegl2,l_fmodreglt,l_fstatut1,l_fstatut2,l_soccont,l_cav,l_numcont,l_fcentrefrais
         FROM  facture f , societe s
         WHERE     f.socfact = s.soccode
               AND s.soccode = p_socfact
               AND f.numfact = p_numfact
               AND f.typfact = p_typfact
               AND f.datfact = to_date(p_datfact,'DD/MM/YYYY');
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
               pack_global.recuperer_message(20103, NULL, NULL, NULL, l_msg);
               raise_application_error(-20103,l_msg);

        WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
      END;

      -- ============================================================
      -- Test si c'est autorise pour Modifier ou Lignes
      -- ============================================================
      IF (l_fstatut1 = 'AE' OR l_fstatut1 = 'SE' OR l_fstatut1 = 'VA'  ) THEN  NULL ; -- OK modif
         ELSE           -- Message  La modification par ce menu n'est possible que si CS1 = AE ou SE ou VA
               pack_global.recuperer_message(20139, NULL, NULL, NULL, l_msg);
               raise_application_error(-20139,l_msg);
      END IF;

      -- ============================================================
      -- Cas facture avec contrat : A-t-on la bonne filiale ?
      -- ============================================================
      IF l_numcont IS NOT NULL THEN
         pack_facture.verif_filiale_cont(l_soccont,l_cav,l_numcont,p_filcode,l_msg_cont,l_codsg,l_comcode);
         IF l_msg_cont IS NOT NULL THEN
            p_msg_info    := 'MSG_ERREUR#' || l_msg_cont ;
         END IF;
      END IF;


      -- ======================================================================================
      -- 21/12/2000 :Contrôler que la facture appartient au centre de frais de l'utilisateur
      -- =======================================================================================
	 -- On récupère le code centre de frais de l'utilisateur
            l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

     	IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
		IF l_fcentrefrais is null THEN
			-- la facture n'est rattachée à aucun centre de frais
			pack_global.recuperer_message(20337,NULL,NULL,NULL, l_msg);
         	 	raise_application_error(-20337, l_msg);

		ELSE
			IF l_centre_frais!=l_fcentrefrais THEN
				-- la facture n'est pas rattachée au centre de frais %s1 mais au centre de frais %s2
				pack_global.recuperer_message(20338,'%s1',to_char(l_centre_frais),'%s2',
									to_char(l_fcentrefrais),NULL, l_msg);
         			raise_application_error(-20338, l_msg);

			END IF;
		END IF;
	END IF;

      -- ============================================================
      -- OK Maintenant tout est bon, select de la facture
      -- ============================================================
      p_nbcurseur := 1;

      BEGIN
      OPEN p_curselect FOR
         SELECT  s.soclib,
                 f.socfact,
                 f.numfact,
                 f.typfact,
                 TO_CHAR(f.datfact,'dd/mm/yyyy'),
                 f.fnom,
                 f.fordrecheq,
                 TO_CHAR(f.fenvsec,'dd/mm/yyyy'),
                 TO_CHAR(f.fregcompta,'dd/mm/yyyy'),
                 TO_CHAR(f.fmodreglt,'FM99'),
                 TO_CHAR(f.fenrcompta,'dd/mm/yyyy'),
                 f.fburdistr,
                 TO_CHAR(f.fcodepost,'FM99999'),
                 f.fstatut2,
                 TO_CHAR(faccsec,'dd/mm/yyyy'),
                 f.fadresse1,
                 f.fadresse2,
                 f.fadresse3,
                 TO_CHAR(f.flaglock,'FM99999999')
         FROM  facture f, societe s
         WHERE  f.socfact = s.soccode
            AND s.soccode = p_socfact
            AND f.numfact = p_numfact
            AND f.typfact = p_typfact
            AND f.datfact = to_date(p_datfact,'DD/MM/YYYY');

      EXCEPTION
        WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END; -- end select pour Modifier , Supprimer ou Lignes

   END;     -- End bloc Modifier


END select_datesuiv_fact;

-- **************************************************************************************
-- TEST sous SQL+
-- var vcur refcursor
-- var vsoc varchar2(20)
-- var vsoclib varchar2(30)
-- var vnumcont varchar2(20)
-- var vcav varchar2(20)
-- var vnumfact varchar2(20)
-- var vtyp varchar2(20)
-- var vdat varchar2(20)
-- var vcodsg varchar2(20)
-- var vcom varchar2(20)
-- var vchoix varchar2(20)
-- var vnbcur number
-- var vmsg varchar2(500)
-- var vmsgi varchar2(500)
-- set serveroutput on
-- set autoprint on
-- exec pack_datesuiv_fact.select_datesuiv_fact('SOPR','LE123456','F','10/11/1999','S935708;achmenu;;0000;01 ;bip_F04_08046',:vcur,:vmsgi,:vnbcur,:vmsg);
-- exec pack_datesuiv_fact.insert_facture('SOPR','SOPRA','','','LE123456','F','10/11/1999','10/11/1999','631195','241612','241612','4376','4376','AE','01/10/1999',0,'S935705;;;;01;',:vcur,:vnbcur,:vmsg)
-- exec pack_datesuiv_fact.delete_facture('SOPR','LE123456','F','10/11/1999','5000,00','10/11/1999','01/10/1999','10/11/1999','10/11/1999',0,'S935705;;;;01;',:vcur,:vnbcur,:vmsg)
-- exec pack_datesuiv_fact.update_datesuiv_fact('SOPR','SOPRA','1248','02','LE123456','F','10/11/1999','1/11/1999','631195','241612','241612','4376','4376','IN','01/10/1999',0,'S935705;;;;01;',:vcur,:vnbcur,:vmsg)
-- attention au flaglock lors des operations update,modify et delete

END pack_datesuiv_fact;
/
CREATE OR REPLACE PACKAGE pack_dom_bancaire AS

   TYPE dom_bancaire_ViewType IS RECORD(cod_db  VARCHAR2(3),
                                   	lib_db  domaine_bancaire.lib_db%TYPE,
                                   	cod_ea  VARCHAR2(2),
                                   	topfer	domaine_bancaire.topfer%TYPE
				  );

   TYPE dom_bancaire_CurType IS REF CURSOR RETURN dom_bancaire_ViewType;

   TYPE ea_dom_bancaire_ViewType IS RECORD (cod_db     VARCHAR2(3),
                                   	    lib_ea_db  VARCHAR2(103)
				  );

   TYPE ea_dom_bancaire_CurType IS REF CURSOR RETURN ea_dom_bancaire_ViewType;


   PROCEDURE insert_dom_bancaire(p_cod_db     	in VARCHAR2,
                         	 p_lib_db 	in domaine_bancaire.lib_db%TYPE,
                         	 p_topfer	IN domaine_bancaire.topfer%TYPE,
                         	 p_cod_ea     	in VARCHAR2,
                         	 p_message   	out VARCHAR2
                            );

   PROCEDURE update_dom_bancaire(p_cod_db    	IN  VARCHAR2,
                            	 p_lib_db 	IN  domaine_bancaire.lib_db%TYPE,
                            	 p_topfer	IN  domaine_bancaire.topfer%TYPE,
                            	 p_cod_ea     	IN VARCHAR2,
                            	 p_message   	OUT VARCHAR2
                              );

   PROCEDURE delete_dom_bancaire(p_cod_db    	in VARCHAR2,
                            	 p_lib_db 	in domaine_bancaire.lib_db%TYPE,
                            	 p_message   	out VARCHAR2
                                   );

   PROCEDURE select_dom_bancaire(p_cod_db  	in     VARCHAR2,
                              	 p_curseur 	IN OUT dom_bancaire_CurType,
                              	 p_message 	out    VARCHAR2
                                );

   PROCEDURE select_num_dom_bancaire (
                              	p_num_db 	OUT 	VARCHAR2,
                              	p_message 	OUT    	VARCHAR2
                                );

   PROCEDURE lister_dom_bancaire ( p_curseur 	IN OUT  ea_dom_bancaire_CurType
                                );

END pack_dom_bancaire;
/

CREATE OR REPLACE PACKAGE BODY pack_dom_bancaire AS

   PROCEDURE insert_dom_bancaire(p_cod_db     	in VARCHAR2,
                         	 p_lib_db 	in domaine_bancaire.lib_db%TYPE,
                         	 p_topfer	IN domaine_bancaire.topfer%TYPE,
                         	 p_cod_ea     	in VARCHAR2,
                         	 p_message   	out VARCHAR2
                                 ) IS
       l_msg VARCHAR2(1024);

       BEGIN
          p_message := '';

           -- création de l'ensemble applicatif
           INSERT INTO domaine_bancaire(cod_db, lib_db, cod_ea, topfer)
           VALUES (p_cod_db, p_lib_db, TO_NUMBER(p_cod_ea), p_topfer);

           pack_global.recuperer_message(20971, '%s1', 'Domaine Bancaire ' || p_lib_db, NULL, l_msg);
           p_message := l_msg;

       END insert_dom_bancaire;


   PROCEDURE update_dom_bancaire (	p_cod_db    	IN  VARCHAR2,
                            	p_lib_db 	IN  domaine_bancaire.lib_db%TYPE,
                            	p_topfer	IN  domaine_bancaire.topfer%TYPE,
                            	p_cod_ea     	IN VARCHAR2,
                            	p_message   	OUT VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       l_dom_bancaire domaine_bancaire.cod_db%TYPE;

       BEGIN
       p_message := '';


          BEGIN
            SELECT cod_db INTO l_dom_bancaire
            FROM domaine_bancaire WHERE cod_db=to_number(p_cod_db);

            UPDATE domaine_bancaire SET
            	lib_db = p_lib_db,
            	topfer = p_topfer,
            	cod_ea = TO_NUMBER(p_cod_ea)
            WHERE cod_db = TO_NUMBER(p_cod_db);

            -- 'ensemble applicatif modifié
            pack_global.recuperer_message(20972, '%s1', 'Domaine bancaire ' || p_lib_db, NULL, l_msg);
            p_message := l_msg;

          EXCEPTION
            WHEN NO_DATA_FOUND THEN
                pack_global.recuperer_message( 20969, '%s1', p_lib_db, NULL, l_msg);
                p_message := l_msg;
                raise_application_error( -20969, l_msg );
            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

          END;

       END update_dom_bancaire;



   PROCEDURE delete_dom_bancaire(p_cod_db    	in VARCHAR2,
                            	 p_lib_db 	in domaine_bancaire.lib_db%TYPE,
                            	 p_message   	out VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       referential_integrity EXCEPTION;
       PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

       BEGIN
          -- Initialiser le message retour
          p_message := '';

          BEGIN
        	   DELETE FROM domaine_bancaire
        		      WHERE cod_db = TO_NUMBER(p_cod_db);
          EXCEPTION
               	WHEN referential_integrity THEN
               		-- habiller le msg erreur
               		pack_global.recuperer_message( 20199, '%s1', p_lib_db, '%s2', 'un projet', NULL, l_msg);
               		p_message := l_msg;
               		raise_application_error( -20199, l_msg );
        	WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
          END;

          IF SQL%NOTFOUND THEN
    	   -- 'Accès concurrent'
    	    pack_global.recuperer_message( 20969, '%s1', p_lib_db, NULL, l_msg);
            raise_application_error( -20969, l_msg );
          ELSE
    	   -- 'Le Domaine Bancaire p_lib_db a été supprimé'
    	   pack_global.recuperer_message( 20973, '%s1', 'Domaine Bancaire ' || p_lib_db, NULL, l_msg);
          END IF;

          p_message := l_msg;

       END delete_dom_bancaire;




   PROCEDURE select_dom_bancaire(p_cod_db  	in     VARCHAR2,
                              	 p_curseur 	IN OUT dom_bancaire_CurType,
                              	 p_message 	out    VARCHAR2
                                )IS

       BEGIN

              OPEN p_curseur FOR SELECT
                   TO_CHAR(cod_db) as cod_db,
                   lib_db,
                   TO_CHAR(cod_ea) as cod_ea,
                   topfer
              FROM  domaine_bancaire
              WHERE cod_db = TO_NUMBER(p_cod_db);

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);


       END select_dom_bancaire;


   PROCEDURE select_num_dom_bancaire (
                              	p_num_db 	OUT 	VARCHAR2,
                              	p_message 	OUT    	VARCHAR2
                                )IS

       BEGIN

              SELECT
                   TO_CHAR(NVL(MAX(cod_db), 0) + 1) INTO p_num_db
              FROM  domaine_bancaire;

       EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);


       END select_num_dom_bancaire;


   PROCEDURE lister_dom_bancaire (p_curseur 	IN OUT ea_dom_bancaire_CurType
                                )IS

       BEGIN

              OPEN p_curseur FOR
              SELECT '', ' ' lib FROM DUAL
              UNION
              SELECT
                   TO_CHAR(cod_db),
                   ea.lib_ea || ' - ' || db.lib_db lib
              FROM  ensemble_applicatif ea,
                    domaine_bancaire db
              WHERE ea.topfer='O'
                AND ea.cod_ea=db.cod_ea
                AND db.topfer='O'
              ORDER BY LIB;

       EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);


       END lister_dom_bancaire;

END pack_dom_bancaire;
/
CREATE OR REPLACE PACKAGE pack_dossier_projet AS

   TYPE dossier_projetCurType IS REF CURSOR RETURN dossier_projet%ROWTYPE;

   PROCEDURE insert_dossier_projet (p_dpcode    IN  VARCHAR2,
                                    p_dplib     IN  dossier_projet.dplib%TYPE,
                                    p_userid    IN  VARCHAR2,
                                    p_dateimmo	IN  VARCHAR2,
                                    p_actif	IN  VARCHAR2,
				    p_dptype    IN  type_dossier_projet.typdp%TYPE,
                                    p_nbcurseur OUT INTEGER,
                                    p_message   OUT VARCHAR2
                                   );

   PROCEDURE update_dossier_projet (p_dpcode    IN  VARCHAR2,
                                    p_dplib     IN  dossier_projet.dplib%TYPE,
                                    p_flaglock  IN  NUMBER,
                                    p_userid    IN  VARCHAR2,
                                    p_dateimmo	IN  VARCHAR2,
                                    p_actif	IN  VARCHAR2,
				    p_dptype    IN  type_dossier_projet.typdp%TYPE,
                                    p_nbcurseur OUT INTEGER,
                                    p_message   OUT VARCHAR2
                                   );

   PROCEDURE delete_dossier_projet (p_dpcode    IN  VARCHAR2,
                                    p_flaglock  IN  NUMBER,
                                    p_userid    IN  VARCHAR2,
                                    p_nbcurseur OUT INTEGER,
                                    p_message   OUT VARCHAR2
                                   );

   PROCEDURE select_dossier_projet (p_dpcode            IN VARCHAR2,
                                    p_userid            IN VARCHAR2,
                                    p_curdossier_projet IN OUT dossier_projetCurType,
                                    p_nbcurseur         OUT INTEGER,
                                    p_message           OUT VARCHAR2
                                   );

END pack_dossier_projet;
/

CREATE OR REPLACE PACKAGE BODY pack_dossier_projet AS


-- *********************************************************************************
--       Procedure   AJOUT  DOSSIER PROJET
-- *********************************************************************************

   PROCEDURE insert_dossier_projet (p_dpcode    IN  VARCHAR2,
                                    p_dplib     IN  dossier_projet.dplib%TYPE,
                                    p_userid    IN  VARCHAR2,
                                    p_dateimmo	IN  VARCHAR2,
                                    p_actif	IN  VARCHAR2,
				    p_dptype    IN  type_dossier_projet.typdp%TYPE,
                                    p_nbcurseur OUT INTEGER,
                                    p_message   OUT VARCHAR2
                                   ) IS

      l_new_dateimmo DATE;
      l_datdebex DATE;
      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- Si la date de saisie est différente de la précédente valeur
      -- et qu'elle est inférieure à l'année en cours, on renvoie une erreur
      SELECT datdebex INTO l_datdebex
      FROM datdebex
      WHERE ROWNUM<2;

      l_new_dateimmo := TO_DATE(p_dateimmo, 'FMDD/MM/YYYY');

      IF (TO_NUMBER(TO_CHAR(l_new_dateimmo,'YYYY')) < TO_NUMBER(TO_CHAR(l_datdebex, 'YYYY'))) THEN
      	    pack_global.recuperer_message( 20927, NULL, NULL, NULL, l_msg);
      	    raise_application_error( -20927, l_msg );
      END IF;

      BEGIN
        INSERT INTO dossier_projet
             (
              dpcode,
              dplib,
              datimmo,
              actif,
	      typdp
             )
             VALUES
             (
              p_dpcode,
              p_dplib,
              TO_DATE(p_dateimmo, 'FMDD/MM/YYYY'),
              p_actif,
	      p_dptype
		 );

        -- p_message := 'Code dossier ' || p_dpcode || ' et libellé enregistrés.';

        pack_global.recuperer_message( 2028, '%s1', p_dpcode, NULL, l_msg);
        p_message := l_msg;

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2291);
         WHEN DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message( 20212, NULL, NULL, NULL, l_msg);
            raise_application_error( -20212, l_msg );
         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;
   END insert_dossier_projet;


-- *********************************************************************************
--       Procedure   MISE A JOUR  DOSSIER PROJET
-- *********************************************************************************

   PROCEDURE update_dossier_projet (p_dpcode    IN  VARCHAR2,
                                    p_dplib     IN  dossier_projet.dplib%TYPE,
                                    p_flaglock  IN  NUMBER,
                                    p_userid    IN  VARCHAR2,
                                    p_dateimmo	IN  VARCHAR2,
                                    p_actif	IN  VARCHAR2,
				    p_dptype    IN  type_dossier_projet.typdp%TYPE,
                                    p_nbcurseur OUT INTEGER,
                                    p_message   OUT VARCHAR2
                                   ) IS

     l_msg VARCHAR2(1024);
     l_new_dateimmo DATE;
     l_old_dateimmo DATE;
     l_datdebex DATE;
     referential_integrity EXCEPTION;
     PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      -- Si la date de saisie est différente de la précédente valeur
      -- et qu'elle est inférieure à l'année en cours, on renvoie une erreur
      SELECT datdebex INTO l_datdebex
      FROM datdebex
      WHERE ROWNUM<2;

      l_new_dateimmo := TO_DATE(p_dateimmo, 'FMDD/MM/YYYY');
      SELECT datimmo INTO l_old_dateimmo
      FROM dossier_projet
      WHERE dpcode = p_dpcode;


      IF (l_new_dateimmo IS NOT NULL) AND (TO_CHAR(l_new_dateimmo, 'FMDD/MM/YYYY') <> TO_CHAR(NVL(l_old_dateimmo, TO_DATE('01/01/1900', 'FMDD/MM/YYYY')), 'FMDD/MM/YYYY')) THEN
      	  IF (TO_NUMBER(TO_CHAR(l_new_dateimmo,'YYYY')) < TO_NUMBER(TO_CHAR(l_datdebex, 'YYYY'))) THEN
      	    pack_global.recuperer_message( 20927, NULL, NULL, NULL, l_msg);
      	    raise_application_error( -20927, l_msg );
      	  END IF;
      END IF;


      BEGIN
         UPDATE dossier_projet SET dpcode = p_dpcode,
                                   dplib  = p_dplib,
                                   datimmo = l_new_dateimmo,
                                   actif = p_actif,
				   typdp = p_dptype,
                                   flaglock = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE dpcode = p_dpcode;

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2291);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message( 2029, '%s1', p_dpcode, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END update_dossier_projet;


-- *********************************************************************************
--       Procedure   SUPPRESSION  DOSSIER PROJET
-- *********************************************************************************

   PROCEDURE delete_dossier_projet (p_dpcode    IN  VARCHAR2,
                                    p_flaglock  IN  NUMBER,
                                    p_userid    IN  VARCHAR2,
                                    p_nbcurseur OUT INTEGER,
                                    p_message   OUT VARCHAR2
                                   ) IS

      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM dossier_projet
                WHERE dpcode = p_dpcode
                AND flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2292);
         WHEN OTHERS THEN
            raise_application_error (-20997, SQLERRM);

      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message( 2099, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message( 2030, '%s1', p_dpcode, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END delete_dossier_projet;


-- *********************************************************************************
--       Procedure   SELECTION  DOSSIER PROJET
-- *********************************************************************************

   PROCEDURE select_dossier_projet (p_dpcode            IN VARCHAR2,
                                    p_userid            IN VARCHAR2,
                                    p_curdossier_projet IN OUT dossier_projetCurType,
                                    p_nbcurseur         OUT INTEGER,
                                    p_message           OUT VARCHAR2
                                   ) IS

      l_msg VARCHAR2(1024);

   BEGIN
      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur := 1;
      p_message := '';
      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curdossier_projet FOR
              SELECT *
              FROM DOSSIER_PROJET
              WHERE dpcode = p_dpcode;

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;
      -- en cas absence
      -- p_message := 'Le centre d'activité n'existe pas';
      pack_global.recuperer_message( 2031, '%s1', p_dpcode, NULL, l_msg);
      p_message := l_msg;

   END select_dossier_projet;

END pack_dossier_projet;
/
CREATE OR REPLACE PACKAGE pack_ecartsbud AS
  -- ------------------------------------------------------------------------
  -- Decription :  Permet de déterminer le type d'alerte sur les écarts budgétaires
  -- Paramètres :  p_param6 (IN) situ_ress.codsg%type: code dpg
  -- param10 classement du report
  -- param
  --               p_message (out) varchar2
  --               p_alerte  (out) varchar2 (type d'écart budgétaire)
  -- Retour     :  renvoie rien si ok, erreur sinon
  -- ------------------------------------------------------------------------


FUNCTION  verif_reecons(p_reestime IN number,
			p_consomme IN number
			) return VARCHAR2;

FUNCTION  verif_reearb( p_reestime IN number,
			p_arbitre IN number
			) return VARCHAR2;

FUNCTION  verif_conso_sans_budget(p_consomme IN number,
				  p_arbitre IN number,
				  p_propose IN number,
				  p_notifie IN number
				) return VARCHAR2;

END pack_ecartsbud;
/

CREATE OR REPLACE PACKAGE BODY pack_ecartsbud AS

  -- ------------------------------------------------------------------------
  --
  -- ------------------------------------------------------------------------

-- ---------------------------------------------------
FUNCTION  verif_reecons(p_reestime IN number,
			p_consomme IN number
			) RETURN VARCHAR2 IS

  l_msg VARCHAR2(1024) :='';
  p_alerte VARCHAR2(20);

BEGIN

 	if (p_reestime < p_consomme)
 	then
      		p_alerte := 'Estimé à revoir';
      	else 	p_alerte := '';
  	end if;

  	return p_alerte;

END verif_reecons;
-- ---------------------------------------------------
FUNCTION  verif_reearb(	p_reestime IN number,
			p_arbitre IN number
			) RETURN VARCHAR2 IS

  l_msg VARCHAR2(1024) :='';
  p_alerte VARCHAR2(20);

BEGIN

 	if (p_reestime > p_arbitre)
 	then
      		p_alerte := 'A justifier';
      	else 	p_alerte := '';
  	end if;

  	return p_alerte;

END verif_reearb;
-- ----------------------------------------------------
FUNCTION  verif_conso_sans_budget(p_consomme IN number,
				  p_arbitre IN number,
				  p_propose IN number,
				  p_notifie IN number
				  ) RETURN VARCHAR2 IS

  l_msg VARCHAR2(1024) :='';
  p_alerte VARCHAR2(20);

BEGIN
 	if ((p_consomme > 0) and ( p_arbitre = 0 and p_propose =0 and p_notifie = 0 )	)
 	then
      		p_alerte := 'Conso sans budget';
      	else 	p_alerte := '';
  	end if;
  	return p_alerte;

END verif_conso_sans_budget;
-- ----------------------------------------------------
END pack_ecartsbud;
/
CREATE OR REPLACE PACKAGE pack_ens_appli AS

   TYPE ens_appli_ViewType IS RECORD(	cod_ea  VARCHAR2(2),
                                   	lib_ea  ensemble_applicatif.lib_ea%TYPE,
                                   	topfer	ensemble_applicatif.topfer%TYPE
				  );

   TYPE ens_appli_CurType IS REF CURSOR RETURN ens_appli_ViewType;


   PROCEDURE insert_ens_appli(	p_cod_ea     	in VARCHAR2,
                         	 p_lib_ea 	in ensemble_applicatif.lib_ea%TYPE,
                         	 p_topfer	IN  ensemble_applicatif.topfer%TYPE,
                         	 p_message   	out VARCHAR2
                            );

   PROCEDURE update_ens_appli(	p_cod_ea    	IN  VARCHAR2,
                            	p_lib_ea 	IN  ensemble_applicatif.lib_ea%TYPE,
                            	p_topfer	IN  ensemble_applicatif.topfer%TYPE,
                            	p_message   	OUT VARCHAR2
                              );

   PROCEDURE delete_ens_appli(	p_cod_ea    	in VARCHAR2,
                            	p_lib_ea 	in ensemble_applicatif.lib_ea%TYPE,
                            	p_message   	out VARCHAR2
                                   );

   PROCEDURE select_ens_appli(	p_cod_ea  	in     VARCHAR2,
                              	p_curseur 	IN OUT ens_appli_CurType,
                              	p_message 	out    VARCHAR2
                                );

   PROCEDURE select_num_ens_appli (
                              	p_num_ea 	OUT 	VARCHAR2,
                              	p_message 	OUT    	VARCHAR2
                                );

   PROCEDURE lister_ens_appli (p_curseur 	IN OUT ens_appli_CurType,
                              	p_message 	out    VARCHAR2
                                );

END pack_ens_appli;
/

CREATE OR REPLACE PACKAGE BODY pack_ens_appli AS

  PROCEDURE insert_ens_appli(	p_cod_ea     	in VARCHAR2,
                         	p_lib_ea 	in ensemble_applicatif.lib_ea%TYPE,
                         	p_topfer	IN ensemble_applicatif.topfer%TYPE,
                         	p_message   	out VARCHAR2
                                 ) IS
       l_msg VARCHAR2(1024);

       BEGIN
          p_message := '';

           -- création de l'ensemble applicatif
           INSERT INTO ensemble_applicatif(cod_ea, lib_ea, topfer)
           VALUES (p_cod_ea, p_lib_ea, p_topfer);

           pack_global.recuperer_message(20971, '%s1', 'Ensemble applicatif ' || p_lib_ea, NULL, l_msg);
           p_message := l_msg;

       END insert_ens_appli;


   PROCEDURE update_ens_appli(	p_cod_ea    	IN  VARCHAR2,
                            	p_lib_ea 	IN  ensemble_applicatif.lib_ea%TYPE,
                            	p_topfer	IN  ensemble_applicatif.topfer%TYPE,
                            	p_message   	OUT VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       l_ens_appli ensemble_applicatif.cod_ea%TYPE;

       BEGIN
       p_message := '';


          BEGIN
            SELECT cod_ea INTO l_ens_appli
            FROM ensemble_applicatif WHERE cod_ea=to_number(p_cod_ea);

            UPDATE ensemble_applicatif SET
            	lib_ea = p_lib_ea,
            	topfer = p_topfer
            WHERE cod_ea = TO_NUMBER(p_cod_ea);

            -- 'Domaine bancaire modifié
            pack_global.recuperer_message(20972, '%s1', 'Ensemble Applicatif ' || p_lib_ea, NULL, l_msg);
            p_message := l_msg;

          EXCEPTION
            WHEN NO_DATA_FOUND THEN
                pack_global.recuperer_message( 20969, '%s1', p_lib_ea, NULL, l_msg);
                p_message := l_msg;
                raise_application_error( -20969, l_msg );
            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

          END;

       END update_ens_appli;



   PROCEDURE delete_ens_appli (p_cod_ea    	in VARCHAR2,
                            	  p_lib_ea 	in ensemble_applicatif.lib_ea%TYPE,
                            	  p_message   	out VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       referential_integrity EXCEPTION;
       PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

       BEGIN
          -- Initialiser le message retour
          p_message := '';

          BEGIN
        	   DELETE FROM ensemble_applicatif
        		      WHERE cod_ea = TO_NUMBER(p_cod_ea);
          EXCEPTION
               	WHEN referential_integrity THEN
               		-- habiller le msg erreur
               		pack_global.recuperer_message( 20199, '%s1', p_lib_ea, '%s2', 'un domaine bancaire', NULL, l_msg);
               		p_message := l_msg;
               		raise_application_error( -20199, l_msg );
        	WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
          END;

          IF SQL%NOTFOUND THEN
    	   -- Pas de données trouvées
    	    pack_global.recuperer_message( 20969, '%s1', p_lib_ea, NULL, l_msg);
            raise_application_error( -20969, l_msg );
          ELSE
    	   -- 'L'ensemble applicatif p_lib_ba a été supprimé'
    	   pack_global.recuperer_message( 20973, '%s1', 'Ensemble Applicatif' || p_lib_ea, NULL, l_msg);
          END IF;

          p_message := l_msg;

       END delete_ens_appli;




   PROCEDURE select_ens_appli (p_cod_ea  	in     VARCHAR2,
                              	p_curseur 	IN OUT ens_appli_CurType,
                              	p_message 	out    VARCHAR2
                                )IS
       l_msg VARCHAR2(1024);

       BEGIN

              OPEN p_curseur FOR SELECT
                   TO_CHAR(cod_ea) as cod_ea,
                   lib_ea,
                   topfer
              FROM  ensemble_applicatif
              WHERE cod_ea = TO_NUMBER(p_cod_ea);

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);


   END select_ens_appli;


   PROCEDURE lister_ens_appli (p_curseur 	IN OUT ens_appli_CurType,
                              	p_message 	out    VARCHAR2
                                ) IS
   l_msg VARCHAR2(1024);

   BEGIN

              OPEN p_curseur FOR SELECT
                   TO_CHAR(cod_ea) as cod_ea,
                   lib_ea,
                   topfer
              FROM  ensemble_applicatif
              WHERE topfer = 'O';

   END lister_ens_appli;

   PROCEDURE select_num_ens_appli (
                              	p_num_ea 	OUT 	VARCHAR2,
                              	p_message 	OUT    	VARCHAR2
                                )IS

       BEGIN

              SELECT
                   TO_CHAR(NVL(MAX(cod_ea), 0) + 1) INTO p_num_ea
              FROM  ensemble_applicatif;

       EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);


       END select_num_ens_appli;


END pack_ens_appli;
/
CREATE OR REPLACE PACKAGE pack_esourcing IS

/* procedure d'insertion/controle des contrats envoyés par esourcing */
PROCEDURE create_contrat(P_HFILE utl_file.file_type);

/* procedure d'insertion/controle des lignes de contrats envoyés par esourcing */
PROCEDURE create_ligne_cont(P_HFILE utl_file.file_type);

/* procedure d'insertion/suppression des contrats et lignes contrat traités */
PROCEDURE historise_contrat(P_HFILE utl_file.file_type);

------------------------------------------------------------
-- Cette procedure met à jour ou crée les ressources
-- envoyées par l'outil eSourcing
------------------------------------------------------------
	PROCEDURE alim_ressource (P_HFILE utl_file.file_type) ;

------------------------------------------------------------
-- Cette procedure crée les situations associées
-- aux ressources
------------------------------------------------------------
	PROCEDURE alim_situ (P_HFILE utl_file.file_type);

------------------------------------------------------------
-- Cette procedure archive les données concernant
-- les ressources (conservées 2 mois)
------------------------------------------------------------
	PROCEDURE archive_esourcing(P_HFILE utl_file.file_type);

------------------------------------------------------------
-- Cette procedure supprime les ressources crees
-- sans situation
------------------------------------------------------------
	PROCEDURE verif_ress (P_HFILE utl_file.file_type);

/* procedure générale permettant le lancement des procédures d'insertions des données pour les ressources*/
PROCEDURE global_ressource (P_LOGDIR VARCHAR2);


/* procedure générale permettant le lancement des procédures d'insertions des données pour les contrats*/
PROCEDURE global_contrat (P_LOGDIR VARCHAR2);

END pack_esourcing;
/

CREATE OR REPLACE PACKAGE BODY pack_esourcing IS

		-- Gestions exceptions
	-- -------------------
	CALLEE_FAILED exception;
	pragma exception_init( CALLEE_FAILED, -20000 );
	CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
	TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
	ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
	CONSTRAINT_VIOLATION exception;          -- pour clause when
	pragma exception_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
	CALLEE_FAILED exception;
	pragma exception_init( CALLEE_FAILED, -20000 );


PROCEDURE create_contrat (P_HFILE utl_file.file_type) IS

	L_PROCNAME varchar2(30):='CREATE_CONTRAT';
	L_ORAERRMSG varchar2(150);
	L_CNAFFAIR contrat.cnaffair%TYPE;
	L_RETOUR tmp_contrat.retour%TYPE;
	L_FILCODE contrat.filcode%TYPE;
	L_CENTREFRAIS contrat.ccentrefrais%TYPE;
	L_SOCIETE societe.soccode%TYPE;
	l_date_courante VARCHAR2(8);
	l_date_fer VARCHAR2(8);

	L_TAMPON  number(2);

	L_VALIDATION CHAR(2);

	CURSOR cr_cont IS
	SELECT ID_OALIA,UPPER(NUMCONT) numcont,CAV,DPG,
		UPPER(SOCCONT) soccont,CAGREMENT,DATARR,
		OBJET,COMCODE,TYPEFACT,COUTOT,CHARESTI,DATDEB,DATFIN
	FROM TMP_CONTRAT
	;

	BEGIN
		TRCLOG.TRCLOG( P_HFILE, '!!!!!!!!!!!!!!!!!!!!  Debut du traitement d insertion des CONTRATS  !!!!!!!!!!!!!!!!!!!!');

		-- parcours du curseur pour insertion, vérification des règles, retours

		FOR enr_cour IN cr_cont LOOP
			TRCLOG.TRCLOG( P_HFILE, '********  Debut insertion contrat: '||enr_cour.numcont||' ,id oalia: '||enr_cour.id_oalia);

			BEGIN
         			L_VALIDATION:='OK';

         			/*  */
         			IF enr_cour.cav = '00' THEN
         				L_CNAFFAIR:='OUI';
         			ELSE
         				L_CNAFFAIR:='NON';
         			END IF;

         			BEGIN
         				SELECT 1 INTO L_TAMPON
         				FROM code_compt
         				WHERE comcode=enr_cour.comcode;
				EXCEPTION
         				WHEN NO_DATA_FOUND THEN
         				TRCLOG.TRCLOG( P_HFILE, 'le code comptable : '||enr_cour.comcode||' n existe pas.');
         				L_RETOUR:='Code comptable inexistant';
         				L_VALIDATION:='ER';
         			END;

         			IF NVL(enr_cour.typefact,' ')<>'R' THEN
         				TRCLOG.TRCLOG( P_HFILE, 'Type de facturation non valide.');
         				L_RETOUR:='Type de facturation non valide.';
         				L_VALIDATION:='ER';
         			END IF;

         			BEGIN
         				SELECT scentrefrais,filcode INTO L_CENTREFRAIS,L_FILCODE
         				FROM struct_info
         				where codsg=enr_cour.dpg;

         			EXCEPTION
         				WHEN NO_DATA_FOUND THEN
         					TRCLOG.TRCLOG( P_HFILE, 'le code DPG : '||enr_cour.dpg||' n est pas correct.');
         					TRCLOG.TRCLOG( P_HFILE, 'Probleme pour récupérer le centre de frais ou le code filiale.');
         					L_RETOUR:='Pb avec centre de frais ou filcode ou DPG.';
         					L_VALIDATION:='ER';
         			END;

         			-- controle de la societe

				SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      				INTO l_date_courante
      				FROM DUAL;

      				l_date_fer := '00';

      				BEGIN
					SELECT TO_CHAR(socfer,'yyyymmdd')
         				INTO l_date_fer
         				FROM societe
         				WHERE soccode = enr_cour.soccont;
         			EXCEPTION
         				WHEN NO_DATA_FOUND THEN
         					TRCLOG.TRCLOG( P_HFILE, 'le code societe : '||enr_cour.soccont||' n est pas correct.');
         					L_RETOUR:='Pb avec la societe';
         					L_VALIDATION:='ER';
         			END;

         			IF l_date_fer <> '00' and l_date_fer <= l_date_courante THEN
         				L_RETOUR:='Code société fermé';
         				L_VALIDATION:='ER';
         			END IF;

         			IF enr_cour.datdeb>enr_cour.datfin THEN
         				TRCLOG.TRCLOG( P_HFILE, 'La date de début est supérieure à la date de fin.');
         				L_RETOUR:='Date de fin inférieure à date de debut contrat';
         				L_VALIDATION:='ER';
         			END IF;

        			-- controle de l'existence du contrat

         			BEGIN

         				SELECT 1 INTO L_TAMPON
         				FROM contrat c
         				WHERE RTRIM(c.numcont)=RTRIM(UPPER(enr_cour.numcont))
         				AND c.cav=enr_cour.cav
         				AND RTRIM(c.soccont)=RTRIM(UPPER(enr_cour.soccont));


         				IF L_TAMPON=1 THEN
         					TRCLOG.TRCLOG( P_HFILE, 'le contrat existe déjà. Création impossible.');
         					L_RETOUR:='Contrat existe déjà. Création impossible.';
         					L_VALIDATION:='ER';
         				END IF;

         			EXCEPTION
         				WHEN NO_DATA_FOUND THEN
         					IF L_VALIDATION='OK' THEN
         						TRCLOG.TRCLOG( P_HFILE, 'Contrat nouveau, insertion à effectuer');
         					ELSE
         						TRCLOG.TRCLOG( P_HFILE, 'Contrat nouveau mais impossible à insérer');
         					END IF;
         			END;


         			IF L_VALIDATION='OK' THEN

         				TRCLOG.TRCLOG( P_HFILE, 'Insertion du contrat');

         				INSERT INTO contrat(numcont,cchtsoc,ctypfact,cobjet1,cobjet2,cobjet3,crem,cantfact,cmoiderfac,cmmens,
         						ccharesti,cecartht,cevainit,cnaffair,cagrement,crang,cantcons,ccoutht,cdatannul,cdatarr,
         						cdatclot,cdatdeb,cdatsoce,cdatfin,cdatmaj,cdatdir,cdatbilq,cdatrpol,cdatsocr,cdatsai,
         						cduree,flaglock,soccont,cav,filcode,comcode,niche,codsg,ccentrefrais)
         				VALUES (
         				UPPER(enr_cour.numcont),
         				NULL,
         				enr_cour.typefact,
         				SUBSTR(enr_cour.objet,1,50),
         				SUBSTR(enr_cour.objet,51,50),
         				NULL,
         				NULL,
         				NULL,
         				NULL,
         				NULL,
         				enr_cour.charesti,
         				NULL,
         				NULL,
         				L_CNAFFAIR,
         				enr_cour.cagrement,
         				NULL,
         				0,
         				enr_cour.coutot,
         				NULL,
         				enr_cour.datarr,
         				NULL,
         				enr_cour.datdeb,
         				NULL,
         				enr_cour.datfin,
         				NULL,
         				sysdate,
         				NULL,
         				sysdate,
         				NULL,
         				sysdate,
         				NULL,
         				0,
         				UPPER(enr_cour.soccont),
         				enr_cour.cav,
         				NVL(L_FILCODE,'01'),
         				enr_cour.comcode,
         				NULL,
         				enr_cour.dpg,
         				L_CENTREFRAIS
         				);

         				L_RETOUR:='INSERTION OK';
         			END IF;

         			UPDATE tmp_contrat
				SET retour=L_RETOUR,
				    date_trait=sysdate
				WHERE tmp_contrat.id_oalia=enr_cour.id_oalia;

         			COMMIT;

			EXCEPTION
				WHEN CONSTRAINT_VIOLATION THEN

					L_ORAERRMSG:=sqlerrm;

					UPDATE tmp_contrat
					SET retour=SUBSTR(L_ORAERRMSG,1,49),
					    date_trait=sysdate
					WHERE tmp_contrat.id_oalia=enr_cour.id_oalia;

					COMMIT;

					TRCLOG.TRCLOG( P_HFILE, 'Contrat, violation de contrainte pour id_oalia: '||enr_cour.id_oalia);
					TRCLOG.TRCLOG( P_HFILE, sqlerrm);

				WHEN others THEN

					L_ORAERRMSG:=sqlerrm;

					UPDATE tmp_contrat
					SET retour=SUBSTR(L_ORAERRMSG,1,49),
					    date_trait=sysdate
					WHERE tmp_contrat.id_oalia=enr_cour.id_oalia;

					COMMIT;
					TRCLOG.TRCLOG( P_HFILE, 'Contrat, probleme lors de l insert'||enr_cour.id_oalia);
					TRCLOG.TRCLOG( P_HFILE, sqlerrm);


			END;
		END LOOP;


	EXCEPTION
		WHEN others THEN
			TRCLOG.TRCLOG( P_HFILE, '**********************************************************');
			TRCLOG.TRCLOG( P_HFILE, 'Probleme lors de l insertion des contrats _ Arret du batch');
			TRCLOG.TRCLOG( P_HFILE, sqlerrm);
			TRCLOG.TRCLOG( P_HFILE, '**********************************************************');

	END;

PROCEDURE create_ligne_cont(P_HFILE utl_file.file_type) IS

	L_PROCNAME varchar2(30):='CREATE_LIGNE_CONT';
	L_ORAERRMSG varchar2(150);
	L_RETOUR tmp_ligne_cont.retour%TYPE;
	L_VALIDATION CHAR(2);
	L_CDATDEB contrat.cdatdeb%TYPE;
	L_CDATFIN contrat.cdatfin%TYPE;
	L_MAXLCNUM ligne_cont.lcnum%TYPE;

	L_TAMPON  number(2);

	CURSOR cr_ligne_cont IS
	SELECT  id_oalia,
		ident,
		UPPER(numcont) numcont,
		cav,
		UPPER(soccont) soccont,
		coutht,
		datdeb,
		datfin,
		proporig,
		qualif
	FROM tmp_ligne_cont
	ORDER BY numcont,cav,soccont,ident,datdeb,datfin
	;

	BEGIN
		TRCLOG.TRCLOG( P_HFILE,' ');
		TRCLOG.TRCLOG( P_HFILE, '!!!!!!!!!!!!!!!!!!  Debut du traitement d insertion des LIGNES DE CONTRATS  !!!!!!!!!!!!!!!!!!');

		FOR enr_cour IN cr_ligne_cont LOOP
			TRCLOG.TRCLOG( P_HFILE, '********  Debut insertion ligne contrat: '||enr_cour.numcont||' ,id oalia: '||enr_cour.id_oalia);
			TRCLOG.TRCLOG( P_HFILE, 'Contrat: '||enr_cour.numcont||' ,id oalia: '||enr_cour.id_oalia);
			BEGIN
         			L_VALIDATION:='OK';
         			L_RETOUR:=NULL;
         			L_CDATDEB:=NULL;
				L_CDATFIN:=NULL;
				L_MAXLCNUM:=0;
				L_TAMPON:=NULL;

				--Vérification de la valeur du coût
				IF enr_cour.coutht IS NULL THEN
					TRCLOG.TRCLOG( P_HFILE, 'Le coût hors taxe est null, il doit être renseigné');
					L_VALIDATION:='ER';
					L_RETOUR:='cout HT non valide';
				END IF;

				-- Vérification de l'existence du contrat et de la validité des dates
				BEGIN
   			         	SELECT c.cdatdeb, c.cdatfin
            				INTO   l_cdatdeb, l_cdatfin
            				FROM   contrat c
            				WHERE RTRIM(UPPER(enr_cour.numcont))=RTRIM(c.numcont)
					AND RTRIM(enr_cour.cav)=RTRIM(c.cav)
					AND RTRIM(UPPER(enr_cour.soccont))=RTRIM(c.soccont);

         			EXCEPTION
         			WHEN NO_DATA_FOUND THEN
                   			TRCLOG.TRCLOG( P_HFILE, 'le contrat : '||enr_cour.numcont||' , '||enr_cour.cav||' , '||enr_cour.soccont||' n existe pas.');
         				L_RETOUR:='Contrat inexistant';
         				L_VALIDATION:='ER';
            			--WHEN OTHERS THEN
                			   --raise_application_error(-20997,SQLERRM);
         			END;

			        IF enr_cour.datdeb > enr_cour.datfin THEN
            				-- La date de fin doit être supérieure ou égale à la date de début
            				TRCLOG.TRCLOG( P_HFILE, 'La date de fin doit etre superieure a la date de debut');
         				L_RETOUR:='La date de fin doit etre superieure a la date de debut';
         				L_VALIDATION:='ER';

			        ELSIF  ( enr_cour.datdeb < L_CDATDEB ) OR
                			( enr_cour.datdeb > L_CDATFIN ) OR
               				 ( enr_cour.datfin < L_CDATDEB ) OR
                			( enr_cour.datfin > L_CDATFIN ) THEN

            			-- message : Dates de début et de fin de prestation doivent être comprises
            			-- entre dates de début et de fin de contrat.
            				TRCLOG.TRCLOG( P_HFILE, 'Date debut et fin de prestation non comprises entre date de fin et debut de contrat');
         				L_RETOUR:='Date deb-fin prest non comprises date deb-fin cont';
         				L_VALIDATION:='ER';

			        END IF;

         			-- Test d'existence de la ressource
         			BEGIN
         				SELECT 1 INTO L_TAMPON
         				FROM ressource
         				WHERE ressource.ident=enr_cour.ident;
         			EXCEPTION
         				WHEN NO_DATA_FOUND THEN
         					TRCLOG.TRCLOG( P_HFILE, 'la ressource : '||enr_cour.ident||' n existe pas.');
         					L_RETOUR:='Ressource inexistante';
         					L_VALIDATION:='ER';
         			END;

				-- calcul du numero de ligne
				BEGIN
         				SELECT max(l.lcnum)
         				INTO   L_MAXLCNUM
         				FROM   ligne_cont l
         				WHERE  RTRIM(l.soccont) = RTRIM(UPPER(enr_cour.soccont))
           				AND  RTRIM(l.numcont) = RTRIM(UPPER(enr_cour.numcont))
           				AND  RTRIM(l.cav) = RTRIM(enr_cour.cav);

      				EXCEPTION
      					WHEN OTHERS THEN
         				   	TRCLOG.TRCLOG( P_HFILE, 'Erreur lors du calcul du numero de ligne ');
         				   	L_RETOUR:='Erreur lors du calcul nu numero de ligne';
         				   	L_VALIDATION:='ER';
      				END;


         			L_MAXLCNUM := NVL(L_MAXLCNUM,0)+1;

      				IF L_VALIDATION='OK' THEN
      					INSERT INTO ligne_cont(lcnum,lfraisdep,lastreinte,lheursup,lresdeb,lresfin,lcdatact,lccouact,
								lccouinit,lcprest,soccont,cav,numcont,ident,proporig)
					VALUES
					(L_MAXLCNUM,
					NULL,
					NULL,
					NULL,
					enr_cour.datdeb,
					enr_cour.datfin,
					NULL,
					enr_cour.coutht,
					NULL,
					enr_cour.qualif,
					UPPER(enr_cour.soccont),
					enr_cour.cav,
					UPPER(enr_cour.numcont),
					enr_cour.ident,
					enr_cour.proporig
					);

					L_RETOUR:='INSERTION OK';
				END IF;



				UPDATE tmp_ligne_cont
				SET retour=L_RETOUR,
				   date_trait=sysdate
				WHERE tmp_ligne_cont.id_oalia=enr_cour.id_oalia;

         			COMMIT;

			EXCEPTION
				WHEN CONSTRAINT_VIOLATION THEN

					L_ORAERRMSG:=sqlerrm;

					UPDATE tmp_ligne_cont
					SET retour=SUBSTR(L_ORAERRMSG,1,50),
					    date_trait=sysdate
					WHERE tmp_ligne_cont.id_oalia=enr_cour.id_oalia;

					COMMIT;

					TRCLOG.TRCLOG( P_HFILE, 'Ligne contrat, violation de contrainte pour id_oalia: '||enr_cour.id_oalia);
					TRCLOG.TRCLOG( P_HFILE, sqlerrm);

				WHEN others THEN

					TRCLOG.TRCLOG( P_HFILE, 'Ligne contrat, probleme lors de l insertion de : '||enr_cour.id_oalia);
					TRCLOG.TRCLOG( P_HFILE, 'Numcont: '||enr_cour.numcont||', soccont: '||enr_cour.soccont||', avenant: '||enr_cour.cav||', N° ligne: '||L_MAXLCNUM);
					TRCLOG.TRCLOG( P_HFILE, sqlerrm);

					L_ORAERRMSG:=sqlerrm;

					UPDATE tmp_ligne_cont
					SET retour=SUBSTR(L_ORAERRMSG,1,50),
					    date_trait=sysdate
					WHERE tmp_ligne_cont.id_oalia=enr_cour.id_oalia;

					COMMIT;


			END;


		END LOOP;

		EXCEPTION
		WHEN others THEN
			TRCLOG.TRCLOG( P_HFILE, '**********************************************************');
			TRCLOG.TRCLOG( P_HFILE, 'Probleme lors de l insertion des lignes contrat _ Arret du batch');
			TRCLOG.TRCLOG( P_HFILE, sqlerrm);
			TRCLOG.TRCLOG( P_HFILE, '**********************************************************');

	END;

PROCEDURE historise_contrat(P_HFILE utl_file.file_type) IS

	L_TAMPON NUMBER(3);


	CURSOR cr_histo IS
		SELECT id_oalia_cont,id_oalia_ligne,soccont,numcont,cav,ident,codsg,datdeb,datfin,proporig,date_trait,retour
		FROM esourcing_contrat;


	BEGIN
		TRCLOG.TRCLOG( P_HFILE, '!!!!!!!!!!!!!!!!!!  Debut du traitement d historisation des enregistrements contrat et ligne contrats  !!!!!!!!!!!!!!!!!!');
		-- Suppression des enregistrements antérieurs de 15 jours à la date du jour

		TRCLOG.TRCLOG( P_HFILE,'Suppression des enregistrements anterieurs de 15 jours à la date du jour');

		BEGIN

			DELETE esourcing_contrat
			WHERE date_trait<sysdate-14;

			COMMIT;

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				TRCLOG.TRCLOG( P_HFILE,'Pas d enregistrement à supprimer.');

		END;

		TRCLOG.TRCLOG( P_HFILE,'Verification des correspondances contrats / lignes contrats dans les tables temporaires.');

		SELECT COUNT(*) INTO L_TAMPON
		FROM tmp_contrat
		WHERE (numcont,soccont,cav) NOT IN (SELECT numcont,soccont,cav FROM tmp_ligne_cont);

		IF L_TAMPON<>0 THEN
			TRCLOG.TRCLOG( P_HFILE,'Certains contrats ne sont pas rattachés à des lignes');
		END IF;

		SELECT COUNT(*) INTO L_TAMPON
		FROM tmp_ligne_cont
		WHERE (numcont,soccont,cav) NOT IN (SELECT numcont,soccont,cav FROM tmp_contrat);

		IF L_TAMPON<>0 THEN
			TRCLOG.TRCLOG( P_HFILE,'Certaines lignes ne sont pas rattachées à des contrats');
		END IF;

		TRCLOG.TRCLOG( P_HFILE,'Insertion des données dans la table d historique');

		INSERT INTO esourcing_contrat (id_oalia_cont,id_oalia_ligne,soccont,numcont,cav,ident,codsg,datdeb,datfin,proporig,date_trait,retour)
		SELECT 	c.id_oalia,
			l.id_oalia,
			c.soccont,
			c.numcont,
			c.cav,
			l.ident,
			c.dpg,
			l.datdeb,
			l.datfin,
			l.proporig,
			DECODE(c.RETOUR,'INSERTION OK',l.date_trait,c.date_trait) datetrait,
			DECODE(c.RETOUR,'INSERTION OK',l.RETOUR, c.retour) message
		FROM
			tmp_contrat c,
			tmp_ligne_cont l
		WHERE
			c.soccont=l.soccont
		AND	c.numcont=l.numcont
		AND	c.cav=l.cav
		;


		COMMIT;


	EXCEPTION
		WHEN others THEN
			TRCLOG.TRCLOG( P_HFILE, '**********************************************************');
			TRCLOG.TRCLOG( P_HFILE, 'Probleme lors de l historisation des enregistrements _ Arret du batch');
			TRCLOG.TRCLOG( P_HFILE, sqlerrm);
			TRCLOG.TRCLOG( P_HFILE, '**********************************************************');


END;

--------------------------------------------------------------------------------------
-- PROCEDURE DE MAJ ET DE CREATION DES RESSOURCES
--------------------------------------------------------------------------------------
PROCEDURE alim_ressource (P_HFILE utl_file.file_type)  IS

L_MATRICULE ressource.matricule%TYPE;
L_IDENT ressource.ident%TYPE;
L_TEST NUMBER;
L_CODE_RETOUR tmp_ressource.code_retour%TYPE;
L_ORA VARCHAR2(200);
L_RETOUR tmp_ressource.retour%TYPE;
referential_integrity EXCEPTION;
PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

L_RETCOD    number;
L_PROCNAME  varchar2(256) := 'alim_ressource';
L_STATEMENT varchar2(256);
BEGIN

	-----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------
	TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

	-- on renseigne les codes retour dans la table temporaire
				-- test format du matricule : commence par X
				UPDATE TMP_RESSOURCE
				SET CODE_RETOUR=1,RETOUR='Matricule doit commencer par X'
				WHERE UPPER(SUBSTR(matricule,0,1)) <> 'X';
				COMMIT;

				-- Matricule en doublon dans le fichier envoye par esourcing
				UPDATE TMP_RESSOURCE tmp
				SET CODE_RETOUR=1,RETOUR='Matricule en doublon'
				WHERE EXISTS (SELECT distinct 1 FROM tmp_ressource r1
					WHERE UPPER(r1.matricule)=UPPER(tmp.matricule)
					AND (r1.id_oalia <> tmp.id_oalia)
	      				AND r1.CODE_RETOUR is null
	      				AND tmp.CODE_RETOUR is null);
				COMMIT;

				-- Ajuste le nom et le prénom : met des majuscules et enlève des accents
				UPDATE TMP_RESSOURCE r
				SET rnom = TRIM(TRANSLATE(upper(rnom),upper('àâéèêëîôû') , 'AAEEEEIOU')),
				 rprenom = TRIM(TRANSLATE(upper(rprenom),upper('àâéèêëîôû') , 'AAEEEEIOU'));

				-- test existence du matricule
				UPDATE TMP_RESSOURCE tmp
				SET CODE_RETOUR=1,RETOUR='Matricule existe mais pas le nom et ou le prénom'
				WHERE EXISTS (SELECT 1 FROM ressource r WHERE UPPER(tmp.matricule)=r.matricule
				AND ((r.rnom <> UPPER(tmp.rnom) AND r.rnom <> TRANSLATE(UPPER(tmp.rnom),'-',' ') )
					OR (r.rprenom <> UPPER(tmp.rprenom) AND r.rprenom <> TRANSLATE(UPPER(tmp.rprenom),'-',' ')))
				AND CODE_RETOUR is null);
				COMMIT;

				-- la ressource n'a pas de situation associée dans le fichier des situations
				UPDATE TMP_RESSOURCE tmp
				SET CODE_RETOUR=1,RETOUR='Ressource sans situation'
				WHERE NOT EXISTS (SELECT 1 FROM tmp_situation s WHERE UPPER(tmp.matricule)=UPPER(s.matricule))
				AND CODE_RETOUR is null;
				COMMIT;


				-- Nom Prénom et Matricule sont dans la Bip
				UPDATE TMP_RESSOURCE tmp
				SET CODE_RETOUR=0,RETOUR='Ressource existant dans la Bip'
				WHERE EXISTS (SELECT 1 FROM ressource r WHERE UPPER(tmp.matricule)=r.matricule
	      			AND (r.rnom = UPPER(tmp.rnom) OR r.rnom = TRANSLATE(UPPER(tmp.rnom),'-',' ') )
	      			AND (r.rprenom = UPPER(tmp.rprenom) OR r.rprenom = TRANSLATE(UPPER(tmp.rprenom),'-',' '))
	      			AND CODE_RETOUR is null);
				COMMIT;

				-- Nom et Prénom connu, Matricule inconnu : homonyme
				UPDATE TMP_RESSOURCE tmp
				SET CODE_RETOUR=2,RETOUR='Homonyme'
				WHERE EXISTS (SELECT 1 FROM ressource r WHERE UPPER(tmp.matricule)<>r.matricule
	      			AND (r.rnom = UPPER(tmp.rnom) OR r.rnom = TRANSLATE(UPPER(tmp.rnom),'-',' ') )
	      			AND (r.rprenom = UPPER(tmp.rprenom) OR r.rprenom = TRANSLATE(UPPER(tmp.rprenom),'-',' '))
	      			AND CODE_RETOUR is null);
				COMMIT;

				-- Nom/prenom inconnu, Matricule inconnu : nouvelle ressource à créer
				UPDATE TMP_RESSOURCE tmp
				SET CODE_RETOUR=2,RETOUR='Nouvelle ressource'
				WHERE NOT EXISTS (SELECT 1 FROM ressource r WHERE UPPER(tmp.matricule)=r.matricule)
				AND NOT EXISTS (SELECT 1 FROM ressource r WHERE
						(r.rnom = UPPER(tmp.rnom) OR r.rnom = TRANSLATE(UPPER(tmp.rnom),'-',' ') )
	      			AND (r.rprenom = UPPER(tmp.rprenom) OR r.rprenom = TRANSLATE(UPPER(tmp.rprenom),'-',' ')))
				AND CODE_RETOUR is null;
				COMMIT;





DECLARE
-- curseur qui parcourt la table temporaire TMP_RESSOURCE alimentée par eSourcing
CURSOR C_RESS IS SELECT ID_OALIA,MATRICULE,RNOM,RPRENOM,CODE_RETOUR
	         FROM TMP_RESSOURCE
	         ;

	BEGIN


	FOR ONE_RESS IN C_RESS LOOP

		BEGIN

         	-- test format du matricule : 6 numériques
         	SELECT TO_NUMBER(SUBSTR(ONE_RESS.matricule,2,6)) INTO L_MATRICULE
         	FROM dual;
         	EXCEPTION
		WHEN OTHERS THEN
			BEGIN
				UPDATE TMP_RESSOURCE SET CODE_RETOUR=1,RETOUR='Numériques après le X'
         			WHERE ONE_RESS.matricule = MATRICULE
         			AND ONE_RESS.ID_OALIA = ID_OALIA;
         			COMMIT;
         		END;
         	END;
        END LOOP;

        FOR ONE_RESS IN C_RESS LOOP

			TRCLOG.TRCLOG( P_HFILE, 'Debut insertion des ressources: '||ONE_RESS.matricule||' ,id oalia: '||ONE_RESS.id_oalia);

		BEGIN

         	IF ONE_RESS.CODE_RETOUR = 2 THEN
         		SELECT MAX(ident) INTO L_IDENT FROM RESSOURCE;
         		L_IDENT := L_IDENT +1;

         		INSERT INTO ressource (ident,rnom,rprenom,matricule,coutot,rtel,batiment,etage,
         		bureau,flaglock,rtype,icodimm)
         		VALUES (L_IDENT,
         		UPPER(ONE_RESS.rnom),
         		UPPER(ONE_RESS.rprenom),
         		UPPER(ONE_RESS.matricule),
         		NULL,
         		NULL,
         		NULL,
         		NULL,
         		NULL,
         		0,
         		'P',
         		NULL);
         		COMMIT;

         		UPDATE TMP_RESSOURCE SET IDENT=L_IDENT,CODE_RETOUR=0
         		WHERE ONE_RESS.matricule = MATRICULE
         		AND ONE_RESS.ID_OALIA = ID_OALIA
         		;
         		COMMIT;

         	ELSIF ONE_RESS.CODE_RETOUR=0 THEN

         		UPDATE TMP_RESSOURCE SET IDENT=(SELECT distinct r.ident FROM ressource r WHERE r.matricule=UPPER(ONE_RESS.matricule)),
         		CODE_RETOUR=0
         		WHERE ONE_RESS.matricule = MATRICULE
         		AND ONE_RESS.ID_OALIA = ID_OALIA
         		AND ONE_RESS.CODE_RETOUR = 0;
         		COMMIT;

         	END IF;

         	EXCEPTION
				WHEN referential_integrity THEN
					L_ORA:=sqlerrm;

					UPDATE tmp_ressource
					SET retour=SUBSTR(L_ORA,1,49)
					WHERE tmp_ressource.id_oalia=ONE_RESS.id_oalia;
					COMMIT;

					TRCLOG.TRCLOG( P_HFILE, 'Violation de contrainte pour id_oalia de la ressource : '||ONE_RESS.id_oalia);
					TRCLOG.TRCLOG( P_HFILE, sqlerrm);

				WHEN others THEN

					L_ORA:=sqlerrm;

					UPDATE tmp_ressource
					SET retour=SUBSTR(L_ORA,1,49)
					WHERE tmp_ressource.id_oalia=ONE_RESS.id_oalia;
					COMMIT;
					TRCLOG.TRCLOG( P_HFILE, 'Erreur lors de l insertion de la ressource '||ONE_RESS.matricule);
					TRCLOG.TRCLOG( P_HFILE, sqlerrm);

         END;
         END LOOP;
        END;

        -----------------------------------------------------
	-- Trace Stop
	-----------------------------------------------------
	TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );

	EXCEPTION
		when others then

			ROLLBACK;

			if sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
--				TRCLOG.CLOSETRCLOG( P_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

END alim_ressource;


--------------------------------------------------------------------------------------
-- PROCEDURE DE MAJ ET DE CREATION DES SITUATIONS
-- ASSOCIEES AUX RESSOURCES
--------------------------------------------------------------------------------------
PROCEDURE alim_situ (P_HFILE utl_file.file_type) IS

L_CREATION CHAR(3);
L_RETOUR tmp_ressource.retour%TYPE;
L_CODE_RETOUR tmp_ressource.code_retour%TYPE;
l_soccode societe.soccode%TYPE;
l_date_courante VARCHAR2(8);
l_date_fer VARCHAR2(8);
l_topfer struct_info.topfer%TYPE;
l_cpident ressource.ident%TYPE;
l_prestation prestation.prestation%TYPE;
l_fermee VARCHAR2(8);

L_DATARR DATE;
L_DATDEP DATE;
l_dat_fin_max VARCHAR2(8);
l_dat_dep_max VARCHAR2(8);
l_dat_deb_max VARCHAR2(8);
l_new number;


referential_integrity EXCEPTION;
PRAGMA EXCEPTION_INIT(referential_integrity, -2291);


CURSOR C_SITU IS
	SELECT  s.id_oalia,
		UPPER(s.matricule) MATRICULE,
		s.datarr,
		s.datdep,
		s.dpg,
		UPPER(s.soccode) SOCCODE,
		s.coutht,
		UPPER(s.qualif) QUALIF,
		UPPER(s.code_prest) CODE_PREST,
		s.cpident,
		r.ident
	FROM tmp_situation s,tmp_ressource r
	WHERE UPPER(s.matricule)=UPPER(r.matricule)
	AND r.CODE_RETOUR='0'
	ORDER BY datarr,datdep
	;

L_RETCOD    number;
L_PROCNAME  varchar2(256) := 'alim_situ';
L_STATEMENT varchar2(256);

BEGIN
	-----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------
	TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );


	-- pas de ressource associée pour la situation
		UPDATE TMP_SITUATION tmp
		SET CODE_RETOUR=1,RETOUR='Situation sans ressource'
		WHERE NOT EXISTS (SELECT 1 FROM tmp_ressource r WHERE UPPER(tmp.matricule)=UPPER(r.matricule)
		AND CODE_RETOUR='0');
		COMMIT;

	TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement d insertion des situations');

	FOR ONE_SITU IN C_SITU LOOP
	TRCLOG.TRCLOG( P_HFILE, 'Debut insertion de la situation de la ressource : '||ONE_SITU.ident||' ,id oalia: '||ONE_SITU.id_oalia);

	BEGIN
        	L_CREATION:='OUI';

        -- test sur le code société

			SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      			INTO l_date_courante
      			FROM DUAL;

      			l_date_fer := '00';

      		BEGIN
			SELECT TO_CHAR(socfer,'yyyymmdd')
         		INTO l_date_fer
         		FROM societe
         		WHERE soccode = ONE_SITU.soccode;
         			EXCEPTION
         			WHEN NO_DATA_FOUND THEN
                   			TRCLOG.TRCLOG(P_HFILE, 'la société : '||ONE_SITU.soccode||' n existe pas.');
                   			L_CODE_RETOUR:='1';
         				L_RETOUR:='Code société inconnu';
         				L_CREATION:='NON';
         	END;

         		IF l_date_fer <> '00' and l_date_fer <= l_date_courante THEN
         			L_CODE_RETOUR:='1';
         			L_RETOUR:='Code société fermé';
         			L_CREATION:='NON';
         		END IF;


         -- test sur le chef de projet : identifiant doit exister dans la BIP
         	BEGIN
			SELECT ident
         		INTO l_cpident
         		FROM ressource
         		WHERE ident = to_number(ONE_SITU.cpident);
         			EXCEPTION
         			WHEN NO_DATA_FOUND THEN
                   			TRCLOG.TRCLOG( P_HFILE, 'l''identifiant chef de projet : '||ONE_SITU.cpident||' n existe pas.');
                   			L_CODE_RETOUR:='1';
         				L_RETOUR:='Code chef de projet inconnu';
         				L_CREATION:='NON';
         	END;


	-- test du code prestation
		BEGIN
			SELECT prestation
         		INTO l_prestation
         		FROM prestation
          		WHERE upper(top_actif)='O'
          		AND RTRIM(prestation) = RTRIM(ONE_SITU.qualif);
         			EXCEPTION
         			WHEN NO_DATA_FOUND THEN
                   			TRCLOG.TRCLOG( P_HFILE, 'la prestation : '||ONE_SITU.qualif||' n existe pas.');
                   			L_CODE_RETOUR:='1';
         				L_RETOUR:='Prestation inconnue';
         				L_CREATION:='NON';
         	END;


-- cas d'erreur : la date de départ ou d'arrivée n'est pas renseignée
-- la date d'arrivée est supérieure à la date de départ
IF ONE_SITU.DATARR is null THEN
	L_CODE_RETOUR:='1';
	L_RETOUR:='Date d''arrivée non renseignée';
        L_CREATION:='NON';
ELSIF ONE_SITU.DATDEP is null THEN
	L_CODE_RETOUR:='1';
	L_RETOUR:='Date de départ non renseignée';
        L_CREATION:='NON';
ELSIF  ONE_SITU.DATARR>ONE_SITU.DATDEP THEN
	L_CODE_RETOUR:='1';
    	L_RETOUR:='Date d''arrivée supérieure à la date de départ';
        L_CREATION:='NON';
ELSE
-- gestion des dates : dates de la situation à créer
	L_DATARR:=to_date('01'||to_char(ONE_SITU.DATARR,'mmyyyy'));
	L_DATDEP:=ONE_SITU.DATDEP;
END IF;

	-- test sur l'existence du DPG
		BEGIN
			SELECT topfer
            		INTO   l_topfer
            		FROM   struct_info
            		WHERE  codsg = to_number(ONE_SITU.dpg);
            			EXCEPTION
         			WHEN NO_DATA_FOUND THEN
                   			TRCLOG.TRCLOG( P_HFILE, 'le dpg : '||ONE_SITU.dpg||' n existe pas.');
                   			L_CODE_RETOUR:='1';
         				L_RETOUR:='Code DPG inconnu';
         				L_CREATION:='NON';
         	END;
         		IF l_topfer='F' THEN
         			L_CODE_RETOUR:='1';
         			L_RETOUR:='Code DPG fermé';
         			L_CREATION:='NON';
         		END IF;

-- test sur l'existence d'une situ dans la Bip pour la ressource
SELECT count(datsitu) INTO l_new FROM situ_ress where ident=ONE_SITU.IDENT;
-- pas de situation pour la ressource
IF l_new=0  AND L_CODE_RETOUR <> '1' THEN
	L_CREATION := 'OUI';
	L_CODE_RETOUR := '0';
	--L_RETOUR := 'Nouvelle situation créée';
ELSIF  l_new<>0 THEN -- la ressource a déjà une situation

	-- cas d'une situation non fermée dans la BIP
		l_fermee := '0';
		BEGIN
			SELECT '1'
         		INTO l_fermee
         		FROM situ_ress
          		WHERE ident = ONE_SITU.ident
          		AND datsitu=(select max(datsitu)
					from situ_ress
					where ident=ONE_SITU.ident)
			AND datdep IS NOT NULL
			 ;
         			EXCEPTION
         			WHEN NO_DATA_FOUND THEN
         			TRCLOG.TRCLOG( P_HFILE, 'La situation antérieure de  : '||ONE_SITU.ident||' n est pas fermee.');
         			L_CODE_RETOUR:='1';
         			L_CREATION:='NON';
         	END;
         	IF l_fermee<>'1' THEN
         		L_CODE_RETOUR:='1';
         		L_RETOUR:='Situation antérieure non fermée';
         		L_CREATION:='NON';
         	END IF;

DECLARE
  -- curseur qui ramène le mois de la date de départ
CURSOR curdate is
	select to_char(datdep,'yyyymm') mois,datsitu deb_periode,datdep fin_periode
	from situ_ress
	where ident=to_number(ONE_SITU.IDENT);

BEGIN
FOR ONE_DATE IN curdate LOOP

	-- la situation à créer a une date de début dans le même mois que la date de départ d'une autre situation
	if (ONE_DATE.mois=to_char(ONE_SITU.DATARR,'yyyymm')) then
			L_DATARR :=round(ONE_SITU.DATARR,'MONTH');
			L_CREATION := 'OUI';

			BEGIN
				UPDATE situ_ress SET datdep=(L_DATARR-1)
				where to_char(datdep,'yyyymm')=ONE_DATE.mois
				and ident=to_number(ONE_SITU.IDENT);
			END;
	elsif (ONE_SITU.DATDEP > ONE_DATE.deb_periode AND ONE_SITU.DATARR < ONE_DATE.fin_periode) then
		L_CREATION := 'NON';
		L_RETOUR := 'Recouvrement supérieur à 1 mois';
		L_CODE_RETOUR := '1';
	end if;

  END LOOP;

END;
END IF;

	-- insertion de la nouvelle situation
	IF L_CREATION='OUI' THEN
		INSERT INTO situ_ress(ident,datsitu,datdep,cpident,codsg,soccode,cout,rmcomp,prestation,dispo)
		VALUES
		(ONE_SITU.ident,
		L_DATARR,
		L_DATDEP,
		ONE_SITU.cpident,
		ONE_SITU.dpg,
		ONE_SITU.soccode,
		ONE_SITU.coutht,
		0,
		ONE_SITU.qualif,
		5);

		UPDATE tmp_situation
		SET retour='Situation créée',code_retour='0'
		WHERE tmp_situation.id_oalia=ONE_SITU.id_oalia
		AND UPPER(tmp_situation.matricule)=ONE_SITU.matricule;
		COMMIT;
	ELSIF L_CREATION = 'NON' THEN
		UPDATE tmp_situation
		SET retour=L_RETOUR,code_retour=L_CODE_RETOUR
		WHERE tmp_situation.id_oalia=ONE_SITU.id_oalia;
		COMMIT;
	END IF;



END;
END LOOP;
	-----------------------------------------------------
	-- Trace Stop
	-----------------------------------------------------
	TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );

	EXCEPTION
		when others then

			ROLLBACK;

			if sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
--				TRCLOG.CLOSETRCLOG( P_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;
END alim_situ;

------------------------------------------------------------
-- Cette procedure archive les données concernant
-- les ressources (conservées 2 mois)
------------------------------------------------------------
PROCEDURE archive_esourcing (P_HFILE utl_file.file_type) IS

L_DATE_COURANTE DATE;

referential_integrity EXCEPTION;
PRAGMA EXCEPTION_INIT(referential_integrity, -2291);


-- On parcourt la table temporaire de création des ressources
	CURSOR C_RESS IS
	SELECT  UPPER(NVL(r.matricule,'vide')) MATRICULE,
		NVL(r.id_oalia,'vide') ID_OALIA,
		UPPER(r.rnom) RNOM,
		UPPER(r.rprenom) RPRENOM,
		r.ident,
		r.code_retour,
		r.retour
	FROM tmp_ressource r
	--WHERE code_retour = '1'
	ORDER BY ident
	;

-- On parcourt la table temporaire de création des situations
	CURSOR C_SITU IS
	SELECT  UPPER(NVL(s.matricule,'vide')) MATRICULE,
  		NVL(s.id_oalia,'vide') ID_OALIA,
  		s.datarr,
		s.datdep,
  		s.dpg,
  		UPPER(s.soccode) SOCCODE,
  		s.coutht,
  		UPPER(s.qualif) QUALIF,
  		s.cpident,
  		r.ident,
  		UPPER(r.rnom) RNOM,
  		UPPER(r.rprenom) RPRENOM,
  		s.code_retour,
  		s.retour
 	FROM tmp_ressource r,tmp_situation s
 	WHERE UPPER(r.matricule(+))=UPPER(s.matricule)
 	AND  r.retour(+) <> 'Matricule en doublon'
 	ORDER BY r.ident
	;

-- Cas particulier : matricule en doublon
	CURSOR C_DOUBLON IS
	 SELECT DISTINCT UPPER(NVL(s.matricule,'vide')) MATRICULE,
   	NVL(s.id_oalia,'vide') ID_OALIA,
   	s.datarr,
   	s.datdep,
   	s.dpg,
   	UPPER(s.soccode) SOCCODE,
   	s.coutht,
   	UPPER(s.qualif) QUALIF,
   	s.cpident,
   	s.code_retour,
   	s.retour
  	FROM tmp_ressource r,tmp_situation s
 	WHERE UPPER(r.matricule)=UPPER(s.matricule)
 	and r.retour='Matricule en doublon'
 	;

BEGIN
	BEGIN
		SELECT to_date(to_char(sysdate,'dd/mm/yyyy'),'dd/mm/yyyy') into L_DATE_COURANTE FROM dual;

		DELETE FROM ESOURCING
		WHERE date_trait < ADD_MONTHS(L_DATE_COURANTE,-2)
		;
		COMMIT;
	END;
	TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement d archivage des ressources');

	FOR ONE_RESS IN C_RESS LOOP
	TRCLOG.TRCLOG( P_HFILE, 'Debut archivage de la ressource : '||ONE_RESS.ident);

	BEGIN
        	INSERT INTO ESOURCING (date_trait,id_oalia,matricule,rnom,rprenom,ident,code_retour,retour)
        	VALUES
        	(L_DATE_COURANTE,
        	ONE_RESS.id_oalia,
        	ONE_RESS.matricule,
        	ONE_RESS.rnom,
        	ONE_RESS.rprenom,
        	ONE_RESS.ident,
        	ONE_RESS.code_retour,
        	ONE_RESS.retour
        	);
        	COMMIT;
        END;
  	END LOOP;

	TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement d archivage des situations');

	FOR ONE_SITU IN C_SITU LOOP
	TRCLOG.TRCLOG( P_HFILE, 'Debut archivage de la situation de la ressource : '||ONE_SITU.ident);

	BEGIN
        	INSERT INTO ESOURCING (date_trait,id_oalia,matricule,datarr,datdep,dpg,soccode,coutht,qualif,
        	cpident,ident,rnom,rprenom,code_retour,retour)
        	VALUES
        	(L_DATE_COURANTE,
        	ONE_SITU.id_oalia,
        	ONE_SITU.matricule,
        	ONE_SITU.datarr,
        	ONE_SITU.datdep,
        	ONE_SITU.dpg,
        	ONE_SITU.soccode,
        	ONE_SITU.coutht,
        	ONE_SITU.qualif,
        	ONE_SITU.cpident,
        	ONE_SITU.ident,
        	ONE_SITU.rnom,
        	ONE_SITU.rprenom,
        	ONE_SITU.code_retour,
        	ONE_SITU.retour
        	);
        	COMMIT;
        END;
  	END LOOP;


  	FOR ONE_DOUBLON IN C_DOUBLON LOOP
	TRCLOG.TRCLOG( P_HFILE, 'Debut archivage cas des doublons de matricule '||ONE_DOUBLON.id_oalia);

	BEGIN
        	INSERT INTO ESOURCING (date_trait,id_oalia,matricule,datarr,datdep,dpg,soccode,coutht,qualif,
        	cpident,code_retour,retour)
        	VALUES
        	(L_DATE_COURANTE,
        	ONE_DOUBLON.id_oalia,
        	ONE_DOUBLON.matricule,
        	ONE_DOUBLON.datarr,
        	ONE_DOUBLON.datdep,
        	ONE_DOUBLON.dpg,
        	ONE_DOUBLON.soccode,
        	ONE_DOUBLON.coutht,
        	ONE_DOUBLON.qualif,
        	ONE_DOUBLON.cpident,
        	ONE_DOUBLON.code_retour,
        	ONE_DOUBLON.retour
        	);
        	COMMIT;
        END;

  	END LOOP;

	TRCLOG.TRCLOG( P_HFILE, 'Fin du traitement d archivage des situations et ressources');

	-- suppression des donnees des tables temporaires
	/*TRCLOG.TRCLOG( P_HFILE, 'Debut de la suppression des donnees des tables temporaires');
	BEGIN
		DELETE FROM TMP_RESSOURCE;
		DELETE FROM TMP_SITUATION;
		COMMIT;
	TRCLOG.TRCLOG( P_HFILE, 'Fin de la suppression des donnees des tables temporaires');
	END;*/

END archive_esourcing;

------------------------------------------------------------
-- Cette procedure verifie que l on a pas cree de ressource
-- sans situation
------------------------------------------------------------
PROCEDURE verif_ress (P_HFILE utl_file.file_type) IS

L_DATE_COURANTE DATE;

referential_integrity EXCEPTION;
PRAGMA EXCEPTION_INIT(referential_integrity, -2291);


L_RETCOD    number;
L_PROCNAME  varchar2(256) := 'verif_ress';
L_STATEMENT varchar2(256);

BEGIN
	-----------------------------------------------------
	-- Trace Start
	-----------------------------------------------------
	TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );
	TRCLOG.TRCLOG( P_HFILE, 'Debut du traitement de suppression des ressources');



	-- suppression des ressources crees sans situ
		DELETE FROM ressource ress
		WHERE ress.ident IN (select distinct r.ident from tmp_ressource r,tmp_situation s
 				where r.code_retour=0
 				and s.code_retour <>0)
 				and ress.ident not in (select distinct sr.ident from situ_ress sr
				where ress.ident=sr.ident)
 				;

		UPDATE tmp_ressource tmp
   			set CODE_RETOUR=1,
   			    RETOUR='Ressource sans situation'
 			WHERE tmp.ident in (select distinct r.ident from tmp_ressource r,tmp_situation s
 				where r.code_retour=0
 				and s.code_retour <>0)
 				and tmp.ident not in (select distinct sr.ident from situ_ress sr
				where tmp.ident=sr.ident)
  			;
		COMMIT;




	-----------------------------------------------------
	-- Trace Stop
	-----------------------------------------------------
	TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );

	EXCEPTION
		when others then

			ROLLBACK;

			if sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
--				TRCLOG.CLOSETRCLOG( P_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;
END verif_ress;


PROCEDURE global_ressource (P_LOGDIR VARCHAR2) IS

		P_HFILE utl_file.file_type;
		L_RETCOD number;
		L_PROCNAME varchar2(30):='GLOBAL_RESSOURCE';

	BEGIN
		-- Init de la trace
		-- ----------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, P_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

		-- lancement des procédures

		pack_esourcing.alim_ressource (P_HFILE) ;

		pack_esourcing.alim_situ (P_HFILE);

		pack_esourcing.verif_ress(P_HFILE);

		pack_esourcing.archive_esourcing(P_HFILE);


		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( P_HFILE );

	exception

		when others then
			rollback;
			if sqlcode <> CALLEE_FAILED_ID and
			   sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( P_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

	END;


PROCEDURE global_contrat (P_LOGDIR VARCHAR2) IS

		P_HFILE utl_file.file_type;
		L_RETCOD number;
		L_PROCNAME varchar2(30):='GLOBAL_CONTRAT';

	BEGIN
		-- Init de la trace
		-- ----------------
		L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, P_HFILE );
		if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
		end if;

		-- Trace Start
		-- -----------
		TRCLOG.TRCLOG( P_HFILE, 'Debut de ' || L_PROCNAME );

		-- lancement des procédures

		pack_esourcing.create_contrat(P_HFILE);

		pack_esourcing.create_ligne_cont(P_HFILE);

		pack_esourcing.historise_contrat(P_HFILE);

		-- Trace Stop
		-- ----------
		TRCLOG.TRCLOG( P_HFILE, 'Fin normale de ' || L_PROCNAME  );
		TRCLOG.CLOSETRCLOG( P_HFILE );

	exception

		when others then
			rollback;
			if sqlcode <> CALLEE_FAILED_ID and
			   sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, L_PROCNAME || ' : ' || SQLERRM );
			end if;
			if sqlcode <> TRCLOG_FAILED_ID then
				TRCLOG.TRCLOG( P_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
				TRCLOG.CLOSETRCLOG( P_HFILE );
				raise_application_error( CALLEE_FAILED_ID,
				                        'Erreur : consulter le fichier LOG',
				                         false );
			else
				raise;
			end if;

	END;

END pack_esourcing;
/
CREATE OR REPLACE PACKAGE pack_etalo05 AS
  -- ------------------------------------------------------------------------
  -- Nom        :  verif_etalo05
  -- Auteur     :  Equipe SOPRA
  -- Decription :  vérifie les dates  pour l'edition etalo05
  -- Paramètres :  p_param6 (IN) DATE: date debut de prestation
  --               p_param7 (IN) DATE: date fin de prestation
  --               p_param8 (IN) DATE: date début de saisie
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------
PROCEDURE  verif_etalo05(p_param6 IN VARCHAR2,
			 p_param7 IN VARCHAR2,
			 p_param8 IN VARCHAR2,
			 p_message OUT VARCHAR2);

END pack_etalo05;
/

CREATE OR REPLACE PACKAGE BODY pack_etalo05 AS

  -- ------------------------------------------------------------------------
  -- Nom        :  prologue
  -- Auteur     :  Equipe SOPRA
  -- Decription :  vérifie que la date de début de prestation est inférieur
  --               à la date de fin de prestation pour l'edition etalo05
  -- Paramètres :  p_param6 (IN) DATE: date debut de prestation
  --               p_param7 (IN) DATE: date fin de prestation
  --               p_param8 (IN) DATE: date début de saisie
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------
PROCEDURE  verif_etalo05(p_param6 IN VARCHAR2,
			 p_param7 IN VARCHAR2,
			 p_param8 IN VARCHAR2,
			 p_message OUT VARCHAR2) IS
  l_msg VARCHAR2(1024) :='';
BEGIN
   IF to_date(p_param6,'mm/yyyy')>to_date(p_param7,'mm/yyyy') THEN
      pack_global.recuperer_message(20284, NULL, NULL, 'p_param6', l_msg);
      p_message := l_msg;
      raise_application_error(-20284, l_msg);
   END IF;
   p_message := l_msg;
END verif_etalo05;

END pack_etalo05;
/
CREATE OR REPLACE PACKAGE pack_export_comptable AS

  -- -----------------------------------------------------------------------
  -- Nom        : f_get_numenvoi
  -- Auteur     : NCM
  -- Description :  combinaison des 10 chiffres et des 26 lettres
  -- Retour     : retourne le numéro d'envoi sur 2 caractères (00 à ZZ)
  --
  -- -----------------------------------------------------------------------
  FUNCTION f_get_numenvoi RETURN VARCHAR2;

  -- -----------------------------------------------------------------------
  -- Nom        : select_export_comptable
  -- Auteur     : Equipe SOPRA
  -- Description : extraction des exports comptables siège,
  --			sélection de factures et de lignes de facture associées
  -- Paramètres : p_chemin_fichier IN VARCHAR2  :
  --
  -- ------------------------------------------------------------------------

  PROCEDURE select_export_comptable( p_chemin_fichier  IN VARCHAR2) ;

END pack_export_comptable;
/

CREATE OR REPLACE PACKAGE BODY pack_export_comptable AS

  -- -----------------------------------------------------------------------
  -- Nom        : f_get_numenvoi
  -- Auteur     : NCM
  -- Description :  combinaison des 10 chiffres et des 26 lettres
  -- Retour     : retourne le numéro d'envoi sur 2 caractères (00 à ZZ)
  --
  -- -----------------------------------------------------------------------

FUNCTION f_get_numenvoi RETURN VARCHAR2 IS

l_num_envoi	CHAR(2) ;
l_numenvoi1	CHAR(2) ;
l_numenvoi2	CHAR(2) ;

l_oldnum1       CHAR(1) ;
l_oldnum2       CHAR(1) ;
l_nextnum1	CHAR(1) ;
l_nextnum2	CHAR(1) ;


l_num1          CHAR(1) ;
l_num2 		CHAR(1) ;
liste_1      VARCHAR2(36);
liste_2		VARCHAR2(36);


BEGIN

liste_1 := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
liste_2 := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';

select numenvoi,oldnum,nextnum
into l_num_envoi, l_oldnum1, l_nextnum1
from abecedaire where numliste=1;

dbms_output.put_line('le numéro d"envoi : '||l_num_envoi);

select oldnum, nextnum, numenvoi
into l_oldnum2, l_nextnum2 , l_numenvoi2
from abecedaire where numliste=2;


-- Si on n'est pas en fin de liste 2, on reste sur le même caractère de la liste 1
-- on se déplace sur la liste 2
IF l_oldnum2!='Z' THEN
	l_num1 := l_oldnum1;
	l_num2 := l_nextnum2;
	-- Prochain numéro d'envoi
	update abecedaire
	set numenvoi=l_num1||l_num2;


	-- le 2ème caractère du numéro d'envoi devient un ancien caractère
	if l_oldnum2!='Y' then
		l_nextnum2 := substr(liste_2, instr(liste_2,l_nextnum2,1,1)+1, 1);
	else
		l_nextnum2 := '0';
	end if;

	update abecedaire
	set oldnum=l_num2,
	    nextnum=l_nextnum2
	where numliste=2;
ELSE
-- On arrive à la fin de la liste 2 et on se déplace sur la liste 1
       	l_num1 := l_nextnum1;
       	l_num2 := l_nextnum2;
	l_nextnum2 := substr(liste_2, instr(liste_2,l_nextnum2,1,1)+1, 1);

	if l_nextnum1='Z' then   -- on arrive à la fin de la liste 1
		l_nextnum1 := '0';
	else
		l_nextnum1 := substr(liste_1, instr(liste_1,l_nextnum1,1,1)+1, 1);
	end if;

       update abecedaire
	set 	oldnum=l_num1,
		nextnum=l_nextnum1,
		numenvoi=l_num1||l_num2
	where numliste=1;

	update abecedaire
	set oldnum=l_num2,
	    nextnum=l_nextnum2
	where numliste=2;



END IF;


return l_num_envoi;

END f_get_numenvoi;

  -- -----------------------------------------------------------------------
  -- Nom        : select_export_comptable
  -- Auteur     : Equipe SOPRA
  -- Description : extraction des exports comptables siège,
  --			sélection de factures et de lignes de facture associées
  -- Paramètres : p_chemin_fichier IN VARCHAR2  :
  --
  -- ------------------------------------------------------------------------
  PROCEDURE select_export_comptable( p_chemin_fichier  IN VARCHAR2) IS

   l_msg       VARCHAR2(1024);
   l_hfile     utl_file.file_type;
   l_idarpege  FACTURE.fcoduser%TYPE ;
   l_filiale   FILIALE_CLI.filcode%TYPE ;
   l_centrefrais centre_frais.codcfrais%TYPE;

   NUMICRO_FAILED 	EXCEPTION;
   NB_FACTURES_FAILED 	EXCEPTION;
   NB_USERS_FAILED	EXCEPTION;
   CF_FICTIF            EXCEPTION;

   l_date_creation   CHAR(8);
   l_date_fichier    CHAR(8);
   l_heure_creation  CHAR(6);
   l_SEPARATEUR      CONSTANT CHAR(1) := ';'  ;
   l_socfour  varchar2(13);

   l_old_socfact FACTURE.socfact%TYPE ;
   l_old_typfact FACTURE.typfact%TYPE ;
   l_old_datfact FACTURE.datfact%TYPE ;
   l_old_numfact FACTURE.numfact%TYPE ;

   l_entete_type_enreg           CONSTANT VARCHAR2(1) := '1'     ;
   l_entete_cle_discriminante     VARCHAR2(257) := ' '     ;
   l_entete_type_fichier         CONSTANT VARCHAR2(3) := 'FAC'     ;
   l_entete_code_application     CONSTANT VARCHAR2(5) := 'A0374' ;
   l_entete_sum_fmontttc         NUMBER(17,2) := 0     ;
   l_entete_sum_lmontht          NUMBER(17,2) := 0     ;
   l_entete_nb_total_lignes      NUMBER(7)    := 0     ;
   l_entete_nb_factures          NUMBER(6)    := 0     ;
   l_entete_nb_lignes_fact       NUMBER(5)    := 0     ;

   l_facture_type_enreg          CONSTANT VARCHAR2(1)  := '2'     ;
   l_facture_entite_payante      CONSTANT VARCHAR2(5)  := 'F7090' ;
   l_facture_code_irt            CONSTANT VARCHAR2(5)  := 'A0374' ;
   l_facture_centre_frais        VARCHAR2(3)  := ''   ;  	-- modif du 5/01/20001
   l_facture_id_lot              VARCHAR2(10)          := ''      ;
   l_facture_date_compta         VARCHAR2(8)  := ''      ;
   l_facture_entite_projet       CONSTANT VARCHAR2(5)  := ''      ;
   l_facture_code_devise         CONSTANT VARCHAR2(3)  := 'EUR'   ;
   l_facture_codefour		 VARCHAR2(10);
   l_facture_sitefour            VARCHAR2(3);

   l_ligne_fact_type_enreg       CONSTANT VARCHAR2(1) := '3'     ;
   l_ligne_fact_entite_immo      CONSTANT VARCHAR2(5) := ''      ;
   l_ligne_fact_code_taux_taxe   VARCHAR2(5)  ;
   l_ligne_fact_code_taxe_recup  CONSTANT VARCHAR2(3) := 'PRO'   ;
   l_ligne_fact_code_dco          VARCHAR2(5) := ''      ;
   l_ligne_fact_emetteur         VARCHAR2(3) := ''   ;

   l_regle_fiscale  CONSTANT VARCHAR2(9)  := 'TVAENCSST' ;
   l_filler         CONSTANT VARCHAR2(19) := ''      ;

   l_num_envoi	CHAR(2) ;
   l_signe        CHAR(1);
   l_date_envoi date;

   -- 05/11/2003 gestion users SGCIB
   l_idSansPoint	FACTURE.fcoduser%TYPE;	-- identifiant dont les '.' sont convertis en '_'
   l_champ18_tailleMax CONSTANT NUMBER(2) := 30;
   -- le champ 18 est limite a 30 caracteres, l'id doit etre tronque pour ne pas depasser
   l_champ18	VARCHAR2(30);


--
-- Curseur de recherche des utilisateurs
-- On selectionne tous les users arpeges  et leur code filiale
--
	CURSOR cur_users IS

		SELECT DISTINCT f.fcoduser, c.filcode, f.fcentrefrais
		FROM contrat c, ligne_fact LF, facture f
		WHERE	F.fstatut1   = 'AE'
		AND	(
			F.numcont IS null
			OR
			   (
			   C.soccont = F.soccont
		   	AND
		   	C.numcont = F.numcont
		   	AND
		   	C.cav     = F.cav
		   	))
		AND	LF.socfact  = F.socfact
		AND   LF.typfact  = F.typfact
		AND   LF.datfact  = F.datfact
		AND   LF.numfact  = F.numfact
		AND   c.filcode='01 ';

   --
   -- Curseur principal
   --
   -- Permet de selectionner les factures ET les lignes de facture associées
   --
   -- Attention : le curseur accepte 2 paramètres :
   --			1. l'identifiant de l'utilisateur
   --			2. le code filiale choisi par l'utilisateur
   --

   CURSOR type_curGlobal( p_idarpege  FACTURE.fcoduser%TYPE,
                          p_filiale   FILIALE_CLI.filcode%TYPE,
			  p_centrefrais CENTRE_FRAIS.codcfrais%TYPE
                        ) IS

	SELECT DISTINCT
		   F.fsocfour,
		   F.socfact,
		   F.typfact,
		   F.numfact,
		   F.datfact,
		   DECODE(F.typfact, 'F', 'INVC', 'A', 'DBMM', '') as code_justificatif,
		   F.fenvsec as fdate_reglt,
		   DECODE(F.typfact, 'F', '+' , 'A', '-', '') as signe,
			NVL(F.fmontttc,0)  as fmontttc,
		   SUBSTR(F.llibanalyt, 1, 35) as llibanalyt,
	 	  DECODE(F.typfact, 'F', '+' , 'A', '-', '') || TO_CHAR(NVL((F.fmontttc-F.fmontht),0),'FM999999999990.00')  as monttva,
		   LF.lnum,
		   LF.lmontht,
		   LF.lcodcompta,
		   to_char(SI.centractiv) centractiv,
		   LF.tva
	FROM	facture	F,
		contrat	C,
		ligne_fact	LF,
		struct_info	SI
	WHERE
		F.fstatut1   = 'AE'
	AND   F.fcoduser   = p_idarpege
	AND   F.fcentrefrais=p_centrefrais
	AND	(
		F.numcont IS null
		OR
		   (
		   C.soccont = F.soccont
		   AND
		   C.numcont = F.numcont
		   AND
		   C.cav     = F.cav
		   AND
		   C.filcode = p_filiale
		   )
		)
	AND	LF.socfact  = F.socfact
	AND   LF.typfact  = F.typfact
	AND   LF.datfact  = F.datfact
	AND   LF.numfact  = F.numfact
	AND   LF.ldeppole = SI.codsg
	ORDER BY
		F.fsocfour 			asc,
		F.socfact 			asc,
		F.numfact 			asc,
		F.typfact 			asc,
		F.datfact 			asc,
		code_justificatif 	asc,
		LF.lnum			asc ;


   BEGIN

	FOR  cur_ligne IN cur_users
	LOOP
		IF cur_users%NOTFOUND THEN
			RAISE NB_USERS_FAILED;
		END IF;

		l_facture_centre_frais  := LPAD(to_char(cur_ligne.fcentrefrais),3,'0');
		l_ligne_fact_emetteur := l_facture_centre_frais;

		-- ------------------------------------------------------------------------------------
		--
		-- Traitement de l'en-tete du fichier, 1er parcours du curseur
		--
		-- ------------------------------------------------------------------------------------
		l_old_socfact := ' ' ;
		l_old_typfact := ' ' ;
		l_old_numfact := ' ' ;
		SELECT to_date('01011900','DDMMYYYY') INTO l_old_datfact FROM dual;

		-- ------------------------------------------------------------------------------------
		-- 08/08/2000 :  table tmp_factae qui contient les factures à envoyer
		-- ------------------------------------------------------------------------------------
		BEGIN

		select sysdate into l_date_envoi
		from dual;

		INSERT INTO tmp_factae (FCODUSER,SOCFACT,TYPFACT,NUMFACT,LNUM,DATFACT,DATE_REGLT,MONTHT,TVA,
					SOCFOUR,LIBSOCFOUR,MOISPREST,CODCOMPTA,DPG,CENTRE_FRAIS,DATE_ENVOI)
			(SELECT DISTINCT
					F.fcoduser,
			    		F.socfact,
			   		F.typfact,
			   		F.numfact,
					LF.lnum,
			   		F.datfact,
					F.fenvsec as date_reglt,
					LF.lmontht,
					LF.tva,
					F.fsocfour,
					A.socflib,
					LF.lmoisprest,
					LF.lcodcompta,
					LF.ldeppole,
					F.fcentrefrais ,   -- 05/01/2001
					l_date_envoi --22/03/2001
			FROM	facture	F,
				contrat	C,
				ligne_fact	LF,
				struct_info	SI,
				agence		A
			WHERE
				F.fstatut1   = 'AE'
			AND   F.fcoduser   = cur_ligne.fcoduser
				AND   F.fcentrefrais=cur_ligne.fcentrefrais
			AND	(
				F.numcont IS null
				OR
			   	(
			   		C.soccont = F.soccont
			   	AND
			   		C.numcont = F.numcont
			   	AND
			   		C.cav     = F.cav
			   	AND
			   		C.filcode = cur_ligne.filcode
			   	)
				)
			AND	LF.socfact  = F.socfact
			AND   LF.typfact  = F.typfact
			AND   LF.datfact  = F.datfact
			AND   LF.numfact  = F.numfact
			AND   LF.ldeppole = SI.codsg
			AND   rtrim(A.socfour)=rtrim(F.fsocfour)
			AND   A.soccode=F.socfact
			);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN null;
		END;

		FOR  cur_enr IN type_curGlobal(cur_ligne.fcoduser, cur_ligne.filcode,cur_ligne.fcentrefrais)
		LOOP

		   --
		   -- Est-ce une nouvelle facture ?
		   --
		   IF (    (cur_enr.socfact != l_old_socfact)
			  OR (cur_enr.typfact != l_old_typfact)
			  OR (cur_enr.datfact != l_old_datfact)
			  OR (cur_enr.numfact != l_old_numfact)
			) THEN

	dbms_output.put_line('montant='||cur_enr.fmontttc);
			l_entete_nb_total_lignes := l_entete_nb_total_lignes + 1 ;
   			l_entete_nb_factures     := l_entete_nb_factures     + 1 ;
		--	l_entete_sum_fmontttc    := l_entete_sum_fmontttc    + to_number(cur_enr.fmontttc,'FM999999999990.00S');
			l_entete_sum_fmontttc    := l_entete_sum_fmontttc    + (cur_enr.signe||to_number(cur_enr.fmontttc));
	dbms_output.put_line('total='||	l_entete_sum_fmontttc    );

			--
			-- Sauvegarder l'id de la facture
			--
			l_old_socfact := cur_enr.socfact ;
			l_old_typfact := cur_enr.typfact ;
			l_old_datfact := cur_enr.datfact ;
			l_old_numfact := cur_enr.numfact ;
		   END IF;

		   l_entete_nb_total_lignes := l_entete_nb_total_lignes + 1 ;
		   l_entete_nb_lignes_fact  := l_entete_nb_lignes_fact  + 1 ;
		   l_entete_sum_lmontht     := l_entete_sum_lmontht     + (cur_enr.signe||cur_enr.lmontht) ;
		l_signe:=cur_enr.signe;
		END LOOP;


		-- ------------------------------------------------------------------------------------
		-- Si pas de facture a extraire
		-- ------------------------------------------------------------------------------------
		IF l_entete_nb_factures = 0 THEN
		   raise NB_FACTURES_FAILED;
		END IF;


		-- ------------------------------------------------------------------------------------
		-- Initialisations
		-- ------------------------------------------------------------------------------------
		SELECT   to_char(sysdate,'YYYYMMDD'),
			   to_char(sysdate,'DDMMYYYY'),
			   to_char(sysdate,'HH24MISS')
		INTO     l_date_creation,
			   l_date_fichier,
			   l_heure_creation
		FROM	dual;


		l_num_envoi:=f_get_numenvoi;

		l_facture_id_lot :=  l_facture_centre_frais || l_num_envoi || l_facture_code_irt;

	        	-- -----------------------------------------------------
     			-- 06/06/2000 :La clé discriminante= codeuser+n°envoi
			-- -----------------------------------------------------
			-- ICI GESTION USERS SGCIB:
			-- on remplace les '.' par des '_' dans le fcoduser
			l_idSansPoint := replace(cur_ligne.fcoduser, '.', '_');

			dbms_output.put_line(cur_ligne.fcoduser || ' ===> ' || l_idSansPoint);
			--l_entete_cle_discriminante := cur_ligne.fcoduser || l_num_envoi;
			l_entete_cle_discriminante := l_idSansPoint || l_num_envoi;


		-- ------------------------------------------------------------------------------------
		-- Sinon, initialisation du fichier et ecriture de l'en-tete
		-- ------------------------------------------------------------------------------------

	  --PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, 'NCS.BIP.BIPEXCOMPTA.' || cur_ligne.fcoduser || l_num_envoi || '.D' || l_date_fichier, l_hfile);
	  PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, 'NCS.BIP.BIPEXCOMPTA.' || l_idSansPoint || l_num_envoi || '.D' || l_date_fichier, l_hfile);

		PACK_GLOBAL.WRITE_STRING( l_hfile,
						  l_entete_type_enreg                                  || l_SEPARATEUR ||
						  l_entete_cle_discriminante                           || l_SEPARATEUR ||
						  l_entete_type_fichier                                || l_SEPARATEUR ||
						  l_entete_code_application                            || l_SEPARATEUR ||
						  l_date_creation                                      || l_SEPARATEUR ||
						  l_heure_creation                                     || l_SEPARATEUR ||
						  TO_CHAR(l_entete_sum_fmontttc,'SFM999999999990.00')      || l_SEPARATEUR ||
						  TO_CHAR(l_entete_sum_lmontht,'SFM999999999990.00')   || l_SEPARATEUR ||
						  TO_CHAR(l_entete_nb_total_lignes)                    || l_SEPARATEUR ||
						  TO_CHAR(l_entete_nb_factures)                        || l_SEPARATEUR ||
						  TO_CHAR(l_entete_nb_lignes_fact)
						);


		-- ------------------------------------------------------------------------------------
		--
		-- Traitement de la suite du fichier, 2e parcours du curseur
		--
		-- ------------------------------------------------------------------------------------

		l_old_socfact := ' ' ;
		l_old_typfact := ' ' ;
		l_old_numfact := ' ' ;
		SELECT to_date('01011900','DDMMYYYY') INTO l_old_datfact FROM dual;


		FOR  cur_enr IN type_curGlobal(cur_ligne.fcoduser, cur_ligne.filcode,cur_ligne.fcentrefrais)
		LOOP

		   --
		   -- Est-ce une nouvelle facture ?
		   --
		   IF (    (cur_enr.socfact != l_old_socfact)
			  OR (cur_enr.typfact != l_old_typfact)
			  OR (cur_enr.datfact != l_old_datfact)
			  OR (cur_enr.numfact != l_old_numfact)
			) THEN

			--
			-- Sauvegarder l'id de la facture
			--
			l_old_socfact := cur_enr.socfact ;
			l_old_typfact := cur_enr.typfact ;
			l_old_datfact := cur_enr.datfact ;
			l_old_numfact := cur_enr.numfact ;

			BEGIN
			   UPDATE	facture
			   SET	fstatut1 = 'EN'
			   WHERE	socfact = cur_enr.socfact
			   AND	typfact = cur_enr.typfact
			   AND	datfact = cur_enr.datfact
			   AND	numfact = cur_enr.numfact;

			   COMMIT;

			EXCEPTION
			   WHEN OTHERS THEN
				--
				--
				--
				null;

			END;
		/* DATE DE COMPTABILISATION = DATE DE SAISIE DE LA FACTURE */
			BEGIN
				SELECT to_char(fdatsai,'YYYYMMDD') into l_facture_date_compta
				FROM facture
				WHERE	socfact = cur_enr.socfact
			       AND	typfact = cur_enr.typfact
			       AND	datfact = cur_enr.datfact
			       AND	numfact = cur_enr.numfact;

			EXCEPTION
				WHEN OTHERS THEN
				null;
     			END;

		/* 18/09/2000: ZONE DCO=H si code compta=6396206 */
		if cur_enr.lcodcompta='6396206' then
			l_ligne_fact_code_dco :='H';

		else
			l_ligne_fact_code_dco :='';
		end if;

		/* 04/10/2000:déconcaténation du code fournisseur sous oracle en codefour et sitefour */
		l_socfour :=RTRIM(LTRIM(cur_enr.fsocfour));
		l_facture_codefour :=LTRIM(SUBSTR(LPAD(l_socfour,10,' '),1,7));
		l_facture_sitefour :=LTRIM(SUBSTR(LPAD(l_socfour,10,' '),8,3));

		/* Test taux de tva pour code de taux de taxe */
		if (cur_enr.tva=19.6 ) then
			l_ligne_fact_code_taux_taxe:='196FG';
		elsif (cur_enr.tva=0) then
   			l_ligne_fact_code_taux_taxe:='0PC';
		elsif (cur_enr.tva=20.6) then
			l_ligne_fact_code_taux_taxe:='206FG';
		end if;

			-- 06/11/2003 SGCIB
			l_champ18 := substr(cur_enr.socfact || cur_enr.numfact || cur_enr.typfact || cur_ligne.fcoduser, 1, l_champ18_tailleMax);

			--
			-- Ecrire l'enreg correspondant a la nouvelle facture
			--
			PACK_GLOBAL.WRITE_STRING( l_hfile,
							  l_facture_type_enreg                              || l_SEPARATEUR ||
							  l_facture_entite_payante                          || l_SEPARATEUR ||
							  l_facture_codefour                                || l_SEPARATEUR ||
 							  l_facture_sitefour              ||l_SEPARATEUR ||      -- site fournisseur
							cur_enr.socfact||cur_enr.numfact||cur_enr.typfact   || l_SEPARATEUR ||
							  to_char(cur_enr.datfact,'YYYYMMDD')      	    || l_SEPARATEUR ||
							  cur_enr.code_justificatif                         || l_SEPARATEUR ||
							  l_facture_id_lot                                  || l_SEPARATEUR ||
							  l_facture_date_compta                             || l_SEPARATEUR ||
							  l_date_creation                                   || l_SEPARATEUR ||
							  to_char(cur_enr.fdate_reglt,'YYYYMMDD')   	    || l_SEPARATEUR ||
							  cur_enr.signe||to_char(cur_enr.fmontttc,'FM999999999990.00')    || l_SEPARATEUR ||
							  cur_enr.monttva                                   || l_SEPARATEUR ||
							  l_regle_fiscale                                   || l_SEPARATEUR ||
							  cur_enr.llibanalyt                                || l_SEPARATEUR ||
							  l_facture_entite_projet                           || l_SEPARATEUR ||
							  l_facture_code_devise                             || l_SEPARATEUR ||
							  -- 06/11/2003 SGCIB
							  --cur_enr.socfact || cur_enr.numfact
							    --              || cur_enr.typfact || cur_ligne.fcoduser  || l_SEPARATEUR
							    l_champ18 || l_SEPARATEUR
							|| l_SEPARATEUR	-- critère de lettrage1
							|| l_SEPARATEUR	-- critère de lettrage2
							|| l_SEPARATEUR   -- motif éco
				                  || l_SEPARATEUR	-- code pays
							|| l_SEPARATEUR	-- zone utilisateur 5
							|| l_SEPARATEUR	-- zone utilisateur 6
							|| l_SEPARATEUR	-- zone utilisateur 7
							|| l_SEPARATEUR ||	-- zone utilisateur 10
							l_filler
							);
		   END IF;

		   --
		   -- Ecrire les enreg correspondants aux lignes de facture
		   --
		  PACK_GLOBAL.WRITE_STRING( l_hfile,
						     l_ligne_fact_type_enreg                             || l_SEPARATEUR ||
						     l_facture_codefour                               || l_SEPARATEUR ||
 						     l_facture_sitefour                 || l_SEPARATEUR ||      -- site fournisseur
						      cur_enr.socfact||cur_enr.numfact||cur_enr.typfact	 || l_SEPARATEUR ||
						     to_char(cur_enr.datfact,'YYYYMMDD')      		   || l_SEPARATEUR ||
						     to_char(cur_enr.lnum,'FM99')                        || l_SEPARATEUR ||
						     cur_enr.signe||to_char(cur_enr.lmontht,'FM999999999990.00')  || l_SEPARATEUR ||
						     cur_enr.llibanalyt                                  || l_SEPARATEUR ||
						     l_ligne_fact_entite_immo                            || l_SEPARATEUR ||
						     l_regle_fiscale                                     || l_SEPARATEUR ||
						     l_ligne_fact_code_taux_taxe                         || l_SEPARATEUR ||
						     l_ligne_fact_code_taxe_recup                        || l_SEPARATEUR ||
						     l_ligne_fact_code_dco                               || l_SEPARATEUR ||
						     cur_enr.lcodcompta                                  || l_SEPARATEUR ||
						     l_ligne_fact_emetteur                               || l_SEPARATEUR ||
						     cur_enr.centractiv                                  || l_SEPARATEUR
							|| l_SEPARATEUR	-- partenaire
							|| l_SEPARATEUR	-- code projet devl
							|| l_SEPARATEUR   -- axe dédié
				                  || l_SEPARATEUR	-- axe libre 1
							|| l_SEPARATEUR	-- axe libre 2
							|| l_SEPARATEUR	-- axe libre 3
							|| l_SEPARATEUR	-- axe libre 4
							|| l_SEPARATEUR	-- identifiant projet
							|| l_SEPARATEUR	-- composant
							|| l_SEPARATEUR   -- numéro d'affaire
				                  || l_SEPARATEUR	-- date début prestation
							|| l_SEPARATEUR	-- date fin prestation
							|| l_SEPARATEUR	-- nomenclature achat
							|| l_SEPARATEUR	-- zone utilisateur 2
							|| l_SEPARATEUR	-- zone utilisateur 6
							|| l_SEPARATEUR	-- zone utilisateur 7
							|| l_SEPARATEUR   -- zone utilisateur 8
				                  || l_SEPARATEUR	-- zone utilisateur 9
							|| l_SEPARATEUR ||	-- zone utilisateur 10
						     l_filler
						   );

		END LOOP;

	-- Fermeture de fichier
   	PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);

	l_entete_sum_fmontttc:= 0;
	l_entete_sum_lmontht:= 0;
	l_entete_nb_total_lignes:= 0;
	l_entete_nb_factures:=0;
	l_entete_nb_lignes_fact:= 0 ;

	END LOOP;

/*EXCEPTION
   WHEN NB_FACTURES_FAILED THEN
	pack_global.recuperer_message(20445, null, null, null, l_msg);
	raise_application_error(-20445, l_msg) ;

   WHEN NB_USERS_FAILED THEN
	pack_global.recuperer_message(20448, null, null, null, l_msg);
	raise_application_error(-20448, l_msg) ;

  WHEN OTHERS THEN
	IF UTL_FILE.IS_OPEN(l_hfile) THEN
	   PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);
	END IF;
	pack_global.recuperer_message(20401,null,null,null,l_msg);
	raise_application_error(-20401, 'SQLCODE=' || SQLCODE || ' - SQLERRM=' || SQLERRM) ;
*/
END select_export_comptable ;

END pack_export_comptable ;
/
CREATE OR REPLACE PACKAGE pack_faccons IS
--###############################################################################
--	Procedure de remplissage de la table faccons_consomme.
--	Pour chaque ressource et pour chaque mois de l'annee courante
--	(selon datdebex) consolide l'ensemble du consomme (hors FORMAT, ABSDIV,
--	CONGES, MOBILI, PARTIE, RTT) pour les ressources non SG.
--###############################################################################
	PROCEDURE Remplir_Consomme;

--###############################################################################
--	Procedure de remplissage de la table faccons_facture.
--	Pour chaque ressource, pour chaque mois de l'annee courante, contient
--	la ou les lignes de factures.
--###############################################################################
	PROCEDURE Remplir_Facture;

--###############################################################################
--	Procedure de remplissage de la table faccons_ressource.
--	Pour chaque ressource presente dans l'une ou l'autre des tables
--	faccons_consomme et faccons_facture, et pour chaque mois :
--		- les informations sur la bonne situation
--		- le cumul du consomme
--		- le cumul du facture
--###############################################################################
	PROCEDURE Remplir_Ressource;
END pack_faccons;
/

CREATE OR REPLACE PACKAGE BODY pack_faccons IS
	PROCEDURE Remplir_Consomme IS
	BEGIN
		INSERT INTO faccons_consomme(
			lmoisprest
			, ident
			, cusag
		)
		SELECT proplus.cdeb
			, proplus.tires
			, SUM(proplus.cusag)
		FROM datdebex
			, proplus
		WHERE proplus.societe!='SG..'
			AND (proplus.qualif NOT IN ('GRA', 'MO') OR proplus.qualif IS NULL)
			AND proplus.cdeb BETWEEN ADD_MONTHS(datdebex.datdebex,-12) AND datdebex.moismens
			AND (proplus.aist NOT IN ('FORMAT', 'ABSDIV', 'CONGES', 'MOBILI', 'PARTIE', 'RTT', 'RTT   ', 'FORHUM', 'ACCUEI', 'FORINT', 'FORINF', 'FOREAO', 'FOREXT') OR proplus.aist IS NULL)
		GROUP BY proplus.cdeb, proplus.tires;

		COMMIT;
	END Remplir_Consomme;


	PROCEDURE Remplir_Facture IS
	BEGIN
		INSERT INTO faccons_facture(
			lmoisprest
			, ident
			, montht
			, socfact
			, numfact
			, typfact
			, datfact
			, lnum
			, codcompta
			, numcont
			, cav
			, codsg)
		SELECT ligne_fact.lmoisprest
			, ligne_fact.ident
			, ligne_fact.lmontht
			, ligne_fact.socfact
			, ligne_fact.numfact
			, ligne_fact.typfact
			, ligne_fact.datfact
			, ligne_fact.lnum
			, ligne_fact.lcodcompta
			, facture.numcont
			, facture.cav
			, ligne_fact.ldeppole
		FROM
			datdebex
			, facture
			, ligne_fact
		WHERE facture.socfact=ligne_fact.socfact
			AND facture.numfact=ligne_fact.numfact
			AND facture.typfact=ligne_fact.typfact
			AND facture.datfact=ligne_fact.datfact
			AND (facture.fmodreglt!=8 or facture.fmodreglt is null)
			AND ligne_fact.lcodcompta NOT IN (6350001, 6350002, 6398001)
			AND ligne_fact.lmoisprest BETWEEN ADD_MONTHS(datdebex.datdebex,-12) AND datdebex.moismens;

		COMMIT;
	END Remplir_Facture;


	PROCEDURE Remplir_Ressource IS
	BEGIN
		INSERT INTO faccons_ressource(
			lmoisprest
			, ident
			, codsg
			, prestation
			, soccode
			, cout
			, conso_total
			, fact_total
			, rnom)
		SELECT
			calendrier.calanmois
			, ress.ident
			, NULL
			, NULL
			, NULL
			, NULL
			, NULL
			, NULL
			, ressource.rnom
		FROM
			datdebex
			, calendrier
			, ressource
			, (SELECT DISTINCT ident FROM faccons_consomme
				UNION
			   SELECT DISTINCT ident FROM faccons_facture
			) ress
		WHERE calendrier.calanmois BETWEEN ADD_MONTHS(datdebex.datdebex,-12) AND datdebex.moismens
			AND ress.ident=ressource.ident;

		COMMIT;



		UPDATE faccons_ressource
			SET (codsg, prestation, soccode, cout, montant_mensuel)=
				(SELECT situ_ress.codsg, situ_ress.prestation, situ_ress.soccode, situ_ress.cout, situ_ress.montant_mensuel
					FROM situ_ress
					WHERE situ_ress.ident=faccons_ressource.ident
						AND situ_ress.datsitu=pack_situation_full.datsitu_ressource(faccons_ressource.ident, faccons_ressource.lmoisprest)
	    		);

		COMMIT;



		UPDATE faccons_ressource
			SET conso_total=
				(SELECT SUM(faccons_consomme.cusag)
					FROM faccons_consomme
					WHERE faccons_consomme.ident=faccons_ressource.ident
						AND faccons_consomme.lmoisprest=faccons_ressource.lmoisprest
				)
				, fact_total=
				(SELECT SUM(faccons_facture.montht*DECODE(faccons_facture.typfact, 'A', -1, 1))
					FROM faccons_facture
					WHERE faccons_facture.ident=faccons_ressource.ident
						AND faccons_facture.lmoisprest=faccons_ressource.lmoisprest
				);

		COMMIT;


		DELETE faccons_ressource
			WHERE NVL(conso_total, 0)=0
			AND NVL(fact_total, 0)=0;
		COMMIT;
	END Remplir_Ressource;
END pack_faccons;
/
CREATE OR REPLACE PACKAGE pack_faccons_habili AS
-- **************************************************************************************
-- Nom 		: verif_habili_me
-- Auteur 	: MMC
-- Description 	: Vérifie si l'utilisateur est habilité au BDDPG
--		  en vérifiant d'abord l'existence du code DPG demandé
--		  ( pack_utile.f_verif_dpg(p_codsg)= true or false )
-- Paramètres 	: p_codsg (IN) code DPG demandé (016**** ou 01616** ou 161612)
--		  p_annee (IN) annee courante ou precedente
--		  p_global (IN) contenant le code périmètre de l'utilisateur
-- Retour	: message d'erreur si non habilitation
--
-- **************************************************************************************
  PROCEDURE verif_habili_me ( 	p_codsg   IN  VARCHAR2,
  				p_annee   IN  VARCHAR2,
				p_global  IN  VARCHAR2,
				p_message OUT VARCHAR2 );

END pack_faccons_habili;
/

CREATE OR REPLACE PACKAGE BODY pack_faccons_habili AS
  PROCEDURE verif_habili_me ( 	p_codsg   IN  VARCHAR2,
  				p_annee   IN  VARCHAR2,
				p_global  IN  VARCHAR2,
				p_message OUT VARCHAR2 ) IS

 -- Création du curseur qui ramène tous les BDDPG du périmètre de l'utilisateur
   CURSOR cur_bddpg (p_perimetre IN VARCHAR2) IS
	select codbddpg, codhabili
	from vue_dpg_perime
	where INSTR(p_perimetre, codbddpg) > 0
	order by codbddpg;

  l_perimetre 	VARCHAR2(255);
  l_branche 	varchar2(2);
  l_direction 	varchar2(2);
  l_departement varchar2(7);
  l_pole 	varchar2(5);
  l_groupe 	varchar2(7);
  c_branche 	varchar2(2);
  c_direction 	varchar2(2);
  c_departement varchar2(7);
  c_pole 	varchar2(5);
  c_groupe 	varchar2(7);
  l_dpg         varchar2(7);
  l_habilitation varchar2(6);
  l_msg         varchar2(1024);
  l_saisi 	varchar2(15);

  BEGIN
	l_msg:=p_message ;
	l_msg:='';
	l_habilitation := 'faux';
  -- **************************************************************
  -- 1) Vérification de l'existence du code DPG demandé
  -- ***************************************************************

      IF (p_codsg!='*******' )  THEN
	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);
     	End if;
     END IF;
  -- *********************************************************************************
  -- 2) Vérification de l'habilitation de l'utilisateur par rapport à son périmètre
  -- *********************************************************************************
	-- Récupérer le perimetre du user
      	l_perimetre := pack_global.lire_globaldata(p_global).perime;

   	-- Remplacer les '*' du code DPG par des 0 et remet le code sur 7 caractères
	l_dpg := REPLACE(LPAD(p_codsg,7,'0'),'*','0');

	if substr(l_dpg,4,4)='0000' then --un département
		l_saisi :='dpt';
	else
		if substr(l_dpg,6,2)='00' then --un pôle
			l_saisi :='pole';
		else
			if l_dpg!='0000000' then --un groupe
				l_saisi :='grpe';
			else
				l_saisi :='bip';
			end if;
		end if;
	end if;


	-- Retrouver la direction et la branche du code DPG
     IF (p_codsg!='*******' )  THEN
	BEGIN
	  select distinct lpad(d.codbr,2,0), lpad(d.coddir,2,0)
		into l_branche     , l_direction
	  from struct_info s, directions d
	  where ( s.codsg=to_number(l_dpg) or s.coddeppole=to_number(substr(l_dpg,1,5)) or s.coddep=to_number(substr(l_dpg,1,3)) )
	  and s.coddir=d.coddir
	  and s.topfer='O';


	  l_departement := l_branche||l_direction||SUBSTR(l_dpg,1,3);
	  l_pole 	:= SUBSTR(l_dpg,1,5);
	  l_groupe 	:= l_dpg;

dbms_output.put_line(l_perimetre||', '||l_branche||', '||l_direction||', '||l_departement);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN   --'Le codsg n''est rattaché à aucune direction'
			pack_global.recuperer_message(20356,'%s1', 'codsg', NULL, l_msg);
              	 	raise_application_error(-20356,l_msg);
	END;
     END IF;

	FOR rec_bddpg IN cur_bddpg(l_perimetre) LOOP

 	  c_branche 	:= SUBSTR(rec_bddpg.codbddpg,1,2);          	--03
	  c_direction 	:= SUBSTR(rec_bddpg.codbddpg,3,2);		--14
	  c_departement := SUBSTR(rec_bddpg.codbddpg,1,7);		--0314016
	  c_pole 	:= SUBSTR(rec_bddpg.codbddpg,5,5);		--01616
	  c_groupe 	:= SUBSTR(rec_bddpg.codbddpg,5,7);		--0161612

dbms_output.put_line(l_perimetre||', '||l_dpg||', '||c_branche||', '||c_direction||', '||c_departement||', '||c_pole||', '||c_groupe||', '||rec_bddpg.codhabili);
	  -- Cas où on veut tout (*******)
		if (l_saisi='bip' and rec_bddpg.codhabili='bip') then
	 		l_habilitation := 'vrai';
			exit;
		end if;

 	  -- ******************************************
          -- cas 1 : habilitation à toute la BIP
	  -- ******************************************
		if rec_bddpg.codhabili='bip' then
			--dbms_output.put_line('Vous êtes habilité à toute la BIP  ');
			l_habilitation := 'vrai';

			exit;
		else
	  -- ******************************************
	  -- cas 2 : habilitation à toute une branche
	  -- ******************************************
		if rec_bddpg.codhabili='br' then
			if c_branche=l_branche then
			--dbms_output.put_line('Vous êtes habilité à toute la branche : '||l_branche);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation branche est  :'||c_branche||', et non : '||l_branche);

		else
	  -- ********************************************
	  -- cas 3 : habilitation à toute une direction
	  -- ********************************************
		if rec_bddpg.codhabili='dir' then
			if c_direction=l_direction then
			--dbms_output.put_line('Vous êtes habilité à toute la direction : '||l_direction);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation direction est : '||c_direction||', et non :'||l_direction);

		else
	  -- ********************************************
	  -- cas 4 : habilitation à tout un département
	  -- ********************************************
		if rec_bddpg.codhabili='dpt' then
			if c_departement=l_departement then
			dbms_output.put_line('Vous êtes habilité à tout le departement : '||l_departement);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation département est '||c_departement||', et non :'||l_departement);

		else
 	  -- ********************************************
	  -- cas 5 : habilitation à tout un pole
	  -- ********************************************
		if rec_bddpg.codhabili='pole' then
			if c_pole=l_pole then
			dbms_output.put_line('Vous êtes habilité à tout le pole : '||l_pole);
				l_habilitation := 'vrai';
				exit;
			end if;
		else
	  -- ********************************************
	  -- cas 6 : habilitation à un BDDPG complet
	  -- ********************************************

			if( c_groupe=l_groupe )then
				dbms_output.put_line('Vous êtes habilité au groupe : '||l_groupe);
				l_habilitation := 'vrai';
				exit;
		  	end if;
	                dbms_output.put_line('Votre habilitation groupe est '||c_groupe||', et non :'||l_groupe);

	        end if;
		end if;
		end if;
		end if;
		end if;

	END LOOP;
	 dbms_output.put_line(l_habilitation);
	If l_habilitation='faux' then
		if ( length(rtrim(LPAD(p_codsg,7,'0'),'*'))=7 ) then
		-- Vous n'êtes pas habilité à ce groupe
			pack_global.recuperer_message(20329, NULL, NULL, NULL, l_msg);
               		raise_application_error(-20329,l_msg);
		else
		  if  ( length(rtrim(LPAD(p_codsg,7,'0'),'*'))=5 ) then
		   -- Vous n'êtes pas habilité à ce pôle
		   	pack_global.recuperer_message(20328, NULL, NULL, NULL, l_msg);
               		raise_application_error(-20328,l_msg);
		  else
		     if  ( length(rtrim(LPAD(p_codsg,7,'0'),'*'))=3) then
		     -- Vous n'êtes pas habilité à ce département
			pack_global.recuperer_message(20327, NULL, NULL, NULL, l_msg);
               		raise_application_error(-20327,l_msg);
		     else
		     -- Vous n'êtes pas habilité à toute la BIP
			pack_global.recuperer_message(20357, NULL, NULL, NULL, l_msg);
               		raise_application_error(-20357,l_msg);
		     end if;
		  end if;
		end if;
	End if;


  END verif_habili_me;

END pack_faccons_habili;
/
CREATE OR REPLACE PACKAGE pack_facres  AS

   PROCEDURE verif_facres(
			p_coderessource IN VARCHAR2,
			p_date_deb      IN VARCHAR2,
			p_date_fin 	IN VARCHAR2,
                        p_menu 		IN VARCHAR2,
			p_userid 	IN VARCHAR2
			);
END pack_facres;
/

CREATE OR REPLACE PACKAGE BODY pack_facres  AS
-- ---------------------------------------------------

PROCEDURE verif_facres(
			p_coderessource IN VARCHAR2,
			p_date_deb  	IN VARCHAR2,
			p_date_fin 	IN VARCHAR2,
			p_menu 		IN VARCHAR2,
			p_userid 	IN VARCHAR2
                       )

IS
     code_ress		VARCHAR2(30);
     l_msg		VARCHAR2(100);
     l_codsg    	varchar2(7);
     l_habilitation 	varchar2(10);
     l_date_deb 	varchar2(8);
     l_date_fin 	varchar2(8);
     l_menu 		varchar2(30);
     l_centrefrais 	varchar2(30);
     l_cfrais 		varchar2(30);
   BEGIN


	-- Vérification que la date début est inférieure à la date de fin

	select to_char(to_date(p_date_deb,'DD/MM/YYYY'),'YYYYMMDD') INTO l_date_deb from dual;
	select to_char(to_date(p_date_fin,'DD/MM/YYYY'),'YYYYMMDD') INTO l_date_fin from dual;
	if (l_date_deb > l_date_fin) then
		raise_application_error(-20000,'la date de début doit être inférieure à la date de fin');
	end if;

	-- Recherche d'un code ressource correspondant au critère p_coderessource
	BEGIN
		select ident into code_ress
		from ressource
		where ident = p_coderessource
		and rownum =1;

		select to_char(codsg, 'FM0000000') into l_codsg
		from situ_ress_full,datdebex
		where ident=p_coderessource
		and datsitu <= moismens
		and (datdep > moismens or datdep is null);


 	EXCEPTION
 		WHEN NO_DATA_FOUND THEN -- Msg Code  ressource inconnue
                          pack_global.recuperer_message(20017, NULL, NULL, NULL, l_msg);
                          raise_application_error(-20017,l_msg);

		WHEN OTHERS THEN
	                 raise_application_error(-20997, SQLERRM);
	END;

	l_menu := pack_global.lire_globaldata(p_userid).menutil;

	IF l_menu != 'ACH' THEN
     -- =====================================================================
     -- 07/02/2001 : Test si le DPG appartient au périmètre de l'utilisateur
     -- =====================================================================
     		l_habilitation := pack_habilitation.fhabili_me( l_codsg, p_userid );

		If l_habilitation='faux' then
		-- 'Vous n''êtes pas habilité à cette ressource'
			pack_global.recuperer_message(20364, '%s1', 'à cette ressource', 'P_param6', l_msg);
                	raise_application_error(-20364,l_msg);
		End if;

	ELSE

		l_centrefrais := pack_global.lire_globaldata(p_userid).codcfrais;
		IF (l_centrefrais <> 0) THEN


			SELECT scentrefrais INTO l_cfrais
			FROM struct_info
			where codsg = TO_NUMBER(l_codsg);

			IF l_cfrais <> l_centrefrais THEN
				-- 'Vous n''êtes pas habilité à cette ressource'
				pack_global.recuperer_message(20364, '%s1', 'à cette ressource', 'P_param6', l_msg);
                		raise_application_error(-20364,l_msg);
			End if;
		END IF;
	END IF;

   END verif_facres;

END pack_facres;
/
CREATE OR REPLACE PACKAGE pack_factcont AS


  TYPE FactSelectRec IS RECORD (soclib       societe.soclib%TYPE,
                                socfact      facture.socfact%TYPE,
                                numcont      facture.numcont%TYPE,
                                cav          facture.cav%TYPE,
                                numfact      facture.numfact%TYPE,
                                typfact      facture.typfact%TYPE,
                                datfact      varchar2(20),
                                codsg        varchar2(20),     -- table contrat
                                comcode      varchar2(20),     -- table contrat pour Modifier
                                flaglock     VARCHAR2(20)
                               );

   TYPE VideRec IS RECORD     (filcode      filiale_cli.filcode%TYPE);

   TYPE SelectCurVide IS REF CURSOR RETURN VideRec;

   TYPE FactSelectCur IS REF CURSOR RETURN FactSelectRec;


-- appel en premier
   PROCEDURE select_factconth1 (p_socfact     IN facture.socfact%TYPE,
                                p_numcont     IN facture.numcont%TYPE,
                                p_rnom        IN ressource.rnom%TYPE,
                                p_numfact     IN facture.numfact%TYPE,
                                p_typfact     IN facture.typfact%TYPE,
                                p_datfact     IN VARCHAR2,
                                p_choixfsc    IN VARCHAR2,        -- choix facture sans contrat
                                p_userid      IN VARCHAR2,
                                p_soclibout      OUT VARCHAR2,
                                p_socfactout     OUT VARCHAR2,
                                p_numfactout     OUT VARCHAR2,
                                p_typfactout     OUT VARCHAR2,
                                p_datfactout     OUT VARCHAR2,
                                p_numcontout     OUT VARCHAR2,
                                p_nbcurseur      OUT INTEGER,
                                p_message        OUT VARCHAR2
                                );

-- appel en deuxieme
   PROCEDURE select_factcont   (p_socfact     IN facture.socfact%TYPE,
                                p_numcont     IN facture.numcont%TYPE,
                                p_rnom        IN ressource.rnom%TYPE,
                                p_numfact     IN facture.numfact%TYPE,
                                p_typfact     IN facture.typfact%TYPE,
                                p_datfact     IN VARCHAR2,
                                p_choixfsc    IN VARCHAR2,
                                p_clelc       IN VARCHAR2,
                                p_userid      IN VARCHAR2,
                                p_soclibout      OUT VARCHAR2,
                                p_socfactout     OUT VARCHAR2,
                                p_numcontout     OUT VARCHAR2,
                                p_cavout         OUT VARCHAR2,
                                p_numfactout     OUT VARCHAR2,
                                p_typfactout     OUT VARCHAR2,
                                p_datfactout     OUT VARCHAR2,
                                p_codsgout       OUT VARCHAR2,
                                p_comcodeout     OUT VARCHAR2,
                                p_nbcurseur      OUT INTEGER,
                                p_message        OUT VARCHAR2
                               );

END pack_factcont;
/

CREATE OR REPLACE PACKAGE BODY pack_factcont AS


-- ********************************************************************************************
-- ********************************************************************************************
--
-- SELECT_FACTCONT
--
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE select_factcont   (p_socfact     IN facture.socfact%TYPE,
                                p_numcont     IN facture.numcont%TYPE,
                                p_rnom        IN ressource.rnom%TYPE,
                                p_numfact     IN facture.numfact%TYPE,
                                p_typfact     IN facture.typfact%TYPE,
                                p_datfact     IN VARCHAR2,
                                p_choixfsc    IN VARCHAR2,
                                p_clelc       IN VARCHAR2,
                                p_userid      IN VARCHAR2,
                                p_soclibout      OUT VARCHAR2,
                                p_socfactout     OUT VARCHAR2,
                                p_numcontout     OUT VARCHAR2,
                                p_cavout         OUT VARCHAR2,
                                p_numfactout     OUT VARCHAR2,
                                p_typfactout     OUT VARCHAR2,
                                p_datfactout     OUT VARCHAR2,
                                p_codsgout       OUT VARCHAR2,
                                p_comcodeout     OUT VARCHAR2,
                                p_nbcurseur      OUT INTEGER,
                                p_message        OUT VARCHAR2
                               ) IS

      l_msg         VARCHAR2(1024) ;
      l_soclib      societe.soclib%TYPE ;
      l_socfact     facture.socfact%TYPE ;
      l_numcont     VARCHAR2(30);
      l_cav         VARCHAR2(20);
      l_comcode     VARCHAR2(20);
      l_codsg       VARCHAR2(20);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      -- ======================================
      --      Libellé du CODE SOCIETE
      -- ======================================
      BEGIN
         SELECT soccode , soclib
         INTO   l_socfact , l_soclib
         FROM   societe
         WHERE  soccode = p_socfact;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN       -- Erreur message "Code Societe inexistant"
             pack_global.recuperer_message(20306, NULL, NULL, NULL, l_msg);
             raise_application_error(-20306,l_msg);
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      -- DBMS_OUTPUT.PUT_LINE('--> après test Code societe : ' || l_socfact || '  ' || l_soclib );
      --      p_soclibout := 'SOCLIB#'|| l_soclib;

      -- ==========================================================
      --  Recupere les infos du contrat via la Clélc composé de
      --  numcont(15);cav(2);comcode(11);codsg(7)
      -- ==========================================================
		pack_liste_contrats.xcle_contrat(p_clelc,0,l_numcont,l_cav,l_comcode,l_codsg);

      p_soclibout    :=  l_soclib;
      p_socfactout   :=  p_socfact;
      p_numfactout   :=  p_numfact;
      p_typfactout   :=  p_datfact;
      p_datfactout   :=  p_typfact;
      p_numcontout   :=  l_numcont;
      p_cavout       :=  l_cav;
      p_codsgout     :=  LPAD(l_codsg, 7, '0');
      p_comcodeout   :=  l_comcode;


   END select_factcont;


-- ********************************************************************************************
-- ********************************************************************************************
--
-- SELECT_FACTCONTH1 : vérification de la societe, son libellé, la date de facture, l'existence
--         ou non de la facture dans FACTURE et HISTO_FACT
-- (on consultera ensuite la liste des contrats historisés afin de créer une facture)
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE select_factconth1 (p_socfact     IN facture.socfact%TYPE,
                                p_numcont     IN facture.numcont%TYPE,
                                p_rnom        IN ressource.rnom%TYPE,
                                p_numfact     IN facture.numfact%TYPE,
                                p_typfact     IN facture.typfact%TYPE,
                                p_datfact     IN VARCHAR2,
                                p_choixfsc    IN VARCHAR2,        -- choix facture sans contrat
                                p_userid      IN VARCHAR2,
                                p_soclibout      OUT VARCHAR2,
                                p_socfactout     OUT VARCHAR2,
                                p_numfactout     OUT VARCHAR2,
                                p_typfactout     OUT VARCHAR2,
                                p_datfactout     OUT VARCHAR2,
                                p_numcontout     OUT VARCHAR2,
                                p_nbcurseur      OUT INTEGER,
                                p_message        OUT VARCHAR2
                               ) IS

      l_msg         VARCHAR2(1024) ;
      l_soclib      societe.soclib%TYPE ;
      l_socfact     facture.socfact%TYPE ;
      p_filcode     filiale_cli.filcode%TYPE ;



   BEGIN
      -- Positionner le nb de curseurs ==> 1 ?? plutot 0 !
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';


         --DBMS_OUTPUT.PUT_LINE(p_bouton || '-;-' || p_socfact || '-;-' || p_numcont || '-;-'
         --  || p_rnom || '-;-' || p_numfact || '-;-' || p_typfact || '-;-' || p_datfact || '-;-'
         --  || p_choixfsc || '-;-' || p_userid || '-;;') ;


      --  On recupere le code filiale de l'utilisateur
      p_filcode := pack_global.lire_globaldata(p_userid).filcode;


      -- =======================================================================
      -- Test existence du CODE SOCIETE : on recupere en meme temps son libelle
      -- =======================================================================
      BEGIN
         SELECT soccode , soclib
         INTO   l_socfact , l_soclib
         FROM   societe
         WHERE  soccode = p_socfact;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN       -- Erreur message "Code Societe inexistant"
             pack_global.recuperer_message(20306, NULL, NULL, NULL, l_msg);
             raise_application_error(-20306,l_msg);
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      -- DBMS_OUTPUT.PUT_LINE('--> après test Code societe : ' || l_socfact || '  ' || l_soclib );
      --  p_soclibout := l_soclib;


      -- =======================================
      -- Test Date de facture <= date du jour
      -- =======================================
      DECLARE
         l_datejour DATE;
      BEGIN
         SELECT SYSDATE INTO l_datejour FROM   dual;
         IF l_datejour < to_date(p_datfact,'DD/MM/YYYY') THEN
               -- a adapter pour le num de message
            pack_global.recuperer_message(20104,NULL,NULL,NULL,l_msg);
            raise_application_error(-20104,l_msg);
         END IF;
      END;

      -- =====================================================================================
      -- Test de l'existence de la facture dans la table histo_facture
      -- =====================================================================================
		BEGIN
         SELECT distinct socfact
         INTO   l_socfact
         FROM   histo_facture
         WHERE  socfact = p_socfact
            AND numfact = p_numfact
            AND typfact = p_typfact
            AND datfact = to_date(p_datfact,'DD/MM/YYYY');
      EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL;
            WHEN OTHERS THEN
                raise_application_error(-20997,SQLERRM);
      END;
               -- DBMS_OUTPUT.PUT_LINE('Apres select dans histo facture');
      IF SQL%FOUND THEN
                     -- Erreur message "La facture existe deja dans histo_facture"
         pack_global.recuperer_message(20100, NULL, NULL, NULL, l_msg);
         raise_application_error(-20100,l_msg);
      END IF;

		-- =====================================================================================
		-- Test de l'existence de la facture dans la table facture
		-- =====================================================================================
      BEGIN
         SELECT distinct socfact
         INTO   l_socfact
         FROM   facture
         WHERE  socfact = p_socfact
            AND numfact = p_numfact
            AND typfact = p_typfact
            AND datfact = to_date(p_datfact,'DD/MM/YYYY');

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL;
            WHEN OTHERS THEN
                raise_application_error(-20997,SQLERRM);
      END;
                -- DBMS_OUTPUT.PUT_LINE('Apres select dans facture');
      IF SQL%FOUND THEN
                -- Erreur message "La facture existe deja" dans facture
         pack_global.recuperer_message(20101, NULL, NULL, NULL, l_msg);
         raise_application_error(-20101,l_msg);
      END IF;

      -- initialisation des champs relatifs au contrat pour facture sans contrat
      -- pour facture avec contrat, initialisation par pack_factcont.select_factcont
		p_nbcurseur := 0;

      p_soclibout    :=  l_soclib;
      p_socfactout   := p_socfact;
      p_numfactout   := p_numfact;
      p_typfactout   := p_datfact;
      p_datfactout   := p_typfact;
      p_numcontout   := p_numcont;

END select_factconth1;



-- **************************************************************************************
-- TEST sous SQL+
-- var vcur refcursor
-- var vsoc varchar2(20)
-- var vsoclib varchar2(30)
-- var vnumcont varchar2(20)
-- var vcav varchar2(20)
-- var vnumfact varchar2(20)
-- var vtyp varchar2(20)
-- var vdat varchar2(20)
-- var vcodsg varchar2(20)
-- var vcom varchar2(20)
-- var vchoix varchar2(20)
-- var vnbcur number
-- var vmsg varchar2(200)
-- set serveroutput on
-- set autoprint on
-- exec pack_factcont.select_factcont('SOPR','1248','LE','971221310339','F','31/12/1997','N','S935705;;;;01;',:vcur,:vsoc,:vsoclib,:vnumcont,:vcav,:vnumfact,:vtyp,:vdat,:vcodsg,:vcom,:vnbcur,:vmsg);
-- exec pack_factcont.select_factconth1('SOPR','1248','LE','971221310339','F','31/12/1997','N','S935705;;;;01;'
-- ,:vsoclib,:vsoc,:vnumfact,:vtyp,:vdat,:vnbcur,:vmsg);



END pack_factcont;
/
CREATE OR REPLACE PACKAGE pack_facture AS

 TYPE FactRecType IS RECORD (soclib           societe.soclib%TYPE,
                               socfact          facture.socfact%TYPE,
                               numfact          facture.numfact%TYPE,
                               typfact          facture.typfact%TYPE,
                               datfact          varchar2(20),
                               fmoiacompta      varchar2(20),
                               fmontht          varchar2(20),
                               fstatut1         facture.fstatut1%TYPE,
                               flaglock         VARCHAR2(20),
                               soccont          facture.soccont%TYPE,
                               cav              facture.cav%TYPE,
                               numcont          facture.numcont%TYPE,
                               fenrcompta       varchar2(20),
                               faccsec          varchar2(20),
                               fregcompta       varchar2(20),
                               date_reception   varchar2(20),
                               fenvsec          varchar2(20),   -- date reglement demande
                               fcodcompta       varchar2(20),
                               fsocfour         facture.fsocfour%TYPE,
                               fdeppole         varchar2(20)
                              );

   TYPE VideRec IS RECORD     (filcode      filiale_cli.filcode%TYPE);


   TYPE FactCurType IS REF CURSOR RETURN FactRecType;
   TYPE SelectCurVide IS REF CURSOR RETURN VideRec;

   PROCEDURE controle_champ   (c_daterecp    IN VARCHAR2,      -- date reception
                               c_fdeppole    IN VARCHAR2,      -- code fdeppole de la facture
                               c_fcodcompta  IN VARCHAR2       -- code comptable
                              );

   PROCEDURE verif_filiale_cont (c_soccont    IN facture.soccont%TYPE, -- Societe
                                 c_cav        IN facture.cav%TYPE,     -- Avenant
                                 c_numcont    IN facture.numcont%TYPE, -- Numero Contrat
                                 c_filcode    IN contrat.filcode%TYPE, -- code filiale
                                 c_msg_typecont  OUT VARCHAR2,
                                 c_codsgout      OUT VARCHAR2,
                                 c_comcodeout    OUT VARCHAR2
                                );

   PROCEDURE insert_facture   (p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_datrecp        IN VARCHAR2,      -- date reception + 30 = fenvsec
                               p_fsocfour       IN facture.fsocfour%TYPE,
                               p_fdeppole       IN VARCHAR2,      -- code fdeppole de la facture
                               p_codsg          IN VARCHAR2,      -- code fdeppole du contrat
                               p_fcodcompta     IN VARCHAR2,
                               p_comcode        IN VARCHAR2,      -- code comptable du contrat
                               p_fstatut1       IN facture.fstatut1%TYPE,
                               p_fmoiacompta    IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              );



   PROCEDURE update_facture   (p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_datrecp        IN VARCHAR2,      -- date reception + 30 = fenvsec
                               p_fsocfour       IN facture.fsocfour%TYPE,
                               p_fdeppole       IN VARCHAR2,      -- code fdeppole de la facture
                               p_codsg          IN VARCHAR2,      -- code fdeppole du contrat
                               p_fcodcompta     IN VARCHAR2,
                               p_comcode        IN VARCHAR2,      -- code comptable du contrat
                               p_fstatut1       IN facture.fstatut1%TYPE,
                               p_fmoiacompta    IN VARCHAR2,
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              );

   PROCEDURE delete_facture   (p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_fmontht        IN VARCHAR2,
                               p_fenrcompta     IN VARCHAR2,      -- date envoi enr compta
                               p_faccsec        IN VARCHAR2,      -- date accord pole
                               p_fregcompta     IN VARCHAR2,      -- date reglement compta
                               p_fenvsec        IN VARCHAR2,      -- date reglement demande
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              );

   PROCEDURE select_facture   (p_mode    IN VARCHAR2,
                               p_socfact   IN facture.socfact%TYPE,
                               p_numcont   IN facture.numcont%TYPE,
                               p_rnom      IN ressource.rnom%TYPE,
                               p_numfact   IN facture.numfact%TYPE,
                               p_typfact   IN facture.typfact%TYPE,
                               p_datfact   IN VARCHAR2,
                               p_choixfsc  IN VARCHAR2,        -- choix facture sans contrat
                               p_userid    IN VARCHAR2,
                               p_curselect IN  OUT FactCurType,
                               p_socfactout    OUT VARCHAR2,
                               p_soclibout     OUT VARCHAR2,
                               p_numcontout    OUT VARCHAR2,
                               p_cavout        OUT VARCHAR2,
                               p_numfactout    OUT VARCHAR2,
                               p_typfactout    OUT VARCHAR2,
                               p_datfactout    OUT VARCHAR2,
                               p_codsgout      OUT VARCHAR2,
                               p_comcodeout    OUT VARCHAR2,
                               p_choixfscout   OUT VARCHAR2,
                               p_ftvaout       OUT VARCHAR2,
                               p_msg_info      OUT VARCHAR2,
                               p_nbcurseur     OUT INTEGER,
                               p_message       OUT VARCHAR2
                              );

END pack_facture;
/

CREATE OR REPLACE PACKAGE BODY pack_facture AS


-- **************************************************************************************
--       Procedure controle date reception et existence du code DPG
-- **************************************************************************************
   PROCEDURE controle_champ   (c_daterecp    IN VARCHAR2,      -- date reception
                               c_fdeppole    IN VARCHAR2,      -- code fdeppole de la facture
                               c_fcodcompta  IN VARCHAR2       -- code comptable
                              ) IS

      l_msg       VARCHAR2(1024);
      l_datejour  date;
      l_codsg     struct_info.codsg%TYPE;
      l_comcode   code_compt.comcode%TYPE;

   BEGIN
      -- =======================================
      -- Test Date de réception <= date du jour
      -- =======================================
      BEGIN
         SELECT SYSDATE INTO l_datejour FROM   dual;
         IF l_datejour < to_date(c_daterecp,'DD/MM/YYYY') THEN   -- msg Date doit inf ou egale date jour
            pack_global.recuperer_message(20108,NULL,NULL,'DATE_RECEPTION',l_msg);
            raise_application_error(-20108,l_msg);
         END IF;
      END;

      -- ===================================================
      -- Test Existence du code DPG dans struct_info.codsg
      -- ===================================================
      BEGIN
            SELECT  codsg INTO l_codsg  FROM  struct_info
            WHERE  codsg = TO_NUMBER(c_fdeppole);
      EXCEPTION
            WHEN NO_DATA_FOUND THEN             -- msg Code Departement/pole/groupe inconnu
               pack_global.recuperer_message(20109, NULL, NULL, 'FDEPPOLE', l_msg);
               raise_application_error(-20109,l_msg);
            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
      END;

      -- ===================================================
      -- Test Existence du code comptable dans CODE_COMPT
      -- ===================================================
      BEGIN
            SELECT comcode INTO l_comcode FROM code_compt
            WHERE  comcode = c_fcodcompta ;
      EXCEPTION
            WHEN NO_DATA_FOUND THEN             -- msg Code comptable invalide
               pack_global.recuperer_message(20110, NULL, NULL, 'FCODCOMPTA', l_msg);
               raise_application_error(-20110,l_msg);
            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
      END;
END controle_champ;



-- **************************************************************************************
--       Procedure Verifier la filiale contrat dans tables CONTRAT et HISTO_CONT
-- **************************************************************************************
   PROCEDURE verif_filiale_cont (c_soccont    IN facture.soccont%TYPE, -- Societe
                                 c_cav        IN facture.cav%TYPE,     -- Avenant
                                 c_numcont    IN facture.numcont%TYPE, -- Numero Contrat
                                 c_filcode    IN contrat.filcode%TYPE, -- code filiale
                                 c_msg_typecont  OUT VARCHAR2,
                                 c_codsgout      OUT VARCHAR2,
                                 c_comcodeout    OUT VARCHAR2
                                ) IS
      l_filcode     contrat.filcode%TYPE;
      l_codsg       contrat.codsg%TYPE;
      l_comcode     contrat.comcode%TYPE;
      l_flag_nontrouve  BOOLEAN;
      l_msg         VARCHAR2(512);

   BEGIN
      -- ===========================================
      -- Recherche dans table CONTRAT
      -- ===========================================
      BEGIN
         l_flag_nontrouve := FALSE;

         SELECT   c.filcode, c.codsg, c.comcode
         INTO     l_filcode, l_codsg, l_comcode
         FROM  contrat c
         WHERE  c.soccont = c_soccont
            AND c.cav     = c_cav
            AND c.numcont = c_numcont;

         IF l_filcode <> c_filcode THEN
               -- msg La facture existe mais pour une autre filiale
               pack_global.recuperer_message(20106, NULL, NULL, NULL, l_msg);
               raise_application_error(-20106,l_msg);
            ELSE  -- Contrat Recent : pas de message
               c_msg_typecont := '';

         END IF;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            --  On ne trouve pas de CONTRAT dans table CONTRAT , on continue ...
            l_flag_nontrouve := TRUE;
         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      -- ===========================================
      -- Recherche dans table HISTO_CONT
      -- ===========================================
      IF l_flag_nontrouve THEN
         BEGIN
            SELECT   c.filcode, c.codsg, c.comcode
            INTO     l_filcode, l_codsg, l_comcode
            FROM   histo_contrat c
            WHERE  c.soccont = c_soccont
               AND c.cav     = c_cav
               AND c.numcont = c_numcont;

         IF l_filcode <> c_filcode THEN
                  -- msg La facture existe mais pour une autre filiale
                  pack_global.recuperer_message(20106, NULL, NULL, NULL, l_msg);
                  raise_application_error(-20106,l_msg);
               ELSE  -- Positionner msg 20132 : Attention facture avec contrat historisé
                  pack_global.recuperer_message(20132, NULL, NULL, NULL, l_msg);
                  c_msg_typecont := l_msg;

            END IF;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 -- msg Probl facture fait reference a un contrat inexistant
               pack_global.recuperer_message(20107, NULL, NULL, NULL, l_msg);
               raise_application_error(-20107,l_msg);
            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
         END;
      END IF;

      c_codsgout   := TO_CHAR(l_codsg, 'FM0000000');
      c_comcodeout := l_comcode;

   END verif_filiale_cont;



-- ********************************************************************************************
-- ********************************************************************************************
--
-- INSERT_FACTURE  : controle eventuel sur le contrat et la filiale fait dans Select_facture
--
-- ********************************************************************************************
-- ********************************************************************************************


   PROCEDURE insert_facture   (p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_datrecp        IN VARCHAR2,      -- date reception + 30 = fenvsec
                               p_fsocfour       IN facture.fsocfour%TYPE,
                               p_fdeppole       IN VARCHAR2,      -- code fdeppole de la facture
                               p_codsg          IN VARCHAR2,      -- code fdeppole du contrat
                               p_fcodcompta     IN VARCHAR2,
                               p_comcode        IN VARCHAR2,      -- code comptable du contrat
                               p_fstatut1       IN facture.fstatut1%TYPE,
                               p_fmoiacompta    IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              ) IS

      l_msg       VARCHAR2(1024);
      l_fcoduser   facture.fcoduser%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA       EXCEPTION_INIT(referential_integrity, -2291);
      l_soccont    facture.soccont%TYPE;
      l_cav        facture.cav%TYPE;
      l_numcont    facture.numcont%TYPE;
      l_llibanalyt facture.llibanalyt%TYPE;
      l_date       DATE;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_scentrefrais centre_frais.codcfrais%TYPE;
      l_topfer struct_info.topfer%TYPE;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      -- On recupere le code user (idarpege)
      l_fcoduser := pack_global.lire_globaldata(p_userid).idarpege;

      -- Controle de la Date de réception , du Code DPG , du Code Comptable
      controle_champ(p_datrecp, p_fdeppole, p_fcodcompta);

      -- OK pour Creer.  -> a differencier avec contrat ou sans contrat pour construire le
      -- le libellé analytique

      IF p_numcont IS  NULL THEN
         l_soccont := NULL;
         l_cav     := NULL;
         l_numcont := NULL;
         l_date    := to_date(p_fmoiacompta,'MM/YYYY');
         l_llibanalyt := (rpad(p_socfact,4) || '-' || to_char(l_date,'MMYYYY')
                     || '-' || rpad(p_numfact,15) );

         ELSE
         l_soccont := p_socfact;
         l_cav     := p_cav;
         l_numcont := rpad(p_numcont,15);
         l_date    := to_date(p_fmoiacompta,'MM/YYYY');
         l_llibanalyt := (rpad(p_socfact,4) || '-' || to_char(l_date,'MMYYYY')
                     || '-' || rpad(p_numfact,15) || '-' || rpad(p_numcont,15) );
      END IF;

      -- DBMS_output.put_line('p_numcont=' || p_numcont || ' l_llibanalyt=' || l_llibanalyt);

     -- ==========================================================
     -- Test  fermeture DPG
     -- ==========================================================

	BEGIN
		select topfer, scentrefrais
		into l_topfer, l_scentrefrais
		from struct_info
		where codsg=to_number(p_fdeppole);

	EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20203, NULL, NULL, 'FDEPPOLE', l_msg);
            raise_application_error(-20203, l_msg);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
        END;

        IF l_topfer = 'F' THEN
          pack_global.recuperer_message(20274, NULL, NULL, 'FDEPPOLE', l_msg);
          raise_application_error(-20274, l_msg);
     	END IF;


     -- =====================================================================
     -- Test : appartenance du DPG dans le centre de frais du user
     -- =====================================================================
	 -- On récupère le code centre de frais de l'utilisateur
            l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

	IF l_centre_frais!=0 then    -- le centre de frais 0 donne tous les droits à l'utilisateur
      		IF (l_scentrefrais is null)   then
			--msg : Le DPG n'est rattaché à aucun centre de frais
			pack_global.recuperer_message(20339, NULL,NULL,'FDEPPOLE', l_msg);
          		raise_application_error(-20339, l_msg);
		ELSE
			IF (l_scentrefrais!=l_centre_frais) then
				--msg:Ce DPG n'appartient pas à ce centre de frais
				pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'FDEPPOLE', l_msg);
          			raise_application_error(-20334, l_msg);
			END IF;
      		END IF;
    	ELSE	-- l'utilisateur n'est pas affecté à un centre de frais réel: récupérer le centre de frais du DPG
		IF (l_scentrefrais is null) then
			--msg : Le DPG n'est rattaché à aucun centre de frais
			pack_global.recuperer_message(20339, NULL,NULL,'FDEPPOLE', l_msg);
          		raise_application_error(-20339, l_msg);

		ELSE
			-- le centre de frais du contrat est le centre de frais du DPG
			l_centre_frais := l_scentrefrais;
		END IF;
    	END IF;





      BEGIN

         INSERT INTO facture (socfact,
                              numfact,
                              typfact,
                              datfact,
                              fnumasn,
                              fnumordre,
                              fenvsec,
                              llibanalyt,
                              fmoiacompta,
                              fcoduser,
                              fdatsai,
                              fenrcompta,
                              fstatut1,
                              fsocfour,
                              fcodcompta,
                              fdeppole,
                              flaglock,
                              soccont,
                              cav,
                              numcont,
			      fdatrecep,
			      fcentrefrais
                              )
         VALUES(  p_socfact,
                  p_numfact,
                  p_typfact,
                  to_date(p_datfact,'DD/MM/YYYY'),
                  0,                         -- fnumasn
                  0,                         -- fnumordre
                  (to_date(p_datrecp,'DD/MM/YYYY') + 30),
                  l_llibanalyt,
                  to_date(p_fmoiacompta,'MM/YYYY'),
                  l_fcoduser,
                  sysdate,
                  sysdate,
                  p_fstatut1,
                  p_fsocfour,
                  p_fcodcompta,
                  TO_NUMBER(p_fdeppole),
                  0,                         -- flaglock
                  l_soccont,
                  l_cav,
                  l_numcont,
		  to_date(p_datrecp,'DD/MM/YYYY'),
		  l_centre_frais
                  );
     EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2291);

         WHEN  DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message(20111,NULL, NULL, NULL, l_msg);
            raise_application_error(-20111 , l_msg );

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM );
      END;


    IF SQL%NOTFOUND THEN  -- Acces concurrent
        pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
        raise_application_error( -20999, l_msg );
     ELSE                  -- Msg Facture créée
        pack_global.recuperer_message(2200,'%s1',p_numfact, NULL, l_msg);

     END IF;

     p_message := l_msg;

END insert_facture;



-- ********************************************************************************************************
-- ********************************************************************************************************
--
-- UPDATE_FACTURE   - possible que si fstatut1 = 'AE' ou 'SE' ou 'IN' déjà contrôlé lors du select_facture
--
-- ********************************************************************************************************
-- ********************************************************************************************************

   PROCEDURE update_facture   (p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_datrecp        IN VARCHAR2,      -- date reception + 30 = fenvsec
                               p_fsocfour       IN facture.fsocfour%TYPE,
                               p_fdeppole       IN VARCHAR2,      -- code fdeppole de la facture
                               p_codsg          IN VARCHAR2,      -- code fdeppole du contrat
                               p_fcodcompta     IN VARCHAR2,
                               p_comcode        IN VARCHAR2,      -- code comptable du contrat
                               p_fstatut1       IN facture.fstatut1%TYPE,
                               p_fmoiacompta    IN VARCHAR2,
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              ) IS

      l_msg          VARCHAR2(1024);
      p_filcode      filiale_cli.filcode%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA         EXCEPTION_INIT(referential_integrity, -2291);
      l_soccont      facture.soccont%TYPE;
      l_cav          facture.cav%TYPE;
      l_numcont      facture.numcont%TYPE;
      l_llibanalyt   facture.llibanalyt%TYPE;
      l_fcoduser     facture.fcoduser%TYPE;
      l_date         DATE;
      l_codsg        contrat.codsg%TYPE;
      l_comcode      contrat.comcode%TYPE;
      l_msg_cont     VARCHAR2(512);
      l_topfer 	     struct_info.topfer%TYPE;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_scentrefrais centre_frais.codcfrais%TYPE;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0 ;
      p_message   := '';
      l_msg_cont  := '';

      -- Controle de la Date de réception , du Code DPG , du Code Comptable
      controle_champ(p_datrecp, p_fdeppole, p_fcodcompta);

      --  On recupere le code filiale de l'utilisateur
      p_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- On recupere le code user (idarpege)
      l_fcoduser := pack_global.lire_globaldata(p_userid).idarpege;

      -- Controle filiale du N° contrat et N° Avenant si present
      -- -> a differencier Facture avec contrat ou sans contrat pour construire le libellé analytique
    IF p_numcont IS NOT NULL THEN
      BEGIN
            verif_filiale_cont(p_socfact,p_cav,p_numcont,p_filcode,l_msg_cont,l_codsg,l_comcode);
            l_soccont := p_socfact;
            l_cav     := p_cav;
            l_numcont := rpad(p_numcont,15);
            l_date    := to_date(p_fmoiacompta,'MM/YYYY');
            l_llibanalyt := (rpad(p_socfact,4) || '-' || to_char(l_date,'MMYYYY')
                        || '-' || rpad(p_numfact,15) || '-' || rpad(p_numcont,15) );
         END;
      ELSE
         BEGIN
            l_soccont := NULL;
            l_cav     := NULL;
            l_numcont := NULL;
            l_date    := to_date(p_fmoiacompta,'MM/YYYY');
            l_llibanalyt := (rpad(p_socfact,4) || '-' || to_char(l_date,'MMYYYY')
                        || '-' || rpad(p_numfact,15) );
         END;
      END IF;

     -- ==========================================================
     -- Test existence et fermeture DPG
     -- ==========================================================

	BEGIN
		select topfer, scentrefrais
		into l_topfer, l_scentrefrais
		from struct_info
		where codsg=to_number(p_fdeppole);

	EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20203, NULL, NULL, 'FDEPPOLE', l_msg);
            raise_application_error(-20203, l_msg);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
        END;

        IF l_topfer = 'F' THEN
          pack_global.recuperer_message(20274, NULL, NULL, 'FDEPPOLE', l_msg);
          raise_application_error(-20274, l_msg);
     	END IF;


     -- =====================================================================
     -- Test : appartenance du DPG dans le centre de frais du user
     -- =====================================================================
	 -- On récupère le code centre de frais de l'utilisateur
            l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

     	IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
      		IF (l_scentrefrais is null)   then
			--msg : Le DPG n'est rattaché à aucun centre de frais
			pack_global.recuperer_message(20339, NULL,NULL,'FDEPPOLE', l_msg);
          		raise_application_error(-20339, l_msg);
		ELSE
			IF (l_scentrefrais!=l_centre_frais) then
				--msg:Ce DPG n'appartient pas à ce centre de frais
				pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'FDEPPOLE', l_msg);
          			raise_application_error(-20334, l_msg);
			END IF;
      		END IF;
    	ELSE	-- l'utilisateur n'est pas affecté à un centre de frais réel: récupérer le centre de frais du DPG
		IF (l_scentrefrais is null) then
			--msg : Le DPG n'est rattaché à aucun centre de frais
			pack_global.recuperer_message(20339, NULL,NULL,'FDEPPOLE', l_msg);
          		raise_application_error(-20339, l_msg);

		ELSE
			-- le centre de frais du contrat est le centre de frais du DPG
			l_centre_frais := l_scentrefrais;
		END IF;
    	END IF;



      -- OK on peut Modifier
      BEGIN
         UPDATE FACTURE
         SET   fnumasn     = 0,
               fnumordre   = 0,
               fenvsec     = (to_date(p_datrecp,'DD/MM/YYYY') + 30 ),
               llibanalyt  = l_llibanalyt,
               fmoiacompta = l_date,
               fdatmaj     = sysdate,
               fstatut1    = p_fstatut1,
               fsocfour    = p_fsocfour,
               flaglock    = decode(p_flaglock, 1000000, 0, p_flaglock + 1),
               soccont     = l_soccont,
               cav         = l_cav,
               numcont     = l_numcont,
               fcodcompta  = p_fcodcompta,
               fdeppole    = to_number(p_fdeppole),
	       fdatrecep =to_date(p_datrecp,'DD/MM/YYYY'),
	       fcentrefrais = l_centre_frais
         WHERE  socfact  = p_socfact
           AND  numfact  = rpad(p_numfact,15)
           AND  typfact  = p_typfact
           AND  datfact  = to_date(p_datfact,'DD/MM/YYYY')
           AND  flaglock = to_number(p_flaglock,'FM9999999');

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2291);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN  -- Acces concurrent
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE                 -- Msg Facture modifiée
         pack_global.recuperer_message(2201,'%s1',p_numfact, NULL, l_msg);
         p_message := l_msg || ' ' || l_msg_cont;
      END IF;

END update_facture;



-- ********************************************************************************************
-- ********************************************************************************************
--
-- DELETE_FACTURE  :
--
-- ********************************************************************************************
-- ********************************************************************************************

   PROCEDURE delete_facture   (p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_fmontht        IN VARCHAR2,
                               p_fenrcompta     IN VARCHAR2,      -- date envoi enr compta
                               p_faccsec        IN VARCHAR2,      -- date accord pole
                               p_fregcompta     IN VARCHAR2,      -- date reglement compta
                               p_fenvsec        IN VARCHAR2,      -- date reglement demande
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              ) IS

      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      -- l'utilisateur a déjà fait un select pour visualiser avant, ici on est sur que
      -- la facture existe et donc la seule difference ne concernera que le Flaglock

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM facture
         WHERE  socfact = p_socfact
           AND  numfact = rpad(p_numfact,15)
           AND  typfact = p_typfact
           AND  datfact = to_date(p_datfact,'DD/MM/YYYY')
           AND  flaglock = to_number(p_flaglock,'FM9999999');
      EXCEPTION
         WHEN referential_integrity THEN
              pack_global.recuperation_integrite(-2292);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN       -- ici ce sera erreur d' Accces concurrent
               pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
               raise_application_error( -20999, l_msg );
         ELSE                    --  Facture supprimée
            pack_global.recuperer_message(2202,'%s1' , p_numfact , NULL, l_msg);
            p_message := l_msg;
      END IF;


   END delete_facture;



-- ********************************************************************************************
-- ********************************************************************************************
--
-- SELECT_FACTURE
-- Cas a tester : 1) Bouton Creer (la facture doit etre inexistante)
--                2) Bouton Modifier ou Supprimer
--                3) Bouton Lignes
--
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE select_facture   (p_mode    IN VARCHAR2,
                               p_socfact   IN facture.socfact%TYPE,
                               p_numcont   IN facture.numcont%TYPE,
                               p_rnom      IN ressource.rnom%TYPE,
                               p_numfact   IN facture.numfact%TYPE,
                               p_typfact   IN facture.typfact%TYPE,
                               p_datfact   IN VARCHAR2,
                               p_choixfsc  IN VARCHAR2,        -- choix facture sans contrat
                               p_userid    IN VARCHAR2,
                               p_curselect IN  OUT FactCurType,
                               p_socfactout    OUT VARCHAR2,
                               p_soclibout     OUT VARCHAR2,
                               p_numcontout    OUT VARCHAR2,
                               p_cavout        OUT VARCHAR2,
                               p_numfactout    OUT VARCHAR2,
                               p_typfactout    OUT VARCHAR2,
                               p_datfactout    OUT VARCHAR2,
                               p_codsgout      OUT VARCHAR2,
                               p_comcodeout    OUT VARCHAR2,
                               p_choixfscout   OUT VARCHAR2,
                               p_ftvaout       OUT VARCHAR2,
                               p_msg_info      OUT VARCHAR2,
                               p_nbcurseur     OUT INTEGER,
                               p_message       OUT VARCHAR2
                              ) IS

      l_msg          VARCHAR2(1024) ;
      l_soclib       societe.soclib%TYPE ;
      l_socfact      facture.socfact%TYPE ;
      p_filcode      filiale_cli.filcode%TYPE ;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_fcentrefrais centre_frais.codcfrais%TYPE;
   BEGIN
      -- Initialiser le message retour
      p_message     := '';
      p_socfactout  :=  p_socfact;
      p_numfactout  :=  p_numfact;
      p_datfactout  :=  p_datfact;
      p_typfactout  :=  p_typfact;
      p_choixfscout :=  p_choixfsc;

      -- initialisation des champs relatifs au contrat pour facture sans contrat
      -- pour Créer facture avec contrat, initialisation par pack_factcont.select_factcont
      p_numcontout  :=  '' ;
      p_cavout      :=  '' ;
      p_codsgout    :=  '' ;
      p_comcodeout  :=  '' ;



         --DBMS_OUTPUT.PUT_LINE(p_mode || '-;-' || p_socfact || '-;-' || p_numcont || '-;-'
         --  || p_rnom || '-;-' || p_numfact || '-;-' || p_typfact || '-;-' || p_datfact || '-;-'
         --  || p_choixfsc || '-;-' || p_userid || '-;;') ;


      --  On recupere le code filiale de l'utilisateur
      p_filcode := pack_global.lire_globaldata(p_userid).filcode;


      -- =======================================================================
      -- Test existence du CODE SOCIETE : on recupere en meme temps son libelle
      -- =======================================================================
      BEGIN
         SELECT soccode , soclib
         INTO   l_socfact , l_soclib
         FROM   societe
         WHERE  soccode = p_socfact;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN       -- Erreur message "Code Societe inexistant"
             pack_global.recuperer_message(20306, NULL, NULL, NULL, l_msg);
             raise_application_error(-20306,l_msg);
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      -- DBMS_OUTPUT.PUT_LINE('--> après test Code societe : ' || l_socfact || '  ' || l_soclib );
      p_soclibout :=  l_soclib;


      -- =======================================
      -- Test Date de facture <= date du jour
      -- =======================================
      DECLARE
         l_datejour DATE;
      BEGIN
         SELECT SYSDATE INTO l_datejour FROM   dual;
         IF l_datejour < to_date(p_datfact,'DD/MM/YYYY') THEN
               -- a adapter pour le num de message
            pack_global.recuperer_message(20104,NULL,NULL,NULL,l_msg);
            raise_application_error(-20104,l_msg);
         END IF;
      END;



  -- ****************************************************************************
  --
  --       Cas   CREER
  --
  -- ****************************************************************************

  IF p_mode = 'insert' THEN

      BEGIN

	-- ========================
      	-- Test SOCIETE FERMEE
      	-- ========================
      	BEGIN
         	SELECT soccode
         	INTO   l_socfact
         	FROM   societe
         	WHERE  soccode = p_socfact
	 	AND (socfer is null or socfer='');
      	EXCEPTION
         	WHEN NO_DATA_FOUND THEN       -- Erreur message "Création impossible, la société n'existe plus"
             		pack_global.recuperer_message(20325, NULL, NULL, NULL, l_msg);
             		raise_application_error(-20325,l_msg);
         	WHEN OTHERS THEN
             		raise_application_error(-20997,SQLERRM);
      	END;


         -- ==============================================================
         -- Test de l'existence de la facture dans la table histo_facture
         -- ==============================================================
         -- S'il n'existe pas OK,  sinon erreur
         BEGIN
            SELECT distinct socfact
            INTO   l_socfact
            FROM   histo_facture
            WHERE  socfact = p_socfact
               AND numfact = rpad(p_numfact,15)
               AND typfact = p_typfact;
         EXCEPTION
               WHEN NO_DATA_FOUND THEN
                   NULL;
               WHEN OTHERS THEN
                   raise_application_error(-20997,SQLERRM);
         END;
                  -- DBMS_OUTPUT.PUT_LINE('Apres select dans histo facture');
         IF SQL%FOUND THEN
                        -- Erreur message "La facture existe deja dans histo_facture"
            pack_global.recuperer_message(20100, NULL, NULL, NULL, l_msg);
            raise_application_error(-20100,l_msg);
         END IF;

         -- ===========================================================
         -- Test de l'existence de la facture dans la table facture
         -- ===========================================================
         BEGIN
            SELECT distinct socfact
            INTO   l_socfact
            FROM   facture
            WHERE  socfact = p_socfact
               AND numfact = rpad(p_numfact,15)
               AND typfact = p_typfact;

            -- modif 19042000 :  AND datfact = to_date(p_datfact,'DD/MM/YYYY');

            EXCEPTION
               WHEN NO_DATA_FOUND THEN
                   NULL;
               WHEN OTHERS THEN
                   raise_application_error(-20997,SQLERRM);
         END;
                   -- DBMS_OUTPUT.PUT_LINE('Apres select dans facture');
         IF SQL%FOUND THEN
                   -- Erreur message "La facture existe deja dans facture "
            pack_global.recuperer_message(20101, NULL, NULL, NULL, l_msg);
            raise_application_error(-20101,l_msg);
         END IF;

         -- ======================================================================
         -- Curseur VIDE  pour armer p_curselect sinon HTML va se perdre !!!
         -- ======================================================================
         BEGIN

         p_nbcurseur   := 0;

            OPEN p_curselect FOR
            SELECT  s.soclib,f.socfact,f.numfact,f.typfact,
                    TO_CHAR(f.datfact,'dd/mm/yyyy'),
                    TO_CHAR(f.fmoiacompta,'mm/yyyy'),
                    TO_CHAR(f.fmontht,'FM99999990D00'),
                    f.fstatut1,
                    TO_CHAR(f.flaglock),f.soccont,f.cav,f.numcont,
                    TO_CHAR(f.fenrcompta,'dd/mm/yyyy'),
                    TO_CHAR(f.faccsec,'dd/mm/yyyy'),
                    TO_CHAR(f.fregcompta,'dd/mm/yyyy'),
		    TO_CHAR(f.fdatrecep,'dd/mm/yyyy'),
                    TO_CHAR(f.fenvsec,'dd/mm/yyyy'),
                    f.fcodcompta,
                    f.fsocfour,
                    TO_CHAR(f.fdeppole,'FM0000000')
            FROM  facture f, societe s
            WHERE f.socfact = s.soccode
               AND s.soccode IS NULL;

         EXCEPTION
           WHEN NO_DATA_FOUND THEN  NULL;
           WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);

         END;  --   Fin de renvoi curseur Vide

      END;  -- Fin Bloc Creation
   END IF;  -- Fin de IF Creation


   -- ******************************************************************
   --
   -- Cas  MODIFIER  ou  SUPPRIMER ou LIGNES
   --
   -- ******************************************************************
   --

   IF (p_mode = 'update' OR p_mode = 'delete' OR p_mode = 'lignes') THEN

   DECLARE
      l_fprovsegl1   facture.fprovsegl1%TYPE;
      l_fprovsegl2   facture.fprovsegl2%TYPE;
      l_fmodreglt    facture.fmodreglt%TYPE;
      l_fstatut1     facture.fstatut1%TYPE;
      l_fstatut2     facture.fstatut2%TYPE;
      l_soccont      facture.soccont%TYPE;
      l_cav          facture.cav%TYPE;
      l_numcont      facture.numcont%TYPE;
      l_tva          facture.ftva%TYPE;
      l_filcode      contrat.filcode%TYPE;
      l_codsg        contrat.codsg%TYPE;
      l_comcode      contrat.comcode%TYPE;
      l_msg_cont     VARCHAR2(200);
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_fcentrefrais centre_frais.codcfrais%TYPE;

   BEGIN
      -- Test existence de la facture
      -- Si existe Alors
      --       Pour Modifier ou Lignes AUTORISER Si fstatut1 = AE ou SE ou IN ou EN (kha 12/08/2004 pas EN)
      --       Pour Supprimer INTERDIRE Si fstatut1 = VA et fmodreglt = 1
      --                                si fstatut1 = AE et fmodreglt = 8
      --                                si fstatut1 = VA et fmodreglt = 8
	--       La liste des lignes de factures sera obtenue par lister_ligne_fact
      -- EXCEPTION si facture inexistante

      BEGIN
         SELECT f.fprovsegl1,f.fprovsegl2,f.fmodreglt,f.fstatut1,f.fstatut2,f.soccont,f.cav,f.numcont,f.ftva,f.fcentrefrais
         INTO   l_fprovsegl1,l_fprovsegl2,l_fmodreglt,l_fstatut1,l_fstatut2,l_soccont,l_cav,l_numcont,l_tva,l_fcentrefrais         	 FROM  facture f , societe s
         WHERE     f.socfact = s.soccode
               AND s.soccode = p_socfact
               AND f.numfact = rpad(p_numfact,15)
               AND f.typfact = p_typfact
               AND f.datfact = to_date(p_datfact,'DD/MM/YYYY');
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
               pack_global.recuperer_message(20103, NULL, NULL, NULL, l_msg);
               raise_application_error(-20103,l_msg);

        WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
      END;

      -- ======================================================================================
      -- 20/12/2000 :Contrôler que la facture appartient au centre de frais de l'utilisateur
      -- =======================================================================================
	 -- On récupère le code centre de frais de l'utilisateur
            l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

     	IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur

		IF l_fcentrefrais is null THEN
			-- la facture n'est rattachée à aucun centre de frais
			pack_global.recuperer_message(20337,NULL,NULL,NULL, l_msg);
         	 	raise_application_error(-20337, l_msg);

		ELSE
			IF l_centre_frais!=l_fcentrefrais THEN
				-- la facture n'est pas rattachée au centre de frais %s1 mais au centre de frais %s2
				pack_global.recuperer_message(20338,'%s1',to_char(l_centre_frais),'%s2',
									to_char(l_fcentrefrais),NULL, l_msg);
         			raise_application_error(-20338, l_msg);

			END IF;
		END IF;

	END IF;


      --    DBMS_OUTPUT.PUT_LINE(' --> Verif statut:' || l_fstatut1 || ';' || l_fprovsegl1  );

                   -- Test si c'est autorise pour Modifier ou Lignes
     IF  (p_mode = 'update' OR p_mode = 'lignes') THEN
     	--kha f209 12/08/2004
     	--IF (l_fstatut1 = 'AE' OR l_fstatut1 = 'SE' OR l_fstatut1 = 'IN' OR l_fstatut1 = 'EN') THEN  NULL ; -- OK modif
         IF (l_fstatut1 = 'AE' OR l_fstatut1 = 'SE' OR l_fstatut1 = 'IN') THEN  NULL ; -- OK modif
         ELSE           -- Message  Modification interdite
               pack_global.recuperer_message(20102, NULL, NULL, NULL, l_msg);
               raise_application_error(-20102,l_msg);
         END IF;
      ELSE       -- Test si c'est autorise pour Supprimer
         IF  p_mode = 'delete' THEN
            IF    (l_fstatut1   = 'VA' AND l_fmodreglt  = 1 )
            THEN  -- Message  Facture validée par SEGL, suppression interdite
                pack_global.recuperer_message(20105, NULL, NULL, NULL, l_msg);
                raise_application_error(-20105,l_msg);
            END IF;

	    IF   ( (l_fstatut1   = 'AE'
			AND l_fmodreglt  = 8 ) OR (l_fstatut1   = 'VA'
			AND l_fmodreglt  = 8 ) )
            THEN  -- Message  Facture annulée, suppression interdite
                pack_global.recuperer_message(20379, NULL, NULL, NULL, l_msg);
                raise_application_error(-20379,l_msg);
            END IF;
         END IF;
      END IF;


      -- =================================================================================
      -- Cas facture avec contrat : A-t-on la bonne filiale ? - Initialisation de C.COMCODE et C.CODSG
      -- =================================================================================
      IF l_numcont IS NOT NULL THEN
            verif_filiale_cont(l_soccont,l_cav,l_numcont,p_filcode,l_msg_cont,l_codsg,l_comcode);
            p_codsgout    :=  TO_CHAR(l_codsg, 'FM0000000');
            p_comcodeout  :=  l_comcode;
         IF l_msg_cont IS NOT NULL THEN
            p_msg_info    :=  l_msg_cont ;
         END IF;
      END IF;

      -- Select du Taux TVA
      IF l_tva IS NULL THEN
           BEGIN SELECT tva into l_tva FROM tva WHERE datetva = (SELECT max(datetva) FROM tva );
           END;
      END IF;
      p_ftvaout := TO_CHAR(l_tva,'FM00D00') ;

      -- =================================================================================
      -- OK Maintenant tout est bon, select de la facture suivant MODIF ou SUPPR ou LIGNES
      -- =================================================================================
      p_nbcurseur := 1;

      BEGIN
      OPEN p_curselect FOR
         SELECT  s.soclib,
                 f.socfact,
                 f.numfact,
                 f.typfact,
                 TO_CHAR(f.datfact,'dd/mm/yyyy'),
                 TO_CHAR(f.fmoiacompta,'mm/yyyy'),
                 TO_CHAR(f.fmontht,'FM99999990D00'),
                 f.fstatut1,
                 TO_CHAR(f.flaglock),
                 f.soccont,
                 f.cav,
                 f.numcont,
                 TO_CHAR(f.fenrcompta,'dd/mm/yyyy'),
                 TO_CHAR(f.faccsec,'dd/mm/yyyy'),
                 TO_CHAR(f.fregcompta,'dd/mm/yyyy'),
TO_CHAR(f.fdatrecep,'dd/mm/yyyy'),
                 --TO_CHAR((f.fenvsec - 30),'dd/mm/yyyy'),    -- date reception
                 TO_CHAR((f.fenvsec),'dd/mm/yyyy'),         -- date reglement souhaite
                 f.fcodcompta,
                 f.fsocfour,
                 TO_CHAR(f.fdeppole,'FM0000000')
         FROM  facture f, societe s
         WHERE  f.socfact = s.soccode
            AND s.soccode = p_socfact
            AND f.numfact = rpad(p_numfact,15)
            AND f.typfact = p_typfact
            AND f.datfact = to_date(p_datfact,'DD/MM/YYYY');
      EXCEPTION
        WHEN NO_DATA_FOUND THEN     -- Msg Aucune facture pour la sélection demandée
            pack_global.recuperer_message(20103, NULL, NULL, NULL, l_msg);
            raise_application_error(-20103,l_msg);

        WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END; -- end select pour Modifier , Supprimer ou Lignes

   END;     -- End bloc Modifier ,Supprimer, Lignes
   END IF;  -- Fin du cas  MODIFIER ou SUPPRIMER ou LIGNES

END select_facture;

-- **************************************************************************************
-- TEST sous SQL+
-- var vcur refcursor
-- var vsoc varchar2(20)
-- var vsoclib varchar2(30)
-- var vnumcont varchar2(30)
-- var vcav varchar2(20)
-- var vnumfact varchar2(30)
-- var vtyp varchar2(20)
-- var vdat varchar2(20)
-- var vcodsg varchar2(20)
-- var vcom varchar2(20)
-- var vchoix varchar2(20)
-- var vnbcur number
-- var vmsg varchar2(200)
-- var vftva varchar2(20)
-- set serveroutput on
-- set autoprint on
-- exec pack_facture.select_facture('Lignes','SOPR','','LE','971221310339','F','10/11/1999','N','S935705;;;;01;', :vcur,:vsoc,:vsoclib,:vnumcont,:vcav,:vnumfact,:vtyp,:vdat,:vcodsg,:vcom,:vchoix,:vftva,:vnbcur,:vmsg);
-- exec pack_facture.insert_facture('SOPR','SOPRA','1248','02','LE123456','F','10/11/1999','10/11/1999','631195','241612','241612','4376','4376','AE','10/1999','S935705;;;;01;',:vcur,:vnbcur,:vmsg)
-- exec pack_facture.insert_facture('SOPR','SOPRA','','','LE123456','F','10/11/1999','10/11/1999','631195','241612','241612','4376','4376','AE','10/1999','S935705;;;;01;',:vcur,:vnbcur,:vmsg)
-- exec pack_facture.delete_facture('SOPR','LE123456','F','10/11/1999','5000,00','10/11/1999','01/10/1999','10/11/1999','10/11/1999',0,'S935705;;;;01;',:vcur,:vnbcur,:vmsg)
-- exec pack_facture.update_facture('SOPR','SOPRA','1248','02','LE123456','F','10/11/1999','1/11/1999','631195','241612','241612','4376','4376','IN','10/1999',0,'S935705;;;;01;',:vcur,:vnbcur,:vmsg)
-- attention au flaglock lors des operations update,modify et delete

END pack_facture;
/
CREATE OR REPLACE PACKAGE pack_fact_segl AS

   TYPE FactSelect1 IS RECORD (soclib       societe.soclib%TYPE,
                               socfact      facture.socfact%TYPE,
                               numfact      facture.numfact%TYPE,
                               typfact      facture.typfact%TYPE,
                               datfact      VARCHAR2(20),
                               faccsec      VARCHAR2(20),
                               fnumasn      VARCHAR2(20),
                               fregcompta   VARCHAR2(20),
                               fenvsec      VARCHAR2(20),
                               fmodreglt    VARCHAR2(20),
                               fmontht      VARCHAR2(20),
                               fmontttc     VARCHAR2(20),
                               llibanalyt   facture.llibanalyt%TYPE,
                               fmoiacompta  VARCHAR2(20),
                               fstatut1     facture.fstatut1%TYPE,
                               fstatut2     facture.fstatut2%TYPE,
                               fprovsdff1   facture.fprovsdff1%TYPE,
                               fprovsdff2   facture.fprovsdff2%TYPE,
                               fprovsegl1   facture.fprovsegl1%TYPE,
                               fprovsegl2   facture.fprovsegl2%TYPE,
                               fsocfour     facture.fsocfour%TYPE,
		        	socflib	agence.socflib%TYPE,
		        	numcont      facture.numcont%TYPE,
                               cav          facture.cav%TYPE,
                               fdeppole     VARCHAR2(20),
                               ftva         VARCHAR2(20),
                               flaglock     VARCHAR2(20)
                               );

   TYPE FactSelect2 IS RECORD (soclib       societe.soclib%TYPE,
                               socfact      facture.socfact%TYPE,
                               numcont      facture.numcont%TYPE,
                               cav          facture.cav%TYPE,
                               numfact      facture.numfact%TYPE,
                               typfact      facture.typfact%TYPE,
                               datfact      VARCHAR2(20),
                               fdeppole     VARCHAR2(20),
                               fmontht      VARCHAR2(20),
                               ftva         VARCHAR2(20),
                               fmontttc     VARCHAR2(20),
                               fmoiacompta  VARCHAR2(20),
                               flaglock     VARCHAR2(20)
                               );

   TYPE FactSelect1Cur IS REF CURSOR RETURN FactSelect1;

   TYPE FactSelect2Cur IS REF CURSOR RETURN FactSelect2;

   TYPE LigfSelect IS RECORD  (socfact      facture.socfact%TYPE,
                               soclib       societe.soclib%TYPE,
                               numcont      facture.numcont%TYPE,
                               cav          facture.cav%TYPE,
                               numfact      facture.numfact%TYPE,
                               typfact      facture.typfact%TYPE,
                               datfact      VARCHAR2(20),
                               lnum         VARCHAR2(10),
                               ident        VARCHAR2(10),
                               rnom         ressource.rnom%TYPE,
                               rprenom      ressource.rprenom%TYPE,
                               lmontht      VARCHAR2(10),
                               lmoisprest   VARCHAR2(10),
                               lcodcompta   VARCHAR2(20)
                              );

   TYPE LigfSelectCur IS REF CURSOR RETURN LigfSelect;

   PROCEDURE verif_codecompta  (c_codcompta   IN VARCHAR2       -- code comptable
                               );

   PROCEDURE verif_filiale_cont_segl
                                (c_soccont    IN facture.soccont%TYPE, -- Societe
                                 c_cav        IN facture.cav%TYPE,     -- Avenant
                                 c_numcont    IN facture.numcont%TYPE, -- Numero Contrat
                                 c_filcode    IN contrat.filcode%TYPE, -- code filiale
                                 c_msg_typecont  OUT VARCHAR2
                                );

PROCEDURE update_facture_segl (p_socfact     IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_fdeppole    IN VARCHAR2,
                               p_fmontht     IN VARCHAR2,
                               p_ftva        IN VARCHAR2,
                               p_fmontttc    IN VARCHAR2,
                               p_fsocfour    IN facture.fsocfour%TYPE,
                               p_fmoiacompta IN VARCHAR2,
                               p_liste       IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_fsocfourout    OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              );

PROCEDURE select_facture_segl (p_socfact     IN facture.socfact%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_curselect   IN OUT FactSelect1Cur,
                               p_soclibout      OUT VARCHAR2,
                               p_socfactout     OUT VARCHAR2,
                               p_numfactout     OUT VARCHAR2,
                               p_typfactout     OUT VARCHAR2,
                               p_datfactout     OUT VARCHAR2,
                               p_msg_info       OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              );

PROCEDURE select_facture2_segl (p_socfact     IN facture.socfact%TYPE,
                                p_soclib      IN societe.soclib%TYPE,
                                p_numfact     IN facture.numfact%TYPE,
                                p_typfact     IN facture.typfact%TYPE,
                                p_datfact     IN VARCHAR2,
                                p_faccsec     IN VARCHAR2,
                                p_fnumasn     IN VARCHAR2,
                                p_fregcompta  IN VARCHAR2,
                                p_fenvsec     IN VARCHAR2,
                                p_fmodreglt   IN VARCHAR2,
                                p_fsocfour    IN VARCHAR2,
                                p_fmontht     IN VARCHAR2,
                                p_fmontttc    IN VARCHAR2,
                                p_llibanalyt  IN facture.llibanalyt%TYPE,
                                p_fmoiacompta IN VARCHAR2,
                                p_fstatut1    IN facture.fstatut1%TYPE,
                                p_fstatut2    IN facture.fstatut2%TYPE,
                                p_fprovsdff1  IN facture.fprovsdff1%TYPE,
                                p_fprovsdff2  IN facture.fprovsdff2%TYPE,
                                p_fprovsegl1  IN facture.fprovsegl1%TYPE,
                                p_fprovsegl2  IN facture.fprovsegl2%TYPE,
                                p_flaglock    IN VARCHAR2,
                                p_userid      IN VARCHAR2,
                                p_curselect   IN OUT FactSelect2Cur,
                                p_fsocfourout    OUT VARCHAR2,
                                p_nbcurseur      OUT INTEGER,
                                p_message        OUT VARCHAR2
                              );

  PROCEDURE select_ligne_segl (p_socfact     IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_fdeppole    IN VARCHAR2,
                               p_fmontht     IN VARCHAR2,
                               p_ftva        IN VARCHAR2,
                               p_fmontttc    IN VARCHAR2,
                               p_fsocfour    IN facture.fsocfour%TYPE,
                               p_fmoiacompta IN VARCHAR2,
                               p_clelf       IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_socfactout     OUT VARCHAR2,
                               p_soclibout      OUT VARCHAR2,
                               p_numcontout     OUT VARCHAR2,
                               p_cavout         OUT VARCHAR2,
                               p_numfactout     OUT VARCHAR2,
                               p_typfactout     OUT VARCHAR2,
                               p_datfactout     OUT VARCHAR2,
                               p_lnumout        OUT VARCHAR2,
                               p_identout       OUT VARCHAR2,
                               p_rnomout        OUT VARCHAR2,
                               p_rprenomout     OUT VARCHAR2,
                               p_lmonthtout     OUT VARCHAR2,
                               p_lmoisprestout  OUT VARCHAR2,
                               p_lcodcomptaout  OUT VARCHAR2,
                               p_fsocfourout    OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              );

  PROCEDURE update_ligne_segl (p_socfact     IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_ident       IN VARCHAR2,
                               p_rnom        IN ressource.rnom%TYPE,
                               p_rprenom     IN ressource.rprenom%TYPE,
                               p_lmontht     IN VARCHAR2,
                               p_lmoisprest  IN VARCHAR2,
                               p_lcodcompta  IN VARCHAR2,
                               p_lnum        IN VARCHAR2,
                               p_fdeppole    IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_fdeppoleout    OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              );
END pack_fact_segl;
/

CREATE OR REPLACE PACKAGE BODY pack_fact_segl AS

-- ***********************************************
--
--       Verification code comptabble
--
-- ***********************************************
   PROCEDURE verif_codecompta  (c_codcompta     IN VARCHAR2       -- code comptable
                               ) IS
      l_msg       VARCHAR2(1024);
      l_comcode   code_compt.comcode%TYPE;
      -- ===================================================
      -- Test Existence du code comptable pour Ligne Facture
      -- ===================================================
   BEGIN
      SELECT comcode INTO l_comcode FROM code_compt
            WHERE  comcode = c_codcompta ;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN             -- msg Code comptable invalide
           pack_global.recuperer_message(20110, NULL, NULL, 'LCODCOMPTA', l_msg);
           raise_application_error(-20110,l_msg);
      WHEN OTHERS THEN
           raise_application_error(-20997,SQLERRM);
   END verif_codecompta;


-- **************************************************************************************
--       Verifier la filiale contrat pour ce menu SEGL dans tables CONTRAT et HISTO_CONT
-- NB : different de pack_facture.verif_filiale_cont
-- **************************************************************************************
   PROCEDURE verif_filiale_cont_segl(c_soccont    IN facture.soccont%TYPE, -- Societe
                                     c_cav        IN facture.cav%TYPE,     -- Avenant
                            	     c_numcont    IN facture.numcont%TYPE, -- Numero Contrat
                            	     c_filcode    IN contrat.filcode%TYPE, -- code filiale
                            	     c_msg_typecont  OUT VARCHAR2
                                ) IS

      l_filcode     	contrat.filcode%TYPE;
      l_flag_nontrouve  BOOLEAN;
      l_msg         	VARCHAR2(512);

   BEGIN
      -- ===========================================
      -- Recherche dans table CONTRAT
      -- ===========================================
      BEGIN
         l_flag_nontrouve := FALSE;

         SELECT   c.filcode
         INTO     l_filcode
         FROM  contrat c
         WHERE  c.soccont = c_soccont
            AND c.cav     = c_cav
            AND c.numcont = c_numcont;

         IF l_filcode <> c_filcode THEN
               -- msg Le Contrat appartient à une autre filiale
               pack_global.recuperer_message(20112, NULL, NULL, NULL, l_msg);
               raise_application_error(-20112,l_msg);
            ELSE  -- Contrat Recent Pas de message
               c_msg_typecont := '';

         END IF;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            --  On ne trouve pas de CONTRAT dans table CONTRAT , on continue ...
            l_flag_nontrouve := TRUE;
         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      -- ===========================================
      -- Recherche dans table HISTO_CONT
      -- ===========================================
      IF l_flag_nontrouve THEN
         BEGIN
            SELECT   c.filcode
            INTO     l_filcode
            FROM   histo_contrat c
            WHERE  c.soccont = c_soccont
               AND c.cav     = c_cav
               AND c.numcont = c_numcont;

            IF l_filcode <> c_filcode THEN
                 -- msg Le Contrat appartient à une autre filiale
                 pack_global.recuperer_message(20112, NULL, NULL, 'NUMCONT', l_msg);
                 raise_application_error(-20112,l_msg);
               ELSE  -- Positionner msg 20132 : Attention facture avec un contrat historisé
                  pack_global.recuperer_message(20132, NULL, NULL, NULL, l_msg);
                  c_msg_typecont := l_msg;
            END IF;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 -- msg Contrat/avenant inconnu
               pack_global.recuperer_message(20129, NULL, NULL, 'NUMCONT', l_msg);
               raise_application_error(-20129,l_msg);
            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
         END;
      END IF;

   END verif_filiale_cont_segl;




-- ********************************************************************************************************
-- ********************************************************************************************************
--
-- UPDATE_FACTURE   - possible que si fstatut1 = 'AE' ou 'SE' ou 'IN' déjà contrôlé lors du select_facture_segl
--
-- ********************************************************************************************************
-- ********************************************************************************************************
   PROCEDURE update_facture_segl (p_socfact     IN facture.socfact%TYPE,
                             	  p_soclib      IN societe.soclib%TYPE,
                             	  p_numcont     IN facture.numcont%TYPE,
                             	  p_cav         IN facture.cav%TYPE,
                             	  p_numfact     IN facture.numfact%TYPE,
                             	  p_typfact     IN facture.typfact%TYPE,
                             	  p_datfact     IN VARCHAR2,
                             	  p_fdeppole    IN VARCHAR2,      -- code fdeppole de la facture
                             	  p_fmontht     IN VARCHAR2,
                             	  p_ftva        IN VARCHAR2,      -- code comptable du contrat
                             	  p_fmontttc    IN VARCHAR2,
                             	  p_fsocfour    IN facture.fsocfour%TYPE,
                             	  p_fmoiacompta IN VARCHAR2,
                             	  p_liste       IN VARCHAR2,
                             	  p_flaglock    IN VARCHAR2,
                             	  p_userid      IN VARCHAR2,
                             	  p_fsocfourout    OUT VARCHAR2,
                             	  p_flaglockout    OUT VARCHAR2,
                             	  p_nbcurseur      OUT INTEGER,
                             	  p_message        OUT VARCHAR2
                              ) IS

      l_msg          VARCHAR2(1024);
      l_filcode      filiale_cli.filcode%TYPE;
      p_filcode      filiale_cli.filcode%TYPE;
      l_codsg        struct_info.codsg%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA         EXCEPTION_INIT(referential_integrity, -2292);
      l_llibanalyt   facture.llibanalyt%TYPE;
      l_date         DATE;
      l_msg_cont     VARCHAR2(200);
      l_soccont      facture.soccont%TYPE;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_scentrefrais centre_frais.codcfrais%TYPE;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';
      p_fsocfourout :=  p_fsocfour ;
      p_flaglockout :=  p_flaglock;

      --  On recupere le code filiale de l'utilisateur
      p_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- ====================================================================================
      -- Controle filiale du N° contrat et N° Avenant si present
      -- -> a differencier Facture avec contrat ou sans contrat pour construire le libellé analytique
      -- ====================================================================================
      IF p_numcont IS NOT NULL THEN
         BEGIN
            -- =========================================================
            --    Test contrat existant ? appartenant à la filiale ?
            -- =========================================================
            verif_filiale_cont_segl(p_socfact,p_cav,p_numcont,p_filcode,l_msg_cont);
            l_msg_cont := ' - ' || l_msg_cont;

            -- =========================================================
            --    Creer Libellé analytique cas Facture avec Contrat
            -- =========================================================
               l_date    := to_date(p_fmoiacompta,'MM/YYYY');
               l_llibanalyt := (rpad(p_socfact,4) || '-' || to_char(l_date,'MMYYYY')
                     || '-' || rpad(p_numfact,15) || '-' || rpad(p_numcont,15) );


         END; -- End Bloc if contrat then
      ELSE
         -- =========================================================
         --    Creer Libellé analytique cas Facture sans Contrat
         -- =========================================================
         BEGIN
            l_llibanalyt := (RPAD(p_socfact,4) || '-' || p_fmoiacompta
                        || '-' || RPAD(p_numfact,15) );
         END;
      END IF; -- End if p_numcont not null

      -- ===============================================================
      --   Test Code DPG  existant ?
      -- ===============================================================
      BEGIN
         SELECT DISTINCT  si.codsg,si.scentrefrais
         INTO     l_codsg, l_scentrefrais
         FROM  struct_info si
         WHERE  si.codsg = TO_NUMBER(p_fdeppole);

      EXCEPTION
         WHEN NO_DATA_FOUND THEN      -- msg Code DPG inconnu
            pack_global.recuperer_message(20109, NULL, NULL, NULL, l_msg);
            raise_application_error(-20109,l_msg);
         WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
      END;

     -- ===================================================================
     -- 21/12/2000 : Test si le DPG appartient bien au centre de frais
     -- ===================================================================
     -- On récupère le code centre de frais de l'utilisateur
	l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

    IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
      	IF (l_scentrefrais is null)   then
		--msg : Le DPG n'est rattaché à aucun centre de frais
		pack_global.recuperer_message(20339, NULL,NULL,'FDEPPOLE', l_msg);
          	raise_application_error(-20339, l_msg);
	ELSE
		IF (l_scentrefrais!=l_centre_frais) then
			--msg:Ce DPG n'appartient pas à ce centre de frais
			pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'FDEPPOLE', l_msg);
          		raise_application_error(-20334, l_msg);
		END IF;
      	END IF;
    ELSE	-- l'utilisateur n'est pas affecté à un centre de frais réel: récupérer le centre de frais du DPG
	IF (l_scentrefrais is null) then
		--msg : Le DPG n'est rattaché à aucun centre de frais
		pack_global.recuperer_message(20339, NULL,NULL,'FDEPPOLE', l_msg);
          	raise_application_error(-20339, l_msg);

	ELSE
		-- le centre de frais du contrat est le centre de frais du DPG
		l_centre_frais := l_scentrefrais;
	END IF;
    END IF;

      -- ===============================================================
      -- OK on peut Modifier
      -- ===============================================================
      -- QHL 18/05/2000 : il faut updater aussi le champ soccont
      IF p_numcont = ''
         THEN l_soccont := null ;
         ELSE l_soccont := p_socfact;
      END IF;

     BEGIN
         UPDATE FACTURE
         SET   llibanalyt = l_llibanalyt,
               fsocfour   = p_fsocfour,
               soccont    = l_soccont,
               cav        = p_cav,
               numcont    = p_numcont,
               fdeppole   = TO_NUMBER(p_fdeppole),
	       fcentrefrais = l_centre_frais,
               flaglock   = decode(p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  socfact   = p_socfact
           AND  numfact   = p_numfact
           AND  typfact   = p_typfact
           AND  datfact   = TO_DATE(p_datfact,'DD/MM/YYYY')
           AND  flaglock  = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2292);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN  -- Acces concurrent
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE                 -- Msg Facture modifiée
         pack_global.recuperer_message(2201,'%s1',p_numfact, NULL, l_msg);
         p_message := l_msg || l_msg_cont;
         p_flaglockout :=  (p_flaglock + 1);
      END IF;


END update_facture_segl;



-- ********************************************************************************************
-- ********************************************************************************************
--
-- select_facture2_segl : appelé par l'écran Consulter en-tete facture (bouton Lignes)
--
-- ********************************************************************************************
-- ********************************************************************************************
PROCEDURE select_facture2_segl (p_socfact     IN facture.socfact%TYPE,
                                p_soclib      IN societe.soclib%TYPE,
                                p_numfact     IN facture.numfact%TYPE,
                                p_typfact     IN facture.typfact%TYPE,
                                p_datfact     IN VARCHAR2,
                                p_faccsec     IN VARCHAR2,              -- date accord pole
                                p_fnumasn     IN VARCHAR2,              -- n° dossier SDFF
                                p_fregcompta  IN VARCHAR2,
                                p_fenvsec     IN VARCHAR2,    -- date reglement demande
                                p_fmodreglt   IN VARCHAR2,
                                p_fsocfour    IN VARCHAR2,
                                p_fmontht     IN VARCHAR2,
                                p_fmontttc    IN VARCHAR2,
                                p_llibanalyt  IN facture.llibanalyt%TYPE,
                                p_fmoiacompta IN VARCHAR2,
                                p_fstatut1    IN facture.fstatut1%TYPE,
                                p_fstatut2    IN facture.fstatut2%TYPE,
                                p_fprovsdff1  IN facture.fprovsdff1%TYPE,
                                p_fprovsdff2  IN facture.fprovsdff2%TYPE,
                                p_fprovsegl1  IN facture.fprovsegl1%TYPE,
                                p_fprovsegl2  IN facture.fprovsegl2%TYPE,
                                p_flaglock    IN VARCHAR2,
                                p_userid      IN VARCHAR2,
                                p_curselect   IN OUT FactSelect2Cur,
                                p_fsocfourout    OUT VARCHAR2,
                                p_nbcurseur      OUT INTEGER,
                                p_message        OUT VARCHAR2
                              ) IS

      l_msg         VARCHAR2(1024) ;
      l_soclib      societe.soclib%TYPE ;
      l_socfact     facture.socfact%TYPE ;
      p_filcode     filiale_cli.filcode%TYPE ;

   BEGIN
      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur   := 1;
      p_message     := '';
      p_fsocfourout :=  p_fsocfour;

      DBMS_OUTPUT.PUT_LINE('Debut select ' );
         --  || p_rnom || '-;-' || p_numfact || '-;-' || p_typfact || '-;-' || p_datfact || '-;-'
         --  || p_choixfsc || '-;-' || p_userid || '-;;') ;

      BEGIN
      OPEN p_curselect FOR
         SELECT  s.soclib,
                 f.socfact,
                 f.numcont,
                 f.cav,
                 f.numfact,
                 f.typfact,
                 TO_CHAR(f.datfact,'dd/mm/yyyy'),
                 TO_CHAR(f.fdeppole,'FM0000000'),
                 TO_CHAR(f.fmontht,'FM99999990D00'),
                 TO_CHAR(f.ftva,'FM90D00'),
                 TO_CHAR(f.fmontttc,'FM99999990D00'),
                 TO_CHAR(f.fmoiacompta,'MM/YYYY'),
                 TO_CHAR(f.flaglock,'FM9999999')
         FROM  facture f, societe s
         WHERE  f.socfact  = s.soccode
            AND s.soccode  = p_socfact
            AND f.numfact  = p_numfact
            AND f.typfact  = p_typfact
            AND f.datfact  = TO_DATE(p_datfact,'DD/MM/YYYY')
            AND f.flaglock = p_flaglock;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN     -- Msg Accès concurrent
            pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
            raise_application_error(-20999,l_msg);

        WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END; -- End select

END select_facture2_segl;




-- ********************************************************************************************
-- ********************************************************************************************
--
-- select_facture_segl
--
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE select_facture_segl (p_socfact     IN facture.socfact%TYPE,
                             	  p_numfact     IN facture.numfact%TYPE,
                             	  p_typfact     IN facture.typfact%TYPE,
                             	  p_datfact     IN VARCHAR2,
                             	  p_userid      IN VARCHAR2,
                             	  p_curselect   IN OUT FactSelect1Cur,
                             	  p_soclibout      OUT VARCHAR2,
                             	  p_socfactout     OUT VARCHAR2,
                             	  p_numfactout     OUT VARCHAR2,
                             	  p_typfactout     OUT VARCHAR2,
                             	  p_datfactout     OUT VARCHAR2,
                             	  p_msg_info       OUT VARCHAR2,
                             	  p_nbcurseur      OUT INTEGER,
                             	  p_message        OUT VARCHAR2
                              ) IS

      l_msg          VARCHAR2(1024) ;
      l_soclib       societe.soclib%TYPE ;
      l_socfact      facture.socfact%TYPE ;
      p_filcode      filiale_cli.filcode%TYPE ;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_fcentrefrais centre_frais.codcfrais%TYPE;

   BEGIN
      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur   := 1;
      p_message     := '';
      p_socfactout  :=  p_socfact;
      p_numfactout  :=  p_numfact;
      p_datfactout  := p_datfact;
      p_typfactout  :=  p_typfact;


      --  On recupere le code filiale de l'utilisateur
      p_filcode := pack_global.lire_globaldata(p_userid).filcode;


      -- =======================================================================
      -- Test existence du CODE SOCIETE
      -- =======================================================================
      BEGIN
         SELECT soccode , soclib
         INTO   l_socfact , l_soclib
         FROM   societe
         WHERE  soccode = p_socfact;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN       -- Erreur message "Code Societe inexistant"
                pack_global.recuperer_message(20306, NULL, NULL, NULL, l_msg);
                raise_application_error(-20306,l_msg);
         WHEN OTHERS THEN
                raise_application_error(-20997,SQLERRM);
      END;

 -- DBMS_OUTPUT.PUT_LINE('--> après test Code societe : ' || l_socfact || '  ' || l_soclib );
      p_soclibout :=  l_soclib;


      -- =======================================================================
      -- Test existence de la facture
      -- Si existe Alors
      --    Autoriser la Modification  Si   fstatut1 = VA et fprovsegl1 = 1
      --                                 ou fstatut2 = VA et fprovsegl2 = 1
      -- =======================================================================

      DECLARE
            l_fprovsegl1  facture.fprovsegl1%TYPE;
            l_fprovsegl2  facture.fprovsegl2%TYPE;
            l_fmodreglt   facture.fmodreglt%TYPE;
            l_fstatut1    facture.fstatut1%TYPE;
            l_fstatut2    facture.fstatut2%TYPE;
            l_soccont     facture.soccont%TYPE;
            l_cav         facture.cav%TYPE;
            l_numcont     facture.numcont%TYPE;
            l_codsg       contrat.codsg%TYPE;
            l_comcode     contrat.comcode%TYPE;
            l_msg_cont    VARCHAR2(200);

      BEGIN

         -- ================================
         -- Test existence de la facture
         -- ================================
         BEGIN
            SELECT f.fprovsegl1,f.fprovsegl2,f.fmodreglt,f.fstatut1,f.fstatut2,f.soccont,f.cav,f.numcont,f.fcentrefrais
            INTO   l_fprovsegl1,l_fprovsegl2,l_fmodreglt,l_fstatut1,l_fstatut2,l_soccont,l_cav,l_numcont,l_fcentrefrais
            FROM  facture f
            WHERE     f.socfact = p_socfact
                  AND f.numfact = RPAD(p_numfact,15)
                  AND f.typfact = p_typfact
                  AND f.datfact = TO_DATE(p_datfact,'DD/MM/YYYY');

 -- DBMS_OUTPUT.PUT_LINE(' --> apres lecture facture:' || l_fstatut1 || ';' || l_fprovsegl1  );
         EXCEPTION
           WHEN NO_DATA_FOUND THEN
                  pack_global.recuperer_message(20103, NULL, NULL, NULL, l_msg);
                  raise_application_error(-20103,l_msg);
           WHEN OTHERS THEN
                  raise_application_error(-20997,SQLERRM);
         END;

 -- DBMS_OUTPUT.PUT_LINE(' --> Verif statut:' || l_fstatut1 || ';' || l_fprovsegl1  );

         -- ================================
         -- Test OK pour modifier ?
         -- ================================
         IF    (l_fstatut1   = 'VA')   -- AND l_fprovsegl1 = '1')
            				--OR (l_fstatut2   = 'VA')    AND l_fprovsegl2 = '1')
            THEN  NULL;
            ELSE  -- Message  Facture non validée par SEGL, correction impossible dans ce menu
                  pack_global.recuperer_message(20128, NULL, NULL, NULL, l_msg);
                  raise_application_error(-20128,l_msg);
         END IF;


         -- =================================================================================
         -- Cas facture avec contrat : A-t-on la bonne filiale ?
         -- =================================================================================
         IF l_numcont IS NOT NULL THEN
            pack_facture.verif_filiale_cont(l_soccont,l_cav,l_numcont,p_filcode,l_msg_cont,l_codsg,l_comcode);
            IF l_msg_cont IS NOT NULL THEN
               p_msg_info    :=  l_msg_cont ;
            END IF;
         END IF;
      END;     -- End bloc Test

      -- ======================================================================================
      -- 21/12/2000 :Contrôler que la facture appartient au centre de frais de l'utilisateur
      -- =======================================================================================
	 -- On récupère le code centre de frais de l'utilisateur
            l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

     	IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
		IF l_fcentrefrais is null THEN
			-- la facture n'est rattachée à aucun centre de frais
			pack_global.recuperer_message(20337,NULL,NULL,NULL, l_msg);
         	 	raise_application_error(-20337, l_msg);

		ELSE
			IF l_centre_frais!=l_fcentrefrais THEN
				-- la facture n'est pas rattachée au centre de frais %s1 mais au centre de frais %s2
				pack_global.recuperer_message(20338,'%s1',to_char(l_centre_frais),'%s2',
									to_char(l_fcentrefrais),NULL, l_msg);
         			raise_application_error(-20338, l_msg);

			END IF;
		END IF;
	END IF;


      -- ===================================================
      -- OK Maintenant tout est bon, select de la facture
      -- ===================================================
      p_nbcurseur := 1;

      BEGIN
      OPEN  p_curselect  FOR
         SELECT  s.soclib,
                 f.socfact,
                 f.numfact,
                 f.typfact,
                 TO_CHAR(f.datfact,'dd/mm/yyyy'),
                 TO_CHAR(f.faccsec,'dd/mm/yyyy'),
                 TO_CHAR(f.fnumasn,'FM999999999'),
                 TO_CHAR(f.fregcompta,'dd/mm/yyyy'),
                 TO_CHAR(f.fenvsec,'dd/mm/yyyy'),
                 DECODE(f.Fmodreglt,1,'Virement',2,'Prélèvement',3,'Chèque',8,'Annulation'),
                 TO_CHAR(f.fmontht,'FM99999999D00'),
                 TO_CHAR(f.fmontttc,'FM99999999D00'),
                 f.llibanalyt,
                 TO_CHAR(f.fmoiacompta,'mm/yyyy'),
                 f.fstatut1,
                 f.fstatut2,
                 f.fprovsdff1,
                 f.fprovsdff2,
                 f.fprovsegl1,
                 f.fprovsegl2,
                 f.fsocfour,
	rpad(a.socflib,25,' '),
	f.numcont,
        f.cav,
        TO_CHAR(f.fdeppole,'FM0000000'),
        TO_CHAR(f.ftva,'FM90D00'),
        TO_CHAR(f.flaglock,'FM9999999')
         FROM  facture f,agence a, societe s
         WHERE  f.socfact = s.soccode
            AND s.soccode = p_socfact
            AND f.numfact = p_numfact
            AND f.typfact = p_typfact
            AND f.datfact = TO_DATE(p_datfact,'DD/MM/YYYY')
            AND s.soccode=a.soccode;

      EXCEPTION
        WHEN NO_DATA_FOUND THEN     -- Msg Aucune facture pour la sélection demandée
            pack_global.recuperer_message(20103, NULL, NULL, NULL, l_msg);
            raise_application_error(-20103,l_msg);

        WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END; -- End select

END select_facture_segl;



-- ********************************************************************************************
-- ********************************************************************************************
--
-- select_ligne_segl
--
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE select_ligne_segl (p_socfact    IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_fdeppole    IN VARCHAR2,      -- code fdeppole de la facture
                               p_fmontht     IN VARCHAR2,
                               p_ftva        IN VARCHAR2,      -- code comptable du contrat
                               p_fmontttc    IN VARCHAR2,
                               p_fsocfour    IN facture.fsocfour%TYPE,
                               p_fmoiacompta IN VARCHAR2,
                               p_clelf       IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_socfactout     OUT VARCHAR2,
                               p_soclibout      OUT VARCHAR2,
                               p_numcontout     OUT VARCHAR2,
                               p_cavout         OUT VARCHAR2,
                               p_numfactout     OUT VARCHAR2,
                               p_typfactout     OUT VARCHAR2,
                               p_datfactout     OUT VARCHAR2,
                               p_lnumout        OUT VARCHAR2,
                               p_identout       OUT VARCHAR2,
                               p_rnomout        OUT VARCHAR2,
                               p_rprenomout     OUT VARCHAR2,
                               p_lmonthtout     OUT VARCHAR2,
                               p_lmoisprestout  OUT VARCHAR2,
                               p_lcodcomptaout  OUT VARCHAR2,
                               p_fsocfourout    OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              ) IS

      l_msg         VARCHAR2(1024) ;
      l_lnum        VARCHAR2(20);
      l_ident       VARCHAR2(20);
      l_rnom        VARCHAR2(40);
      l_rprenom     VARCHAR2(20);
      l_lmontht     VARCHAR2(20);
      l_lmoisprest  VARCHAR2(20);
      l_lcodcompta  VARCHAR2(50);


   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur   := 0;
      p_message     := '';
      p_flaglockout :=  p_flaglock;

     pack_liste_lignes_fact.xcle_ligne_fact(p_clelf, 1,
            l_lnum, l_ident, l_rnom, l_rprenom,
            l_lmontht, l_lmoisprest,l_lcodcompta) ;

        -- Cle retourne  lf.lnum(2);lf.ident(5);r.rnom(20);r.rprenom(15);
        --               lf.lmontht(11);lf.lmoisprest(7);lf.lcodcompta(11)

      p_socfactout     :=  p_socfact     ;
      p_soclibout      :=  p_soclib      ;
      p_numcontout     :=  p_numcont     ;
      p_cavout         :=  p_cav         ;
      p_numfactout     :=  p_numfact     ;
      p_typfactout     :=  p_typfact     ;
      p_datfactout     :=  p_datfact     ;

      p_lnumout        :=  l_lnum       ;
      p_identout       :=  l_ident      ;
      p_rnomout        :=  l_rnom       ;
      p_rprenomout     :=  l_rprenom    ;
      p_lmonthtout     :=  l_lmontht    ;
      p_lmoisprestout  :=  l_lmoisprest ;
      p_lcodcomptaout  :=  l_lcodcompta ;
      p_fsocfourout    :=  p_fsocfour ;
END select_ligne_segl;


-- ********************************************************************************************
-- ********************************************************************************************
--
-- update_ligne_segl
--
-- 09/02/2000    QHL      ajout test mois/annee prestation < mois/annee courant
--
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE update_ligne_segl (p_socfact    IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_ident       IN VARCHAR2,
                               p_rnom        IN ressource.rnom%TYPE,
                               p_rprenom     IN ressource.rprenom%TYPE,
                               p_lmontht     IN VARCHAR2,
                               p_lmoisprest  IN VARCHAR2,
                               p_lcodcompta  IN VARCHAR2,
                               p_lnum        IN VARCHAR2,
                               p_fdeppole    IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_fdeppoleout    OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              ) IS

      l_msg         VARCHAR2(1024) ;
      referential_integrity EXCEPTION;
      PRAGMA       EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN
      p_nbcurseur := 0;
      p_message := '';
      p_flaglockout  :=  p_flaglock;
      p_fdeppoleout  :=  LPAD(p_fdeppole, 7, '0');
      -- =======================================
      -- Mise à jour du flaglock de la facture
      -- =======================================
      BEGIN
         UPDATE  facture
         SET    flaglock  = decode(p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  socfact   = p_socfact
           AND  numfact   = p_numfact
           AND  typfact   = p_typfact
           AND  datfact   = TO_DATE(p_datfact,'DD/MM/YYYY')
           AND  flaglock  = p_flaglock;

         IF SQL%NOTFOUND THEN  -- Acces concurrent
            pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
            raise_application_error( -20999, l_msg );
         END IF;

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2292);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END;

      -- ===================================================
      -- Test Existence du code comptable dans CODE_COMPT
      -- ===================================================
      verif_codecompta(p_lcodcompta);


      -- ===================================================
      -- ajout kha 12/08/2004 fiche 210
      -- Test Mois Prestation  vs  Periode de validite du contrat
      -- ===================================================
      pack_ligne_fact.verif_periode_contrat(p_socfact, p_numcont, p_cav, p_lmoisprest);
      -- ===================================================
      -- Test Date Mois Prestation < Mois courant
      -- ===================================================
            IF  to_date(p_lmoisprest,'MM/YYYY') >= to_date((to_char(sysdate,'MM/YYYY')),'MM/YYYY')
         THEN -- Msg erreur Mois prestation doit etre strictement inferieur au mois courant
            pack_global.recuperer_message(20140,NULL, NULL, NULL, l_msg);
            raise_application_error( -20140, l_msg );
      END IF;

      -- ===============================================================
      -- OK on peut Modifier
      -- ===============================================================
      BEGIN
         UPDATE  ligne_fact
         SET   lmoisprest = TO_DATE(p_lmoisprest,'MM/YYYY'),
               lcodcompta = p_lcodcompta
         WHERE  socfact   = p_socfact
           AND  numfact   = p_numfact
           AND  typfact   = p_typfact
           AND  datfact   = TO_DATE(p_datfact,'DD/MM/YYYY')
           AND  lnum      = p_lnum;

         IF SQL%NOTFOUND THEN  -- Acces concurrent
            pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
            raise_application_error( -20999, l_msg );
         ELSE                 -- Msg Ligne de Facture modifiée
            pack_global.recuperer_message(2204,NULL,NULL, NULL, l_msg);
            p_message := l_msg;
            p_flaglockout  := (p_flaglock + 1);
         END IF;


      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2292);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END;


END update_ligne_segl;

END pack_fact_segl;
/
CREATE OR REPLACE PACKAGE pack_fair AS

   PROCEDURE alim_fair(p_filsigle IN VARCHAR2);

   PROCEDURE selectP_fair (   p_filsigle IN VARCHAR2,
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2);

   PROCEDURE referentielE_fair (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2);

   PROCEDURE referentielA_fair (   p_filsigle IN VARCHAR2,
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2);

   PROCEDURE select_fair (
                           p_chemin_fichier IN VARCHAR2,
                           p_nom_fic_sgpm IN VARCHAR2,
                           p_nom_fic_sgam IN VARCHAR2,
			  -- p_nom_fic_sogessur IN VARCHAR2,
                           p_nom_fic_refE IN VARCHAR2,
                           p_nom_fic_refApm IN VARCHAR2,
			   p_nom_fic_refAam IN VARCHAR2
                          ) ;

END pack_fair;
/

CREATE OR REPLACE PACKAGE BODY pack_fair AS

   PROCEDURE alim_fair(p_filsigle IN VARCHAR2) IS


	l_nbmois    NUMBER(2,0);             -- nombre de mois M-` traiter
        i           NUMBER(2,0);             -- compteur (mois a traiter)
        l_mois      DATE ;                   -- mois a traiter, deduit de 'i'
        l_mois_min  DATE ;
	l_where	    VARCHAR2(100);

	BEGIN
--1ere étape : delete de la table temporaire et insertion des données de proplus

		DELETE FROM tmp_fair;
		COMMIT;

		l_nbmois    := 0 ;
        	select datdebex into l_mois_min from datdebex;

		SELECT  MONTHS_BETWEEN( trunc(add_months(moismens,1), 'Month'), trunc(datdebex, 'year') )
        	INTO            l_nbmois
        	FROM            datdebex;

	IF p_filsigle = 'SGPM' THEN
	FOR i IN 1..l_nbmois
        LOOP

           l_mois := trunc( add_months( l_mois_min, i-1), 'month' ) ;


		INSERT INTO tmp_fair (  type_enreg,
					ident,
					date_crea,
					date_emi,
					carat,
					codsg,
					numligne,
					rnom,
					qualif,
					cout,
					cusag,
					unite_oeuvre,
					montantht,
					code_classe,
					code_iso,
					rtype,
					pid ,
					pnom,
					societe)
				(SELECT 2,
					conso.tires,
					to_char(trunc(l_mois,'MONTH'),'DDMMYYYY'),
					'20'||to_char(l_mois,'MMYYYY'),
					decode(p_filsigle,'SGPM','S0001','S6640'),
					conso.divsecgrou,
					'1',
					decode(conso.rtype,'P',' ',conso.rnom),
					conso.qualif,
					conso.cout,
					conso.cusag,
					'J',
					conso.cout*conso.cusag,
					'SENT',
					'EUR',
					decode(conso.rtype,'P','R','F'),
					conso.factpid,
					conso.factpno,
					conso.societe
				FROM struct_info si,
				     (select sum(cusag) cusag,tires,divsecgrou,cdeb,rtype,qualif,cout,
				      factpid,factpno,rnom,societe
				      from proplus,datdebex
				      where trunc(l_mois,'MONTH')= trunc(cdeb,'MONTH')
				      and (aist not in ('CONGES','FORMAT','ABSDIV','PARTIE','RTT')
						OR aist IS NULL)
				      AND societe <> 'SG..'
				      AND factpid is not null
				      group by tires,divsecgrou,cdeb,rtype,qualif,cout,factpid,factpno,rnom,societe) 				      conso
				WHERE si.codsg = conso.divsecgrou
			  	AND	si.filcode in ('01','05','06','07')
				);

	END LOOP;
	ELSE
		l_where:=''''||02||'''';
	FOR i IN 1..l_nbmois
        LOOP

           l_mois := trunc( add_months( l_mois_min, i-1), 'month' ) ;


		INSERT INTO tmp_fair (  type_enreg,
					ident,
					date_crea,
					date_emi,
					carat,
					codsg,
					numligne,
					rnom,
					qualif,
					cout,
					cusag,
					unite_oeuvre,
					montantht,
					code_classe,
					code_iso,
					rtype,
					pid ,
					pnom,
					societe)
				(SELECT 2,
					conso.tires,
					to_char(trunc(l_mois,'MONTH'),'DDMMYYYY'),
					'20'||to_char(l_mois,'MMYYYY'),
					decode(p_filsigle,'SGPM','S0001','S6640'),
					conso.divsecgrou,
					'1',
					decode(conso.rtype,'P',' ',conso.rnom),
					conso.qualif,
					conso.cout,
					conso.cusag,
					'J',
					conso.cout*conso.cusag,
					'SENT',
					'EUR',
					decode(conso.rtype,'P','R','F'),
					conso.factpid,
					conso.factpno,
					conso.societe
				FROM struct_info si,
				     (select sum(cusag) cusag,tires,divsecgrou,cdeb,rtype,qualif,cout,
				      factpid,factpno,rnom,societe
				      from proplus,datdebex
				      where trunc(l_mois,'MONTH')= trunc(cdeb,'MONTH')
				      and (aist not in ('CONGES','FORMAT','ABSDIV','PARTIE','RTT')
						OR aist IS NULL)
				      AND societe <> 'SG..'
				      AND factpid is not null
				      group by tires,divsecgrou,cdeb,rtype,qualif,cout,factpid,factpno,rnom,societe) 				      conso
				WHERE si.codsg = conso.divsecgrou
			  	AND	si.filcode='02'
				);

	END LOOP;
	END IF;

		COMMIT;

--2eme etape : les update

UPDATE tmp_fair SET type = (select t.typproj || t.libtyp from type_projet t,ligne_bip lb
			    WHERE t.typproj = lb.typproj
			    AND lb.pid = tmp_fair.pid);
COMMIT;

UPDATE tmp_fair SET  cavcont = (select max(lc.cav) || lc.numcont cavcont from ligne_cont lc
				where tmp_fair.ident  = lc.ident
				and tmp_fair.societe = lc.soccont
				and lc.lcnum = (select max(l.lcnum) from ligne_cont l
						where tmp_fair.ident  = l.ident
						and tmp_fair.societe = l.soccont
						and trunc(l.lresdeb,'MONTH') <= to_date(tmp_fair.date_crea,'DDMMYYYY')
						and trunc(l.lresfin,'MONTH') > to_date(tmp_fair.date_crea,'DDMMYYYY'))
				and trunc(lc.lresdeb,'MONTH') <= to_date(tmp_fair.date_crea,'DDMMYYYY')
				and trunc(lc.lresfin,'MONTH') > to_date(tmp_fair.date_crea,'DDMMYYYY')
				and rownum = 1
				group by lc.numcont);
COMMIT;

UPDATE tmp_fair SET libdpg = (select b.libbr||'/'||d.libdir||'/'||si.sigdep||'/'||si.sigpole
				from struct_info si,branches b,directions d
				where tmp_fair.codsg = si.codsg
				and si.coddir = d.coddir
				and d.codbr = b.codbr
				);
COMMIT;

UPDATE tmp_fair SET code_comta = (select comcode from contrat
				where tmp_fair.societe = contrat.soccont
				and tmp_fair.cavcont =contrat.cav||contrat.numcont),
		    date_fin_contrat = (select to_char(cdatfin,'DDMMYYYY') from contrat
					where tmp_fair.societe = contrat.soccont
					and tmp_fair.cavcont =contrat.cav||contrat.numcont);
COMMIT;

UPDATE tmp_fair SET sms = (select distinct (SUBSTR(fact.fsocfour,1,9)) from facture fact,ligne_fact lf
				where tmp_fair.societe = lf.socfact
				and tmp_fair.ident = lf.ident
				and to_char(lf.lmoisprest,'DDMMYYYY') = tmp_fair.date_crea
				and lf.socfact = fact.socfact
				and lf.numfact = fact.numfact
				and lf.datfact = fact.datfact
				and lf.typfact = fact.typfact
				and rownum = 1);
COMMIT;


UPDATE tmp_fair SET centre_activite = (select centractiv from struct_info
					where struct_info.codsg = tmp_fair.codsg);
COMMIT;

UPDATE tmp_fair SET camo = (select decode(caamort,22000,decode(codcamo,22000,NULL,codcamo),nvl(caamort,decode(codcamo,22000,NULL,codcamo)))
				from ligne_bip
				where ligne_bip.pid = tmp_fair.pid);
COMMIT;

UPDATE tmp_fair SET dpcode = (select dp.dpcode from dossier_projet dp,ligne_bip lb
				where lb.dpcode = dp.dpcode
				and lb.pid = tmp_fair.pid),
		    libdpcode = (select dplib from dossier_projet dp,ligne_bip lb
					where lb.dpcode = dp.dpcode
				and lb.pid = tmp_fair.pid);
COMMIT;

UPDATE tmp_fair SET icpi = (select lb.icpi from ligne_bip lb
			    where lb.pid = tmp_fair.pid),
		    libproj = (select SUBSTR(ilibel,1,40) from proj_info,ligne_bip lb
				where proj_info.icpi = lb.icpi
				and lb.pid = tmp_fair.pid);
COMMIT;

UPDATE tmp_fair SET tva = (select tva from tva where datetva = (select max(datetva) from tva));
COMMIT;

UPDATE tmp_fair SET taux_recup = (select taux from taux_recup,datdebex where annee = to_number(to_char(datdebex,'YYYY')) and filcode ='01');
COMMIT;

UPDATE tmp_fair SET libsoc = (select soclib from societe where soccode = tmp_fair.societe);

UPDATE tmp_fair SET sms = (select substr(socfour,1,9)
						from agence a, societe s
						where s.soccode= tmp_fair.societe
						and s.soccode = a.soccode
						and rownum = 1)
WHERE sms is null;

COMMIT;


	END alim_fair;

PROCEDURE selectP_fair (   p_filsigle IN VARCHAR2,
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2) IS


       l_hfile utl_file.file_type;
       l_msg  varchar2(1024);
	l_moismens varchar2(6);
	l_sysdate varchar2(8);
	l_heure varchar2(6);
	compteur number(19);
	l_compteur varchar2(19);
	l_subdiv varchar2(1);

-- déclaration du curseur pour fair
	CURSOR curs_fair IS
	SELECT lpad(to_char(type_enreg),1,' ') type_enreg,
	lpad(to_char(ident),5,' ') ident,
	rpad(date_crea,8,' ') date_crea,
	rpad(date_emi,8,' ') date_emi,
	rpad(nvl(type,' '),50,' ') type,
	rpad(nvl(cavcont,' '),20,' ') cavcont,
	rpad(carat,20,' ') carat,
	lpad(to_char(nvl(codsg,0)),6,' ') codsg,
	rpad(nvl(libdpg,' '),50,' ') libdpg,
	lpad(to_char(numligne),4,' ') numligne,
	rpad(nvl(rnom,' '),50,' ') rnom,
	rpad(nvl(code_comta,' '),20,' ') code_comta,
	rpad(nvl(qualif,' '),20,' ') qualif,
	rpad(nvl(sms,'BIP fournisseur'),20,' ') sms,
	rpad(nvl(centre_activite,' '),20,' ') centre_activite,
	rpad(nvl(camo,' '),20,' ') camo,
	lpad(to_char(nvl(dpcode,0)),20,' ')dpcode,
	rpad(nvl(libdpcode,' '),40,' ') libdpcode,
	rpad(nvl(icpi,' '),20,' ') icpi,
	rpad(nvl(libproj,' '),40,' ') libproj,
	lpad(to_char(nvl(cout,0),'FM999999990D00','NLS_NUMERIC_CHARACTERS=''.,'),20,' ') cout,
	lpad(to_char(nvl(cusag,0),'FM999999990D00','NLS_NUMERIC_CHARACTERS=''.,'),15,' ') cusag,
	rpad(nvl(unite_oeuvre,' '),15,' ') unite_oeuvre,
	lpad(to_char(nvl(montantht,0),'FM999999990D00','NLS_NUMERIC_CHARACTERS=''.,'),15,' ') montantht,
	lpad(to_char(nvl(tva,0),'FM999990D00','NLS_NUMERIC_CHARACTERS=''.,'),15,' ') tva,
	lpad(to_char(nvl(taux_recup,0),'FM999990D00','NLS_NUMERIC_CHARACTERS=''.,'),15,' ') taux_recup,
	rpad(nvl(code_classe,' '),4,' ') code_classe,
	rpad(nvl(code_iso,' '),3,' ') code_iso,
	rpad(nvl(date_fin_contrat,' '),8,' ') date_fin_contrat,
	rpad(nvl(rtype,' '),20,' ') rtype,
	rpad(nvl(pid,' '),4,' ') pid,
	rpad(nvl(pnom,' '),50,' ') pnom,
	rpad(nvl(societe,' '),4,' ') societe,
	rpad(nvl(libsoc,' '),50,' ') libsoc
FROM    tmp_fair
ORDER BY rpad(date_crea,8,' '),lpad(to_char(ident),5,' ');


   BEGIN

	select to_char(moismens,'MMYYYY') into l_moismens from datdebex;
	select to_char(sysdate,'DDMMYYYY') into l_sysdate from dual;
	select to_char(sysdate,'HH24MISS') into l_heure from dual;
	select decode(p_filsigle,'SGPM','1',decode(p_filsigle,'SGAM','2','3')) into l_subdiv from dual;

      PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);


--entete
     PACK_GLOBAL.WRITE_STRING( l_hfile,
				'1' || ';' ||
				'BB' || ';' ||
				l_subdiv || ';' ||
				'P' || ';' ||
				l_moismens || ';' ||
				l_sysdate || ';' ||
				l_heure
			     );


	compteur := 0;

	 FOR cur_enr IN curs_fair
      LOOP

        PACK_GLOBAL.WRITE_STRING(l_hfile,
                                    cur_enr.type_enreg	||';'||
                                   cur_enr.ident		|| ';' ||
                                   cur_enr.date_crea 				|| ';' ||
                                   cur_enr.date_emi			 	|| ';' ||
                                   cur_enr.type 				|| ';' ||
                                   cur_enr.cavcont 				|| ';' ||
                                   cur_enr.carat 				|| ';' ||
                                   cur_enr.codsg				|| ';' ||
                                   cur_enr.libdpg 				|| ';' ||
				   cur_enr.numligne 				|| ';' ||
                                   cur_enr.rnom 				|| ';' ||
				   cur_enr.code_comta 				|| ';' ||
                                   cur_enr.qualif 				|| ';' ||
				   ' '				|| ';' ||
				   cur_enr.sms					|| ';' ||
				   ' '				|| ';' ||
				   ' '				|| ';' ||
                                   cur_enr.centre_activite 			|| ';' ||
                                   cur_enr.camo 				|| ';' ||
                                   cur_enr.dpcode 				|| ';' ||
                                   cur_enr.libdpcode 				|| ';' ||
                                   cur_enr.icpi 				|| ';' ||
				   cur_enr.libproj 				|| ';' ||
				   cur_enr.cout 				|| ';' ||
				   cur_enr.cusag				|| ';' ||
                                   cur_enr.unite_oeuvre 			|| ';' ||
                                   cur_enr.montantht	 			|| ';' ||
                                   cur_enr.tva 					|| ';' ||
                                   cur_enr.taux_recup 				|| ';' ||
				   cur_enr.code_classe				|| ';' ||
				   cur_enr.code_iso				|| ';' ||
				   cur_enr.date_fin_contrat			|| ';' ||
				   ' '				|| ';' ||
				   ' '				|| ';' ||
				   ' '				|| ';' ||
				   ' '				|| ';' ||
				   ' '				|| ';' ||
				   ' '				|| ';' ||
				   cur_enr.pid ||'\'|| cur_enr.pnom || ';' ||
				   cur_enr.societe ||'\'|| cur_enr.libsoc || ';' ||
				   ' '				|| ';' ||
				   ' ');


		-- alimentation du compteur d'occurence
			compteur := compteur+1;

       END LOOP;

	select lpad(to_char(compteur, 'FM9999999999999999990'),19,' ') into l_compteur from dual;
--fin de fichier
	PACK_GLOBAL.WRITE_STRING( l_hfile,
				 '3' || ';' ||
				 l_compteur);

       PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);


	EXCEPTION
   		WHEN OTHERS THEN


   		pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
   		raise_application_error(-20401, l_msg);

    END selectP_fair;



PROCEDURE referentielE_fair (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2) IS


       l_hfile utl_file.file_type;
       l_msg  varchar2(1024);
	l_moismens varchar2(6);
	l_sysdate varchar2(8);
	l_heure varchar2(6);
	compteur number(19);
	l_compteur varchar2(19);


-- déclaration du curseur pour le fichier de référentiel de type E contenant les dpg et centre d'activité
-- et envoyé seulement à SGAM
	CURSOR curs_refE IS
	SELECT  2 type_enreg,
		lpad(to_char(sti.codsg),6,' ') ||'\'|| lpad(to_char(sti.centractiv),7,' ') code_occurence,
		rpad(sti.libdsg,30,' ') libelle_occurence,
		lpad(to_char(sti.centractiv),7,' ') code_ca
	FROM struct_info sti,centre_activite ca
	where sti.centractiv = ca.codcamo
	and sti.codsg > 1
	order by sti.codsg;



   BEGIN

	select to_char(moismens,'MMYYYY') into l_moismens from datdebex;
	select to_char(sysdate,'DDMMYYYY') into l_sysdate from dual;
	select to_char(sysdate,'HH24MISS') into l_heure from dual;


      PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);


--entete
     PACK_GLOBAL.WRITE_STRING( l_hfile,
				'1' || ';' ||
				'BB' || ';' ||
				'2' || ';' ||
				'E' || ';' ||
				l_moismens || ';' ||
				l_sysdate || ';' ||
				l_heure
			     );


	compteur := 0;

	 FOR cur_enr IN curs_refE
      LOOP

        PACK_GLOBAL.WRITE_STRING(l_hfile,
                                   cur_enr.type_enreg	||';'||
                                   cur_enr.code_occurence		|| ';' ||
                                   cur_enr.libelle_occurence 				|| ';' ||
                                   ' '			 	|| ';' ||
                                   ' ' 				|| ';' ||
                                   cur_enr.code_ca 		|| ';' ||
                                   ' ' 				|| ';' ||
                                   ' '				|| ';' ||
                                   ' '
				   );


		-- alimentation du compteur d'occurence
			compteur := compteur+1;

       END LOOP;

	select lpad(to_char(compteur, 'FM9999999999999999990'),19,' ') into l_compteur from dual;
--fin de fichier
	PACK_GLOBAL.WRITE_STRING( l_hfile,
				 '3' || ';' ||
				 l_compteur);

       PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);


	EXCEPTION
   		WHEN OTHERS THEN


   		pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
   		raise_application_error(-20401, l_msg);

    END referentielE_fair;




PROCEDURE referentielA_fair ( p_filsigle IN VARCHAR2,
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2) IS


       l_hfile utl_file.file_type;
       l_msg  varchar2(1024);
	l_moismens varchar2(6);
	l_sysdate varchar2(8);
	l_heure varchar2(6);
	compteur number(19);
	l_compteur varchar2(19);
	l_subdiv varchar2(1);

-- déclaration du curseur pour le fichier de référentiel de type A contenant les qualif
-- et envoyé  à SGAM et à SGPM
	CURSOR curs_refA IS
	SELECT 	2 type_enreg,
		rpad(prestation,20,' ') code_occurence,
		rpad(libprest,50,' ') libelle_occurence
	FROM prestation;



   BEGIN

	select to_char(moismens,'MMYYYY') into l_moismens from datdebex;
	select to_char(sysdate,'DDMMYYYY') into l_sysdate from dual;
	select to_char(sysdate,'HH24MISS') into l_heure from dual;
	select decode(p_filsigle,'SGPM','1',decode(p_filsigle,'SGAM','2','3')) into l_subdiv from dual;


      PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);


--entete
     PACK_GLOBAL.WRITE_STRING( l_hfile,
				'1' || ';' ||
				'BB' || ';' ||
				l_subdiv || ';' ||
				'A' || ';' ||
				l_moismens || ';' ||
				l_sysdate || ';' ||
				l_heure
			     );


	compteur := 0;

	 FOR cur_enr IN curs_refA
      LOOP

        PACK_GLOBAL.WRITE_STRING(l_hfile,
                                  cur_enr.type_enreg	||';'||
                                   cur_enr.code_occurence		|| ';' ||
                                   cur_enr.libelle_occurence 				|| ';' ||
                                   ' '			 	|| ';' ||
                                   ' ' 				|| ';' ||
                                   ' ' 				|| ';' ||
                                   ' ' 				|| ';' ||
                                   ' '				|| ';' ||
                                   ' '
				   );


		-- alimentation du compteur d'occurence
			compteur := compteur+1;

       END LOOP;

	select lpad(to_char(compteur, 'FM9999999999999999990'),19,' ') into l_compteur from dual;
--fin de fichier
	PACK_GLOBAL.WRITE_STRING( l_hfile,
				 '3' || ';' ||
				 l_compteur);

       PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);


	EXCEPTION
   		WHEN OTHERS THEN


   		pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
   		raise_application_error(-20401, l_msg);

    END referentielA_fair;


PROCEDURE select_fair (
                           p_chemin_fichier IN VARCHAR2,
                           p_nom_fic_sgpm IN VARCHAR2,
                           p_nom_fic_sgam IN VARCHAR2,
			  -- p_nom_fic_sogessur IN VARCHAR2,
                           p_nom_fic_refE IN VARCHAR2,
                           p_nom_fic_refApm IN VARCHAR2,
			  -- p_nom_fic_refAso IN VARCHAR2,
			   p_nom_fic_refAam IN VARCHAR2
                          ) IS

l_msg  varchar2(1024);
BEGIN


	pack_fair.referentielE_fair(p_chemin_fichier,p_nom_fic_refE);
	pack_fair.referentielA_fair('SGPM',p_chemin_fichier,p_nom_fic_refApm);
	pack_fair.referentielA_fair('SGAM',p_chemin_fichier,p_nom_fic_refAam);

	pack_fair.alim_fair('SGPM');
	pack_fair.selectP_fair('SGPM',p_chemin_fichier,p_nom_fic_sgpm);

	pack_fair.alim_fair('SGAM');
	pack_fair.selectP_fair('SGAM',p_chemin_fichier,p_nom_fic_sgam);



EXCEPTION
   WHEN OTHERS THEN
   pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
   raise_application_error(-20401, l_msg);

END select_fair;



END PACK_FAIR;
/
CREATE OR REPLACE PACKAGE     pack_favoris AS

   -- Définition curseur sur la table stat_page

   TYPE favoris_ViewType IS RECORD ( 	id_user  		FAVORIS.IDUSER%TYPE,
						  	 			typefav  		FAVORIS.TYPEFAV%TYPE,
										ordre  			FAVORIS.ORDRE%TYPE,
										libelle  		FAVORIS.LIBFAV%TYPE,
										lien  			FAVORIS.LIENFAV%TYPE,
										menu  			FAVORIS.MENU%TYPE
										);


   TYPE favorisCurType_Char IS REF CURSOR RETURN favoris_ViewType;


   PROCEDURE select_liste ( p_userid	IN VARCHAR2,
   			 			  	p_menu      IN VARCHAR2,
   			 			  	p_curstat 	IN OUT favorisCurType_Char ,
                            p_nbcurseur    OUT INTEGER,
                            p_message      OUT VARCHAR2
                          );

   PROCEDURE add_favori ( p_userid  IN VARCHAR2,
		 			  	  p_menu    IN VARCHAR2,
                          p_libelle IN VARCHAR2,
                          p_lien    IN VARCHAR2,
                          p_type    IN VARCHAR2,
                          p_nbcurseur  OUT INTEGER,
                          p_message    OUT VARCHAR2
                        );

   PROCEDURE delete_favori ( p_userid  IN VARCHAR2,
   			 			  	 p_menu    IN VARCHAR2,
                             p_type    IN VARCHAR2,
                             p_ordre   IN INTEGER,
                             p_nbcurseur  OUT INTEGER,
                             p_message    OUT VARCHAR2
                           );

   PROCEDURE update_ordre ( p_userid  IN VARCHAR2,
   			 			  	p_menu    IN VARCHAR2,
                            p_type    IN VARCHAR2,
                            p_ordre   IN INTEGER,
                            p_sens    IN INTEGER,
                            p_nbcurseur  OUT INTEGER,
                            p_message    OUT VARCHAR2
                           );

END pack_favoris;
/

CREATE OR REPLACE PACKAGE BODY     pack_favoris AS


/***********************************************************************************/
/*                                                                                 */
/*               SELECTION LISTE DES FAVORIS POUR UN UTILISATEUR                   */
/*                                                                                 */
/***********************************************************************************/
PROCEDURE select_liste ( p_userid	 IN VARCHAR2,
		 			  	 p_menu      IN VARCHAR2,
		  			   	 p_curstat 	 IN OUT favorisCurType_Char ,
                         p_nbcurseur    OUT INTEGER,
                         p_message      OUT VARCHAR2
                       ) IS
	l_msg VARCHAR2(1024);
    l_idarpege	    FAVORIS.IDUSER%TYPE;
	l_codsg NUMBER;
BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
	p_nbcurseur := 1;
   	p_message := '';

	l_idarpege := PACK_GLOBAL.lire_globaldata(p_userid).idarpege;

   	OPEN   p_curstat FOR
       	SELECT iduser, typefav, ordre, libfav, lienfav, menu
          FROM FAVORIS
		 WHERE IDUSER = l_idarpege
		   AND MENU = p_menu
	    ORDER BY typefav, ordre;

EXCEPTION
	WHEN OTHERS THEN
   		raise_application_error( -20997, SQLERRM);

END select_liste;



/***********************************************************************************/
/*                                                                                 */
/*                    AJOUT D'UN FAVORI A UN UTILISATEUR                           */
/*                                                                                 */
/***********************************************************************************/
PROCEDURE add_favori ( p_userid  IN VARCHAR2,
		  			   p_menu    IN VARCHAR2,
                       p_libelle IN VARCHAR2,
                       p_lien    IN VARCHAR2,
                       p_type    IN VARCHAR2,
                       p_nbcurseur  OUT INTEGER,
                       p_message    OUT VARCHAR2
                              ) IS
    l_idarpege	    FAVORIS.IDUSER%TYPE;
    l_next_ordre		FAVORIS.ORDRE%TYPE;
BEGIN
    -- Initialiser le message retour
    p_message   := '';
	p_nbcurseur := 1;

	l_idarpege := PACK_GLOBAL.lire_globaldata(p_userid).idarpege;

	select nvl(max(ordre),0) + 2
	  into l_next_ordre
	  from FAVORIS
	 where IDUSER = l_idarpege
	   and MENU = p_menu
	   and TYPEFAV = p_type;

	insert into FAVORIS (IDUSER, MENU, TYPEFAV, ORDRE, LIBFAV, LIENFAV)
	values (l_idarpege, p_menu, p_type, l_next_ordre, p_libelle, p_lien);

    pack_global.recuperer_message( 20366 , '%s1', 'La page a été ajoutée aux favoris.', '', p_message);

END add_favori;


/***********************************************************************************/
/*                                                                                 */
/*                    SUPPRESSION D'UN FAVORI D'UN UTILISATEUR                     */
/*                                                                                 */
/***********************************************************************************/
PROCEDURE delete_favori ( p_userid  IN VARCHAR2,
                          p_menu    IN VARCHAR2,
                          p_type    IN VARCHAR2,
                          p_ordre   IN INTEGER,
                          p_nbcurseur  OUT INTEGER,
                          p_message    OUT VARCHAR2
                        ) IS
    l_idarpege	    FAVORIS.IDUSER%TYPE;
BEGIN
    -- Initialiser le message retour
    p_message   := '';
	p_nbcurseur := 1;

	l_idarpege := PACK_GLOBAL.lire_globaldata(p_userid).idarpege;


	delete FAVORIS
	 where IDUSER = l_idarpege and MENU = p_menu and TYPEFAV = p_type and ORDRE = p_ordre;


	-- si le favori supprimé n'était pas le dernier de la liste on décrémente l'ordre des favoris suivants
    update FAVORIS
	   set ORDRE = ORDRE - 2
     where IDUSER = l_idarpege and MENU = p_menu and TYPEFAV = p_type and ORDRE > p_ordre;

    --pack_global.recuperer_message( 20366 , '%s1', 'La page a été ajoutée aux favoris.', '', p_message);

END delete_favori;





/***********************************************************************************/
/*                                                                                 */
/*                    MODIFICATION DE L'ORDRE D'UN FAVORI                          */
/*                                                                                 */
/***********************************************************************************/
PROCEDURE update_ordre ( p_userid  IN VARCHAR2,
                         p_menu    IN VARCHAR2,
                         p_type    IN VARCHAR2,
                         p_ordre   IN INTEGER,
                         p_sens    IN INTEGER,
                         p_nbcurseur  OUT INTEGER,
                         p_message    OUT VARCHAR2
                       ) IS
    l_idarpege	    FAVORIS.IDUSER%TYPE;
	l_first_ordre   INTEGER;
	l_second_ordre  INTEGER;
BEGIN
    -- Initialiser le message retour
    p_message   := '';
	p_nbcurseur := 1;

	l_idarpege := PACK_GLOBAL.lire_globaldata(p_userid).idarpege;


	if (p_sens>0) then
	    l_first_ordre  := p_ordre;
	    l_second_ordre := p_ordre+2;
	else
	    l_first_ordre  := p_ordre-2;
	    l_second_ordre := p_ordre;
	end if;

    update FAVORIS
	   set ORDRE = ORDRE - 3
     where IDUSER = l_idarpege and MENU = p_menu and TYPEFAV = p_type and ORDRE = l_second_ordre;

    update FAVORIS
	   set ORDRE = ORDRE + 2
     where IDUSER = l_idarpege and MENU = p_menu and TYPEFAV = p_type and ORDRE = l_first_ordre;

    update FAVORIS
	   set ORDRE = ORDRE + 1
     where IDUSER = l_idarpege and MENU = p_menu and TYPEFAV = p_type and ORDRE = l_second_ordre - 3;

    --pack_global.recuperer_message( 20366 , '%s1', 'La page a été ajoutée aux favoris.', '', p_message);

END update_ordre;


END pack_favoris;
/
CREATE OR REPLACE PACKAGE pack_ferme_ligne AS

   -- definition d'un enregistrement de la table ligne_bip pour la gestion  des entetes

   TYPE ligne_bip_ViewType IS RECORD ( PID          LIGNE_BIP.PID%TYPE,
                                       CODCAMO      LIGNE_BIP.CODCAMO%TYPE,
                                       TYPPROJ      LIGNE_BIP.TYPPROJ%TYPE,
                                       ARCTYPE      LIGNE_BIP.ARCTYPE%TYPE,
                                       TOPTRI       LIGNE_BIP.TOPTRI%TYPE,
                                       ICPI         LIGNE_BIP.ICPI%TYPE,
                                       ILIBEL       PROJ_INFO.ILIBEL%TYPE,
                                       AIRT	    LIGNE_BIP.AIRT%TYPE,
                                       ALIBEL       APPLICATION.ALIBEL%TYPE,
                                       DPCODE       LIGNE_BIP.DPCODE%TYPE,
                                       DPLIB        DOSSIER_PROJET.DPLIB%TYPE,
                                       CODPSPE      LIGNE_BIP.CODPSPE%TYPE,
                                       LIBPSPE      PROJ_SPE.LIBPSPE%TYPE,
                                       CODSG        LIGNE_BIP.CODSG%TYPE,
                                       LIBDSG       STRUCT_INFO.LIBDSG%TYPE,
                                       RNOM         RESSOURCE.RNOM%TYPE,
                                       METIER       LIGNE_BIP.METIER%TYPE,
                                       PNOM         LIGNE_BIP.PNOM%TYPE,
                                       PNMOUVRA     LIGNE_BIP.PNMOUVRA%TYPE,
                                       CLICODE      LIGNE_BIP.CLICODE%TYPE,
                                       CLILIB       CLIENT_MO.CLILIB%TYPE,
                                       POBJET       LIGNE_BIP.POBJET%TYPE,
                                       ANNEE	    VARCHAR2(4),
                                       BNMONT       VARCHAR2(12),
                                       BPMONTME     VARCHAR2(12),
                                       ANMONT       VARCHAR2(12),
                                       REESTIME     VARCHAR2(12),
                                       ESTIMPLURIAN VARCHAR2(12),
                                       CUSAG 	    VARCHAR2(12),
                                       BPMONTMO     VARCHAR2(12),
                                       FLAGLOCK     ligne_bip.FLAGLOCK%TYPE
					);

  -- définition du curseur sur la table ligne_bip pour la gestion de l'entete du projet

   TYPE ligne_bipCurType IS REF CURSOR RETURN ligne_bip_ViewType;



	PROCEDURE select_ligne( p_pid          IN ligne_bip.pid%TYPE,
                                p_adatestatut  IN VARCHAR2,
                                p_global       IN VARCHAR2,
                                p_curLigne_bip IN OUT ligne_bipCurType,
                                p_nbcurseur    OUT INTEGER,
                                p_message      OUT VARCHAR2
                              );

   	PROCEDURE ferme_ligne (	p_pid         	IN  ligne_bip.pid%TYPE,
		       		p_adatestatut 	IN  VARCHAR2,
		       		p_flaglock	IN  VARCHAR2,
                              	p_global      	IN  VARCHAR2,
                              	p_message     	OUT VARCHAR2
                              );

END pack_ferme_ligne;
/

CREATE OR REPLACE PACKAGE BODY     pack_ferme_ligne AS

PROCEDURE select_ligne ( 	p_pid          	IN ligne_bip.pid%TYPE,
                                p_adatestatut  	IN VARCHAR2,
                                p_global      	IN VARCHAR2,
                                p_curLigne_bip 	IN OUT ligne_bipCurType,
                                p_nbcurseur    	OUT INTEGER,
                                p_message      	OUT VARCHAR2
                              ) IS
	msg 		VARCHAR(1024);
	l_pid 		ligne_bip.pid%TYPE;
	l_datdebex	VARCHAR2(4);
	l_moismens	datdebex.moismens%TYPE;
	l_typproj 	ligne_bip.typproj%TYPE;
	l_arctype 	ligne_bip.arctype%TYPE;
	l_adatestatut	ligne_bip.adatestatut%TYPE;
	l_codsg		ligne_bip.codsg%TYPE;
	l_habilitation 	VARCHAR2(10);
    	l_datesaisie	VARCHAR2(6);
    	l_annee		VARCHAR2(4);
    	l_mois		VARCHAR2(2);
    	l_dpcode        ligne_bip.dpcode%TYPE;


BEGIN
      	-- ====================================================================
      	-- On teste l'existence de la ligne et on récupère ses données
      	-- ====================================================================
  	 BEGIN
            SELECT pid, typproj, arctype, adatestatut, codsg, dpcode
            INTO l_pid, l_typproj, l_arctype, l_adatestatut, l_codsg, l_dpcode
            FROM ligne_bip
            WHERE pid = p_pid;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               -- Code projet %s1 inexistant
               pack_global.recuperer_message(20504, '%s1', p_pid, NULL, msg);
               raise_application_error( -20504, msg );
            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);
	  END;


      	-- ====================================================================
      	-- Test appartenance au perimetre ME
      	-- ====================================================================
     	pack_habilitation.verif_habili_me(TO_CHAR(l_codsg, 'FM0000000'), p_global, msg );

      	-- ====================================================================
      	--  test sur le TYPE (doit etre <> T1)
      	-- ====================================================================
	IF l_typproj = '1 ' AND (l_arctype = 'T1' OR l_dpcode <> '00000') THEN
       		--('vous n etes pas autorisé à fermer une ligne T1')
       		pack_global.recuperer_message(20365, '%s1',  'fermer une ligne T1','PID', msg);
	   	raise_application_error(-20365,  msg);
   	END IF;

      	-- ====================================================================
      	--  test sur un ligne non fermée
      	-- ====================================================================
	IF l_adatestatut IS NOT NULL THEN
       		--('cette ligne est déjà fermée ')
       		pack_global.recuperer_message(20981, '%s1', p_pid, 'PID', msg);
	   	raise_application_error(-20981,  msg);
   	END IF;


      	-- ====================================================================
      	--  test sur date non rétroactive
      	-- ====================================================================
	SELECT moismens
	INTO l_moismens
	FROM datdebex
	WHERE rownum < 2;

	IF TO_DATE(p_adatestatut, 'MM/YYYY') <= l_moismens THEN
		--('vous n etes pas autorisé à effectuer une fermeture rétroactive')
       		pack_global.recuperer_message(20365, '%s1',  'effectuer une fermeture rétroactive','ADATESTATUT', msg);
	   	raise_application_error(-20365,  msg);
	END IF;

      	-- ====================================================================
      	--  Curseur rapportant les infos sur la ligne BIP
      	-- ====================================================================

	BEGIN
		SELECT TO_CHAR(datdebex, 'YYYY')
		INTO l_datdebex
		FROM datdebex
		WHERE rownum < 2;

		OPEN p_curLigne_bip FOR
			SELECT lb.PID,
			lb.CODCAMO, --CA payeur
			lb.TYPPROJ, --type
			lb.ARCTYPE, 	--typologie
			lb.TOPTRI,
			lb.ICPI, 	--code projet
			pi.ILIBEL, 	--libelle projet
			lb.AIRT, 	--code irt
			a.ALIBEL,	--libelle application
			lb.DPCODE,	--code dossier projet
			dp.DPLIB, 	--libelle dossier projet
			lb.codpspe, 	-- projet special
			ps.LIBPSPE, 	--libelle projet special
			lb.CODSG, 	--DPG
			st.LIBDSG, 	--libelle DPG
			r.RNOM, 	--nom chef de projet
			lb.METIER,
			lb.PNOM, 	--libelle ligne BIP
			rtrim(lb.PNMOUVRA), 	--nom du correspondant MO
			lb.CLICODE, 	--direction cliente
			cm.CLILIB,	--direction cliente
			lb.POBJET, 	--zone de texte
			l_datdebex,	-- Année en cours
			DECODE( b.BNMONT,NULL,',00',TO_CHAR(b.BNMONT, 'FM9999999990D00')) AS BNMONT,  		--budget notifie
		        DECODE(b.BPMONTME,NULL,',00',TO_CHAR(b.BPMONTME, 'FM9999999990D00')) AS BPMONTME,	--propose ME
		        DECODE(b.ANMONT,NULL,',00',TO_CHAR(b.ANMONT, 'FM9999999990D00')) AS ANMONT,		--arbitre
		        DECODE(b.REESTIME,NULL,',00',TO_CHAR(b.REESTIME, 'FM9999999990D00')) AS REESTIME,	--re-estime ME
		        DECODE(lb.ESTIMPLURIAN,NULL,',00',TO_CHAR(lb.ESTIMPLURIAN, 'FM9999999990D00')) AS ESTIMPLURIAN,	--estimation pluriannuelle
		        DECODE(c.CUSAG ,NULL,',00',TO_CHAR(c.CUSAG , 'FM9999999990D00')) AS CUSAG,	--realise
		        DECODE( b.BPMONTMO ,NULL,',00',TO_CHAR( b.BPMONTMO , 'FM9999999990D00')) AS BPMONTMO,	--propose MO
			lb.FLAGLOCK

		FROM  ligne_bip lb,
	              struct_info st,
        	      ressource r,
        	      dossier_projet dp,
        	      proj_spe ps,
        	      proj_info pi,
        	      client_mo cm,
        	      application a,
        	      budget b,
        	      consomme c
      		WHERE lb.pid = p_pid
      		AND lb.pid = b.pid(+)
      		AND lb.pid = c.pid(+)
      		AND lb.codsg=st.codsg
      		AND r.ident=lb.pcpi
      		AND lb.airt=a.airt
      		AND lb.icpi=pi.icpi
      		AND lb.dpcode=dp.dpcode
      		AND lb.codpspe=ps.codpspe(+)
      		AND cm.clicode=lb.clicode
      		AND b.annee(+) = TO_NUMBER(l_datdebex)
      		AND c.annee(+) = TO_NUMBER(l_datdebex);

      EXCEPTION
         	WHEN OTHERS THEN
         	   raise_application_error(-20997,SQLERRM);
      END;


END select_ligne;

   PROCEDURE ferme_ligne (	p_pid         	IN  ligne_bip.pid%TYPE,
		       		p_adatestatut 	IN  VARCHAR2,
		       		p_flaglock	IN  VARCHAR2,
                              	p_global      	IN  VARCHAR2,
                              	p_message     	OUT VARCHAR2
                             ) IS

 l_user		ligne_bip_logs.user_log%TYPE;
 -- Valeurs précédentes pour les logs
 l_topfer	ligne_bip.topfer%TYPE;
 l_adatestatut	ligne_bip.adatestatut%TYPE;

   BEGIN

      -- Initialiser le message retour
      p_message := '';
      l_user := SUBSTR(pack_global.lire_globaldata(p_global).idarpege, 1, 30);


      BEGIN

         -- On récupère les valeurs précédentes pour les logs
         SELECT topfer, adatestatut
         INTO l_topfer, l_adatestatut
         FROM ligne_bip
         WHERE pid = p_pid
         AND flaglock = p_flaglock;

         UPDATE ligne_bip
         SET 	topfer     = 'O',
             	adatestatut = TO_DATE(p_adatestatut, 'MM/YYYY'),
             	flaglock    = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  pid = p_pid
         AND flaglock = p_flaglock;

         -- On loggue le topfer, la date de statut
         pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'Top fermeture', l_topfer, 'O', 'Fermeture de la ligne BIP via pcmmenu');
         pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'Date statut', TO_CHAR(l_adatestatut, 'MM/YYYY'), p_adatestatut, 'Fermeture de la ligne BIP via pcmmenu');


	 --Audit
	 pack_st_amort.audit(p_pid, TO_CHAR(SYSDATE, 'DD/MM/YYYY'), SUBSTR(l_user, 1, 15), 'Fermeture via pcmmenu', p_message);

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      pack_global.recuperer_message(20371, '%s1', p_pid, NULL, p_message);

END ferme_ligne;

END pack_ferme_ligne;
/
CREATE OR REPLACE PACKAGE pack_fichier AS

   PROCEDURE insert_calendrier (p_idfic     IN  fichier.idfic%TYPE,
                                p_contenu   IN  fichier.contenu%TYPE,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                               );

END pack_fichier;
/

CREATE OR REPLACE PACKAGE BODY pack_fichier AS

   PROCEDURE insert_calendrier (p_idfic     IN  fichier.idfic%TYPE,
                                p_contenu   IN  fichier.contenu%TYPE,
                                p_userid    IN  VARCHAR2,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                               ) IS

   l_msg VARCHAR2(1024);
   l_idfic fichier.idfic%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- TEST pour savoir si la cle existe ou pas -> existe update, sinon insert

      BEGIN
         SELECT idfic
         INTO   l_idfic
         FROM   fichier
         WHERE  idfic = p_idfic;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN

            -- la cle n'existe pas donc insert.

            BEGIN
               INSERT INTO fichier (idfic,
                                    contenu
                                   )
               VALUES (p_idfic,
                       p_contenu
                      );

               -- 'Dates de traitement' || p_idfic ||' créé.';

               pack_global.recuperer_message(2079,'%s1',p_idfic, NULL, l_msg);
               p_message := l_msg;

            EXCEPTION
                WHEN DUP_VAL_ON_INDEX THEN
                     pack_global.recuperer_message(20272,NULL, NULL, NULL, l_msg);
                     raise_application_error( -20272, l_msg );

                WHEN OTHERS THEN
                     raise_application_error( -20997, SQLERRM );
            END;
     END;

     IF l_idfic IS NOT NULL THEN

        BEGIN
          UPDATE fichier SET contenu = p_contenu
          WHERE  idfic = p_idfic;

        EXCEPTION
           WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM );
        END;

        IF SQL%NOTFOUND THEN
           pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
           raise_application_error( -20999, l_msg );
        ELSE
           pack_global.recuperer_message(2080, '%s1', p_idfic, NULL, l_msg);
           p_message := l_msg;
        END IF;
     END IF;

   END insert_calendrier;

END pack_fichier;
/
CREATE OR REPLACE PACKAGE PACK_FILE AS

   -- Définition curseur sur la table actualite

   TYPE file_ViewType IS RECORD (
					fichier actualite.fichier%TYPE,
					nom_fichier actualite.nom_fichier%TYPE,
					mime_fichier actualite.mime_fichier%TYPE,
					size_fichier actualite.size_fichier%TYPE

					 	);


   TYPE fileCurType_Char IS REF CURSOR RETURN file_ViewType;



   PROCEDURE DOWNLOAD_FILE ( p_code_actu	   IN VARCHAR2,
                                  p_userid         IN VARCHAR2,
                                  p_curfile IN OUT fileCurType_Char,
                                  p_nbcurseur         OUT INTEGER,
                                  p_message           OUT VARCHAR2
                                );


END PACK_FILE;
/

CREATE OR REPLACE PACKAGE BODY PACK_FILE AS





   PROCEDURE DOWNLOAD_FILE ( p_code_actu	   IN VARCHAR2,
                                  p_userid         IN VARCHAR2,
                                  p_curfile IN OUT fileCurType_Char,
                                  p_nbcurseur         OUT INTEGER,
                                  p_message           OUT VARCHAR2
                                ) IS

	l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;

      p_message := '';



-- dbms_output.put_line('p_code_actu = ' || p_code_actu || ' --- p_userid = ' || p_userid );

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN   p_curfile FOR
              SELECT
		fichier,
		nom_fichier,
		mime_fichier,
		size_fichier

              FROM  actualite
              WHERE code_actu = TO_NUMBER(p_code_actu);

         -- en cas absence
	   -- 'Code Département/Pôle/Groupe p_code_actu inexistant'

         pack_global.recuperer_message( 20203, '%s1', p_code_actu, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION

        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;

   END DOWNLOAD_FILE;
END PACK_FILE;
/
CREATE OR REPLACE PACKAGE pack_filiale_cli AS

   TYPE filiale_cliCurType IS REF CURSOR RETURN filiale_cli%ROWTYPE;

   PROCEDURE insert_filiale_cli ( p_filcode   IN CHAR,
                                  p_filsigle  IN CHAR,
                                  p_top_immo  IN CHAR,
                                  p_top_sdff  IN CHAR,
                                  p_userid    IN VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                                );

   PROCEDURE update_filiale_cli ( p_filcode   IN CHAR,
                                  p_filsigle  IN CHAR,
                                  p_top_immo  IN CHAR,
                                  p_top_sdff  IN CHAR,
                                  p_flaglock  IN NUMBER,
                                  p_userid    IN VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                                );

   PROCEDURE delete_filiale_cli ( p_filcode   IN CHAR,
                                  p_flaglock  IN NUMBER,
                                  p_userid    IN VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                                );

   PROCEDURE select_filiale_cli ( p_filcode        IN CHAR,
                                  p_userid         IN VARCHAR2,
                                  p_curFiliale_cli IN OUT filiale_cliCurType,
                                  p_nbcurseur      OUT INTEGER,
                                  p_message        OUT VARCHAR2
                                );

END pack_filiale_cli;
/

CREATE OR REPLACE PACKAGE BODY pack_filiale_cli AS

   PROCEDURE insert_filiale_cli ( p_filcode   IN CHAR,
                                  p_filsigle  IN CHAR,
                                  p_top_immo  IN CHAR,
                                  p_top_sdff  IN CHAR,
                                  p_userid    IN VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO filiale_cli ( filcode,
                                   filsigle,
                                   top_immo,
                                   top_sdff )
         VALUES ( p_filcode,
                  p_filsigle,
                  p_top_immo,
                  p_top_sdff
                );

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message( 20501, NULL, NULL, NULL, msg);
            raise_application_error( -20501, msg );

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      -- 'Code filiale ' || p_filcode || ' enregistré.';

      pack_global.recuperer_message( 5001, '%s1', p_filcode, NULL, msg);
      p_message := msg;

   END insert_filiale_cli;


   PROCEDURE update_filiale_cli ( p_filcode   IN CHAR,
                                  p_filsigle  IN CHAR,
                                  p_top_immo  IN CHAR,
                                  p_top_sdff  IN CHAR,
                                  p_flaglock  IN NUMBER,
                                  p_userid    IN VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                              ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         UPDATE filiale_cli
         SET filsigle = p_filsigle,
             top_immo = p_top_immo,
             top_sdff = p_top_sdff,
             flaglock = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE filcode = p_filcode
         AND flaglock = p_flaglock;

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message( 20999, NULL, NULL, NULL, msg);
         raise_application_error( -20999, msg );
      ELSE
         pack_global.recuperer_message( 5002, '%s1', p_filcode, NULL, msg);
         p_message := msg;
      END IF;

   END update_filiale_cli;


   PROCEDURE delete_filiale_cli ( p_filcode   IN CHAR,
                                  p_flaglock  IN NUMBER,
                                  p_userid    IN VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                              ) IS
      msg VARCHAR(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM filiale_cli
         WHERE filcode = p_filcode
         AND flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

           -- pack_global.recuperation_integrite(-2292);
            pack_global.recuperer_message( 20856, NULL, NULL, NULL, msg);
         raise_application_error( -20856, msg );

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message( 20999, NULL, NULL, NULL, msg);
         raise_application_error( -20999, msg );
      ELSE
         pack_global.recuperer_message( 5003, '%s1', p_filcode, NULL, msg);
         p_message := msg;
      END IF;

   END delete_filiale_cli;


   PROCEDURE select_filiale_cli ( p_filcode        IN CHAR,
                                  p_userid         IN VARCHAR2,
                                  p_curFiliale_cli IN OUT filiale_cliCurType,
                                  p_nbcurseur      OUT INTEGER,
                                  p_message        OUT VARCHAR2
                              ) IS
      l_msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      OPEN p_curFiliale_cli FOR
           SELECT *
           FROM FILIALE_CLI
           WHERE FILCODE = p_filcode;

      -- en cas absence
      -- 'Code filiale inexistant'

      pack_global.recuperer_message( 5004, '%s1', p_filcode, NULL, l_msg);
      p_message := l_msg;

   END select_filiale_cli;

END pack_filiale_cli;
/
CREATE OR REPLACE PACKAGE pack_fmt IS
-- *************************************************************************
   FUNCTION f_fmtAlpha (p_champ IN VARCHAR2, p_ln IN INTEGER) RETURN VARCHAR2;
   FUNCTION f_fmtInt (p_champ IN INTEGER, p_ln IN INTEGER) RETURN VARCHAR2;
   FUNCTION f_fmtNum (p_champ IN NUMBER, p_ln IN INTEGER) RETURN VARCHAR2;
   FUNCTION f_fmtDat(p_champ IN DATE) RETURN VARCHAR2;
   FUNCTION f_Cadrer (p_champ IN VARCHAR2, p_ln IN INTEGER, P_cote IN CHAR, p_car IN CHAR) RETURN VARCHAR2;

   -- Pragma permettant d'appeler les fonctions dans des selects
   PRAGMA restrict_references(f_fmtAlpha,wnds,wnps);
   PRAGMA restrict_references(f_fmtInt,wnds,wnps);
   PRAGMA restrict_references(f_fmtDat,wnds,wnps);
   PRAGMA restrict_references(f_Cadrer,wnds,wnps);
END pack_fmt;
/

CREATE OR REPLACE PACKAGE BODY pack_fmt IS

-- *************************************************************************
-- f_fmtAlpha : formate la variable p_champ (alphabetique) selon la regle suivante :
--              cadrage à gauche, completer à blancs jusqu'a ce que p_champ
--              ait une taille = p_ln caracteres.
-- *************************************************************************
 FUNCTION f_fmtAlpha (p_champ IN VARCHAR2, p_ln IN INTEGER) RETURN VARCHAR2 IS
    l_champ VARCHAR2(1024);
    l_car CHAR(1);
 BEGIN
    l_car   := ' ';
    l_champ := NVL(p_champ,l_car);

    RETURN (f_Cadrer (l_champ , p_ln ,'G' , l_car));
 END;



-- *************************************************************************
-- f_fmtInt : formate la variable p_champ (entier) selon la regle suivante :
--            Cadrage à droite, completer a gauche par des zeros jusqu' a ce
--            que p_champ ait une taille = p_ln caracteres.
-- *************************************************************************
 FUNCTION f_fmtInt (p_champ IN INTEGER, p_ln IN INTEGER) RETURN VARCHAR2 IS
    l_champ VARCHAR2(1024);
    l_car CHAR(1);
 BEGIN
    l_car   := '0';
    l_champ := to_char(NVL(p_champ,l_car),'FM99999999999');

    RETURN (f_Cadrer (l_champ , p_ln ,'D' , l_car));
 END;



-- *************************************************************************
-- f_fmtNum : formate la variable p_champ (numerique) selon la regle suivante :
--            Format des nombres avec deux chiffre décimales apres la virgule
--            Cadrage à droite, completer a gauche par des zeros jusqu' a ce
--            que p_champ ait une taille = p_ln caracteres (positions decimale
--            et virgule comprises).
-- *************************************************************************

 FUNCTION f_fmtNum(p_champ IN NUMBER, p_ln IN INTEGER) RETURN VARCHAR2 IS
    l_champ VARCHAR2(1024);
    l_car CHAR(1);
 BEGIN
    l_car := ' ';
    l_champ := to_char(NVL(p_champ,l_car),'FM99999999999.00');
    RETURN (f_Cadrer (l_champ , p_ln ,'D' , l_car));

 END;
-- *************************************************************************
-- f_fmtDat : formate la variable p_champ (date) selon la regle suivante :
--            format 'ddmmyyyy'
-- *************************************************************************

 FUNCTION f_fmtDat(p_champ IN DATE) RETURN VARCHAR2 IS
    l_champ VARCHAR2(1024);
    l_car CHAR(1);
 BEGIN
    l_car := '0';
    IF (p_champ is null) THEN
       RETURN ('00000000');
    ELSE
    	RETURN (to_char(p_champ,'ddmmyyyy'));
    END IF;
 END;



-- *************************************************************************
-- f_Cadrer : Cadre p_champ a droite ou a gauche selon la valeur p_cote,
--            le comlete par p_car pour que p_champ soit de taille=p_ln
-- *************************************************************************
 FUNCTION f_Cadrer (p_champ IN VARCHAR2, p_ln IN INTEGER, p_cote IN CHAR, p_car IN CHAR) RETURN VARCHAR2 IS
    l_champ VARCHAR2(1024);
 BEGIN
    IF LENGTH(p_champ) >= p_ln then
       RETURN (SUBSTR(p_champ,1, p_ln));
    ELSIF P_cote = 'D' THEN
       RETURN (lpad(p_champ, p_ln, p_car));
    ELSIF P_cote = 'G' THEN
       RETURN (rpad(p_champ, p_ln, p_car));
    ELSE
       RETURN ('Erreur');
    END IF;
 END;



END pack_fmt;
/
CREATE OR REPLACE PACKAGE Pack_Gestbudg AS

   TYPE GestBudg_ViewType IS RECORD( pid          LIGNE_BIP.pid%TYPE,
                                     pnom         LIGNE_BIP.pnom%TYPE,
                                     astatut      LIGNE_BIP.astatut%TYPE,
                                     date_statut  VARCHAR2(20),
                                     annee        VARCHAR2(20),
                                     bud_prop     VARCHAR2(20),
                                     bud_propmo   VARCHAR2(20),
                                     bud_not      VARCHAR2(20),
                                     bud_arb      VARCHAR2(20),
                                     reserve      VARCHAR2(20),
                                     bud_rst      VARCHAR2(20),
                                     flaglock     NUMBER
                                    );

   TYPE gestbudgCurType IS REF CURSOR RETURN GestBudg_ViewType;


   PROCEDURE update_gestbudg ( p_pid          IN LIGNE_BIP.pid%TYPE,
                               p_pnom         IN LIGNE_BIP.pnom%TYPE,
                               p_annee        IN CHAR,
                               p_bud_prop     IN VARCHAR2,
                               p_bud_propmo   IN VARCHAR2,
                               p_bud_not      IN VARCHAR2,
                               p_bud_arb      IN VARCHAR2,
                               p_reserve      IN VARCHAR2,
                               p_bud_rst      IN VARCHAR2,
                               p_flaglock     IN NUMBER,
                               p_userid       IN VARCHAR2,
                               p_nbcurseur    OUT INTEGER,
                               p_message      OUT VARCHAR2
                             );


   PROCEDURE select_gestbudg ( p_pid         IN LIGNE_BIP.pid%TYPE,
                               p_annee       IN VARCHAR2,
                               p_mode      IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_curGestbudg IN OUT gestbudgCurType,
                               p_annee_sav   OUT VARCHAR2,
                               p_bud_rees    OUT VARCHAR2,
                               p_nbcurseur   OUT INTEGER,
                               p_message     OUT VARCHAR2
                             );

END Pack_Gestbudg;
/

CREATE OR REPLACE PACKAGE BODY Pack_Gestbudg AS

   PROCEDURE update_gestbudg ( p_pid          IN LIGNE_BIP.pid%TYPE,
                               p_pnom         IN LIGNE_BIP.pnom%TYPE,
                               p_annee        IN CHAR,
                               p_bud_prop     IN VARCHAR2,
                               p_bud_propmo   IN VARCHAR2,
                               p_bud_not      IN VARCHAR2,
                               p_bud_arb      IN VARCHAR2,
                               p_reserve      IN VARCHAR2,
                               p_bud_rst      IN VARCHAR2,
                               p_flaglock     IN NUMBER,
                               p_userid       IN VARCHAR2,
                               p_nbcurseur    OUT INTEGER,
                               p_message      OUT VARCHAR2
                             ) IS
      l_msg VARCHAR(1024);
      l_msg2 VARCHAR2(1024);
      l_bud_prop  VARCHAR2(13);
      l_bud_propmo  VARCHAR2(13);
      l_bud_not   VARCHAR2(13);
      l_bud_arb   VARCHAR2(13);
      l_reserve   VARCHAR2(13);
      l_bud_rst   BUDGET.reestime%TYPE;
      l_datdebex VARCHAR(20);
	  l_user		LIGNE_BIP_LOGS.user_log%TYPE;

   BEGIN



 l_user := SUBSTR(Pack_Global.lire_globaldata(p_userid).idarpege, 1, 30);


      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';
      l_msg := '';
      l_msg2 := '';
      SELECT TO_CHAR(DATDEBEX,'YYYY') INTO l_datdebex FROM DATDEBEX;
      -- La valeur du flaglock issu de PROP_BUDGET indique la présence
      -- ou non des données

      IF (p_flaglock=-1) THEN

         -- L'occurence code projet-année n'existe pas, on l'insère

         BEGIN
            INSERT INTO BUDGET ( pid,
                                      annee,
                                      bpdate,
                                      bpmontme,
                                      reserve,
				      bpmontmo,
				      bnmont,
				      anmont,
				      reestime,
				      flaglock)
            VALUES( p_pid,
                    TO_NUMBER( p_annee),
                    TO_DATE( TO_CHAR( SYSDATE, 'DD/MM/YYYY'),
                             'DD/MM/YYYY'),
                    DECODE( p_bud_prop,
                            ',00',
                            NULL,
                            TO_NUMBER( p_bud_prop)),
                    DECODE( p_reserve,
                            ',00',
                            NULL,
                            TO_NUMBER( p_reserve)),
		    DECODE( p_bud_propmo,
                            ',00',
                            NULL,
                            TO_NUMBER( p_bud_propmo)),
		    DECODE( p_bud_not,
                            ',00',
                            NULL,
                            TO_NUMBER( p_bud_not)),
		    DECODE( p_bud_arb,
                            ',00',
                            NULL,
                            TO_NUMBER( p_bud_arb)),
		    DECODE( p_bud_rst,
                            '0',
                            NULL,
                            TO_NUMBER( p_bud_rst)),
		    0
                  );


		  -- On loggue le arbitré et réestimé
            Pack_Ligne_Bip.maj_ligne_bip_logs(p_pid, l_user, 'Arbitré ' || p_annee, NULL,p_bud_arb, 'Par Ligne/Gestion budgets/Modifier le budget');

         EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN

               -- ' budget déjà créé.'

               Pack_Global.recuperer_message( 20310, NULL, NULL,
                                              NULL, l_msg);

               RAISE_APPLICATION_ERROR( -20310, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

	   -- 'Proposition de budget enregistrée'

         Pack_Global.recuperer_message( 3007, NULL, NULL, NULL, l_msg);
         l_msg2 := l_msg;

	Pack_Global.recuperer_message( 3015, NULL, NULL, NULL, l_msg);
	 l_msg2 := l_msg2 || '\n' || l_msg;




	   -- 'Notification de budget créée.'

         Pack_Global.recuperer_message( 3009, NULL, NULL, NULL, l_msg);

         IF l_msg2 IS NULL THEN
            l_msg2 := l_msg;
         ELSE
            l_msg2 := l_msg2 || '\n' || l_msg;
         END IF;



 	-- 'Notification Arbitrage créée'

         Pack_Global.recuperer_message( 3011, NULL, NULL, NULL, l_msg);

         IF l_msg2 IS NULL THEN
            l_msg2 := l_msg;
         ELSE
            l_msg2 := l_msg2 || '\n' || l_msg;
         END IF;

         p_message := l_msg2;


      ELSE

         -- L'occurence code projet-année existe
         -- On effectue la mise à jour si les données saisies sont
         -- différentes de celles de la base

         BEGIN
            SELECT NVL(TO_CHAR(bpmontme, 'FM9999999990D00'),',00'),
                   NVL(TO_CHAR(reserve, 'FM9999999990D00'),',00'),
		   NVL(TO_CHAR(bpmontmo, 'FM9999999990D00'),',00'),
		   NVL(TO_CHAR(bnmont, 'FM9999999990D00'),',00'),
		   NVL(TO_CHAR(anmont, 'FM9999999990D00'), ',00'),
		   NVL(TO_CHAR(reestime, 'FM9999999990D00'), ',00')
            INTO l_bud_prop,
                 l_reserve,
		 l_bud_propmo,
		 l_bud_not,
		 l_bud_arb,
		 l_bud_rst
            FROM BUDGET
            WHERE pid = p_pid
            AND   annee = TO_NUMBER( p_annee)
	    AND   flaglock = TO_NUMBER(p_flaglock);

         EXCEPTION
            WHEN NO_DATA_FOUND THEN

               -- 'Accès concurrent'

               Pack_Global.recuperer_message( 20999, NULL, NULL,
                                              NULL, l_msg);
               RAISE_APPLICATION_ERROR( -20999, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF RTRIM(LTRIM(p_bud_prop)) != RTRIM(LTRIM(l_bud_prop)) OR
            RTRIM(LTRIM(p_reserve)) != RTRIM(LTRIM(l_reserve))  OR
	    RTRIM(LTRIM(p_bud_propmo)) != RTRIM(LTRIM(l_bud_propmo)) OR
	    p_bud_not != l_bud_not OR
	    p_bud_arb != l_bud_arb OR
	   (p_annee = l_datdebex AND (TO_NUMBER( p_bud_rst) != l_bud_rst
              OR  l_bud_rst IS NULL
              OR  TO_NUMBER( p_bud_rst) IS NULL)) THEN

	      -- MAJ de la table BUDGET

            BEGIN
               UPDATE BUDGET
               SET bpdate  = TO_DATE( TO_CHAR( SYSDATE, 'DD/MM/YYYY'),
                                      'DD/MM/YYYY'),
                   bpmontme = DECODE( p_bud_prop,
                                     ',00',
                                     NULL,
                                     TO_NUMBER( p_bud_prop)),
                   reserve = DECODE( p_reserve,
                                     ',00',
                                     NULL,
                                     TO_NUMBER( p_reserve)),
		   bpmontmo = DECODE( p_bud_propmo,
                                     ',00',
                                     NULL,
                                     TO_NUMBER( p_bud_propmo)),
		   bnmont = DECODE( p_bud_not,
                                    ',00',
                                    NULL,
                                    TO_NUMBER( p_bud_not)),
		   anmont = DECODE( p_bud_arb,
                                    ',00',
                                    NULL,
                                    TO_NUMBER( p_bud_arb)),
		   reestime = TO_NUMBER( p_bud_rst),
                   flaglock = DECODE( TO_NUMBER( p_flaglock), 1000000,
                                      0, TO_NUMBER( p_flaglock) + 1)
               WHERE pid = p_pid
               AND   annee = TO_NUMBER( p_annee)
               AND   flaglock = TO_NUMBER( p_flaglock);


			 -- On loggue le arbitré et réestimé
            Pack_Ligne_Bip.maj_ligne_bip_logs(p_pid, l_user, 'Arbitré ' || p_annee, l_bud_arb,p_bud_arb, 'Par Ligne/Gestion budgets/Modifier le budget');
			Pack_Ligne_Bip.maj_ligne_bip_logs(p_pid, l_user, 'Réestimé  ' || p_annee, l_bud_rst,p_bud_rst, 'Par Ligne/Gestion budgets/Modifier le budget');


            EXCEPTION
               WHEN OTHERS THEN
                  RAISE_APPLICATION_ERROR( -20997, SQLERRM);
            END;

            IF SQL%NOTFOUND THEN

               -- 'Accès concurrent'

               Pack_Global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
               RAISE_APPLICATION_ERROR( -20999, l_msg);
            END IF;

            -- Renseigner le message dans le cas de la mise à jour
            -- 'Proposition de budget modifiée'

            IF RTRIM(LTRIM(p_reserve)) != RTRIM(LTRIM(l_reserve))   THEN
              	Pack_Global.recuperer_message( 3013, NULL, NULL, NULL, l_msg);
              	l_msg2 := l_msg;
            END IF;

            IF RTRIM(LTRIM(p_bud_prop)) != RTRIM(LTRIM(l_bud_prop))   THEN
              	Pack_Global.recuperer_message( 3008, NULL, NULL, NULL, l_msg);
              	IF l_msg2 IS NULL THEN
                	l_msg2 := l_msg;
              	ELSE
                	l_msg2 := l_msg2 || '\n' || l_msg;
              	END IF;
            END IF;

	    IF RTRIM(LTRIM(p_bud_propmo)) != RTRIM(LTRIM(l_bud_propmo)) THEN
              	Pack_Global.recuperer_message( 3016, NULL, NULL, NULL, l_msg);
              	IF l_msg2 IS NULL THEN
                	l_msg2 := l_msg;
              	ELSE
                	l_msg2 := l_msg2 || '\n' || l_msg;
              	END IF;
	    END IF;


	    IF (p_bud_not != l_bud_not) THEN
	    	-- Renseigner le message dans le cas de la mise à jour
	    	-- 'Notification de budget modifiée.'
            	Pack_Global.recuperer_message( 3010, NULL, NULL, NULL, l_msg);
            	IF l_msg2 IS NULL THEN
               		l_msg2 := l_msg;
            	ELSE
               		l_msg2 := l_msg2 || '\n' || l_msg;
            	END IF;
	    END IF;



	   IF ( p_bud_arb != l_bud_arb ) THEN
	     	-- 'Notification Arbitrage modifiée.'

            	Pack_Global.recuperer_message( 3012, NULL, NULL, NULL, l_msg);

            	IF l_msg2 IS NULL THEN
               		l_msg2 := l_msg;
           	 ELSE
               		l_msg2 := l_msg2 || '\n' || l_msg;
            	END IF;
	   END IF;


	   IF (p_annee = l_datdebex AND (TO_NUMBER( p_bud_rst) != l_bud_rst
              OR  l_bud_rst IS NULL
              OR  TO_NUMBER( p_bud_rst) IS NULL)) THEN
		-- Réestimation du projet modifié

         	Pack_Global.recuperer_message( 3014, NULL, NULL, NULL, l_msg);

         	IF l_msg2 IS NULL THEN
           		l_msg2 := l_msg;
         	ELSE
           		l_msg2 := l_msg2 || '\n' || l_msg;
         	END IF;
	    END IF;


            p_message := l_msg2;

         END IF;
      END IF;
   END update_gestbudg;


   PROCEDURE select_gestbudg ( p_pid         IN LIGNE_BIP.pid%TYPE,
                               p_annee       IN VARCHAR2,
                               p_mode      IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_curGestbudg IN OUT gestbudgCurType,
                               p_annee_sav   OUT VARCHAR2,
                               p_bud_rees    OUT VARCHAR2,
                               p_nbcurseur   OUT INTEGER,
                               p_message     OUT VARCHAR2
                             ) IS
   l_msg   		VARCHAR(1024);
   l_result   		INTEGER;
   l_codsg    		LIGNE_BIP.codsg%TYPE;
   l_datdebex 		VARCHAR2(20);
   l_statut 		CHAR(1);
   l_date_statut 	VARCHAR2(10);
   l_topfer 		CHAR(1);
   l_datdeb 		VARCHAR2(10);
   l_date_statut_number NUMBER(10);
   l_menu 		VARCHAR2(255);



   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';
      SELECT TO_CHAR(DATDEBEX,'YYYY') INTO l_datdebex FROM DATDEBEX;

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      -- Récupération du code département/division

      BEGIN
         SELECT codsg
         INTO   l_codsg
         FROM   LIGNE_BIP
         WHERE  pid = p_pid;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN

            -- 'Identifiant ligne BIP inexistant'

            Pack_Global.recuperer_message( 20504, '%s1', p_pid, 'PID', l_msg);
            RAISE_APPLICATION_ERROR( -20504, l_msg);

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

      END;

      -- Vérification habilitation

      l_result := Pack_Global.verifier_habilitation( p_userid, l_codsg,
                                                     'à accéder aux données de ce projet',
                                                     NULL);

	-- test de la date statut
      IF (p_mode = 'update' AND l_menu <> 'DIR') THEN

	SELECT TO_CHAR(adatestatut,'DD/MM/YYYY'),NVL(astatut,'E'),topfer INTO l_date_statut,l_statut,l_topfer
	FROM LIGNE_BIP WHERE pid = p_pid;

	SELECT TO_NUMBER(TO_CHAR(adatestatut,'YYYY')) INTO l_date_statut_number
	FROM LIGNE_BIP WHERE pid = p_pid;


	SELECT TO_NUMBER(p_annee) INTO l_datdeb FROM dual;
	--raise_application_error(-20000,l_datdeb);
	--p_annee >= annee en cours et <= à l'annee de fermeture
	-- message d'erreur quand < annee en cours -> controle de l'annee
	-- OU > annee de fermeture
	IF ((l_date_statut IS NOT NULL) AND (l_date_statut_number < l_datdeb)) THEN
		RAISE_APPLICATION_ERROR (-20000,'Vous ne pouvez pas modifier la ligne bip ' || p_pid ||
					' car son statut est ' || l_statut ||
					', son top fermeture est ' || l_topfer ||
					' et sa date de statut ou de top fermeture est ' || l_date_statut);
	END IF;
      END IF;


      -- Contrôle de l'année

      IF ( p_mode = 'update'              AND
           p_annee < l_datdebex ) THEN

         -- 'Pas de mise à jour sur les années antérieures'

         Pack_Global.recuperer_message( 20313, NULL, NULL, 'ANNEE', l_msg);
         RAISE_APPLICATION_ERROR( -20313, l_msg);
      END IF;

      -- Test annee > annee courante le champs Budget reestimes ne doit pas etre modifiable.

     IF ( p_mode = 'update'              AND
           p_annee > l_datdebex ) THEN

        --p_bud_rees := 'BUD_REES#<input type="hidden" name="BUD_RST" value="<% BUD_RST %>">';
       p_bud_rees := 'NON';

     ELSE

       --p_bud_rees := 'BUD_REES#<input type="text" size=15 maxlength=15 name="BUD_RST" value="<% BUD_RST %>"OnChange="return VerifierNum(this,13,0);">';
     --  p_bud_rees := '<html:text property="bud_rst" styleClass="input" size="1" maxlength="1" onchange="return VerifierNum(this,13,0);"/>';
	 p_bud_rees := 'OUI';
     END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      OPEN p_curGestbudg FOR
         SELECT lb.pid,
                lb.pnom,
                lb.astatut,
                TO_CHAR( lb.adatestatut, 'DD/MM/YYYY'),
                NVL(budg.annee,TO_NUMBER(p_annee)),
                DECODE( budg.bpmontme,
                                NULL,
                                ',00',
                                TO_CHAR(budg.bpmontme, 'FM9999999990D00')),
                DECODE( budg.bpmontmo,
                                NULL,
                                ',00',
                                TO_CHAR(budg.bpmontmo, 'FM9999999990D00')),
                DECODE( budg.bnmont,
                                NULL,
                                ',00',
                                TO_CHAR(budg.bnmont, 'FM9999999990D00')),
                DECODE( budg.anmont,
                                NULL,
                                ',00',
                                TO_CHAR(budg.anmont, 'FM9999999990D00')),
                DECODE( budg.reserve,
                                NULL,
                                ',00',
                                TO_CHAR( budg.reserve, 'FM9999999990D00')),
                DECODE( budg.reestime,
                        NULL,
                        '0',
                        DECODE(p_annee, TO_CHAR(DATDEBEX.DATDEBEX, 'YYYY'), TO_CHAR(budg.reestime), NULL)),
                NVL(budg.flaglock,-1)
         FROM   LIGNE_BIP                             lb,
                BUDGET budg,DATDEBEX
         WHERE  lb.pid       =   p_pid
          AND   lb.pid       =   budg.pid  (+)
	  AND   budg.annee (+)= TO_NUMBER(p_annee);

      -- Récupération des paramètres OUT

      p_annee_sav := SUBSTR( p_annee, 1, 4);


   -- p_annee_sav := 'ANNEE_SAISIE#' ||  SUBSTR(p_annee, 1, 4);

      -- en cas absence
      -- p_message := 'Identifiant ligne BIP inexistant';
      -- Ce message est utilisé comme message APPLICATIF et
      -- message d'exception. => Il porte un numéro d'EXCEPTION

      Pack_Global.recuperer_message( 20735, NULL, NULL, NULL, l_msg);
      p_message := l_msg;

   END ;

END Pack_Gestbudg;
/
CREATE OR REPLACE PACKAGE pack_global AS

   TYPE GlobalData IS RECORD( idarpege   VARCHAR2(255),
                              menutil    VARCHAR2(25),
                              codpole    VARCHAR2(25),
                              direction1 client_mo.clicode%TYPE,
                              filcode    filiale_cli.filcode%TYPE,
			      perime     VARCHAR2(255),
			      perimo     VARCHAR2(255),
			      codcfrais  NUMBER(3),
			      chefprojet VARCHAR2(600),
			      doss_proj	 VARCHAR2(255),
			      appli	 VARCHAR2(255),
			      projet	 VARCHAR2(255),
			      ca_fi	 VARCHAR2(255),
			      ca_payeur	 VARCHAR2(255),
			      sousmenus  VARCHAR2(255)
                             );

   FUNCTION lire_globaldata( p_string VARCHAR2) RETURN GlobalData;

   FUNCTION lire_perime		(p_global VARCHAR2) RETURN VARCHAR2;

   FUNCTION lire_perimo		(p_global VARCHAR2) RETURN VARCHAR2;

   FUNCTION lire_doss_proj	(p_global VARCHAR2) RETURN VARCHAR2;

   FUNCTION lire_appli		(p_global VARCHAR2) RETURN VARCHAR2;

   FUNCTION lire_projet		(p_global VARCHAR2) RETURN VARCHAR2;

   FUNCTION lire_ca_fi		(p_global VARCHAR2) RETURN VARCHAR2;

   FUNCTION lire_ca_payeur	(p_global VARCHAR2) RETURN VARCHAR2;


   FUNCTION verifier_habilitation ( p_global  IN VARCHAR2,
                                    p_codsg   IN VARCHAR2,
                                    p_libelle IN VARCHAR2,
                                    p_focus   IN VARCHAR2
                                  ) RETURN INTEGER;


   PROCEDURE recuperation_integrite ( p_code IN NUMBER );

   PROCEDURE recuperer_message( p_id_msg        IN NUMBER,
                                p_tag           IN VARCHAR2,
                                p_replace_value IN VARCHAR2,
				p_focus         IN VARCHAR2,
	                        p_msg           OUT VARCHAR2);

   PROCEDURE recuperer_message( p_id_msg         IN NUMBER,
                                p_tag1           IN VARCHAR2,
                                p_replace_value1 IN VARCHAR2,
                                p_tag2           IN VARCHAR2,
                                p_replace_value2 IN VARCHAR2,
				p_focus          IN VARCHAR2,
	                        p_msg            OUT VARCHAR2);

   PROCEDURE recuperer_message( p_id_msg         IN NUMBER,
                                p_tag1           IN VARCHAR2,
                                p_replace_value1 IN VARCHAR2,
                                p_tag2           IN VARCHAR2,
                                p_replace_value2 IN VARCHAR2,
                                p_tag3           IN VARCHAR2,
                                p_replace_value3 IN VARCHAR2,
				p_focus          IN VARCHAR2,
	                        p_msg            OUT VARCHAR2);

   -- Initialisation du fichier en sortie si existe alors REPLACE
   --                                     sinon CREATE

   PROCEDURE init_write_file ( p_dirname IN VARCHAR2,
                               p_filename IN VARCHAR2,
                               p_hfile OUT UTL_FILE.FILE_TYPE);

   -- Ecriture d'une chaine de caractère dans un fichier

   PROCEDURE write_string ( p_hfile IN UTL_FILE.FILE_TYPE,
                            p_string IN VARCHAR2);

   -- Fermeture du fichier

   PROCEDURE close_write_file ( p_hfile IN OUT UTL_FILE.FILE_TYPE);



END pack_global;
/

CREATE OR REPLACE PACKAGE BODY pack_global AS

   FUNCTION lire_globaldata( p_string VARCHAR2) RETURN GlobalData IS

      glob_rec  GlobalData;
      pos1   integer;
      pos2   integer;
      pos3   integer;
      pos4   integer;
      pos5   integer;
      pos6   integer;
      pos7   integer;
      pos8   integer;
      pos9   integer;
      pos10  integer;
      pos11  integer;
      pos12  integer;
      pos13  integer;
      pos14  integer;
      lgth   integer;

   BEGIN

      pos1 := INSTR( p_string, ';', 1, 1);

      pos2 := INSTR( p_string, ';', 1, 2);

      pos3 := INSTR( p_string, ';', 1, 3);

      pos4 := INSTR( p_string, ';', 1, 4);

      pos5 := INSTR( p_string, ';', 1, 5);

      pos6 := INSTR( p_string, ';', 1, 6);

      pos7 := INSTR( p_string, ';', 1, 7);

      pos8 := INSTR( p_string, ';', 1, 8);

      pos9 := INSTR( p_string, ';', 1, 9);

      pos10:= INSTR( p_string, ';', 1,10);

      pos11:= INSTR( p_string, ';', 1,11);

      pos12:= INSTR( p_string, ';', 1,12);

      pos13:= INSTR( p_string, ';', 1,13);

      pos14:= INSTR( p_string, ';', 1,14);

      lgth := LENGTH( p_string);


      	glob_rec.idarpege   	:= substr( p_string, 1, pos1-1);

      	glob_rec.menutil    	:= UPPER(substr( p_string, pos1+1, pos2-pos1-1));

      	glob_rec.direction1 	:= substr( p_string, pos2+1, pos3-pos2-1);

      	glob_rec.codpole    	:= substr( p_string, pos3+1, pos4-pos3-1);

      	glob_rec.filcode    	:= substr( p_string, pos4+1, pos5-pos4-1);

  	glob_rec.perime   	:= substr( p_string, pos5+1, pos6-pos5-1);

      	glob_rec.perimo   	:= substr( p_string, pos6+1, pos7-pos6-1);

      	glob_rec.codcfrais   	:= to_number(substr( p_string, pos7+1, pos8-pos7-1));

      	glob_rec.chefprojet   	:= substr( p_string, pos8+1, pos9-pos8-1);

	glob_rec.doss_proj   	:= substr( p_string, pos9+1, pos10-pos9-1);

	glob_rec.appli   	:= substr( p_string, pos10+1, pos11-pos10-1);

	glob_rec.projet   	:= substr( p_string, pos11+1, pos12-pos11-1);

	glob_rec.ca_fi   	:= substr( p_string, pos12+1, pos13-pos12-1);

      	glob_rec.ca_payeur   	:= substr( p_string, pos13+1, pos14-pos13-1);

      	glob_rec.sousmenus   	:= substr( p_string, pos14+1, lgth-pos14);

      RETURN glob_rec;

   END lire_globaldata;


   FUNCTION lire_perime(p_global VARCHAR2) RETURN VARCHAR2 IS
     BEGIN
   	RETURN pack_global.lire_globaldata(p_global).perime;
   END lire_perime;

   FUNCTION lire_perimo(p_global VARCHAR2) RETURN VARCHAR2 IS
     BEGIN
   	RETURN pack_global.lire_globaldata(p_global).perimo;
   END lire_perimo;

   FUNCTION lire_doss_proj(p_global VARCHAR2) RETURN VARCHAR2 IS
     BEGIN
   	RETURN pack_global.lire_globaldata(p_global).doss_proj;
   END lire_doss_proj;

   FUNCTION lire_appli(p_global VARCHAR2) RETURN VARCHAR2 IS
     BEGIN
   	RETURN pack_global.lire_globaldata(p_global).appli;
   END lire_appli;

   FUNCTION lire_projet(p_global VARCHAR2) RETURN VARCHAR2 IS
     BEGIN
   	RETURN pack_global.lire_globaldata(p_global).projet;
   END lire_projet;

   FUNCTION lire_ca_fi(p_global VARCHAR2) RETURN VARCHAR2 IS
     BEGIN
   	RETURN pack_global.lire_globaldata(p_global).ca_fi;
   END lire_ca_fi;

   FUNCTION lire_ca_payeur(p_global VARCHAR2) RETURN VARCHAR2 IS
     BEGIN
   	RETURN pack_global.lire_globaldata(p_global).ca_payeur;
   END lire_ca_payeur;

   FUNCTION verifier_habilitation ( p_global  IN VARCHAR2,
                                    p_codsg   IN VARCHAR2,
                                    p_libelle IN VARCHAR2,
                                    p_focus   IN VARCHAR2
                                  )
                              RETURN INTEGER IS
      msg VARCHAR(1024);
      l_codpole VARCHAR2(25);
      l_menutil VARCHAR2(255);

   BEGIN

      l_codpole := LPAD(pack_global.lire_globaldata( p_global).codpole, 7, '0');
      l_menutil := pack_global.lire_globaldata( p_global).menutil;

      IF l_codpole IS NULL THEN
         IF l_menutil != 'DIR' AND
            l_menutil != 'ME' THEN
            pack_global.recuperer_message( 20274, NULL, NULL, NULL, msg);
            raise_application_error( -20274, msg );
         END IF;
      END IF;

      IF ( SUBSTR( l_codpole, 1, 3) != SUBSTR(LPAD(p_codsg, 7, '0'), 1, 3)
           AND SUBSTR( l_codpole, 1, 3) != '000' ) THEN

         -- Departement invalide

         pack_global.recuperer_message( 20012, '%s1', p_libelle, '%s2',
                                        SUBSTR(l_codpole, 1, 3),
                                        p_focus, msg);
         raise_application_error( -20012, msg );
      END IF;

      IF ( SUBSTR( l_codpole, 4, 2) != SUBSTR(LPAD(p_codsg, 7, '0'), 4, 2)
           AND SUBSTR( l_codpole, 4, 2) != '00' ) THEN

         -- Pole invalide

         pack_global.recuperer_message( 20013, '%s1', p_libelle, '%s2',
                                        SUBSTR(l_codpole, 4, 2),
                                        p_focus, msg);
         raise_application_error( -20013, msg );
      END IF;

      RETURN 0;

      -- Ne pas intercepter les exceptions

   END verifier_habilitation;


   PROCEDURE recuperation_integrite ( p_code IN NUMBER ) IS
      msg VARCHAR(1024);
      temp CHAR(20);
      no_msg NUMBER(5);
      positionDebut PLS_INTEGER;
      positionFin PLS_INTEGER;
   BEGIN

      -- Recuperer le message complet

      msg := SQLERRM(p_code);

      -- Chercher le point qui separe le nom integrite du nom
      -- owner

      positionDebut := INSTR( msg , '.' );

      -- Chercher la parenthese fermante du nom integrite

      positionFin := INSTR( SUBSTR( msg, positionDebut + 1), ')');

      -- Recuperer la chaine situee entre le point et )

      temp := SUBSTR( msg, positionDebut + 1, positionFin - 1 );

      -- Decouper nomchamp_nomsg (constituant le nom integrite)

      IF (p_code = -2291) THEN
         no_msg := '20' ||
                   TO_NUMBER( SUBSTR( temp, INSTR( temp, '_' ) +1 ) + 600 );
      ELSE

       -- p_code = -2292

         no_msg := '20' ||
                   TO_NUMBER( SUBSTR( temp, INSTR( temp, '_' ) +1 ) + 750 );
      END IF;

      -- Recuperer le message erreur concatené avec le nom du champ
      -- en erreur (qui recevra le focus)

      pack_global.recuperer_message(no_msg, NULL, NULL,
                                    SUBSTR( temp, 1, INSTR(temp,'_' )-1),
                                    msg);
      raise_application_error( - no_msg, msg);

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            raise_application_error( - no_msg,
                                     'Message à définir :\t' || no_msg || '\n' ||
                                     'Contrainte :\t' || temp || '\n' ||
                                     'Type integrite :\t' || p_code || '\n' ||
                                     'FOCUS=' || SUBSTR( temp, 1, INSTR( temp, '_' ) - 1) );

         -- Ne pas intercepter les autres exceptions

   END recuperation_integrite;


   PROCEDURE recuperer_message( p_id_msg        IN NUMBER,
                                p_tag           IN VARCHAR2,
                                p_replace_value IN VARCHAR2,
 				p_focus         IN VARCHAR2,
	                        p_msg           OUT VARCHAR2
                              ) IS
      l_msgerr VARCHAR2(1024);
   BEGIN

   p_msg := NULL;
   l_msgerr := NULL;

   -- Récupération et enrichissement du message

      SELECT REPLACE( limsg, p_tag, p_replace_value) ||
             DECODE( p_focus, NULL,
                     NULL, 'FOCUS=' || p_focus)
      INTO   p_msg
      FROM   message
      WHERE  id_msg = p_id_msg;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         l_msgerr := 'Code message '    ||
                     TO_CHAR( p_id_msg) ||
                     ' inexistant' ;

         raise_application_error( -20998, l_msgerr);

      WHEN OTHERS THEN
         raise_application_error( -20998, SQLERRM);

   END recuperer_message;


   PROCEDURE recuperer_message( p_id_msg         IN NUMBER,
                                p_tag1           IN VARCHAR2,
                                p_replace_value1 IN VARCHAR2,
                                p_tag2           IN VARCHAR2,
                                p_replace_value2 IN VARCHAR2,
				p_focus          IN VARCHAR2,
	                        p_msg            OUT VARCHAR2
                              ) IS
      l_msgerr VARCHAR2(1024);
   BEGIN

   p_msg := NULL;
   l_msgerr := NULL;

   -- Récupération et enrichissement du message

      SELECT REPLACE( REPLACE( limsg, p_tag1, p_replace_value1),
                      p_tag2, p_replace_value2) ||
             DECODE( p_focus, NULL,
                     NULL, 'FOCUS=' || p_focus)
      INTO   p_msg
      FROM   message
      WHERE  id_msg = p_id_msg;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         l_msgerr := 'Code message '    ||
                     TO_CHAR( p_id_msg) ||
                     ' inexistant' ;

         raise_application_error( -20998, l_msgerr);

      WHEN OTHERS THEN
         raise_application_error( -20998, SQLERRM);

   END recuperer_message;

   PROCEDURE recuperer_message( p_id_msg         IN NUMBER,
                                p_tag1           IN VARCHAR2,
                                p_replace_value1 IN VARCHAR2,
                                p_tag2           IN VARCHAR2,
                                p_replace_value2 IN VARCHAR2,
                                p_tag3           IN VARCHAR2,
                                p_replace_value3 IN VARCHAR2,
				p_focus          IN VARCHAR2,
	                        p_msg            OUT VARCHAR2
                              ) IS
      l_msgerr VARCHAR2(1024);
   BEGIN

   p_msg := NULL;
   l_msgerr := NULL;

   -- Récupération et enrichissement du message

      SELECT REPLACE( REPLACE( REPLACE( limsg,
                                        p_tag1,
                                        p_replace_value1),
                               p_tag2,
                               p_replace_value2),
                       p_tag3,
                       p_replace_value3) ||
             DECODE( p_focus, NULL,
                     NULL, 'FOCUS=' || p_focus)
      INTO   p_msg
      FROM   message
      WHERE  id_msg = p_id_msg;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         l_msgerr := 'Code message '    ||
                     TO_CHAR( p_id_msg) ||
                     ' inexistant' ;

         raise_application_error( -20998, l_msgerr);

      WHEN OTHERS THEN
         raise_application_error( -20998, SQLERRM);

   END recuperer_message;


   -- Initialisation du fichier en sortie si existe alors REPLACE
   --                                     sinon CREATE

   PROCEDURE init_write_file ( p_dirname IN VARCHAR2,
                              p_filename IN VARCHAR2,
                              p_hfile OUT UTL_FILE.FILE_TYPE) IS

   l_msg VARCHAR2(1024);

   BEGIN

     -- nom de fichier vide interdit
     IF LENGTH( RTRIM(LTRIM(p_filename))) = 0 THEN
        pack_global.recuperer_message( 20402, NULL, NULL, NULL, l_msg);
        raise_application_error(-20402, l_msg);
     END IF;

     p_hfile := UTL_FILE.FOPEN(p_dirname, p_filename, 'w');

   EXCEPTION
     WHEN OTHERS THEN
       pack_global.recuperer_message( 20402, NULL, NULL, NULL, l_msg);
       -- raise_application_error( -20402, l_msg);
       raise_application_error( -20997, SQLERRM);

   END init_write_file;


   -- Ecriture d'une chaine de caractère dans un fichier


   PROCEDURE write_string ( p_hfile IN UTL_FILE.FILE_TYPE,
                            p_string IN VARCHAR2) IS

   l_msg VARCHAR2(1024);

   BEGIN
-- pour des lignes de longueur superieure a 1023 il faut le faire en deux fois
	IF (LENGTH(p_string)<1024) THEN
		UTL_FILE.PUT_LINE(p_hfile, p_string);
	ELSE
		UTL_FILE.PUT(p_hfile, SUBSTR(p_string, 1, 1000));
		UTL_FILE.PUT_LINE(p_hfile, SUBSTR(p_string, 1001));
	END IF;

   EXCEPTION
     WHEN OTHERS THEN
       pack_global.recuperer_message( 20402, NULL, NULL, NULL, l_msg);
       l_msg := l_msg || ' : Err. dans pack_global.Write_string';
       raise_application_error( -20997, SQLERRM);
   END write_string;


   -- Fermeture du fichier


   PROCEDURE close_write_file ( p_hfile IN OUT UTL_FILE.FILE_TYPE) IS

   l_msg VARCHAR2(1024);

   BEGIN
     UTL_FILE.FFLUSH(p_hfile);
     UTL_FILE.FCLOSE(p_hfile);

   EXCEPTION
     WHEN OTHERS THEN
       pack_global.recuperer_message( 20402, NULL, NULL, NULL, l_msg);
       -- raise_application_error( -20402, l_msg);
       raise_application_error( -20997, SQLERRM);

   END close_write_file;

END pack_global;
/
CREATE OR REPLACE PACKAGE pack_habilitation AS
-- **************************************************************************************
-- Nom 		: verif_habili_me
-- Auteur 	: NBM
-- Description 	: Vérifie si l'utilisateur est habilité au BDDPG
--		  en vérifiant d'abord l'existence du code DPG demandé
--		  ( pack_utile.f_verif_dpg(p_codsg)= true or false )
-- Paramètres 	: p_codsg (IN) code DPG demandé (16**** ou 1616** ou 161612 ou 16** )
--		  p_global (IN) contenant le code périmètre de l'utilisateur
-- Retour	: message d'erreur si non habilitation
--
-- **************************************************************************************
  PROCEDURE verif_habili_me ( p_codsg   IN VARCHAR2,
				 p_global  IN VARCHAR2,
				 p_message OUT VARCHAR2 );

-- **************************************************************************************
-- Nom 		:
-- Auteur 	: NBM
-- Description 	: Vérifie que le codsg appartient ou pas au périmètre de l'utilisateur
-- Paramètres 	: p_codsg (IN) code DPG demandé (161612 )
--		  p_global (IN) contenant le code périmètre de l'utilisateur
-- Retour	:  retourne 'vrai' si habilitation, 'faux' sinon
--
-- **************************************************************************************

  FUNCTION fhabili_me ( p_codsg   IN VARCHAR2,
			p_global  IN VARCHAR2) RETURN VARCHAR2;

 PROCEDURE select_verif_deppole_mens  (p_codsg     IN VARCHAR2,
                                  p_global    IN CHAR,
                                  p_libcodsg     OUT VARCHAR2,
                                  p_nbcurseur    OUT INTEGER,
                                  p_message      OUT VARCHAR2
                                 );
-- **************************************************************************************
-- Nom 		: fverif_habili_mo
-- Auteur 	: NCM
-- Description 	: Vérifie si l'utilisateur est habilité au département ou à la direction
--
-- Paramètres 	: p_codperimo (IN) code périmètre MO de l'utilisateur
--		  p_direction (IN) code direction ou département
-- Retour	: true si habilité, false sinon
--
-- **************************************************************************************
  FUNCTION  fverif_habili_mo( p_perimo IN VARCHAR2,
			      p_direction IN client_mo.clicode%TYPE
			  ) RETURN BOOLEAN;

-- **************************************************************************************
-- Nom 		: verif_perimetre
-- Auteur 	: MMC
-- Description 	: même chose que select_verif_deppole_mens mais on enlève lel contrôle dans
-- le cas ou l'utilisateur saisit *******
--
-- Paramètres 	: p_codsg (IN) code DPG demandé (16**** ou 1616** ou 161612 ou 16** )
--		  p_global (IN) contenant le code périmètre de l'utilisateur
-- Retour	: message d'erreur si non habilitation
--
-- **************************************************************************************
PROCEDURE verif_perimetre  (p_codsg     IN VARCHAR2,
                                  p_global    IN CHAR,
                                  p_libcodsg     OUT VARCHAR2,
                                  p_nbcurseur    OUT INTEGER,
                                  p_message      OUT VARCHAR2
                                 );


-- **************************************************************************************
-- Nom 		: verif_habili_dpg_appli
-- Auteur 	: JMA
-- Description 	: Vérifie si l'utilisateur est habilité au DPG
--		  en vérifiant d'abord l'existence du code DPG demandé
--		  ( pack_utile.f_verif_dpg(p_codsg)= true or false )
--		  et si le code application est dans le périmètre de l'utilisateur
-- Paramètres 	: p_codsg (IN) code DPG demandé (16**** ou 1616** ou 161612 ou 16** )
-- 				  p_airt (IN) code application
--		  		  p_global (IN) contenant le code périmètre de l'utilisateur
-- Retour	: message d'erreur si non habilitation
--
-- **************************************************************************************
  PROCEDURE verif_habili_dpg_appli ( p_codsg   IN VARCHAR2,
  								     p_airt    IN VARCHAR2,
				 					 p_global  IN VARCHAR2,
				 					 p_message OUT VARCHAR2 );

END pack_habilitation;
/

CREATE OR REPLACE PACKAGE BODY pack_habilitation AS
  PROCEDURE verif_habili_me( p_codsg   IN VARCHAR2,
				 p_global  IN VARCHAR2,
				 p_message OUT VARCHAR2 ) IS

 -- Création du curseur qui ramène tous les BDDPG du périmètre de l'utilisateur
 --  CURSOR cur_bddpg (p_perimetre IN number) IS
 --	select codbddpg, codhabili
 --	from detail_perimetre_me
 --	where codperime=p_perimetre
 --	order by codbddpg;

 -- Variables qui contiennent un BDDPG et le code d'habilitation
  codbddpg	VARCHAR2(25);
  codhabili	VARCHAR2(15);

  l_perimetre  	 varchar2(255);
  l_branche 	 varchar2(10);
  l_direction 	 varchar2(10);
  l_departement  varchar2(10);
  l_pole 	 varchar2(10);
  l_groupe 	 varchar2(10);
  c_branche 	 varchar2(10);
  c_direction 	 varchar2(10);
  c_departement  varchar2(10);
  c_pole 	 varchar2(10);
  c_groupe 	 varchar2(10);
  l_dpg          varchar2(10);
  l_habilitation varchar2(10);
  l_msg          varchar2(1024);
  l_saisi 	 varchar2(15);
  pos_bddpg	 integer;
  pos_bddpg_suiv integer;
  nb_bddpg	 integer;
  l_perimTermine boolean;

  BEGIN
	l_msg:=p_message ;
	l_msg:='';
	l_habilitation := 'faux';
  -- **************************************************************
  -- 1) Vérification de l'existence du code DPG demandé
  -- ***************************************************************

      IF (p_codsg!='*******' )  THEN
	If ( pack_utile.f_verif_dpg(LPAD(p_codsg, 7, '0'))= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);
     	End if;
     END IF;
  -- *********************************************************************************
  -- 2) Vérification de l'habilitation de l'utilisateur par rapport à son périmètre
  -- *********************************************************************************

	-- retrouver le périmètre me de l'utilisateur
	l_perimetre := pack_global.lire_globaldata(p_global).perime;


   	-- Remplacer les '*' du code DPG par des 0 et remet le code sur 7 caractères
	l_dpg := LPAD(REPLACE(p_codsg,'*','0'),7,'0');

	if substr(l_dpg,4,4)='0000' then --un département
		l_saisi :='dpt';
	else
		if substr(l_dpg,6,2)='00' then --un pôle
			l_saisi :='pole';
		else
			if l_dpg!='0000000' then --un groupe
				l_saisi :='groupe';
			else
				l_saisi :='all';
			end if;
		end if;
	end if;


	-- Retrouver la direction et la branche du code DPG
     IF (p_codsg!='*******' )  THEN
	BEGIN
	  select distinct lpad(d.codbr,2,0), lpad(d.coddir,2,0)
		into l_branche     , l_direction
	  from struct_info s, directions d
	  where ( s.codsg=to_number(l_dpg) or s.coddeppole=to_number(substr(l_dpg,1,5)) or s.coddep=to_number(substr(l_dpg,1,3)) )
	  and s.coddir=d.coddir
	  and s.topfer='O'
	  and rownum=1;


	  l_departement := l_branche||l_direction||SUBSTR(l_dpg,1,3);
	  l_pole 	:= SUBSTR(l_dpg,1,5);
	  l_groupe 	:= l_dpg;

--dbms_output.put_line(l_perimetre||', '||l_branche||', '||l_direction||', '||l_departement);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN   --'Le codsg n''est rattaché à aucune direction'
			pack_global.recuperer_message(20356,'%s1', 'codsg', NULL, l_msg);
              	 	raise_application_error(-20356,l_msg);
	END;
     END IF;

	-- On initialise les paramètrers de la boucle while comptant le nombre de BDDPG du périmètre
	pos_bddpg := 0;
	nb_bddpg := 0;
	pos_bddpg_suiv := 0;
	l_perimTermine := false;

	-- Test si perimetre ME est vide on ne va pas plus loin
	if (l_perimetre is null or trim(l_perimetre) = '') then
		l_perimTermine := true;
	end if ;


	-- Tant qu'il y a des bddpg dans le périmètre, on tourne.
	WHILE NOT (l_perimTermine) LOOP

	  --On met à jour les paramètres identifiant les BDDPG du périmètre ME.
	  pos_bddpg := pos_bddpg_suiv + 1;
	  nb_bddpg := nb_bddpg + 1;
	  pos_bddpg_suiv := INSTR(l_perimetre, ',', 1, nb_bddpg);

	  IF pos_bddpg_suiv = 0 THEN
	     l_perimTermine := true;
	  END IF;

	  --On met à jour le BDDPG courant
	  --Si c'est le dernier, on prend la longueur de chaîne du périmètre - la position de la virgule
	  --Sinon on prend la position du suivant - la position de l'actuel
	  IF l_perimTermine THEN
	     codbddpg := SUBSTR(l_perimetre, pos_bddpg, LENGTH(l_perimetre)-pos_bddpg + 1);
	  ELSE
	     codbddpg := SUBSTR(l_perimetre, pos_bddpg, pos_bddpg_suiv-pos_bddpg);
	  END IF;

	  -- On trouve le codhabili en fonction du format du BDDPG
	if codbddpg= '00000000000' then
	   codhabili :='all';
	else
	  if substr(codbddpg,3,9)='000000000' then --une branche
	  	codhabili :='br';
	  else
	     if substr(codbddpg,5,7)='0000000' then --une direction
	  	  codhabili :='dir';
	     else
		  if substr(codbddpg,8,4)='0000' then --un département
		  	codhabili :='dpt';
		  else
			if substr(codbddpg,10,2)='00' then --un pôle
				codhabili :='pole';
			else
				if substr(codbddpg,1,11) !='00000000000' then --un groupe
					codhabili :='tout';
				end if;
			end if;
		  end if;
	     end if;
	  end if;
	end if;

	  -- On récupère les différentes composantes du bddpg
 	  c_branche 	:= SUBSTR(codbddpg,1,2);          	--03
	  c_direction 	:= SUBSTR(codbddpg,3,2);		--14
	  c_departement := SUBSTR(codbddpg,1,7);		--0314016
	  c_pole 	:= SUBSTR(codbddpg,5,5);		--01616
	  c_groupe 	:= SUBSTR(codbddpg,5,7);		--0161612

	  --dbms_output.put_line(l_perimetre||', '||l_dpg||', '||c_branche||', '||c_direction||', '||c_departement||', '||c_pole||', '||c_groupe||', '||codhabili);

	  -- Cas où on veut tout (*******)
		if (l_saisi='all' and codhabili='all') then
	 		l_habilitation := 'vrai';
			exit;
		end if;

 	  -- ******************************************
          -- cas 1 : habilitation à toute la BIP
	  -- ******************************************
		if codhabili='all' then
			--dbms_output.put_line('Vous êtes habilité à toute la BIP  ');
			l_habilitation := 'vrai';

			exit;
		else
	  -- ******************************************
	  -- cas 2 : habilitation à toute une branche
	  -- ******************************************
		if codhabili='br' then
			if c_branche=l_branche then
			--dbms_output.put_line('Vous êtes habilité à toute la branche : '||l_branche);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation branche est  :'||c_branche||', et non : '||l_branche);

		else
	  -- ********************************************
	  -- cas 3 : habilitation à toute une direction
	  -- ********************************************
		if codhabili='dir' then
			if c_direction=l_direction then
			--dbms_output.put_line('Vous êtes habilité à toute la direction : '||l_direction);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation direction est : '||c_direction||', et non :'||l_direction);

		else
	  -- ********************************************
	  -- cas 4 : habilitation à tout un département
	  -- ********************************************
		if codhabili='dpt' then
			if c_departement=l_departement then
			--dbms_output.put_line('Vous êtes habilité à tout le departement : '||l_departement);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation département est '||c_departement||', et non :'||l_departement);

		else
 	  -- ********************************************
	  -- cas 5 : habilitation à tout un pole
	  -- ********************************************
		if codhabili='pole' then
			if c_pole=l_pole then
			--dbms_output.put_line('Vous êtes habilité à tout le pole : '||l_pole);
				l_habilitation := 'vrai';
				exit;
			/*else
			-- cas habilitation à un pole (0301000) avec un choix (030****)
				if (l_saisi='dpt' and substr(c_pole,1,2)=substr(l_pole,1,2)) then
					--dbms_output.put_line('Vous êtes habilité à tout le pole : '||l_pole);
					l_habilitation := 'vrai';
					exit;
				end if;*/
			end if;
		else
	  -- ********************************************
	  -- cas 6 : habilitation à un BDDPG complet
	  -- ********************************************

			if( c_groupe=l_groupe )then
				--dbms_output.put_line('Vous êtes habilité au groupe : '||l_groupe);
				l_habilitation := 'vrai';
				exit;
		  	end if;

	        end if;
		end if;
		end if;
		end if;
		end if;

	END LOOP;

	 --dbms_output.put_line(l_habilitation);
	If l_habilitation='faux' then
		if ( length(rtrim(p_codsg,'*'))=7 ) then
		-- Vous n'êtes pas habilité à ce groupe
			pack_global.recuperer_message(20329, NULL, NULL, NULL, l_msg);
               		raise_application_error(-20329,l_msg);
		else
		  if  ( length(rtrim(p_codsg,'*'))=5 ) then
		   -- Vous n'êtes pas habilité à ce pôle
		   	pack_global.recuperer_message(20328, NULL, NULL, NULL, l_msg);
               		raise_application_error(-20328,l_msg);
		  else
		     if  ( length(rtrim(p_codsg,'*'))=3) then
		     -- Vous n'êtes pas habilité à ce département
			pack_global.recuperer_message(20327, NULL, NULL, NULL, l_msg);
               		raise_application_error(-20327,l_msg);
		     else
		     -- Vous n'êtes pas habilité à toute la BIP
			pack_global.recuperer_message(20357, NULL, NULL, NULL, l_msg);
               		raise_application_error(-20357,l_msg);
		     end if;
		  end if;
		end if;
	End if;


  END verif_habili_me;
-------------------------------------------------------------------------------------------------------------------------
-- =====================================================================================================================
-------------------------------------------------------------------------------------------------------------------------
FUNCTION fhabili_me ( p_codsg   IN VARCHAR2,
			p_global  IN VARCHAR2) RETURN VARCHAR2 IS


  codbddpg	VARCHAR2(25);
  codhabili	VARCHAR2(15);

  l_coduser      varchar2(255);
  l_perimetre  	 varchar2(255);

  l_branche 	 varchar2(10);
  l_direction 	 varchar2(10);
  l_departement  varchar2(10);
  l_pole 	 varchar2(10);
  l_groupe 	 varchar2(10);
  c_branche 	 varchar2(10);
  c_direction 	 varchar2(10);
  c_departement  varchar2(10);
  c_pole 	 varchar2(10);
  c_groupe 	 varchar2(10);
  l_dpg          varchar2(10);
  l_habilitation varchar2(10);
  l_msg          varchar2(1024);

  pos_bddpg	 integer;
  pos_bddpg_suiv integer;
  nb_bddpg	 integer;
  l_perimTermine boolean;


  BEGIN

	l_msg:='';
	l_habilitation := 'faux';
  -- **************************************************************
  -- 1) Vérification de l'existence du code DPG demandé
  -- **************************************************************
	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu

		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               	raise_application_error(-20203,l_msg);
     	End if;

	-- Si on trouve des '*' dans le code DPG demandé - On sort
	 IF (INSTR(p_codsg,'*',1,1) > 0) then
		pack_global.recuperer_message(20385, NULL, NULL, NULL, l_msg);
               	raise_application_error(-20385,l_msg);
     	End if;

  -- *********************************************************************************
  -- 2) Vérification de l'habilitation de l'utilisateur par rapport à son périmètre
  -- *********************************************************************************
	-- retrouver le code périmètre de l'utilisateur
	l_perimetre := pack_global.lire_globaldata(p_global).perime;


	-- Retrouver la direction et la branche du code DPG
	BEGIN
	  select distinct d.codbr, d.coddir
		into l_branche     , l_direction
	  from struct_info s, directions d
	  where s.codsg=to_number(p_codsg)
	  and s.coddir=d.coddir;

	  l_departement := LPAD(l_branche,2,0)||LPAD(l_direction,2,0)||SUBSTR(LPAD(p_codsg,7,'0'),1,3);
	  l_pole 	:= SUBSTR(LPAD(p_codsg,7,'0'),1,5);
	  l_groupe 	:= LPAD(p_codsg,7,'0');

        --dbms_output.put_line(l_perimetre||', '||l_branche||', '||l_direction||', '||l_departement);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN   --'Le codsg n''est rattaché à aucune direction'
			pack_global.recuperer_message(20356,'%s1', 'codsg', NULL, l_msg);
              	 	raise_application_error(-20356,l_msg);
	END;


	-- On initialise les paramètrers de la boucle while comptant le nombre de BDDPG du périmètre
	pos_bddpg := 0;
	nb_bddpg := 0;
	pos_bddpg_suiv := 0;
	l_perimTermine := false;

	-- Test si perimetre ME est vide on ne va pas plus loin
	if (l_perimetre is null or trim(l_perimetre) = '') then
		l_perimTermine := true;
	end if ;

	-- Tant qu'il y a des bddpg dans le périmètre, on tourne.
	WHILE (NOT l_perimTermine) LOOP

	  --On met à jour les paramètres identifiant les BDDPG du périmètre ME.
	  pos_bddpg := pos_bddpg_suiv + 1;
	  nb_bddpg := nb_bddpg + 1;
	  pos_bddpg_suiv := INSTR(l_perimetre, ',', 1, nb_bddpg);

	  IF pos_bddpg_suiv = 0 THEN
	     l_perimTermine := true;
	  END IF;

	  --On met à jour le BDDPG courant
	  --Si c'est le dernier, on prend la longueur de chaîne du périmètre - la position de la virgule
	  --Sinon on prend la position du suivant - la position de l'actuel
	  IF l_perimTermine THEN
	     codbddpg := SUBSTR(l_perimetre, pos_bddpg, LENGTH(l_perimetre)-pos_bddpg + 1);
	  ELSE
	     codbddpg := SUBSTR(l_perimetre, pos_bddpg, pos_bddpg_suiv-pos_bddpg);
	  END IF;



	  -- On trouve le codhabili en fonction du format du BDDPG
	if codbddpg= '00000000000' then -- Toute la BIP
	   codhabili :='all';
	else
	  if substr(codbddpg,3,9)='000000000' then --une branche
	  	codhabili :='br';
	  else
	     if substr(codbddpg,5,7)='0000000' then --une direction
	  	  codhabili :='dir';
	     else
		  if substr(codbddpg,8,4)='0000' then --un département
		  	codhabili :='dpt';
		  else
			if substr(codbddpg,10,2)='00' then --un pôle
				codhabili :='pole';
			else
				if substr(codbddpg,1,11) !='00000000000' then --un groupe
					codhabili :='tout';
				end if;
			end if;
		  end if;
	     end if;
	  end if;
	end if;

	  -- On récupère les différentes composantes du bddpg
    	  c_branche 	:= SUBSTR(codbddpg,1,2);          	--03
	  c_direction 	:= SUBSTR(codbddpg,3,2);		--14
	  c_departement := SUBSTR(codbddpg,1,7);		--0314016
	  c_pole 	:= SUBSTR(codbddpg,5,5);		--01616
	  c_groupe 	:= SUBSTR(codbddpg,5,7);		--0161612

--dbms_output.put_line(l_perimetre||', '||l_dpg||', '||c_branche||', '||c_direction||', '||c_departement||', '||c_pole||', '||c_groupe);
 	  -- ******************************************
          -- cas 1 : habilitation à toute la BIP
	  -- ******************************************
		if codhabili='all' then
			--dbms_output.put_line('Vous êtes habilité à toute la BIP  ');
			l_habilitation := 'vrai';

			exit;
		else
	  -- ******************************************
	  -- cas 2 : habilitation à toute une branche
	  -- ******************************************
		if codhabili='br' then
			if to_number(c_branche) = to_number(l_branche) then
			--dbms_output.put_line('Vous êtes habilité à toute la branche : '||l_branche);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation branche est  :'||c_branche||', et non : '||l_branche);

		else
	  -- ********************************************
	  -- cas 3 : habilitation à toute une direction
	  -- ********************************************
		if codhabili='dir' then
			if to_number(c_direction) = to_number(l_direction) then
			--dbms_output.put_line('Vous êtes habilité à toute la direction : '||l_direction);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation direction est : '||c_direction||', et non :'||l_direction);

		else
	  -- ********************************************
	  -- cas 4 : habilitation à tout un département
	  -- ********************************************
		if codhabili='dpt' then
			if to_number(c_departement) = to_number(l_departement) then
			--dbms_output.put_line('Vous êtes habilité à tout le departement : '||l_departement);
				l_habilitation := 'vrai';
				exit;
			end if;
		--dbms_output.put_line('Votre habilitation département est '||c_departement||', et non :'||l_departement);

		else
 	  -- ********************************************
	  -- cas 5 : habilitation à tout un pole
	  -- ********************************************
		if codhabili='pole' then
			if to_number(c_pole) = to_number(l_pole) then
			--dbms_output.put_line('Vous êtes habilité à tout le pole : '||l_pole);
				l_habilitation := 'vrai';
				exit;
			end if;

		else
	  -- ********************************************
	  -- cas 6 : habilitation à un BDDPG complet
	  -- ********************************************

			if to_number(c_groupe) = to_number(l_groupe ) then
				--dbms_output.put_line('Vous êtes habilité au groupe : '||l_groupe);
				l_habilitation := 'vrai';
				exit;

			end if;
	                --dbms_output.put_line('Votre habilitation groupe est '||c_groupe||', et non :'||l_groupe);

	        end if;
		end if;
		end if;
		end if;
		end if;

	END LOOP;

	return (l_habilitation);
END fhabili_me;
-------------------------------------------------------------------------------------------------------------------------
-- =====================================================================================================================
-------------------------------------------------------------------------------------------------------------------------
 PROCEDURE select_verif_deppole_mens  (p_codsg     IN VARCHAR2,
                                  p_global    IN CHAR,
                                  p_libcodsg     OUT VARCHAR2,
                                  p_nbcurseur    OUT INTEGER,
                                  p_message      OUT VARCHAR2
                                 ) IS
      l_msg        VARCHAR2(512);
      l_libcodsg   VARCHAR2(100);
      l_pcoddp     VARCHAR2(10);
      l_coddep     CHAR(3);
      l_codpol     CHAR(2);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      l_pcoddp := LPAD(p_codsg, 7, '0');

      l_coddep := substr(LPAD(p_codsg, 7, '0'),1,3);
      l_codpol := substr(LPAD(p_codsg, 7, '0'),4,2);


      IF (INSTR(l_coddep,'*',1,1) > 0) OR (INSTR(l_coddep,' ',1,1) > 0 )
         THEN  -- Il y a * = Tous les dep : on ne verifie pas l'existence du dep/pole
               l_libcodsg := 'Tous les Dep.';
			l_libcodsg := 'Tout le périmètre';
         ELSE

               IF (LENGTH(l_codpol) IS NULL) OR (INSTR(l_codpol,'*',1,1) > 0) OR (INSTR(l_codpol,' ',1,1) > 0 )
                  THEN -- il y a * = Tous les pole, mais il faut verifier le dep
                     BEGIN
                        l_pcoddp := l_coddep || '__';
                        SELECT  sigdep INTO l_libcodsg   FROM struct_info
	                     WHERE TO_CHAR(coddeppole, 'FM00000') like l_pcoddp AND ROWNUM <= 1;
                     EXCEPTION
                        WHEN OTHERS THEN -- Msg Code  Dep/Pole inconnu
                           pack_global.recuperer_message(20135, NULL, NULL, NULL, l_msg);
                           raise_application_error(-20135,l_msg);
                     END;
                  ELSE  -- il y a DEP et POLE , verifions !
		     IF substr(p_codsg,6,2)='**' THEN
                     	BEGIN
                        	l_pcoddp := substr(LPAD(p_codsg, 7 , '0'),1,5) ;
                        	SELECT  sigdep || '/' || sigpole INTO l_libcodsg   FROM struct_info
	                     	WHERE TO_CHAR(coddeppole, 'FM00000') = l_pcoddp AND ROWNUM <= 1;
                     	EXCEPTION
                        	WHEN OTHERS THEN -- Msg Code  Dep/Pole inconnu
                           	pack_global.recuperer_message(20135, NULL, NULL, NULL, l_msg);
                           	raise_application_error(-20135,l_msg);
                     	END;
		    ELSE
			BEGIN
				SELECT libdsg INTO l_libcodsg   FROM struct_info
				WHERE codsg = to_number(p_codsg) AND ROWNUM <= 1;
                     	EXCEPTION
                        	WHEN OTHERS THEN -- Msg Code  Dep/Pole inconnu
                           	pack_global.recuperer_message(20135, NULL, NULL, NULL, l_msg);
                           	raise_application_error(-20135,l_msg);

			END;
		    END IF;
               END IF;

      END IF;

      -- ================================================================================
      -- OK le deppole existe : Verifier l'habilitation dep pole de l'utilisateur
      -- ================================================================================

      -- ====================================================================
      -- 12/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
	-- 18/03/2002 MMC : on ne fait plus de verification sur l'appartenance
	-- du DPG au perimetre utilisateur. Ce controle s'effectue au niveau des
	-- etats, ce qui permet de lancer directement 1 etat avec tout le perimetre
	-- d'un utilisateur. (fiche 362)
         -- PLUS VRAI !!
       -- ==============================================================
   	pack_habilitation.verif_habili_me(  p_codsg,p_global,l_msg  );

         p_libcodsg := 'LIBCODSG#' || l_libcodsg ;


   -- var vmsg varchar2(100)
   -- var p6   varchar2(50)
   -- exec pack_utile3A.verif_deppole_mens('15','IT5C530;;;;01;',:p6,:vmsg)

   END select_verif_deppole_mens;
-------------------------------------------------------------------------------------------------------------------------
-- =====================================================================================================================
-------------------------------------------------------------------------------------------------------------------------
 FUNCTION fverif_habili_mo( p_perimo IN VARCHAR2,
			     p_direction IN client_mo.clicode%TYPE )
				RETURN BOOLEAN IS
  l_exist number;
  l_dir varchar2(15);
  l_msg varchar2(1024);
  l_habilitation varchar2(10);

  l_bdclicode 	    VARCHAR2(10);
  l_branches 	    VARCHAR2(50);
  l_directions	    VARCHAR2(50);
  l_clicodes 	    VARCHAR2(255);
  nb_bdclicodes	    INTEGER;
  pos_bdclicode	    INTEGER;
  pos_bdclicode_suiv INTEGER;

  BEGIN

	-- Existence de la direction
 	BEGIN

		select 1 into l_exist
		from client_mo
		where  rtrim(ltrim(clicode))=rtrim(ltrim(p_direction));

     	EXCEPTION
	WHEN NO_DATA_FOUND THEN -- Direction inexistante
	 	pack_global.recuperer_message( 20505, '%s1', p_direction, NULL, l_msg);
         	raise_application_error( -20505, l_msg );
     	END;

	-- Appartenance de la direction ou départment au périmètre MO choisi
	BEGIN

	  	--On met toutes les branches globales(la branche suivie de '0000000') dans l_branches
	  	-- Les directions globales (la direction suivie de '00000') dans l_dir
	  	--et la liste des clicodes du périmètre dans l_clicodes
	  	-- On initialise les paramètrers de la boucle while comptant le nombre de bdclicode du périmètre
		pos_bdclicode := 1;
		nb_bdclicodes := 1;
		pos_bdclicode_suiv := INSTR(p_perimo, ',', 1, nb_bdclicodes);
		l_branches := '';
		l_directions := '';
		l_clicodes := '';

		-- Tant qu'il y a des clicodes dans le périmètre, on boucle.
		WHILE (pos_bdclicode_suiv!=0) LOOP

		    --On met à jour le CLICODE courant
		    l_bdclicode := SUBSTR(p_perimo, pos_bdclicode, pos_bdclicode_suiv - pos_bdclicode);

		    IF SUBSTR(l_bdclicode,3,7) = '0000000' THEN
		       l_branches := l_branches || SUBSTR(l_bdclicode,1,2)||',';
		    ELSIF SUBSTR(l_bdclicode,5,5) = '00000' THEN
		       l_directions := l_directions || SUBSTR(l_bdclicode,3,2)||',';
		    ELSE
		       l_clicodes := l_clicodes || SUBSTR(l_bdclicode,5,5)||',';
		    END IF;

		    --On met à jour les paramètres identifiant les clicodes du périmètre MO.
		    pos_bdclicode := pos_bdclicode_suiv +1;
		    nb_bdclicodes := nb_bdclicodes + 1;
		    pos_bdclicode_suiv := INSTR(p_perimo, ',', 1, nb_bdclicodes);

	  	END LOOP;

		-- On gère le dernier code
		--On met à jour le dernier CLICODE
		l_bdclicode := SUBSTR(p_perimo, pos_bdclicode, LENGTH(p_perimo) - pos_bdclicode + 1);

		IF SUBSTR(l_bdclicode,3,7) = '0000000' THEN
		   l_branches := l_branches || SUBSTR(l_bdclicode,1,2)||',';
		ELSIF SUBSTR(l_bdclicode,5,5) = '00000' THEN
		   l_directions := l_directions || SUBSTR(l_bdclicode,3,2)||',';
		ELSE
		   l_clicodes := l_clicodes || SUBSTR(l_bdclicode,5,5)||',';
		END IF;

		--On séléctionne les clicodes pour lesquels
		--Le clicode est égal au clicode demandé(p_direction)
		--Et pour lesquels, l'utilisateur est habilité

--		select clicode into l_dir
--		from client_mo cmo, directions d
--		where cmo.clidir=d.coddir
--		  and (cmo.clicode = p_direction)
--		  and ((INSTR(l_clicodes, LPAD(RTRIM(LTRIM(cmo.clicode)), 5, '0')) > 0)
--		      or (INSTR(l_directions, LPAD(TO_CHAR(cmo.clidir),2,'0')) > 0)
--		      or (INSTR(l_branches, LPAD(TO_CHAR(d.codbr),2,'0')) > 0))
--		  and rownum < 2;
		select
			clicode into l_dir
		from
			vue_clicode_perimo cmo
		where
			cmo.clicode = p_direction
		and INSTR(p_perimo, cmo.bdclicode) > 0
		and rownum < 2;



	EXCEPTION
	WHEN NO_DATA_FOUND THEN -- La direction ne fait pas partie du périmètre choisi
	 	return (false);
     	END;

	return (true);

 END fverif_habili_mo;

 -- ==================================================================================
 -- verif_perimetre
 -- procedure pour verifier les habilitations de l'utilisateur
 -- si ****** : pas de contrôle, c'est dans l'état que l'on prendra tout son périmètre
 -- ==================================================================================

PROCEDURE verif_perimetre (p_codsg     IN VARCHAR2,
                                  p_global    IN CHAR,
                                  p_libcodsg     OUT VARCHAR2,
                                  p_nbcurseur    OUT INTEGER,
                                  p_message      OUT VARCHAR2
                                 ) IS
      l_msg        VARCHAR2(512);
      l_libcodsg   VARCHAR2(100);
      l_pcoddp     VARCHAR2(10);
      l_coddep     CHAR(3);
      l_codpol     CHAR(2);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      l_pcoddp := LPAD(p_codsg, 7, '0');

      l_coddep := substr(LPAD(p_codsg, 7, '0'),1,3);
      l_codpol := substr(LPAD(p_codsg, 7, '0'),4,2);


      IF (INSTR(l_coddep,'*',1,1) > 0) OR (INSTR(l_coddep,' ',1,1) > 0 )
         THEN  -- Il y a * = Tous les dep : on ne verifie pas l'existence du dep/pole
                l_libcodsg := 'Tous les Dep.';
		l_libcodsg := 'Tout le périmètre';
         ELSE

               IF (LENGTH(l_codpol) IS NULL) OR (INSTR(l_codpol,'*',1,1) > 0) OR (INSTR(l_codpol,' ',1,1) > 0 )
                  THEN -- il y a * = Tous les pole, mais il faut verifier le dep
                     BEGIN
                        l_pcoddp := l_coddep || '__';
                        SELECT  sigdep INTO l_libcodsg   FROM struct_info
	                     WHERE TO_CHAR(coddeppole, 'FM00000') like l_pcoddp AND ROWNUM <= 1;
                     EXCEPTION
                        WHEN OTHERS THEN -- Msg Code  Dep/Pole inconnu
                           pack_global.recuperer_message(20135, NULL, NULL, NULL, l_msg);
                           raise_application_error(-20135,l_msg);
                     END;
                  ELSE  -- il y a DEP et POLE , verifions !
		     IF substr(p_codsg,6,2)='**' THEN
                     	BEGIN
                        	l_pcoddp := substr(LPAD(p_codsg, 7 , '0'),1,5) ;
                        	SELECT  sigdep || '/' || sigpole INTO l_libcodsg   FROM struct_info
	                     	WHERE TO_CHAR(coddeppole, 'FM00000') = l_pcoddp AND ROWNUM <= 1;
                     	EXCEPTION
                        	WHEN OTHERS THEN -- Msg Code  Dep/Pole inconnu
                           	pack_global.recuperer_message(20135, NULL, NULL, NULL, l_msg);
                           	raise_application_error(-20135,l_msg);
                     	END;
		    ELSE
			BEGIN
				SELECT libdsg INTO l_libcodsg   FROM struct_info
				WHERE codsg = to_number(p_codsg) AND ROWNUM <= 1;
                     	EXCEPTION
                        	WHEN OTHERS THEN -- Msg Code  Dep/Pole inconnu
                           	pack_global.recuperer_message(20135, NULL, NULL, NULL, l_msg);
                           	raise_application_error(-20135,l_msg);

			END;
		    END IF;
               END IF;
   END IF;


      -- ==============================================================
      -- Test appartenance du DPG au périmètre de l'utilisateur
      -- ==============================================================
      IF (p_codsg!='*******' )  THEN
   	pack_habilitation.verif_habili_me(  p_codsg,p_global,l_msg  );
      END IF;

         p_libcodsg := 'LIBCODSG#' || l_libcodsg ;

   END verif_perimetre;





PROCEDURE verif_habili_dpg_appli( p_codsg   IN VARCHAR2,
		  						  p_airt    IN VARCHAR2,
								  p_global  IN VARCHAR2,
				 				  p_message OUT VARCHAR2 ) IS
	l_msg          varchar2(1024);
	appli_codsg	   application.codsg%type;
BEGIN
	if ( (p_codsg is not null) and (length(p_codsg)>0) ) Then
	   verif_habili_me(p_codsg, p_global, l_msg);
	end if;

	if ( (p_airt is not null) and (length(p_airt)>0) ) Then
	    BEGIN
	        select codsg
	          into appli_codsg
		      from application
		     where airt = p_airt;

	   		verif_habili_me(appli_codsg, p_global, l_msg);

		EXCEPTION
		    WHEN NO_DATA_FOUND then
               	pack_global.recuperer_message(20733, NULL, NULL, NULL, l_msg);
               	raise_application_error(-20733,l_msg);
		    WHEN OTHERS then
               	pack_global.recuperer_message(20997, NULL, NULL, NULL, l_msg);
               	raise_application_error(-20997,l_msg);
		END;
	end if;
END verif_habili_dpg_appli;
-------------------------------------------------------------------------------------------------------------------------
-- =====================================================================================================================
-------------------------------------------------------------------------------------------------------------------------

END pack_habilitation;
/
CREATE OR REPLACE PACKAGE pack_hab_historique AS
-- ------------------------------------------------------------------------
--
-- Nom        : verif_prodeta
-- Auteur     : Olivier Duprey
-- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
-- Paramètres :
--		p_mois_annee	IN		Mois et Année traitée
--		p_pid		IN		Code ligne bip
--		p_global	IN		informations globales sur la connexion
--		p_nom_schema	OUT
--		p_message	OUT		Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------
	PROCEDURE verif_prodeta(
   		p_mois_annee	IN	VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
		p_pid		IN	VARCHAR2,		-- VARCHAR2(4)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	);



-- ------------------------------------------------------------------------
--
-- Nom         : verif_prohist
-- Auteur      : Olivier Duprey
-- Description : Vérification des paramètres saisis pour l'etat $PROHIST
-- Paramètres  :
--              p_mois_annee   IN		Mois et Année traitée
--              p_factpid      IN		Code ligne bip
--		p_global       IN		informations globales sur la connexion
--              p_nom_schema  OUT
--              p_message     OUT		Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------
PROCEDURE verif_prohist(
   		p_mois_annee	IN	VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
		p_factpid	IN	VARCHAR2,		-- CHAR(3)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	);



-- ------------------------------------------------------------------------
--
-- Nom        : verif_reshist
-- Auteur     : Olivier Duprey
-- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
-- Paramètres :
--              p_mois_annee   IN		Mois et Année traitée
--              p_coderess     IN		Code ressource
--		p_global       IN		informations globales sur la connexion
--              p_nom_schema  OUT
--              p_message     OUT		Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------
	PROCEDURE verif_reshist(
		p_mois_annee	IN	VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
		p_coderess	IN	VARCHAR2,		-- CHAR(5)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	);




-- ------------------------------------------------------------------------
-- Nom        : verif_prodecl (Prend en compte le concept d'historique)
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des champs saisies dans la page WEB pour PRODECL
-- Paramètres :
--		p_nom_etat	IN	VARCHAR2,
--		p_mois_annee	IN	VARCHAR2,	-- CHAR(7) (Format MM/AAAA)
--		p_pid		IN	VARCHAR2,	-- CHAR(6)
--		p_global	IN	VARCHAR2,
--		p_nom_schema	OUT	VARCHAR2,
--		p_message	OUT	VARCHAR2
--
-- ------------------------------------------------------------------------
PROCEDURE verif_prodecl(
		p_nom_etat	IN	VARCHAR2,
		p_mois_annee	IN	VARCHAR2,	-- CHAR(7) (Format MM/AAAA)
		p_pid		IN	VARCHAR2,	-- CHAR(3)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	);



-- ------------------------------------------------------------------------
-- Nom        : verif_prodecl_MO (Prend en compte le concept d'historique)
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des champs saisies dans la page WEB pour PRODECL dans le menu Client
-- Paramètres :
--		p_nom_etat	IN	VARCHAR2,
--		p_mois_annee	IN	VARCHAR2,	-- CHAR(7) (Format MM/AAAA)
--		p_pid		IN	VARCHAR2,	-- VARCHAR2(4)
--		p_global	IN	VARCHAR2,
--		p_nom_schema	OUT	VARCHAR2,
--		p_message	OUT	VARCHAR2
--
-- ------------------------------------------------------------------------
PROCEDURE verif_prodecl_MO(
		p_nom_etat	IN	VARCHAR2,
		p_mois_annee	IN	VARCHAR2,	-- CHAR(7) (Format MM/AAAA)
		p_pid		IN	VARCHAR2,	-- VARCHAR2(4)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	);
END pack_hab_historique ;
/

CREATE OR REPLACE PACKAGE BODY pack_hab_historique AS

-------------------------------------------------------------------
--
------------------------------------------------------------------

-- ------------------------------------------------------------------------
--
-- Nom        : verif_PID_ME
-- Auteur     : O. Duprey
-- Decription : Vérification de presence de la ligne BIP dans le perimetre ME
--		de l'utilisateur
-- ------------------------------------------------------------------------
	FUNCTION verif_PID_ME(
		p_pid		IN	VARCHAR2,
		p_global	IN	VARCHAR2,
		p_focus		IN	VARCHAR2,
		p_message	OUT	VARCHAR2
	) RETURN BOOLEAN IS
		l_hab		BOOLEAN;
		l_dpg		situ_ress.codsg%TYPE;
		l_global	pack_global.GlobalData;
	BEGIN
		l_global:=pack_global.lire_globaldata(p_global);
		l_hab:=FALSE;
	   	BEGIN
	   		SELECT ligne_bip.codsg
	   			INTO l_dpg
	   			FROM ligne_bip
	   			WHERE ligne_bip.pid=p_pid
	   				AND ligne_bip.codsg IN (SELECT codsg
	   								FROM vue_dpg_perime
	   								WHERE INSTR(l_global.perime, vue_dpg_perime.codbddpg) > 0);
	   		l_hab:=TRUE;
	   	EXCEPTION
	   		WHEN no_data_found THEN
	   			l_hab:=FALSE;
	   		WHEN OTHERS THEN
	   			RAISE;
	   	END;

	   	IF NOT(l_hab) THEN
			pack_global.recuperer_message(20201, '%s1', p_pid , p_focus, p_message);
	   		RETURN FALSE;
	   	END IF;
	   	RETURN TRUE;
	END verif_PID_ME;

-- ------------------------------------------------------------------------
--
-- Nom        : verif_PID_ME
-- Auteur     : O. Duprey
-- Decription : Vérification de presence de la ligne BIP dans le perimetre ME
--		de l'utilisateur
-- ------------------------------------------------------------------------
	FUNCTION verif_PID_MO(
		p_pid		IN	VARCHAR2,
		p_global	IN	VARCHAR2,
		p_focus		IN	VARCHAR2,
		p_message	OUT	VARCHAR2
	) RETURN BOOLEAN IS
		l_hab		BOOLEAN;
		l_clicode	ligne_bip.clicode%TYPE;
		l_global	pack_global.GlobalData;
	BEGIN
		l_global:=pack_global.lire_globaldata(p_global);
		l_hab:=FALSE;
	   	BEGIN
	   		SELECT ligne_bip.clicode
	   			INTO l_clicode
	   			FROM ligne_bip
	   			WHERE ligne_bip.pid=p_pid
	   				AND ligne_bip.clicode IN (SELECT clicode
	   								FROM vue_clicode_perimo
	   								WHERE INSTR(l_global.perimo, vue_clicode_perimo.bdclicode) > 0);
	   		l_hab:=TRUE;
	   	EXCEPTION
	   		WHEN no_data_found THEN
	   			l_hab:=FALSE;
	   		WHEN OTHERS THEN
	   			RAISE;
	   	END;

	   	IF NOT(l_hab) THEN
			pack_global.recuperer_message(20201, '%s1', p_pid , p_focus, p_message);
	   		RETURN FALSE;
	   	END IF;
	   	RETURN TRUE;
	END verif_PID_MO;

-- ------------------------------------------------------------------------
--
-- Nom        : verif_prodeta
-- Auteur     : O. Duprey
-- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
--		avec controle des habilitations
-- ------------------------------------------------------------------------

	PROCEDURE verif_prodeta(
   		p_mois_annee	IN	VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
		p_pid		IN	VARCHAR2,		-- VARCHAR2(4)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	) IS
	BEGIN
	IF (p_pid <> 'Tout') THEN
	---------------------------------------------------------------------------------------------
	-- (1) Vérification des habilitations
	---------------------------------------------------------------------------------------------
	IF NOT verif_PID_ME(p_pid, p_global, 'P_param8', p_message) THEN
		RETURN;
	END IF;
	END IF;
	---------------------------------------------------------------------------------------------
	-- (2) Vérifications autres
	---------------------------------------------------------------------------------------------
	pack_historique.verif_prodeta(p_mois_annee, '', p_pid, p_nom_schema, p_message);

   END verif_prodeta;



-- ------------------------------------------------------------------------
--
-- Nom        : verif_prohist
-- Auteur     : Olivier Duprey
-- Decription : Vérification des paramètres saisis pour l'etat $PROHIST
-- ------------------------------------------------------------------------
	PROCEDURE verif_prohist(
   		p_mois_annee	IN	VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
		p_factpid	IN	VARCHAR2,		-- VARCHAR2(4)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	) IS
	BEGIN
		IF (p_factpid <> 'Tout') THEN
-- controle d'habilitation : la ligne BIP fait-elle partie du perimetre de l'utilisateur ?
		IF NOT verif_PID_ME(p_factpid, p_global, 'P_param8', p_message) THEN
			RETURN;
		END IF;
	END IF;

-- appel de la PROCEDURE standard historiue sans habilitation
		pack_historique.verif_prohist(p_mois_annee, '', p_factpid, p_nom_schema, p_message);

   END verif_prohist;



-- ------------------------------------------------------------------------
-- Nom        : verif_reshist
-- Auteur     : Olivier Duprey
-- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
--		avec controle d'habilitations
-- ------------------------------------------------------------------------

	PROCEDURE verif_reshist(
		p_mois_annee	IN  VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
		p_coderess	IN  VARCHAR2,		-- CHAR(5)
		p_global	IN  VARCHAR2,
		p_nom_schema	OUT  VARCHAR2,
		p_message	OUT  VARCHAR2
	) IS
		l_hab		BOOLEAN;
		l_dpg		situ_ress.codsg%TYPE;
		l_global	pack_global.GlobalData;
	   BEGIN
---------------------------------------------------------------------------------------------
-- (1) Vérification habilitation
-- On verifie que le ressource a la date de l'histo avait une situation dans le
-- perimetre ME du demandeur.
---------------------------------------------------------------------------------------------
		l_global:=pack_global.lire_globaldata(p_global);
		l_hab:=FALSE;
		IF (p_coderess <> 'Toute') THEN
	   	BEGIN
	   		SELECT situ_ress.codsg
	   			INTO l_dpg
	   			FROM situ_ress
	   			WHERE situ_ress.datsitu<=TO_DATE(p_mois_annee, 'mm/yyyy')
	   				AND ( situ_ress.datdep IS NULL OR situ_ress.datdep>=TO_DATE(p_mois_annee, 'mm/yyyy') )
	   				AND situ_ress.ident=p_coderess
	   				AND situ_ress.codsg IN (SELECT codsg
	   								FROM vue_dpg_perime
	   								WHERE INSTR(l_global.perime, vue_dpg_perime.codbddpg) > 0);
	   		l_hab:=TRUE;
	   	EXCEPTION
	   		WHEN no_data_found THEN
	   			l_hab:=FALSE;
	   		WHEN OTHERS THEN
	   			RAISE;
	   	END;

	   	IF NOT(l_hab) THEN
			pack_global.recuperer_message(20270, '%s1', p_coderess , 'P_param8', p_message);
	   		RETURN;
	   	END IF;
		END IF;
---------------------------------------------------------------------------------------------
-- (2) Autres controles
-- ON fait appel a la procedure standard des historiques sans habilitations
---------------------------------------------------------------------------------------------
	pack_historique.verif_reshist(p_mois_annee, '', p_coderess, p_nom_schema, p_message);



	EXCEPTION
		WHEN OTHERS THEN
			raise_application_error(-20997, SQLERRM);
	END verif_reshist;


-- ------------------------------------------------------------------------
-- Nom        : verif_prodecl (Prend en compte le concept d'historique)
-- Auteur     : Olivier Duprey
-- Decription : Vérification des champs saisies dans la page WEB pour PRODECL
--		avec controle des habilitations
-- ------------------------------------------------------------------------
	PROCEDURE verif_prodecl(
		p_nom_etat	IN	VARCHAR2,
		p_mois_annee	IN	VARCHAR2,	-- CHAR(7) (Format MM/AAAA)
		p_pid		IN	VARCHAR2,	-- VARCHAR2(4)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	) IS
	BEGIN
-- controle d'habilitation
	IF p_pid <> 'Tout' THEN
		IF NOT verif_PID_ME(p_pid, p_global, 'P_param9', p_message) THEN
			RETURN;
		END IF;
	END IF;

-- controles autres
		pack_historique.verif_prodecl(p_nom_etat, p_mois_annee, '', p_pid, p_nom_schema, p_message);
	END verif_prodecl;


-- ------------------------------------------------------------------------
-- Nom        : verif_prodecl_MO (Prend en compte le concept d'historique)
-- Auteur     : Olivier Duprey
-- Decription : Vérification des champs saisies dans la page WEB pour PRODECL
--		avec controle des habilitations pour CNSLMENU
-- ------------------------------------------------------------------------
	PROCEDURE verif_prodecl_MO(
		p_nom_etat	IN	VARCHAR2,
		p_mois_annee	IN	VARCHAR2,	-- CHAR(7) (Format MM/AAAA)
		p_pid		IN	VARCHAR2,	-- VARCHAR2(4)
		p_global	IN	VARCHAR2,
		p_nom_schema	OUT	VARCHAR2,
		p_message	OUT	VARCHAR2
	) IS
	BEGIN
-- controle d'habilitation
		IF NOT verif_PID_MO(p_pid, p_global, 'P_param9', p_message) THEN
			RETURN;
		END IF;
-- controles autres
		pack_historique.verif_prodecl(p_nom_etat, p_mois_annee, '', p_pid, p_nom_schema, p_message);
	END verif_prodecl_MO;
END pack_hab_historique ;
/
CREATE OR REPLACE PACKAGE     pack_hab_ref AS


FUNCTION Delete_Donnees (P_numseq IN NUMBER)
RETURN BOOLEAN;

FUNCTION Select_Donnees (p_param7  IN VARCHAR2, 	-- Dossier projet demandé
			p_codcamo IN VARCHAR2, 	-- Centre d'activité demandé
			p_dos_proj IN VARCHAR2, -- Dossiers projets habilités dans le RTFE
			p_projet IN VARCHAR2, 	-- Projets habilités dans le RTFE
			p_app IN VARCHAR2)	-- Applications habilitées dans le RTFE
RETURN NUMBER ;

END pack_hab_ref;
/

CREATE OR REPLACE PACKAGE BODY     pack_hab_ref AS


-- -------------------------------------------------------------------------
-- FUNCTION Delete_Donnees
-- Role : Supprime, dans la table TMP_SYNTHCOUTPROJ, les données creees par la
-- fonction Select_Donnees A la fin de l'édition.
-- -------------------------------------------------------------------------

FUNCTION Delete_Donnees (
			 P_numseq IN NUMBER
                         ) RETURN BOOLEAN IS
BEGIN
   DELETE FROM TMP_SYNTHCOUTPROJ
   WHERE  numseq = p_numseq;
   COMMIT;
   RETURN TRUE;
EXCEPTION
      WHEN OTHERS THEN RETURN(FALSE); -- NOK
END Delete_Donnees;

-- -------------------------------------------------------------------------
-- FUNCTION Select_Donnees
-- -------------------------------------------------------------------------
FUNCTION Select_Donnees (
			p_param7  IN VARCHAR2, 	-- Dossier projet demandé
			p_codcamo IN VARCHAR2, 	-- Centre d'activité demandé
			p_dos_proj IN VARCHAR2, -- Dossiers projets habilités dans le RTFE
			p_projet IN VARCHAR2, 	-- Projets habilités dans le RTFE
			p_app IN VARCHAR2 	-- Applications habilitées dans le RTFE
                        ) RETURN NUMBER IS

   l_annee0  NUMBER(4);
   l_msg  VARCHAR2(1024);

   l_where  VARCHAR2(1024); -- Chaine pour constituer la requete
   l_where_ca  VARCHAR2(200);-- Chaine pour constituer la clause where sur les CA

   -- Données ramenées par les curseurs
   l_clicode client_mo.clicode%TYPE;
   l_clisigle client_mo.clisigle%TYPE;
   l_typedp type_dossier_projet.typdp%TYPE;
   l_codcamo ligne_investissement.codcamo%TYPE;
   l_annee  NUMBER(4);
   l_dpcode ligne_investissement.dpcode%TYPE;
   l_libdp dossier_projet.dplib%TYPE;
   l_filcode centre_activite.filcode%TYPE;
   l_conso tmp_synthcoutproj.conso%TYPE;

   l_numseq         NUMBER ; -- numéro de séquence identifiant l'edition en cours

   -- Données pour la clause where sur Dossier Projet,Projet,Application
   l_doss_proj VARCHAR2(200);
   l_projet VARCHAR2(200);
   l_application VARCHAR2(200);
   l_hab VARCHAR2(500);
   l_tous VARCHAR2(10);

   l_test 	CHAR(1) ; -- utilisée dans un test d'existance

   TYPE RefCurTyp IS REF CURSOR;
   c_ligne_inv RefCurTyp; -- déclaration du cursor sur les investissements
   c_ligne_bip RefCurTyp; -- déclaration du cursor sur les lignes BIP

BEGIN
	-- p_msg := '';
	SELECT TO_NUMBER( TO_CHAR( datdebex, 'YYYY') )
	INTO l_annee0
	FROM datdebex;

	-- Définition de la requete
	l_where := 'select distinct cli.clicode CLICODE,'
		|| 'cli.clisigle CLISIGLE,'
		|| 'typedp.typdp TYPEDP,'
		|| 'l_inv.CODCAMO CODCAMO,'
	 	|| 'l_inv.ANNEE  ANNEE,'
	        || 'l_inv.dpcode DPCODE,'
	        || 'dp.dplib     LIBDP,'
	        || 'ca.filcode FILCODE';
	l_where := l_where || ' FROM centre_activite ca,'
	 	|| 'client_mo cli,'
	     	|| 'ligne_investissement l_inv,'
	 	|| 'investissements inv,'
	 	|| 'dossier_projet dp,'
	        || 'type_dossier_projet typedp';
	l_where := l_where ||' WHERE inv.codtype = l_inv.type'
		|| ' AND dp.dpcode=l_inv.dpcode'
		|| ' AND dp.typdp=typedp.typdp'
		|| ' AND ca.codcamo=l_inv.codcamo'
		|| ' AND cli.clidep <> 0'
		|| ' AND cli.clipol=0'
		|| ' AND (ca.codcamo=cli.codcamo'
	     	|| ' or ca.caniv1=cli.codcamo'
	     	|| ' or ca.caniv2=cli.codcamo'
	     	|| ' or ca.caniv3=cli.codcamo'
	     	|| ' or ca.caniv4=cli.codcamo)'
	    	|| ' AND l_inv.annee='|| l_annee0 ;

	l_where_ca := ' ';

	-- CENTRE ACTIVITE
  	if(p_codcamo IS NOT NULL and p_codcamo<> 'TOUS' ) THEN
	   	l_where_ca := ' and (ca.CODCAMO IN (' || p_codcamo
	   	||') or ca.CANIV1 IN (' || p_codcamo
	   	||') or ca.CANIV2 IN (' || p_codcamo
	   	||') or ca.CANIV3 IN (' || p_codcamo
	   	||') or ca.CANIV4 IN (' || p_codcamo ||')) ';
	end if ;

	l_hab := ' ';

	-- DOSSIER PROJET
    -- Dossier Projet demandé
  	if(p_param7 IS NOT NULL and p_param7 <> 'TOUS') THEN
	  	l_hab := ' and l_inv.DPCODE IN (' ||p_param7 ||') ';
	else
	 	-- Si il n'y a aucun critère passe - construit à partir des données du RTFE
 	  	if(p_dos_proj IS NOT NULL AND p_dos_proj<> 'TOUS') THEN
			l_hab := ' and l_inv.DPCODE IN (' || p_dos_proj ||') ';
		end if;
	end if;

	l_where := l_where || l_where_ca || l_hab;


	-- Recherche du numéro de séquence de l'édition
      	SELECT Seqreftrans.nextval INTO l_numseq FROM dual;


	OPEN c_ligne_inv   for l_where  ;

        LOOP
            	FETCH c_ligne_inv INTO l_clicode,l_clisigle,l_typedp,l_codcamo,l_annee,l_dpcode,l_libdp,l_filcode ;

	    	EXIT WHEN c_ligne_inv%NOTFOUND;

            	INSERT INTO TMP_SYNTHCOUTPROJ
	       	(numseq,CLICODE,CLISIGLE,TYPEDP, CODCAMO, ANNEE, DPCODE, LIBDP,FILCODE
	       	)
	      	VALUES
               	(l_numseq,l_clicode,l_clisigle,l_typedp,l_codcamo,l_annee,l_dpcode,
                l_libdp,l_filcode
                );

        END LOOP;

	COMMIT ;

	CLOSE c_ligne_inv   ;


        -- Calcul des montants des lignes d'investissement par Materiel,Logiciel, Mobilier

            -- MATERIEL
            UPDATE TMP_SYNTHCOUTPROJ tmp SET (NOTIFIE_MAT,REALISE_MAT)=
	    (select sum(pack_utile_cout.AppliqueTauxHTR(TO_NUMBER(TO_CHAR(d.datdebex,'yyyy')),l_inv.notifie,TO_CHAR(d.datdebex,'dd/mm/yyyy'),tmp.filcode)),
	    sum(pack_suivi_investissement.sum_realises_htr(TO_NUMBER(l_inv.codinv),TO_NUMBER(l_inv.codcamo),TO_NUMBER(l_inv.annee)))
	    from datdebex d,ligne_investissement l_inv,investissements inv
	    where
	    inv.codposte=1000
	    AND inv.codtype = l_inv.type
	    AND l_inv.dpcode=tmp.dpcode
	    AND l_inv.codcamo=tmp.codcamo
	    AND l_inv.annee=TO_NUMBER(TO_CHAR(d.datdebex,'yyyy'))
	    )
	    where numseq =  l_numseq
	    ;
	    COMMIT;

	    -- LOGICIEL
	    UPDATE TMP_SYNTHCOUTPROJ tmp SET (NOTIFIE_LOG,REALISE_LOG)=
	    (select sum(pack_utile_cout.AppliqueTauxHTR(TO_NUMBER(TO_CHAR(d.datdebex,'yyyy')),l_inv.notifie,TO_CHAR(d.datdebex,'dd/mm/yyyy'),tmp.filcode)),
	    sum(pack_suivi_investissement.sum_realises_htr(TO_NUMBER(l_inv.codinv),TO_NUMBER(l_inv.codcamo),TO_NUMBER(l_inv.annee)))
	    from datdebex d,ligne_investissement l_inv,investissements inv
	    where
	    inv.codposte=2000
	    AND inv.codtype = l_inv.type
	    AND l_inv.dpcode=tmp.dpcode
	    AND l_inv.codcamo=tmp.codcamo
	    AND l_inv.annee=TO_NUMBER(TO_CHAR(d.datdebex,'yyyy'))
	    )
	    where numseq =  l_numseq
	    ;
	    COMMIT;

	    -- MOBILIER
	    UPDATE TMP_SYNTHCOUTPROJ tmp SET (NOTIFIE_MOB,REALISE_MOB)=
	    (select sum(pack_utile_cout.AppliqueTauxHTR(TO_NUMBER(TO_CHAR(d.datdebex,'yyyy')),l_inv.notifie,TO_CHAR(d.datdebex,'dd/mm/yyyy'),tmp.filcode)),
	    sum(pack_suivi_investissement.sum_realises_htr(TO_NUMBER(l_inv.codinv),TO_NUMBER(l_inv.codcamo),TO_NUMBER(l_inv.annee)))
	    from datdebex d,ligne_investissement l_inv,investissements inv
	    where
	    inv.codposte=3000
	    AND inv.codtype = l_inv.type
	    AND l_inv.dpcode=tmp.dpcode
	    AND l_inv.codcamo=tmp.codcamo
	    AND l_inv.annee=TO_NUMBER(TO_CHAR(d.datdebex,'yyyy'))
	    )
	    where numseq =  l_numseq
	    ;
	    COMMIT;

	-- Regroupe toutes les lignes (par client , dossier projet ) sur une seule ligne avec codcamo à 0
	INSERT INTO TMP_SYNTHCOUTPROJ
	       	(numseq,CLICODE,CLISIGLE,TYPEDP, CODCAMO, ANNEE, DPCODE, LIBDP,FILCODE,
	       	NOTIFIE_MAT,REALISE_MAT,NOTIFIE_LOG,REALISE_LOG,NOTIFIE_MOB,REALISE_MOB
	       	)
	SELECT numseq, clicode, clisigle, typedp ,0, annee , dpcode , libdp , filcode,
		sum(NOTIFIE_MAT),sum(REALISE_MAT),sum(NOTIFIE_LOG),sum(REALISE_LOG),sum(NOTIFIE_MOB),sum(REALISE_MOB)
	FROM TMP_SYNTHCOUTPROJ
	WHERE numseq =  l_numseq
	GROUP BY numseq, clicode, clisigle, typedp , annee , dpcode , libdp , filcode ;

        -- Supprime toutes les lignes regroupées
	DELETE FROM TMP_SYNTHCOUTPROJ
	WHERE numseq =  l_numseq
	AND   codcamo <> 0 ;

        COMMIT ;

	-- Recherche des lignes BIP à prendre en compte

	-- Définition de la requete
	l_where := 'select d.clicode CLICODE,'
		|| 'd.clisigle CLISIGLE,'
		|| 'typedp.typdp TYPEDP,'
	        || 'lb.dpcode DPCODE,'
	        || 'dp.dplib     LIBDP,'
	        || 'round(sum( nvl(cc.ftsg,0) + nvl(cc.ftssii,0) + nvl(cc.envsg,0) + nvl(cc.envssii,0) ) /1000) CONSO';
	l_where := l_where || ' FROM ligne_bip lb,'
	 	|| 'client_mo d,'
	 	|| 'client_mo p,'
	 	|| 'cumul_conso cc,'
	 	|| 'dossier_projet dp,'
	        || 'type_dossier_projet typedp';
	l_where := l_where ||' WHERE cc.pid=lb.pid'
		|| ' AND dp.dpcode=lb.dpcode'
		|| ' AND dp.typdp=typedp.typdp'
		|| ' AND d.clidir=p.clidir'
		|| ' AND d.clidep=p.clidep'
		|| ' AND d.clipol=0'
		|| ' AND p.clicode = lb.clicode'
	    	|| ' AND cc.annee='|| l_annee0 ;

	-- Code du CA --
	-- Recherche des clients dont le CA est dans la liste des CA payeur du RTFE
	l_where_ca := ' AND lb.clicode IN ( SELECT clicoderatt FROM vue_clicode_hierarchie v, client_mo cl ' ||
			' WHERE v.clicode = cl.clicode ' ||
			' AND cl.codcamo IN (';

   	if(p_codcamo IS NOT NULL and p_codcamo<> 'TOUS' ) THEN
		l_where := l_where || l_where_ca  || p_codcamo ||')) ';
	end if ;

        --
	-- Rajout des restrictions sur Dossier projet, Projet, Application
	--

	l_doss_proj :='VIDE';
	l_projet := 'VIDE';
	l_application :='VIDE';
	l_tous :='VIDE';

	-- Test pour savoir si une des valeurs du RTFE est tous
	if ((NVL(p_dos_proj,' ')= 'TOUS' or NVL(p_projet,' ')= 'TOUS' or NVL(p_app,' ') = 'TOUS')) THEN
		l_tous:='TOUS';
	end if ;

        -- Dossier Projet demandé
  	if(p_param7 IS NOT NULL and p_param7 <> 'TOUS') THEN
	  	l_doss_proj := ' lb.DPCODE IN (' ||p_param7 ||') ';
	  end if;

 	-- Si il n'y a aucun critère passe - construit à partir des données du RTFE
 	if ( l_doss_proj = 'VIDE' and l_tous <> 'TOUS') THEN
 			--dossier projet
 	  	if(p_dos_proj IS NOT NULL ) THEN
			l_doss_proj := ' lb.DPCODE IN (' || p_dos_proj ||') ';
			end if;
			-- projet
  	  	if(p_projet IS NOT NULL) THEN
		  	l_projet := ' lb.ICPI IN ('''||p_projet||''') ';
		  end if ;
		 -- application
 	  	if(p_app IS NOT NULL) THEN
	  		l_application := ' lb.AIRT IN ('''||p_app||''')';
	  	end if;
  	end if ;

 	-- Compile le select sur Dossier projet, Projet, Application
 	if ( l_doss_proj <> 'VIDE' OR l_projet <> 'VIDE' OR l_application <> 'VIDE' ) THEN
 		l_hab := ' AND ( ' ;
 		if (  l_doss_proj <> 'VIDE' ) then
 			l_hab := l_hab || l_doss_proj ;
 		end if;
 		if ( l_projet <> 'VIDE' ) then
 			if ( l_hab <> ' AND ( ') then
 				l_hab := l_hab || ' OR ' ;
 			end if ;
 			l_hab := l_hab || l_projet ;
 		end if ;
 		if ( l_application <> 'VIDE' ) then
 			if ( l_hab <> ' AND ( ') then
 				l_hab := l_hab || ' OR ' ;
 			end if ;
 			l_hab := l_hab || l_application ;
 		end if ;
 		l_hab := l_hab ||' ) ' ;
 		l_where := l_where || l_hab ;
 	end if ;

	-- Rajout du Group By
	l_where := l_where || ' GROUP BY d.clicode,d.clisigle,typedp.typdp,lb.dpcode,dp.dplib ' ;

--insert into test_message(message) values(l_where);

	OPEN c_ligne_bip   for l_where  ;

        LOOP
            	FETCH c_ligne_bip INTO l_clicode,l_clisigle,l_typedp,l_dpcode,l_libdp,l_conso ;

	    	EXIT WHEN c_ligne_bip%NOTFOUND;

                BEGIN
                	-- Recherche si une ligne existe dans TMP_SYNTHCOUTPROJ
	                SELECT '1' into l_test FROM TMP_SYNTHCOUTPROJ
	                WHERE numseq=l_numseq
	                AND   clicode=l_clicode
	                AND   dpcode=l_dpcode;

			-- Met à jour le consommé
	                UPDATE TMP_SYNTHCOUTPROJ SET CONSO=l_conso
	                WHERE numseq=l_numseq
	                AND   clicode=l_clicode
	                AND   dpcode=l_dpcode;

	  	EXCEPTION
	            WHEN NO_DATA_FOUND THEN
	      	  	-- Insère une ligne dans TMP_SYNTHCOUTPROJ
	      	  	-- Cas des départements qui n'ont pas de lignes d'investissements
	      	  	IF (l_conso<>0) THEN
		      	  	INSERT INTO TMP_SYNTHCOUTPROJ
		       		(numseq,CLICODE,CLISIGLE,TYPEDP,ANNEE, DPCODE, LIBDP,CONSO
		       		)
		      		VALUES
	               		(l_numseq,l_clicode,l_clisigle,l_typedp,l_annee0,l_dpcode,
	                	l_libdp,l_conso
	                	);
	            END IF;
	    	END;

        END LOOP;

	COMMIT ;

	CLOSE c_ligne_bip   ;

	-- Met à jour le budget par département et dossier projet
        UPDATE TMP_SYNTHCOUTPROJ tmp SET BUDGET=
		   ( SELECT BUDGETHTR
		     FROM BUDGET_DP b
		     WHERE b.annee=l_annee0
		     AND   b.dpcode=tmp.dpcode
		     AND   b.clicode=tmp.clicode
		   )
	WHERE tmp.numseq =  l_numseq;
	COMMIT;

      RETURN l_numseq;

EXCEPTION
    WHEN OTHERS THEN
    RETURN 0; -- code d'erreur
END Select_Donnees;


END pack_hab_ref;
/
CREATE OR REPLACE PACKAGE pack_historique AS

-- ------------------------------------------------------------------------
--
-- Nom         :  select_nom_schema_a_ecraser
-- Auteur      :  Equipe SOPRA (MSA)
-- Description :  récupération du nom du schema le plus ancien
--
-- Paramètres :
--                p_chemin_fichier  IN   repertoire ou il faut ecrire le fichier
--			p_nom_fichier     IN   nom du fichier devant contenir le nom du schema
--
-- Remarque :
--
-- ------------------------------------------------------------------------
   PROCEDURE select_nom_schema_a_ecraser( p_chemin_fichier  IN VARCHAR2,
                                          p_nom_fichier     IN VARCHAR2
                                         );


-- ------------------------------------------------------------------------
--
-- Nom         :  select_nom_schema
-- Auteur      :  Equipe SOPRA (MSA)
-- Description :  récupération du nom du schema pour une date donnee
--
-- Paramètres :
--                p_date         IN		date pour laquelle on veut le nom du schema
--                p_focus        IN		champ devant recevoir le focus en cas d'erreur
--                p_nom_schema  OUT		nom du schema correspondant à la date ci-dessus
--                p_message     OUT		message de sortie
--
-- Remarque :  p_nom_schema = '' si date en dehors de la plage M-14 -> M-1
--
-- ------------------------------------------------------------------------
   PROCEDURE select_nom_schema( p_date         IN VARCHAR2,
                                p_focus        IN VARCHAR2,
                                p_nom_schema   OUT VARCHAR2,
                                p_message      OUT VARCHAR2
                              );


-- ------------------------------------------------------------------------
--
-- Nom         : verif_codsg
-- Auteur      : Equipe SOPRA (MSA)
-- Description : Vérification du code DPG saisi
-- Paramètres  :
--              p_nom_schema   IN		Nom du schema
--              p_codsg        IN 		Code DPG
--              p_focus        IN		champ devant recevoir le focus en cas d'erreur
--              p_message     OUT		Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------
   PROCEDURE verif_codsg( p_nom_schema  IN VARCHAR2,
                          p_codsg       IN VARCHAR2,
                          p_focus       IN VARCHAR2,
                          p_message    OUT VARCHAR2
                        );


-- ------------------------------------------------------------------------
--
-- Nom         : verif_pid
-- Auteur      : Equipe SOPRA
-- Description : Vérification du code pid saisi
-- Paramètres  :
--              p_nom_schema  IN		Nom du schema
--              p_pid         IN 		Code pid
--              p_focus       IN 		Nom du champ devant recevoir le focus
--		    p_message    OUT          Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------

   PROCEDURE verif_pid( p_nom_schema  IN VARCHAR2,
                        p_pid         IN VARCHAR2,
                        p_focus       IN VARCHAR2,
                        p_message    OUT VARCHAR2
                      );


-- ------------------------------------------------------------------------
--
-- Nom        : verif_prodeta
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
-- Paramètres :
--              p_mois_annee   IN		Mois et Année traitée
--              p_codsg        IN 		Code DPG
--              p_pid          IN		Code ligne bip
--              p_nom_schema  OUT
--              p_message     OUT		Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------
   PROCEDURE verif_prodeta( p_mois_annee   IN  VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
                            p_codsg        IN  VARCHAR2,		-- CHAR(6)
                            p_pid          IN  VARCHAR2,		-- CHAR(3)
                            p_nom_schema  OUT  VARCHAR2,
                            p_message     OUT  VARCHAR2
                          );



-- ------------------------------------------------------------------------
--
-- Nom         : verif_prohist
-- Auteur      : Equipe SOPRA
-- Description : Vérification des paramètres saisis pour l'etat $PROHIST
-- Paramètres  :
--              p_mois_annee   IN		Mois et Année traitée
--              p_codsg        IN 		Code DPG
--              p_factpid      IN		Code ligne bip
--              p_nom_schema  OUT
--              p_message     OUT		Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------
   PROCEDURE verif_prohist( p_mois_annee   IN  VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
                            p_codsg        IN  VARCHAR2,		-- CHAR(6)
                            p_factpid      IN  VARCHAR2,		-- CHAR(3)
                            p_nom_schema  OUT  VARCHAR2,
                            p_message     OUT  VARCHAR2
                          );



-- ------------------------------------------------------------------------
--
-- Nom        : verif_reshist
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
-- Paramètres :
--              p_mois_annee   IN		Mois et Année traitée
--              p_codsg        IN 		Code DPG
--              p_tires        IN		Code ressource
--              p_nom_schema  OUT
--              p_message     OUT		Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------
   PROCEDURE verif_reshist( p_mois_annee   IN  VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
                            p_codsg        IN  VARCHAR2,		-- CHAR(6)
                            p_tires        IN  VARCHAR2,		-- CHAR(3)
                            p_nom_schema  OUT  VARCHAR2,
                            p_message     OUT  VARCHAR2
                          );



-- ------------------------------------------------------------------------
-- Nom        : verif_prodec3 (Prend en compte le concept d'historique)
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des champs saisies dans la page WEB pour PRODEC3
-- Paramètres :
--		     p_nom_etat     IN  VARCHAR2,
--               p_mois_annee   IN  VARCHAR2,	    		-- CHAR(7) (Format MM/AAAA)
--               p_codsg        IN  VARCHAR2,               -- CHAR(6)
--               p_nom_schema  OUT  VARCHAR2,
--               p_message     OUT VARCHAR2
--
-- ------------------------------------------------------------------------
PROCEDURE verif_prodec3( p_nom_etat     IN  VARCHAR2,
                         p_mois_annee   IN  VARCHAR2,			-- CHAR(7) (Format MM/AAAA)
                         p_codsg        IN  VARCHAR2,             -- CHAR(6)
                         p_nom_schema  OUT  VARCHAR2,
                         p_message     OUT  VARCHAR2
                       );



-- ------------------------------------------------------------------------
-- Nom        : verif_prodecl (Prend en compte le concept d'historique)
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des champs saisies dans la page WEB pour PRODECL
-- Paramètres :
--		     p_nom_etat     IN  VARCHAR2,
--               p_mois_annee   IN  VARCHAR2,	    		-- CHAR(7) (Format MM/AAAA)
--               p_codsg        IN  VARCHAR2,               -- CHAR(6)
--               p_pid          IN  VARCHAR2,               -- CHAR(6)
--               p_nom_schema  OUT  VARCHAR2,
--               p_message     OUT  VARCHAR2
--
-- ------------------------------------------------------------------------
PROCEDURE verif_prodecl( p_nom_etat     IN  VARCHAR2,
                         p_mois_annee   IN  VARCHAR2,	     -- CHAR(7) (Format MM/AAAA)
                         p_codsg        IN  VARCHAR2,          -- CHAR(7)
                         p_pid          IN  VARCHAR2,          -- CHAR(3)
                         p_nom_schema  OUT  VARCHAR2,
                         p_message     OUT  VARCHAR2
                 );


END pack_historique ;
/

CREATE OR REPLACE PACKAGE BODY pack_historique AS

-------------------------------------------------------------------
--
------------------------------------------------------------------

   PROCEDURE select_nom_schema_a_ecraser( p_chemin_fichier  IN VARCHAR2,
                                          p_nom_fichier     IN VARCHAR2
                                        ) IS

	l_nom_schema	ref_histo.nom_schema%TYPE;
	l_hfile		utl_file.file_type;

   BEGIN

	SELECT  LOWER(nom_schema)
	INTO	  l_nom_schema
	FROM	  ref_histo
	WHERE	  mois = ( SELECT min(RH2.mois) FROM ref_histo RH2 ) ;

      PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);

	PACK_GLOBAL.WRITE_STRING( l_hfile, l_nom_schema );

      PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);

   EXCEPTION
     WHEN OTHERS THEN
        raise_application_error(-20997, SQLERRM);

   END select_nom_schema_a_ecraser;


-------------------------------------------------------------------
--
------------------------------------------------------------------

   PROCEDURE select_nom_schema( p_date         IN VARCHAR2,
                                p_focus        IN VARCHAR2,
                                p_nom_schema   OUT VARCHAR2,
                                p_message      OUT VARCHAR2
                              ) IS

	l_min_mois	VARCHAR2(10);
	l_max_mois	VARCHAR2(10);

   BEGIN

	BEGIN
	   SELECT  nom_schema
	   INTO    p_nom_schema
	   FROM    ref_histo
	   WHERE   mois = to_date(p_date,'MM/YYYY') ;

	EXCEPTION
	   WHEN NO_DATA_FOUND THEN
		SELECT  to_char(min(mois),'MM/YYYY')
		INTO    l_min_mois
		FROM    ref_histo;

		SELECT  to_char(max(mois),'MM/YYYY')
		INTO    l_max_mois
		FROM    ref_histo;

		-- Message de la forme : 'Le mois de traitement doit être compris entre --- et ---'
		pack_global.recuperer_message(20950, '%s1', l_min_mois, '%s2', l_max_mois, p_focus, p_message);

	   WHEN OTHERS THEN
		raise_application_error(-20997,SQLERRM);
	END;

   EXCEPTION
	WHEN OTHERS THEN
	   raise_application_error(-20997,SQLERRM);

   END select_nom_schema;



-- ------------------------------------------------------------------------
--
-- Nom         : verif_codsg
-- Auteur      : Equipe SOPRA (MSA)
-- Description : Vérification du code DPG saisi
-- Paramètres  :
--              p_nom_schema   IN		Nom du schema
--              p_codsg        IN 		Code DPG
--              p_focus        IN		champ devant recevoir le focus en cas d'erreur
--              p_message     OUT		Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------

   PROCEDURE verif_codsg( p_nom_schema  IN VARCHAR2,
                          p_codsg       IN VARCHAR2,
                          p_focus       IN VARCHAR2,
                          p_message    OUT VARCHAR2
                        ) IS

	CID		INTEGER;
	l_requete   VARCHAR2(250) := '';
	l_FmtCharDPG VARCHAR2(10) := '';

   BEGIN

	---------------------------------------------------------------------------------------------
	-- Vérification existence Code DPG dans la table des DPG (Table struct_info)
	-- Commentaire 28/08/2003 : Pierre JOSSE
	-- Les parties de test sur 6 caractères pourront être enlevées une fois qu'il
	-- n'y aura plus d'hitoriques au format Number(6) pour les DPG
	---------------------------------------------------------------------------------------------

	IF ( ( p_codsg IS NOT NULL ) AND ( p_codsg != '*******' ) AND ( p_codsg != '       ' ) AND ( p_codsg != '******' ) AND ( p_codsg != '      ' ) )
	THEN

	   BEGIN
		--
		-- Ouverture du curseur et récupération de l'ID
		--
		CID := DBMS_SQL.OPEN_CURSOR;

		--------------------------------------------------
		-- Définition du format demandé.
		--------------------------------------------------
	   	IF (length(p_codsg) = 7) THEN
	   		l_FmtCharDPG := 'FM0000000';
	   	ELSE
	   		l_FmtCharDPG := 'FM000000';
	   	END IF;


		-- p_codsg peut avoir une valeur = '01313**' ou '0131312' ou '01312  ' (avec des blancs) ou '1313**' ou '131312' ou '1312  '
		-- S'il possede un metacaractere (' ', '*'), on va le supprimer
		-- Puis former la condition Where du Select en fonction de la longueur de p_codsg
		--
		-- SELECT  codsg
		-- INTO    l_codsg
		-- FROM    struct_info
		-- WHERE   substr(to_char(codsg,'FM0000000'),1,length(rtrim(rtrim(p_codsg,'*')))) = rtrim(rtrim(p_codsg,'*'))
		-- AND     ROWNUM <= 1;
      	--
		l_requete	:=  'SELECT   codsg'
				||  ' FROM    struct_info_' || p_nom_schema || '@linkhisto'
				||  ' WHERE   substr(to_char(codsg,''' || l_FmtCharDPG || '''),1,length(rtrim(rtrim(''' || p_codsg || ''',''*'')))) = rtrim(rtrim(''' || p_codsg || ''',''*''))' ;

		DBMS_SQL.PARSE( CID, l_requete, DBMS_SQL.V7 );

		IF ( DBMS_SQL.EXECUTE_AND_FETCH( CID ) = 0 )
		THEN
		   pack_global.recuperer_message(pack_utile_numsg.nuexc_coddpg_invalide3, '%s1', p_codsg, p_focus, p_message);
		END IF;

		DBMS_SQL.CLOSE_CURSOR( CID );

	   EXCEPTION
		WHEN OTHERS THEN
		   DBMS_SQL.CLOSE_CURSOR( CID );
		   raise;

	   END;

	END IF;

   END verif_codsg;



-- ------------------------------------------------------------------------
--
-- Nom         : verif_pid
-- Auteur      : Equipe SOPRA
-- Description : Vérification du code pid saisi
-- Paramètres  :
--              p_nom_schema  IN		Nom du schema
--              p_pid         IN 		Code pid
--              p_focus       IN 		Nom du champ devant recevoir le focus
--		    p_message    OUT          Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------

   PROCEDURE verif_pid( p_nom_schema  IN VARCHAR2,
                        p_pid         IN VARCHAR2,
                        p_focus       IN VARCHAR2,
                        p_message    OUT VARCHAR2
                      ) IS

	CID		INTEGER;
	l_requete   VARCHAR2(250) := '';

   BEGIN

	---------------------------------------------------------------------------------------------
	-- Vérification existence Code ligne BIP dans LIGNE_BIP
	---------------------------------------------------------------------------------------------

	IF ( p_pid IS NOT NULL )
	THEN
	   BEGIN
		--
		-- Ouverture du curseur et récupération de l'ID
		--
		CID := DBMS_SQL.OPEN_CURSOR;

		l_requete	:=  'SELECT  pid'
				||  ' FROM   ligne_bip_' || p_nom_schema || '@linkhisto'
				||  ' WHERE  pid = ''' || p_pid || '''' ;

		DBMS_SQL.PARSE( CID, l_requete, DBMS_SQL.V7 );

		IF ( DBMS_SQL.EXECUTE_AND_FETCH( CID ) = 0 )
		THEN
		   pack_global.recuperer_message(pack_utile_numsg.nuexc_codligne_bip_inexiste, '%s1', p_pid , p_focus, p_message);
		END IF;

		DBMS_SQL.CLOSE_CURSOR( CID );

	   EXCEPTION
		WHEN OTHERS THEN
		   DBMS_SQL.CLOSE_CURSOR( CID );
		   raise;
	   END;

      END IF;


   END verif_pid;


-- ------------------------------------------------------------------------
--
-- Nom        : verif_prodeta
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
-- Paramètres :
--              p_mois_annee  (IN)		Mois et Année traitée
--              p_codsg       (IN) 		Code DPG
--              p_pid IN      (IN)        Code ligne bip
--              p_nom_schema  OUT
--		    p_message     OUT         Message de sortie
--
-- Remarque :
--
-- Quand    	Qui  	Quoi
-- -----    	---  	--------------------------------------------------------
-- 25/01/00  	HTM  Ajout contrôle existence code ligne BIP saisi
-- 23/02/2000	MSA	Adaptation au concept d'historique
-- ------------------------------------------------------------------------

   PROCEDURE verif_prodeta( p_mois_annee   IN  VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
                            p_codsg        IN  VARCHAR2,		-- CHAR(7)
                            p_pid          IN  VARCHAR2,		-- CHAR(3)
                            p_nom_schema  OUT  VARCHAR2,
                            p_message     OUT  VARCHAR2
                          ) IS

	l_message		VARCHAR2(1024) := '';
	l_nom_schema	ref_histo.nom_schema%TYPE;

   BEGIN
	---------------------------------------------------------------------------------------------
	-- (1) Vérification date et récupération du nom du schéma
	---------------------------------------------------------------------------------------------
	pack_historique.select_nom_schema(p_mois_annee, 'P_param6', l_nom_schema, l_message );


	---------------------------------------------------------------------------------------------
	-- (2) Vérification CODSG
	---------------------------------------------------------------------------------------------
	IF (l_nom_schema IS NOT NULL) THEN
	   pack_historique.verif_codsg(l_nom_schema, p_codsg, 'P_param7', l_message );
	END IF;


	---------------------------------------------------------------------------------------------
	-- (3) Vérification existence Code ligne BIP dans LIGNE_BIP
	---------------------------------------------------------------------------------------------
	IF ( (l_nom_schema IS NOT NULL) AND (l_message IS NULL) AND (p_pid <> 'Tout') ) THEN
	   pack_historique.verif_pid(l_nom_schema, p_pid, 'P_param8', l_message );
	END IF;


	p_message    := l_message;
	p_nom_schema := 'NOM_SCHEMA#' || l_nom_schema;


   EXCEPTION
	WHEN OTHERS THEN
	   raise_application_error(-20997, SQLERRM);

   END verif_prodeta;



-- ------------------------------------------------------------------------
--
-- Nom        : verif_prohist
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'etat $PROHIST
-- Paramètres :
--              p_mois_annee  IN		Mois et Année traitée
--              p_codsg       IN 		Code DPG
--              p_factpid     IN		Code ligne bip
--              p_nom_schema  OUT
--		    P_message	OUT             Message de sortie
--
-- Remarque :
--
-- Quand    	Qui  	Quoi
-- -----    	---  	--------------------------------------------------------
-- 25/01/2000  	HTM	Ajout contrôle existence code ligne BIP saisi
-- 23/02/2000	MSA	Adaptation au concept d'historique
-- ------------------------------------------------------------------------


   PROCEDURE verif_prohist( p_mois_annee   IN  VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
                            p_codsg        IN  VARCHAR2,		-- CHAR(7)
                            p_factpid      IN  VARCHAR2,		-- CHAR(3)
                            p_nom_schema  OUT  VARCHAR2,
                            p_message     OUT  VARCHAR2
                          ) IS

	l_message		VARCHAR2(1024) := '';
	l_nom_schema	ref_histo.nom_schema%TYPE;
      l_count		NUMBER := 0;
	CID			INTEGER;
	l_requete		VARCHAR2(250) := '';

   BEGIN
	---------------------------------------------------------------------------------------------
	-- (1) Vérification date et récupération du nom du schéma
	---------------------------------------------------------------------------------------------
	pack_historique.select_nom_schema(p_mois_annee, 'P_param6', l_nom_schema, l_message );


	---------------------------------------------------------------------------------------------
	-- (2) Vérification CODSG
	---------------------------------------------------------------------------------------------
	IF (l_nom_schema IS NOT NULL) THEN
	   pack_historique.verif_codsg(l_nom_schema, p_codsg, 'P_param7', l_message );
	END IF;


	---------------------------------------------------------------------------------------------
	-- (3) Vérification existence Code ligne BIP dans PROPLUS
	---------------------------------------------------------------------------------------------
	IF ( (l_nom_schema IS NOT NULL) AND (l_message IS NULL) AND (LENGTH(p_factpid) != 0) AND (p_factpid != 'Tout') )
	THEN
	   BEGIN

		CID := DBMS_SQL.OPEN_CURSOR;

		l_requete	:=  'SELECT  factpid'
				||  ' FROM   proplus_' || l_nom_schema || '@linkhisto'
				||  ' WHERE  factpid = ''' || p_factpid || '''' ;

		DBMS_SQL.PARSE( CID, l_requete, DBMS_SQL.V7 );

		IF ( DBMS_SQL.EXECUTE_AND_FETCH( CID ) = 0 )
		THEN
		   pack_global.recuperer_message(pack_utile_numsg.nuexc_codligne_bip_inexiste, '%s1', p_factpid , 'P_param8', l_message);
		END IF;

		DBMS_SQL.CLOSE_CURSOR( CID );

	   EXCEPTION
		WHEN OTHERS THEN
		   DBMS_SQL.CLOSE_CURSOR( CID );
		   raise_application_error(-20997,SQLERRM);
	   END;

      END IF;

	p_message    := l_message;
	p_nom_schema := 'NOM_SCHEMA#' || l_nom_schema;

   EXCEPTION
	WHEN OTHERS THEN
	   raise_application_error(-20997, SQLERRM);

   END verif_prohist;



-- ------------------------------------------------------------------------
--
-- Nom        : verif_reshist
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
-- Paramètres :
--              p_mois_annee   IN		Mois et Année traitée
--              p_codsg        IN 		Code DPG
--              p_tires        IN         Code ressource
--              p_nom_schema  OUT
--		    p_message     OUT         Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------

   PROCEDURE verif_reshist( p_mois_annee   IN  VARCHAR2,		-- CHAR(7) (Format MM/AAAA)
                            p_codsg        IN  VARCHAR2,		-- CHAR(7)
                            p_tires        IN  VARCHAR2,		-- CHAR(3)
                            p_nom_schema  OUT  VARCHAR2,
                            p_message     OUT  VARCHAR2
                          ) IS

	l_message	 	VARCHAR2(1024) := '';
	l_nom_schema	ref_histo.nom_schema%TYPE;

   BEGIN
	---------------------------------------------------------------------------------------------
	-- (1) Vérification date et récupération du nom du schéma
	---------------------------------------------------------------------------------------------
	pack_historique.select_nom_schema(p_mois_annee, 'P_param6', l_nom_schema, l_message );


	---------------------------------------------------------------------------------------------
	-- (2) Vérification CODSG
	---------------------------------------------------------------------------------------------
	IF (l_nom_schema IS NOT NULL) THEN
	   pack_historique.verif_codsg(l_nom_schema, p_codsg, 'P_param7', l_message );
	END IF;


	p_message    := l_message;
	p_nom_schema := 'NOM_SCHEMA#' || l_nom_schema;

   EXCEPTION
	WHEN OTHERS THEN
	   raise_application_error(-20997, SQLERRM);

   END verif_reshist;



-- ------------------------------------------------------------------------
-- Nom        : verif_prodec3 (Prend en compte le concept d'historique)
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des champs saisies dans la page WEB pour PRODEC3
-- Paramètres :
--		     p_nom_etat     IN  VARCHAR2,
--               p_mois_annee   IN  VARCHAR2,	    		-- CHAR(7) (Format MM/AAAA)
--               p_codsg        IN  VARCHAR2,               -- CHAR(7)
--               p_nom_schema  OUT  VARCHAR2,
--               p_message     OUT VARCHAR2
--
-- ------------------------------------------------------------------------
PROCEDURE verif_prodec3( p_nom_etat    IN  VARCHAR2,
                         p_mois_annee  IN  VARCHAR2,	     -- CHAR(7) (Format MM/AAAA)
                         p_codsg       IN  VARCHAR2,          -- CHAR(7)
                         p_nom_schema OUT  VARCHAR2,
                         p_message    OUT  VARCHAR2
                       ) IS

      l_message   	VARCHAR2(1024) := '';
	l_nom_schema	ref_histo.nom_schema%TYPE;

BEGIN

	---------------------------------------------------------------------------------------------
	-- (1) Vérification date et récupération du nom du schéma
	---------------------------------------------------------------------------------------------
	pack_historique.select_nom_schema(p_mois_annee, 'P_param7', l_nom_schema, l_message );


	---------------------------------------------------------------------------------------------
	-- (2) Vérification existence Code DPG dans la table des DPG du schéma (Table <l_nom_schema>.struct_info))
	---------------------------------------------------------------------------------------------
	IF (l_nom_schema IS NOT NULL) THEN
	   pack_historique.verif_codsg(l_nom_schema, p_codsg, 'P_param8', l_message );
	END IF;


      p_message    := l_message;
	p_nom_schema := 'NOM_SCHEMA#' || l_nom_schema;


   EXCEPTION
	WHEN OTHERS THEN
	   raise_application_error(-20997, SQLERRM);


END  verif_prodec3;



-- ------------------------------------------------------------------------
-- Nom        : verif_prodecl (Prend en compte le concept d'historique)
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des champs saisies dans la page WEB pour PRODECL
-- Paramètres :
--		     p_nom_etat     IN  VARCHAR2,
--               p_mois_annee   IN  VARCHAR2,	    		-- CHAR(7) (Format MM/AAAA)
--               p_codsg        IN  VARCHAR2,               -- CHAR(7)
--               p_pid          IN  VARCHAR2,               -- VARCHAR2(4)
--               p_nom_schema  OUT  VARCHAR2,
--               p_message     OUT  VARCHAR2
--
-- ------------------------------------------------------------------------
PROCEDURE verif_prodecl(
		 p_nom_etat     IN  VARCHAR2,
                 p_mois_annee   IN  VARCHAR2,	     -- CHAR(7) (Format MM/AAAA)
                 p_codsg        IN  VARCHAR2,          -- CHAR(7)
		 p_pid          IN  VARCHAR2,          -- VARCHAR2(4)
                 p_nom_schema  OUT  VARCHAR2,
                 p_message     OUT  VARCHAR2
                 ) IS

	l_message		VARCHAR2(1024) := '';
	l_nom_schema	ref_histo.nom_schema%TYPE;


   BEGIN
	---------------------------------------------------------------------------------------------
	-- (1) Vérification date et récupération du nom du schéma
	---------------------------------------------------------------------------------------------
	pack_historique.select_nom_schema(p_mois_annee, 'P_param7', l_nom_schema, l_message );


	---------------------------------------------------------------------------------------------
	-- (2) Vérification CODSG
	---------------------------------------------------------------------------------------------
	IF (l_nom_schema IS NOT NULL) THEN
	   pack_historique.verif_codsg(l_nom_schema, p_codsg, 'P_param8', l_message );
	END IF;


	---------------------------------------------------------------------------------------------
	-- (3) Vérification existence Code ligne BIP dans LIGNE_BIP
	---------------------------------------------------------------------------------------------
	IF ( (l_nom_schema IS NOT NULL) AND (l_message IS NULL) AND (p_pid <> 'Tout') ) THEN
	   pack_historique.verif_pid(l_nom_schema, p_pid, 'P_param9', l_message );
	END IF;


	p_message    := l_message;
	p_nom_schema := 'NOM_SCHEMA#' || l_nom_schema;


   EXCEPTION
	WHEN OTHERS THEN
	   raise_application_error(-20997, SQLERRM);

   END  verif_prodecl;


END pack_historique ;
/
CREATE OR REPLACE PACKAGE pack_immeuble AS

   TYPE immeubleCurType IS REF CURSOR RETURN immeuble%ROWTYPE;

   PROCEDURE insert_immeuble (p_icodimm   IN immeuble.icodimm%TYPE,
                              p_iadrabr   IN immeuble.iadrabr%TYPE,
                              p_userid    IN VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                              );

   PROCEDURE update_immeuble (p_icodimm   IN immeuble.icodimm%TYPE,
                              p_iadrabr   IN immeuble.iadrabr%TYPE,
                              p_flaglock  IN NUMBER,
                              p_userid    IN VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );

   PROCEDURE delete_immeuble (p_icodimm   IN immeuble.icodimm%TYPE,
                              p_flaglock  IN NUMBER,
                              p_userid    IN VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );

   PROCEDURE select_immeuble (p_icodimm     IN immeuble.icodimm%TYPE,
                              p_userid      IN VARCHAR2,
                              p_curimmeuble IN OUT immeubleCurType,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             );

END pack_immeuble;
/

CREATE OR REPLACE PACKAGE BODY pack_immeuble AS

   PROCEDURE insert_immeuble (p_icodimm   IN immeuble.icodimm%TYPE,
                              p_iadrabr   IN immeuble.iadrabr%TYPE,
                              p_userid    IN VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO immeuble (iadrabr,
                               icodimm
                              )
         VALUES (p_iadrabr,
                 p_icodimm
                );

         --'L'immeuble ' || p_icodimm ||  ' a été créé.';

         pack_global.recuperer_message( 2012, '%s1', p_icodimm, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message(20213, NULL, NULL, NULL, l_msg);
            raise_application_error( -20213, l_msg );

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);

      END;

   END insert_immeuble;


   PROCEDURE update_immeuble (p_icodimm   IN immeuble.icodimm%TYPE,
                              p_iadrabr   IN immeuble.iadrabr%TYPE,
                              p_flaglock  IN NUMBER,
                              p_userid    IN VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         UPDATE immeuble SET iadrabr = p_iadrabr,
                             icodimm = p_icodimm,
                             flaglock = decode( p_flaglock, 1000000,
                                                0, p_flaglock + 1)
         WHERE icodimm = p_icodimm
          AND flaglock = p_flaglock;

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -22097, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message( 2013, '%s1', p_icodimm, NULL, l_msg);
         p_message := l_msg;
      END IF;

  END update_immeuble;


   PROCEDURE delete_immeuble (p_icodimm   IN immeuble.icodimm%TYPE,
                              p_flaglock  IN NUMBER,
                              p_userid    IN VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS

      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM immeuble
         WHERE icodimm = p_icodimm
         AND flaglock = p_flaglock;

      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM );
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message( 2014, '%s1', p_icodimm, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END delete_immeuble;

   PROCEDURE select_immeuble (p_icodimm     IN immeuble.icodimm%TYPE,
                              p_userid      IN VARCHAR2,
                              p_curimmeuble IN OUT immeubleCurType,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curimmeuble FOR
              SELECT *
              FROM IMMEUBLE
              WHERE icodimm = p_icodimm;

      EXCEPTION

          WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);
      END;

      -- en cas absence
      -- 'L'immeuble n'existe pas';

      pack_global.recuperer_message( 2015, '%s1', p_icodimm, NULL, l_msg);
      p_message := l_msg;

   END select_immeuble;

END pack_immeuble;
/
CREATE OR REPLACE PACKAGE pack_immosfact AS
-- ===============================================================================
-- ===============================================================================
PROCEDURE select_immosfact ( p_global IN CHAR,
			    p_titre  IN VARCHAR2,
                           p_chemin_fichier IN VARCHAR2,
                           p_nom_fichier IN VARCHAR2,
                           p_nbfichier OUT INTEGER,
                           p_nbcurseur OUT INTEGER,
                           p_message OUT VARCHAR2
                          );
end pack_immosfact;
/
CREATE OR REPLACE PACKAGE pack_import_cs1 AS

   PROCEDURE traite_import_cs1     ( p_userid                 IN CHAR,
                                     p_chemin_fichier         IN VARCHAR2,
                                     p_nom_fichier            IN VARCHAR2

                                   );
END pack_import_cs1;
/

CREATE OR REPLACE PACKAGE BODY pack_import_cs1 AS
-- ********************************************************************
-- FONCTION getURL : sert \340 visualiser le fichier import
-- ********************************************************************

-- *********************************************************************************
-- PROCEDURE traite_import_cs1 : traite les factures import\351es
-- *********************************************************************************
   PROCEDURE traite_import_cs1     ( p_userid           IN CHAR,
                                     p_chemin_fichier   IN VARCHAR2,
                                     p_nom_fichier      IN VARCHAR2
                                   ) IS

   l_msg        varchar2(1024);
   l_ligne_fichier varchar2(2000);
   l_hfile utl_file.file_type;
   l_test varchar2(4);
   probleme_insertion EXCEPTION;
   pas_facture_traite EXCEPTION;
   filiale_differente EXCEPTION;
      pas_num_sms EXCEPTION;
   l_flag_maj BOOLEAN;

   /*** Curseur pour lire les lignes de la table import_compta_data ***/
   CURSOR curimp IS
        select socfact,numfact,typfact,num_sms
        from import_compta_data
        where nom_fichier=p_nom_fichier;

   BEGIN

      -- insertion du compte rendu si necessaire

      UPDATE import_compta_log
      SET  etat = 'en cours de traitement'
      WHERE userid = p_userid
      AND nom_fichier = p_nom_fichier
      AND date_trait = trunc(sysdate);

      IF SQL%NOTFOUND THEN
        INSERT INTO import_compta_log ( userid, nom_fichier, etat, date_trait)
        VALUES (p_userid, p_nom_fichier, 'en cours de traitement', TRUNC(sysdate));
        COMMIT;
      END IF;

      -- ouverture du fichier
      l_hfile := UTL_FILE.FOPEN(p_chemin_fichier, p_nom_fichier, 'r');


      -- Bloc d'insertion dans la table temporaire

      DECLARE
      l_socfact facture.socfact%TYPE;
      l_typfact facture.typfact%TYPE;
      l_numfact facture.numfact%TYPE;
      l_interne_sms VARCHAR2(15);
      l_code_erreur INTEGER;
      l_lib_erreur VARCHAR2(200);
      l_pos1 INTEGER ;
      l_pos2 INTEGER ;
      l_pos3 INTEGER ;
      l_pos4 INTEGER ;
      l_posuser  INTEGER ;
      l_count number;
      l_champ1 VARCHAR2(30);

      BEGIN
l_count:=0;

/* Ne pas prendre en compte l'ent\352te ie la premi\350re ligne*/
    UTL_FILE.GET_LINE(l_hfile, l_ligne_fichier);
     DBMS_OUTPUT.PUT_LINE('on lance la boucle');
    LOOP
          -- lecture de chaque ligne du fichier apr\350s l'ent\352te
          UTL_FILE.GET_LINE(l_hfile, l_ligne_fichier);
l_count:=l_count+1;
DBMS_OUTPUT.PUT_LINE(l_count);

          -- position des s\351parateurs
                l_pos1 := TO_NUMBER(INSTR(l_ligne_fichier, ';', 1, 1));
                l_pos2 := TO_NUMBER(INSTR(l_ligne_fichier, ';', 1, 2));
                l_pos3 := TO_NUMBER(INSTR(l_ligne_fichier, ';', 1, 3));
                l_pos4 := TO_NUMBER(INSTR(l_ligne_fichier, ';', 1, 4));

                l_champ1 := SUBSTR(l_ligne_fichier, 1, l_pos1-1);
                DBMS_OUTPUT.PUT_LINE('l_champ1 : ' || l_champ1);
                l_socfact := SUBSTR(l_ligne_fichier, 1, 4);
                DBMS_OUTPUT.PUT_LINE('l_socfact : ' || l_socfact);
                -- 10 pour 30 - [ 4(socfact)+15(numfact)+1(typfact) ]
                -- le champ18 (fichier export) possede dans les details factureun identifiant de longueur max 10
                -- c'est cet identifiant tronque qui se trouve dans le detail des lignes ici
                l_posuser := INSTR(l_ligne_fichier, SUBSTR(p_userid, 1, 10), 1);

                l_typfact := SUBSTR(l_ligne_fichier, l_posuser-1, 1);
                DBMS_OUTPUT.PUT_LINE('l_typfact : ' || l_typfact);
                l_numfact := SUBSTR(l_ligne_fichier, 5, l_posuser-6);   -- -6 pour 4(socfact) + 1(typfact) + 1(espace)
                DBMS_OUTPUT.PUT_LINE('l_numfact : ' || l_numfact);

          l_interne_sms := SUBSTR(l_ligne_fichier, l_pos1 +1 ,l_pos2 - l_pos1 -1);

          l_code_erreur := TO_NUMBER(SUBSTR(l_ligne_fichier, l_pos2 +1 ,l_pos3 - l_pos2 - 1));

          l_lib_erreur := SUBSTR(l_ligne_fichier, l_pos4 +1 ,195);

          -- insertion dans la table contenant les lignes des fichiers d'importation
          	INSERT INTO import_compta_data (userid, nom_fichier,socfact, numfact,typfact, num_sms, code_error,lib_error)
         	VALUES(p_userid, p_nom_fichier, l_socfact, l_numfact, l_typfact, l_interne_sms, l_code_erreur,l_lib_erreur);

        commit;
    END LOOP;

      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          COMMIT;
          UTL_FILE.FCLOSE(l_hfile);
        WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Exception');
          if (l_pos1!=0) then
           ROLLBACK;
           raise probleme_insertion;
         else   --cas o\371 il y a une ligne vide \340 la fin du fichier
          COMMIT;
          UTL_FILE.FCLOSE(l_hfile);
         end if;

      END;

      -- MAJ des factures

      /*MAJ NUM_SMS*/
      UPDATE facture fac
      SET fac.num_sms = (SELECT data.num_sms FROM import_compta_data data
                        WHERE fac.socfact  = data.socfact
                        AND   fac.typfact  = data.typfact
                        AND   fac.numfact  = data.numfact
                        AND data.num_sms IS NOT NULL)
      WHERE (socfact,numfact,typfact) in (SELECT socfact,numfact,typfact FROM import_compta_data)
      AND fac.num_sms IS NULL
      ;
     IF SQL%NOTFOUND THEN
          raise pas_num_sms;
      END IF;
      COMMIT;

      l_flag_maj := FALSE;

      UPDATE facture fac SET fac.fstatut1 = 'VA'
      WHERE EXISTS (SELECT 1 FROM import_compta_data data
                    WHERE fac.socfact  = data.socfact
                    AND   fac.typfact  = data.typfact
                    AND   fac.numfact  = data.numfact
                    AND   data.code_error = 0)
      AND fac.fstatut1 = 'EN';

      IF SQL%NOTFOUND THEN l_flag_maj := TRUE;
      END IF;

      UPDATE facture fac SET fac.fstatut1 = 'IN'
      WHERE     EXISTS (SELECT 1 FROM import_compta_data data
                        WHERE fac.socfact  = data.socfact
                        AND   fac.typfact  = data.typfact
                        AND   fac.numfact  = data.numfact
                        AND   data.code_error <> 0)
      AND fac.fstatut1 = 'EN';

      IF SQL%NOTFOUND AND l_flag_maj = TRUE THEN
          raise pas_facture_traite;
      END IF;

      COMMIT;
  -- Ajout de la date de facture et du statut CS1 pour l'\351tat de controle des fichiers imports
 DECLARE
      l_date date;
      l_statut char(2);
  BEGIN

      FOR cur_enr IN curimp
      LOOP
        select f.datfact,f.fstatut1 into l_date,l_statut
        from facture f
        where f.socfact=cur_enr.socfact
          and f.numfact=cur_enr.numfact
          and f.typfact=cur_enr.typfact;

        update import_compta_data i
        set      datfact=l_date,
                statut1=l_statut
        where i.socfact=cur_enr.socfact
          and i.numfact=cur_enr.numfact
          and i.typfact=cur_enr.typfact;

      END LOOP;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
                commit;

   END;

      -- MAJ effectu\351e fin de proc\351dure
      -- MAJ de la table des logs

      UPDATE import_compta_log
      SET ETAT = 'Fichier traite'
      WHERE userid = p_userid
      AND   nom_fichier = p_nom_fichier
      AND   date_trait = trunc(sysdate);

      COMMIT;

  EXCEPTION

     WHEN probleme_insertion THEN
          -- mise \340 jour du log
          UPDATE import_compta_log
          SET ETAT = 'Erreur rencontr\351e lors de l''insertion des factures consulter la bip'
          WHERE userid = p_userid
          AND   nom_fichier = p_nom_fichier
          AND   date_trait = trunc(sysdate);
          COMMIT;
     WHEN pas_facture_traite THEN
          -- mise \340 jour du log
          UPDATE import_compta_log
          SET ETAT = 'Pas de facture a importer'
                    WHERE userid = p_userid
          AND   nom_fichier = p_nom_fichier
          AND   date_trait = trunc(sysdate);
          COMMIT;
      WHEN pas_num_sms THEN
          -- mise à jour du log
          UPDATE import_compta_log
          SET ETAT = 'SMS'
          WHERE userid = p_userid
          AND   nom_fichier = p_nom_fichier
          AND   date_trait = trunc(sysdate);
          COMMIT;
     WHEN filiale_differente THEN
          -- maj du log
          UPDATE import_compta_log
          SET ETAT = 'Le fichier comporte des factures avec des filiales diff\351rente contacter la BIP'
          WHERE userid = p_userid
          AND   nom_fichier = p_nom_fichier
          AND   date_trait = trunc(sysdate);
          COMMIT;
           WHEN OTHERS THEN
        raise_application_error(-20997, SQLERRM);

   END traite_import_cs1;

END pack_import_cs1;
/
CREATE OR REPLACE PACKAGE pack_import_ES AS

------------------------------------------------------------
-- Cette procedure modifie les donnees concernant le niveau
-- present dans la situation de la ressource
------------------------------------------------------------
	PROCEDURE alim_ES;

END pack_import_ES;
/

CREATE OR REPLACE PACKAGE BODY pack_import_ES AS

PROCEDURE alim_ES IS
BEGIN
	--on vide la table des erreurs
DELETE FROM  CHARGE_ES_ERR;
COMMIT;

INSERT INTO CHARGE_ES_ERR (IDELST,CODCAMO,CDTYES,LILOES,LICOES)
SELECT   nvl(IDELST,'null'),nvl(CODCAMO,'null'),nvl(CDTYES,'0'),nvl(substr(LILOES,1,24),'non renseigné'),nvl(substr(LICOES,1,30),'non renseigné')
FROM charge_es
where IDELST is null
OR CODCAMO is null OR CDTYES is null OR LILOES is null;
commit;

DELETE FROM  CHARGE_ES
where IDELST is null
OR CODCAMO is null OR CDTYES is null OR LILOES is null;
commit;




	-----------------------------------------------------
        -- Alimentation de la table ENTITE_STRUCTURE a partir
        -- de la table CHARGE_ES
        -----------------------------------------------------

        -----------------------------------------------------
        -- MAJ dans le cas le l'existence d'un code centre
        -- d'activite dans la table de chargement et dans la
        -- la table des entites structure
        -----------------------------------------------------

     update ENTITE_STRUCTURE es
     set (es.CODCAMO,
            es.CDTYES,
            es.NIVEAU,
            es.LILOES ,
            es.LICOES,
            es.IDELST ) =
           (select
           ches.CODCAMO,
           ches.CDTYES,
           to_number(decode(ches.CDTYES, 30, 5, 99, 4, 31, 4, 32, 3,
                                 33, 2, 34, 1, 35, 0, 0)),
           substr(ches.LILOES, 1, 24),
           substr(ches.LICOES, 1, 30),
           ches.IDELST from CHARGE_ES ches
   		where to_number(ches.CODCAMO) = es.CODCAMO)
 	where es.CODCAMO IN (select es.CODCAMO
                              from entite_structure es, charge_es ches
                              where to_number(ches.CODCAMO) = es.CODCAMO
                              )

          ;
      commit;


     -----------------------------------------------------
      -- INSERT dans le cas de l'inexistance d'un code centre
      -- d'activite dans la table de chargement et dans la
      -- la table entite structure
      -----------------------------------------------------



      insert into ENTITE_STRUCTURE     (CODCAMO,CDTYES,NIVEAU,LILOES,LICOES,IDELST)
      select
          to_number(ches.CODCAMO),
          ches.CDTYES,
          to_number(decode(ches.CDTYES, 30, 5, 99, 4, 31, 4, 32, 3,
                                33, 2, 34, 1, 35, 0, 0)),
          substr(ches.LILOES, 1, 30),
          substr(ches.LICOES, 1, 30),
          to_number(ches.IDELST)
      from CHARGE_ES ches
      where not exists (select 1 from ENTITE_STRUCTURE es
                        where to_number(ches.CODCAMO) = es.CODCAMO)

        ;

      commit;


END alim_ES;



END pack_import_ES;
/
CREATE OR REPLACE PACKAGE pack_import_niveau AS

------------------------------------------------------------
-- Cette procedure modifie les donnees concernant le niveau
-- present dans la situation de la ressource
------------------------------------------------------------
	PROCEDURE alim_situation;

END pack_import_niveau;
/

CREATE OR REPLACE PACKAGE BODY pack_import_niveau AS

PROCEDURE alim_situation IS

l_date_defaut VARCHAR2(10);


BEGIN

--on vide la table des erreurs
DELETE FROM  TMP_IMP_NIVEAU_ERR;
COMMIT;

--Gestion des anomalies : A inserer dans une TABLE des erreurs
--Cas 1 : la ressource n'existe pas dans la Bip
/*INSERT INTO TMP_IMP_NIVEAU_ERR
	(SELECT DISTINCT t.matricule,t.nom,t.prenom,t.niveau,t.date_maj,'matricule inexistant'
	FROM TMP_IMP_NIVEAU t,datdebex dx
	WHERE NOT EXISTS (SELECT 1 FROM ressource r WHERE r.matricule=t.matricule)
	AND (TO_CHAR(dx.datdebex,'yyyy')=SUBSTR(t.date_maj,1,4) OR t.date_maj = '00000000')
);
COMMIT;*/

--Cas a part : ressource existe mais plus de situation sur l annee en cours : on les fait pas
-- apparaitre dans l extraction (trop de ressources)
INSERT INTO TMP_IMP_NIVEAU_ERR
	(SELECT DISTINCT t.matricule,situ.ident,situ.codsg,t.nom,t.prenom,t.niveau,t.date_maj,'situation terminée'
	 FROM TMP_IMP_NIVEAU t,datdebex dx,situ_ress_full situ,ressource r
 	 WHERE to_number(TO_CHAR(dx.datdebex,'yyyy')) > to_number(to_char(situ.datsitu-1,'yyyy'))
         and situ.type_situ='P'
         and situ.datdep is null
         AND  t.matricule=r.matricule
 	 AND r.ident=situ.ident
 	 AND (TO_CHAR(dx.datdebex,'yyyy')=SUBSTR(t.date_maj,1,4) OR t.date_maj = '00000000')
);
COMMIT;

--Cas 2 : le niveau n'existe pas dans la table NIVEAU
INSERT INTO TMP_IMP_NIVEAU_ERR
	(SELECT DISTINCT t.matricule,situ.ident,situ.codsg,t.nom,t.prenom,t.niveau,t.date_maj,'niveau inexistant'
	FROM TMP_IMP_NIVEAU t,datdebex dx,situ_ress situ,ressource r
	WHERE NOT EXISTS (SELECT 1 FROM niveau n WHERE n.niveau=(rtrim(t.niveau)))
	AND EXISTS (SELECT 1 FROM ressource r WHERE r.matricule=t.matricule)
	AND NOT EXISTS (select 1 FROM TMP_IMP_NIVEAU_ERR err where err.matricule=t.matricule
			AND err.type_err='situation terminée')
	AND situ.ident=r.ident
	AND r.matricule=t.matricule
	AND ( situ.datdep IS NULL OR TO_CHAR(situ.datdep,'yyyy')=TO_CHAR(dx.datdebex,'yyyy') )
);
COMMIT;

--Cas 3 : la ressource existe dans la bip mais n'a pas de situation
INSERT INTO TMP_IMP_NIVEAU_ERR
	(SELECT DISTINCT t.matricule,NULL,NULL,t.nom,t.prenom,t.niveau,t.date_maj,'ressource sans situation'
	FROM TMP_IMP_NIVEAU t,datdebex dx
	WHERE NOT EXISTS (SELECT 1 FROM situ_ress s,ressource r WHERE s.ident=r.ident
			  AND r.matricule=t.matricule)
	AND EXISTS (SELECT 1 FROM ressource r WHERE r.matricule=t.matricule)
	AND (TO_CHAR(dx.datdebex,'yyyy')=SUBSTR(t.date_maj,1,4) OR t.date_maj = '00000000')
);
COMMIT;



--Cas 4 : le changement de niveau intervient dans le même mois qu'une nouvelle situation
INSERT INTO TMP_IMP_NIVEAU_ERR
	(SELECT DISTINCT t.matricule,s.ident,s.codsg,t.nom,t.prenom,t.niveau,t.date_maj,'changement dans le mois'
	FROM TMP_IMP_NIVEAU t,situ_ress s,ressource r,datdebex dx
	WHERE
	TO_CHAR(s.datsitu,'mmyyyy')=SUBSTR(t.date_maj,5,2)||SUBSTR(t.date_maj,1,4)
	AND  t.matricule=r.matricule
	AND r.ident=s.ident
	AND (TO_CHAR(dx.datdebex,'yyyy')=SUBSTR(t.date_maj,1,4) OR t.date_maj = '00000000')
	AND s.niveau <> rtrim(t.niveau)
);
COMMIT;

--Cas 5 : matricule en doublon dans la Bip (ca ne devrait pas exister mais sait-on jamais ...)
INSERT INTO TMP_IMP_NIVEAU_ERR
	(SELECT DISTINCT  t.matricule,s.ident,s.codsg,t.nom,t.prenom,t.niveau,t.date_maj,'matricule en doublon'
	FROM TMP_IMP_NIVEAU t,ressource r,situ_ress s,datdebex dx
	WHERE  EXISTS  (SELECT  1 FROM  ressource r2 WHERE  r2.matricule=r.matricule AND  r2.ident!=r.ident)
	AND r.matricule=t.matricule
	AND NOT EXISTS (select 1 FROM TMP_IMP_NIVEAU_ERR err where err.matricule=t.matricule
			AND err.type_err='situation terminée')
	AND s.ident=r.ident
	AND ( s.datdep IS NULL OR TO_CHAR(s.datdep,'yyyy')=TO_CHAR(dx.datdebex,'yyyy') )
);
COMMIT;

--Cas 6 : ressource existe dans la Bip avec une situation dans l'annee et niveau à NULL
-- mais son matricule ne figure pas dans le fichier Gershwin
INSERT INTO TMP_IMP_NIVEAU_ERR
	(SELECT DISTINCT  NVL(r.matricule,'XX'),s.ident,s.codsg,NVL(r.rnom,'XX'),NVL(r.rprenom,'XX'),NVL(s.niveau,'XX'),'XX','La ressource n''est pas dans le fichier Gershwin'
	FROM ressource r,situ_ress s,datdebex dx
	WHERE s.ident=r.ident
	AND s.niveau IS NULL
	AND ( s.datdep IS NULL OR TO_CHAR(s.datdep,'yyyy')=TO_CHAR(dx.datdebex,'yyyy') )
	AND s.soccode='SG..'
	AND r.rtype='P'
	AND NOT EXISTS (SELECT 1 FROM tmp_imp_niveau t  WHERE t.matricule=r.matricule)
);
COMMIT;

-- On initalise la date par défaut du changement de niveau , car la date est rarement renseignée
-- dans le fichier de Gerschwin , on fixe cette date au mois suivant du mois de la mensuelle
SELECT to_char(add_months(moismens,1),'yyyy/mm/dd')
	INTO l_date_defaut
	FROM datdebex ;

DECLARE
--dans le curseur a parcourir, on prend les ressources dont le matricule existe dans la BIP
-- et dont le niveau est present dans la table NIVEAU
--si la DATE de maj est 00000000, ON la remplace par la date par défaut
CURSOR C_NIVEAU IS SELECT DISTINCT t.niveau,r.ident,decode(t.date_maj,'00000000',l_date_defaut ,t.date_maj) date_maj
			FROM  TMP_IMP_NIVEAU t,ressource r,niveau n,datdebex dx
			WHERE t.matricule=r.matricule
			AND rtrim( t.niveau)=n.niveau
			AND (TO_CHAR(dx.datdebex,'yyyy')=SUBSTR(t.date_maj,1,4)	OR t.date_maj = '00000000')
			AND t.niveau <> '00'
			;

	BEGIN
	FOR ONE_NIVEAU IN C_NIVEAU LOOP
	 BEGIN
	 	-- Met à jour tous les niveaux non renseignés
	 	--
		UPDATE situ_ress
		        SET situ_ress.niveau=rtrim(ONE_NIVEAU.niveau)
		        WHERE situ_ress.ident=ONE_NIVEAU.ident
		        AND (TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd') >= situ_ress.datsitu )
		        AND (TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd') < situ_ress.datdep OR situ_ress.datdep IS NULL)
		        AND ( situ_ress.niveau IS NULL  )
		        AND situ_ress.soccode='SG..';
		COMMIT;

	 	-- Met à jour tous les niveaux différents pour une ligne ayant la même date de situation
	 	--
		UPDATE situ_ress
		        SET situ_ress.niveau=rtrim(ONE_NIVEAU.niveau)
		        WHERE situ_ress.ident=ONE_NIVEAU.ident
		        AND (TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd') = situ_ress.datsitu )
		        AND (TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd') < situ_ress.datdep OR situ_ress.datdep IS NULL)
		        AND situ_ress.niveau<>rtrim(ONE_NIVEAU.niveau)
		        AND situ_ress.soccode='SG..';
		COMMIT;

		--Cas d'un changement de niveau
		--On insère une ligne identique à celle présente dans la base avec le nouveau niveau et
		--Une date de situation égale à la date de mise à jour
		INSERT INTO situ_ress (datsitu,datdep,cpident,cout,dispo,marsg2,rmcomp,prestation,dprest,
		ident,soccode,codsg,niveau)
			 (SELECT TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd'),
				s.datdep ,
				s.cpident,s.cout,s.dispo,s.marsg2,s.rmcomp,s.prestation,s.dprest,
				s.ident,s.soccode,s.codsg,
				rtrim(ONE_NIVEAU.niveau)
			 FROM situ_ress s
			 WHERE s.ident=ONE_NIVEAU.ident
			 AND (TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd') > s.datsitu )
		         AND (TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd') < s.datdep OR s.datdep IS NULL)
		         AND s.niveau <> rtrim(ONE_NIVEAU.niveau)
		         AND s.soccode='SG..'
		         );
		         COMMIT;

		--Cas d'un changement de niveau
		--ON renseigne la DATE de depart dans la situation existante
		UPDATE situ_ress s
		 	 SET s.datdep=TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd')-1
			 WHERE s.ident=ONE_NIVEAU.ident
			 AND (TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd') > s.datsitu )
		         AND (TO_DATE(ONE_NIVEAU.date_maj,'yyyy/mm/dd') < s.datdep OR s.datdep IS NULL)
		         AND s.niveau <> rtrim(ONE_NIVEAU.niveau)
		         AND s.soccode='SG..' ;


		         COMMIT;


	 END;
	END LOOP;
	END;
	END alim_situation;



END pack_import_niveau;
/
CREATE OR REPLACE PACKAGE pack_initbdg AS

  -- Initialisation des budgets notifi_s et arbitr_s de tous les projets  : supprimé
  -- Initialisation des budgets notifi_s et arbitr_s par direction : supprimé
  -- Initialisation des budgets notifi_s et arbitr_s par type de projet : supprimé
  -- Initialisation des budgets arbitr_s par direction : supprimé
  -- Initialisation des budgets r_estim_s par domaine : supprimé


-- notification pour les grands projets
PROCEDURE initbdg_grand_projet (p_dpcode 	IN VARCHAR2,
				p_icpi 	IN VARCHAR2,
				p_metier 	IN VARCHAR2,
				p_dirme 	IN VARCHAR2,
				p_dirmo 	IN VARCHAR2,
                               	p_userid       	IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2);

FUNCTION tous_metier  RETURN VARCHAR2;

-- notification hors grands projets
PROCEDURE initbdg_hors_grand_projet (p_typeprojet	IN VARCHAR2,
				p_metier 	IN VARCHAR2,
				p_dirme 	IN VARCHAR2,
				p_dirmo_partie 	IN VARCHAR2,
				p_code_mo 	IN VARCHAR2,
				p_dirmo_entier 	IN VARCHAR2,
                               	p_userid       	IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2);


-- notification pour les lignes de type 9
PROCEDURE initbdg_type_9 (	p_dirme 	IN VARCHAR2,
			     	p_userid       	IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2);


END pack_initbdg;
/

CREATE OR REPLACE PACKAGE BODY pack_initbdg AS

VIOLATION_CONSTRAINT_UNIQUE EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( VIOLATION_CONSTRAINT_UNIQUE, -00001 );

FUNCTION tous_metier  RETURN VARCHAR2 IS

l_metier VARCHAR2(50);

	CURSOR cur_metier  IS
 	select metier
 	from metier
 	order by metier;

 BEGIN
--l_metier := '';
FOR enr_cour IN cur_metier LOOP
  l_metier := l_metier || ',''' || enr_cour.metier|| '''';
END LOOP;



 return (substr(l_metier,2));
END tous_metier;

PROCEDURE initbdg_grand_projet (p_dpcode 	IN VARCHAR2,
				  p_icpi 	IN VARCHAR2,
				  p_metier 	IN VARCHAR2,
				  p_dirme 	IN VARCHAR2,
				  p_dirmo 	IN VARCHAR2,
                                  p_userid       	IN VARCHAR2,
                                  p_nbcurseur 	OUT INTEGER,
                                  p_message   	OUT VARCHAR2) IS

    -- variables locales

    msg 	VARCHAR(1024);
    l_annee 	NUMBER(4);                       -- annee courante
    l_jour 	DATE;                       -- jour de la modif
    l_user	VARCHAR2(35);
    l_bool_vide 	BOOLEAN;
    l_num_vide  VARCHAR2(4);

    exc_vide 	EXCEPTION;
    concurrence EXCEPTION;
    PRAGMA 	EXCEPTION_INIT (concurrence, -00054);

--*******************************************
--cas 1 : tous les projets - toutes les directions fournisseur - tous les metiers
CURSOR cur_1 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE lb.dpcode = p_dpcode
	AND lb.clicode=cm.clicode
	AND cm.clidir = p_dirmo
	AND lb.arctype = 'T1'
	AND (RTRIM(lb.typproj)='1'
                    OR RTRIM(lb.typproj)='2'
                    OR RTRIM(lb.typproj)='3'
                    OR RTRIM(lb.typproj)='4')
        AND lb.dpcode <> 70000
	;
--******************

--*******************************************
--cas 2 : tous les projets - toutes les directions fournisseur
CURSOR cur_2 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE lb.metier = p_metier
	AND lb.dpcode = p_dpcode
	AND lb.clicode=cm.clicode
	AND cm.clidir = p_dirmo
	AND lb.arctype = 'T1'
	AND (RTRIM(lb.typproj)='1'
                    OR RTRIM(lb.typproj)='2'
                    OR RTRIM(lb.typproj)='3'
                    OR RTRIM(lb.typproj)='4')
        AND lb.dpcode <> 70000
	;
--******************

--*******************************************
--cas 3 : tous les projets - tous les metiers
CURSOR cur_3 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE lb.dpcode = p_dpcode
	AND lb.codsg in (select codsg from struct_info si
			where si.coddir = p_dirme)
	AND lb.clicode=cm.clicode
	AND cm.clidir = p_dirmo
	AND lb.arctype = 'T1'
	AND lb.dpcode <> 70000
	AND (RTRIM(lb.typproj)='1'
                    OR RTRIM(lb.typproj)='2'
                    OR RTRIM(lb.typproj)='3'
                    OR RTRIM(lb.typproj)='4')
	;
--******************

--*******************************************
--cas 4 : tous les projets (donc on se base sur le dossier projet pour faire la selection)
CURSOR cur_4 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE lb.metier = p_metier
	AND lb.dpcode = p_dpcode
	AND lb.codsg in (select codsg from struct_info si
			where si.coddir = p_dirme)
	AND lb.clicode=cm.clicode
	AND cm.clidir = p_dirmo
	AND lb.arctype = 'T1'
	AND lb.dpcode <> 70000
	AND (RTRIM(lb.typproj)='1'
                    OR RTRIM(lb.typproj)='2'
                    OR RTRIM(lb.typproj)='3'
                    OR RTRIM(lb.typproj)='4')
	;
--******************

--*******************************************
--cas 5 : tous les metiers, toutes les directions fournisseur
CURSOR cur_5 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE lb.icpi = p_icpi
	AND lb.clicode=cm.clicode
	AND cm.clidir = p_dirmo
	AND lb.arctype = 'T1'
	AND lb.dpcode <> 70000
	AND (RTRIM(lb.typproj)='1'
                    OR RTRIM(lb.typproj)='2'
                    OR RTRIM(lb.typproj)='3'
                    OR RTRIM(lb.typproj)='4')
	;
--******************

--*******************************************
--cas 6 : toutes les directions fournisseur d'un projet
CURSOR cur_6 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE lb.metier = p_metier
	AND lb.icpi = p_icpi
	AND lb.clicode=cm.clicode
	AND cm.clidir = p_dirmo
	AND lb.arctype = 'T1'
	AND lb.dpcode <> 70000
	AND (RTRIM(lb.typproj)='1'
                    OR RTRIM(lb.typproj)='2'
                    OR RTRIM(lb.typproj)='3'
                    OR RTRIM(lb.typproj)='4')
	;
--******************

--*******************************************
--cas 7 : tous les metiers
CURSOR cur_7 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE lb.icpi = p_icpi
	AND lb.codsg in (select codsg from struct_info si
			where si.coddir = p_dirme)
	AND lb.clicode=cm.clicode
	AND cm.clidir = p_dirmo
	AND lb.dpcode <> 70000
	AND (RTRIM(lb.typproj)='1'
                    OR RTRIM(lb.typproj)='2'
                    OR RTRIM(lb.typproj)='3'
                    OR RTRIM(lb.typproj)='4')
        AND lb.arctype = 'T1'
	;
--******************

--*******************************************
--cas 8 : on a tous les parametres renseignes

	CURSOR cur_8 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE lb.metier = p_metier
	AND lb.icpi = p_icpi
	AND lb.codsg in (select codsg from struct_info si
			where si.coddir = p_dirme)
	AND lb.clicode=cm.clicode
	AND cm.clidir = p_dirmo
	AND lb.dpcode <> 70000
	AND (RTRIM(lb.typproj)='1'
                    OR RTRIM(lb.typproj)='2'
                    OR RTRIM(lb.typproj)='3'
                    OR RTRIM(lb.typproj)='4')
        AND lb.arctype = 'T1'
	;

--******************

BEGIN
	-- recuperation de la date courante
	BEGIN
	 SELECT TO_NUMBER(TO_CHAR(datdebex,'YYYY')) INTO l_annee FROM datdebex;

     	 EXCEPTION
        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);
	END;

	l_user := SUBSTR(pack_global.lire_globaldata(p_userid).idarpege, 1, 30);

-- on appelle un curseur en fonction des parametres passes
	BEGIN
		-- cas 1 : tous les projets - toutes les directions fournisseur - tous les metiers
		IF p_icpi=' TOUS' AND p_dirme=' TOUS' AND p_metier=' TOUS'
		THEN
			begin

				begin
        		OPEN cur_1;
         		FETCH cur_1 INTO l_num_vide;
         		l_bool_vide := cur_1%NOTFOUND;
        	CLOSE cur_1;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_1 LOOP
		BEGIN
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		EXCEPTION
            	WHEN NO_DATA_FOUND THEN
	      		pack_global.recuperer_message(20508, '%s1', '', NULL, msg);
          		raise_application_error(-20508, msg);
          		p_message:=msg;
	        WHEN OTHERS THEN
                	raise_application_error( -20997, SQLERRM);
		END;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime=0 )
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,DPCODE,ICPI,METIER,DIR_ME,DIR_MO,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_dpcode,p_icpi,p_metier,p_dirme,p_dirmo,'Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;

	--cas 2 : tous les projets - toutes les directions fournisseur
	ELSIF p_icpi=' TOUS' AND p_dirme=' TOUS' THEN
		begin

			begin
        		OPEN cur_2;
         	FETCH cur_2 INTO l_num_vide;
         	l_bool_vide := cur_2%NOTFOUND;
        	CLOSE cur_2;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_2 LOOP
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		COMMIT;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime = 0)
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,DPCODE,ICPI,METIER,DIR_ME,DIR_MO,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_dpcode,p_icpi,p_metier,p_dirme,p_dirmo,'Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;

	--cas 3 : tous les projets - tous les metiers
	ELSIF p_icpi=' TOUS' AND p_metier=' TOUS' THEN
		begin

			begin
        		OPEN cur_3;
         	FETCH cur_3 INTO l_num_vide;
         	l_bool_vide := cur_3%NOTFOUND;
        	CLOSE cur_3;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_3 LOOP
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		COMMIT;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime = 0)
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,DPCODE,ICPI,METIER,DIR_ME,DIR_MO,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_dpcode,p_icpi,p_metier,p_dirme,p_dirmo,'Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;

	--cas 4 : tous les projets (donc on se base sur le dossier projet pour faire la selection)
	ELSIF p_icpi=' TOUS'  THEN
		begin

			begin
        		OPEN cur_4;
         	FETCH cur_4 INTO l_num_vide;
         	l_bool_vide := cur_4%NOTFOUND;
        	CLOSE cur_4;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_4 LOOP
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		COMMIT;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime = 0)
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,DPCODE,ICPI,METIER,DIR_ME,DIR_MO,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_dpcode,p_icpi,p_metier,p_dirme,p_dirmo,'Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;

	--cas 5 : tous les metiers, toutes les directions fournisseur
	ELSIF p_icpi <>' TOUS' AND p_dirme=' TOUS' AND p_metier=' TOUS' THEN
		begin

			begin
        		OPEN cur_5;
         	FETCH cur_5 INTO l_num_vide;
         	l_bool_vide := cur_5%NOTFOUND;
        	CLOSE cur_5;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_5 LOOP
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		COMMIT;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime= 0)
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,DPCODE,ICPI,METIER,DIR_ME,DIR_MO,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_dpcode,p_icpi,p_metier,p_dirme,p_dirmo,'Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;

	--cas 6 : toutes les directions fournisseur d'un projet
		ELSIF p_icpi <> ' TOUS' AND p_dirme=' TOUS' AND p_metier <> ' TOUS' THEN
		begin

			begin
        		OPEN cur_6;
         	FETCH cur_6 INTO l_num_vide;
         	l_bool_vide := cur_6%NOTFOUND;
        	CLOSE cur_6;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_6 LOOP
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		COMMIT;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime=0 )
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,DPCODE,ICPI,METIER,DIR_ME,DIR_MO,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_dpcode,p_icpi,p_metier,p_dirme,p_dirmo,'Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;

	--cas 7 : tous les metiers d'un projet
		ELSIF p_icpi <>' TOUS' AND p_metier=' TOUS' THEN
		begin
			begin
        		OPEN cur_7;
         	FETCH cur_7 INTO l_num_vide;
         	l_bool_vide := cur_7%NOTFOUND;
        	CLOSE cur_7;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;
		FOR curseur IN cur_7 LOOP
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		COMMIT;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime=0 )
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,DPCODE,ICPI,METIER,DIR_ME,DIR_MO,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_dpcode,p_icpi,p_metier,p_dirme,p_dirmo,'Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;

	--cas 8 : on a tous les parametres renseignes
	ELSE
		begin

	begin
        OPEN cur_8;
         FETCH cur_8 INTO l_num_vide;
         l_bool_vide := cur_8%NOTFOUND;
        CLOSE cur_8;
        IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        end;

	FOR curseur IN cur_8 LOOP
		begin
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;


		END;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime=0 )
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,DPCODE,ICPI,METIER,DIR_ME,DIR_MO,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_dpcode,p_icpi,p_metier,p_dirme,p_dirmo,'Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

	END LOOP;
		end;
	END IF;

pack_global.recuperer_message(21029,NULL,NULL, NULL, msg);
p_message := msg;

END;

END initbdg_grand_projet;


-- notification hors grands projets
PROCEDURE initbdg_hors_grand_projet (p_typeprojet	IN VARCHAR2,
				p_metier 	IN VARCHAR2,
				p_dirme 	IN VARCHAR2,
				p_dirmo_partie 	IN VARCHAR2,
				p_code_mo 	IN VARCHAR2,
				p_dirmo_entier 	IN VARCHAR2,
                               	p_userid       	IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2)
                               	IS
-- variables locales

    msg 	VARCHAR(1024);
    l_annee 	NUMBER(4);                       -- annee courante
    l_jour 	DATE;                       -- jour de la modif
    l_user	VARCHAR2(35);
    l_bool_vide 	BOOLEAN;
    l_num_vide  VARCHAR2(4);

    exc_vide 	EXCEPTION;
    concurrence EXCEPTION;
    PRAGMA 	EXCEPTION_INIT (concurrence, -00054);

--*******************************************
--cas 1 : toutes les directions fournisseur - tous les metiers
CURSOR cur_1 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE INSTR(to_number(p_typeprojet),to_number(lb.typproj)) > 0
	AND lb.clicode=cm.clicode
	AND cm.clidir = DECODE (nvl(p_dirmo_partie,'0'),'0',p_dirmo_entier,p_dirmo_partie)
	AND (nvl(p_code_mo,'0')= '0' OR cm.clicode = p_code_mo)
	AND lb.arctype <> 'T1'
	AND lb.dpcode <> 70000
	;

--*******************************************
--cas 2 : toutes les directions fournisseur
CURSOR cur_2 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE INSTR(to_number(p_typeprojet),to_number(lb.typproj)) > 0
	AND lb.clicode=cm.clicode
	AND cm.clidir = DECODE (nvl(p_dirmo_partie,'0'),'0',p_dirmo_entier,p_dirmo_partie)
	AND lb.metier = p_metier
	AND lb.arctype <> 'T1'
	AND lb.dpcode <> 70000
	;

--*******************************************
--cas 3 : tous les parametres definis
CURSOR cur_3 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE INSTR(to_number(p_typeprojet),to_number(lb.typproj)) > 0
	AND lb.clicode=cm.clicode
	AND cm.clidir = DECODE (nvl(p_dirmo_partie,'0'),'0',p_dirmo_entier,p_dirmo_partie)
	AND lb.metier = p_metier
	AND lb.codsg in (select codsg from struct_info si
			where si.coddir = p_dirme)
	AND lb.arctype <> 'T1'
	AND lb.dpcode <> 70000
	;

--*******************************************
--cas 4 : tous les metiers
CURSOR cur_4 IS
	SELECT 	lb.pid
	FROM ligne_bip lb,client_mo cm
	WHERE INSTR(to_number(p_typeprojet),to_number(lb.typproj)) > 0
	AND lb.clicode=cm.clicode
	AND cm.clidir = DECODE (nvl(p_dirmo_partie,'0'),'0',p_dirmo_entier,p_dirmo_partie)
	AND lb.codsg in (select codsg from struct_info si
			where si.coddir = p_dirme)
	AND lb.arctype <> 'T1'
	AND lb.dpcode <> 70000
	;

BEGIN
	-- recuperation de la date courante
	BEGIN
	 SELECT TO_NUMBER(TO_CHAR(datdebex,'YYYY')) INTO l_annee FROM datdebex;

     	 EXCEPTION
        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);
	END;

	l_user := SUBSTR(pack_global.lire_globaldata(p_userid).idarpege, 1, 30);

-- on appelle un curseur en fonction des parametres passes
	BEGIN
		-- cas 1 : tous les projets - toutes les directions fournisseur - tous les metiers
		IF p_dirme=' TOUS' AND p_metier=' TOUS'
		THEN
		BEGIN
		begin
        		OPEN cur_1;
         		FETCH cur_1 INTO l_num_vide;
         		l_bool_vide := cur_1%NOTFOUND;
        	CLOSE cur_1;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_1 LOOP
		BEGIN
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		EXCEPTION
            	WHEN NO_DATA_FOUND THEN
	      		pack_global.recuperer_message(20508, '%s1', '', NULL, msg);
          		raise_application_error(-20508, msg);
	        WHEN OTHERS THEN
                	raise_application_error( -20997, SQLERRM);
		END;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime=0 )
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,METIER,DIR_ME,DIR_MO,CLICODE,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_metier,p_dirme,p_dirmo_partie||p_dirmo_entier,p_code_mo,'Hors Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;


		END LOOP;
		end;

		-- cas 2 : toutes les directions fournisseur
	ELSIF p_dirme=' TOUS'
		THEN
		BEGIN
			begin
        		OPEN cur_2;
         		FETCH cur_2 INTO l_num_vide;
         		l_bool_vide := cur_2%NOTFOUND;
        	CLOSE cur_2;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_2 LOOP
		BEGIN
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		EXCEPTION
            	WHEN NO_DATA_FOUND THEN
	      		pack_global.recuperer_message(20508, '%s1', '', NULL, msg);
          		raise_application_error(-20508, msg);
	        WHEN OTHERS THEN
                	raise_application_error( -20997, SQLERRM);
		END;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime=0 )
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,METIER,DIR_ME,DIR_MO,CLICODE,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_metier,p_dirme,p_dirmo_partie||p_dirmo_entier,p_code_mo,'Hors Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;


		END LOOP;
		end;

		-- cas 3 : tous les parametres renseignes
	ELSIF p_dirme <> ' TOUS' AND p_metier <> ' TOUS'
		THEN
		BEGIN
		begin
        	OPEN cur_3;
         	FETCH cur_3 INTO l_num_vide;
         		l_bool_vide := cur_3%NOTFOUND;
        	CLOSE cur_3;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_3 LOOP
		BEGIN
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		EXCEPTION
            	WHEN NO_DATA_FOUND THEN
	      		pack_global.recuperer_message(20508, '%s1', '', NULL, msg);
          		raise_application_error(-20508, msg);
	        WHEN OTHERS THEN
                	raise_application_error( -20997, SQLERRM);
		END;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime=0 )
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,METIER,DIR_ME,DIR_MO,CLICODE,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_metier,p_dirme,p_dirmo_partie||p_dirmo_entier,p_code_mo,'Hors Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;

		-- cas 4 : tous les metiers
	ELSIF p_dirme <> ' TOUS' AND p_metier = ' TOUS'
		THEN
		BEGIN
		begin
        	OPEN cur_4;
         	FETCH cur_4 INTO l_num_vide;
         		l_bool_vide := cur_4%NOTFOUND;
        	CLOSE cur_4;
        	IF l_bool_vide THEN
          	raise exc_vide;
        	END IF;

      		EXCEPTION
        	WHEN exc_vide THEN
          	pack_global.recuperer_message(20508, '%s1', 'avec ces paramètres', NULL, msg);
          	raise_application_error(-20508, msg);

          	p_message:=msg;
        	end;

		FOR curseur IN cur_4 LOOP
		BEGIN
		UPDATE budget b SET
			bnmont	= bpmontmo,
	    		anmont	= bpmontmo,
	    		apmont	= bpmontmo
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
                AND b.bpmontmo IS NOT NULL
                AND b.bnmont IS NULL
                AND b.anmont IS NULL
                AND b.apmont IS NULL
                ;
       		EXCEPTION
            	WHEN NO_DATA_FOUND THEN
	      		pack_global.recuperer_message(20508, '%s1', '', NULL, msg);
          		raise_application_error(-20508, msg);
	        WHEN OTHERS THEN
                	raise_application_error( -20997, SQLERRM);
		END;

       		UPDATE budget b SET
			reestime = bpmontme
		WHERE pid	= curseur.pid
		AND b.annee = l_annee
		AND b.bpmontme IS NOT NULL
                AND ( b.reestime is null or b.reestime=0 )
                ;
       		COMMIT;

       		begin
       			-- alimentation de la table de logs
		INSERT INTO NOTIFICATION_LOGS (NOTIFIE,REESTIME,PID,DATE_LOG,USER_LOG,METIER,DIR_ME,DIR_MO,CLICODE,TYPE_NOTIF)
		(SELECT distinct bpmontmo,bpmontme,pid,sysdate,l_user,p_metier,p_dirme,p_dirmo_partie||p_dirmo_entier,p_code_mo,'Hors Grand Projet' from budget
		where pid=curseur.pid
		and annee=l_annee)
		;
		EXCEPTION
        	WHEN OTHERS THEN
          	raise_application_error( -20997, SQLERRM);
          	end;

		END LOOP;
		end;
	END IF;


pack_global.recuperer_message(21029,NULL,NULL, NULL, msg);
p_message := msg;

END;
END initbdg_hors_grand_projet;



-- notification pour les lignes de type 9
PROCEDURE initbdg_type_9 (	p_dirme 	IN VARCHAR2,
			     	p_userid       	IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2)
                               	IS
-- variables locales

    l_annee 	NUMBER(4);                  -- annee courante
    l_moismens  DATE ;						-- mois de la mensuelle
    l_notifie  NUMBER (12,2);               -- notifié à répartir
    l_codrep   RJH_TABREPART.CODREP%TYPE ;  -- table de répartition
    l_taux  NUMBER (6,5);

    exc_vide 	EXCEPTION;
    concurrence EXCEPTION;
    PRAGMA 	EXCEPTION_INIT (concurrence, -00054);

    -- Recherche la somme des notifiés de toutes les lignes d'origine
    -- qui pointent sur des tables de répartition actives
	CURSOR cur_origine IS
	SELECT SUM(nvl(bud.bnmont,0)) notifie ,
	rjh.codrep codrep
	FROM BUDGET bud , LIGNE_BIP lb , RJH_TABREPART rjh
	WHERE bud.annee = l_annee
	AND lb.pid = bud.pid
	AND lb.typproj != 9
	AND lb.codrep = rjh.codrep
	AND rjh.coddir = p_dirme
	AND rjh.flagactif = 'O'
	GROUP BY rjh.codrep ;

    CURSOR cur_not IS
	SELECT distinct
	det.pid,
	det.tauxrep taux
	FROM RJH_TABREPART_DETAIL det, datdebex d
	WHERE det.codrep = l_codrep
	AND det.typtab = 'P'
	AND det.moisrep = d.moismens
	;


	BEGIN

	-- recuperation de la date courante
	BEGIN
 	SELECT TO_NUMBER(TO_CHAR(datdebex,'YYYY')), moismens INTO l_annee,l_moismens FROM datdebex;

 	 	EXCEPTION
    	WHEN OTHERS THEN
      	raise_application_error( -20997, SQLERRM);
	END;

    -- Remet à zero tous les notifiés des lignes T9 de la direction
    UPDATE BUDGET
    SET  bnmont = 0, anmont = 0, apmont = 0, bpdate = sysdate, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
    WHERE  pid IN ( SELECT pid FROM LIGNE_BIP
                    WHERE typproj = 9
                    AND codsg IN ( SELECT codsg FROM STRUCT_INFO
                    			   WHERE coddir = p_dirme
					           	 )
					)
	AND annee = l_annee
	;
    COMMIT;


	-- Boucle pour chaque table de répartition
	FOR origine IN cur_origine LOOP

		-- Sauve les valeurs de travail
		l_notifie := origine.notifie ;
		l_codrep  := origine.codrep ;

		-- boucle sur toutes les lignes de répartition de cette table
		FOR curseur IN cur_not LOOP
		BEGIN

			-- Met à jour le notifié , l'arbitré et l'arbitre proposé ( ne sert plus ?)
			-- On somme les valeurs car une ligne de type 9 appartient à plusieurs tables
			-- de répartition
			UPDATE BUDGET
			SET bnmont = bnmont + l_notifie * curseur.taux,
				anmont = anmont + l_notifie * curseur.taux,
				apmont = apmont + l_notifie * curseur.taux
			WHERE pid = curseur.pid
			AND annee = l_annee ;

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
			-- Si on n'a pas trouvé de budget - on crée la ligne
			INSERT INTO BUDGET (PID,ANNEE,BNMONT,ANMONT,APMONT,FLAGLOCK)
	        VALUES(curseur.pid,l_annee,(l_notifie * curseur.taux),(l_notifie * curseur.taux),(l_notifie * curseur.taux),0);
		END ;

		COMMIT;
		END LOOP ;

	END LOOP;

	COMMIT;


    EXCEPTION
		   WHEN OTHERS THEN
		        ROLLBACK;
	   		RAISE_APPLICATION_ERROR( -20997, SQLERRM);

END initbdg_type_9;

END pack_initbdg;
/
CREATE OR REPLACE PACKAGE     pack_investissement AS

   TYPE investissement_ViewType IS RECORD ( cod_type   	VARCHAR2(4),
					 	                    lib_type    investissements.lib_type%TYPE,
                                  	 	    cod_poste    VARCHAR2(4),
                                            lib_poste   poste.lib_poste%TYPE,
                                  	 	    cod_nature  	VARCHAR2(4),
                                            lib_nature  nature.lib_nature%TYPE,
					 	                    flaglock   	investissements.flaglock%TYPE
						                   );

   TYPE investissementCurType IS REF CURSOR RETURN investissement_ViewType;


   PROCEDURE insert_investissement (p_type  in VARCHAR2,
 	                     p_lib_type  in investissements.lib_type%TYPE,
                         p_poste     in VARCHAR2,
                         p_nature    in VARCHAR2,
 	                     p_flaglock  in investissements.flaglock%TYPE,
                         p_message   out VARCHAR2
                                 );

   PROCEDURE update_investissement (p_type     	in VARCHAR2,
					 	            p_lib_type  in investissements.lib_type%TYPE,
                                  	p_poste    	in VARCHAR2,
                                  	p_nature    in VARCHAR2,
					 	            p_flaglock  in investissements.flaglock%TYPE,
                                  	p_message   out VARCHAR2
                              );

   PROCEDURE delete_investissement ( p_type    in VARCHAR2,
                                     p_lib_type  in VARCHAR2,
                                     p_flaglock  in investissements.flaglock%TYPE,
                                     p_message out VARCHAR2
                                   );

   PROCEDURE select_investissement_c ( p_type     in VARCHAR2,
                                     p_curseur IN OUT investissementCurType,
                                     p_message  out VARCHAR2
                                );

   PROCEDURE select_investissement_m ( p_type     in VARCHAR2,
                                     p_curseur IN OUT investissementCurType,
                                     p_message  out VARCHAR2
                                );


END pack_investissement;
/

CREATE OR REPLACE PACKAGE BODY     pack_investissement AS

       PROCEDURE insert_investissement (p_type  in VARCHAR2,
                	                    p_lib_type  in investissements.lib_type%TYPE,
                                        p_poste     in VARCHAR2,
                                        p_nature    in VARCHAR2,
                	                    p_flaglock  in investissements.flaglock%TYPE,
                         p_message   out VARCHAR2
                                 ) IS
       l_msg VARCHAR2(1024);
       l_type investissements.CODTYPE%TYPE;

       BEGIN
          p_message := '';

          begin
            select codtype into l_type
            from investissements where codtype=to_number(p_type);

            -- test si le type d'investissement n'existe pas déjà.

            if(l_type is not null OR l_type != null) then
                pack_global.recuperer_message( 20968, '%s1', p_type, NULL, l_msg);
                p_message := l_msg;
                raise_application_error( -20968, l_msg );
            end if;

            EXCEPTION
            WHEN NO_DATA_FOUND THEN
               begin
                -- création du type d'investissement
                insert into investissements(codtype, lib_type, codposte, codnature, flaglock)
                values
                (p_type,
                 p_lib_type,
                 p_poste,
                 p_nature,
                 0
                );
                pack_global.recuperer_message(20971, '%s1', 'Code type d''investissement' || p_type, NULL, l_msg);
                p_message := l_msg;
              end;

            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
          end;

       END insert_investissement;

       /******************** PROCEDURE update_investissement ******************/

       PROCEDURE update_investissement (p_type     	in VARCHAR2,
					 	                p_lib_type  in investissements.lib_type%TYPE,
                                  	    p_poste    	in VARCHAR2,
                                  	    p_nature    in VARCHAR2,
					 	                p_flaglock  in investissements.flaglock%TYPE,
                                  	    p_message   out VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       l_type investissements.CODTYPE%TYPE;

       BEGIN
       p_message := '';

          -- test si le type d'investissement existe .

          begin
            select codtype into l_type
            from investissements where codtype=to_number(p_type);

            update investissements set
            lib_type = p_lib_type,
            codposte = to_number(p_poste),
            codnature = to_number(p_nature),
            flaglock 	= DECODE( p_flaglock, 1000000, 0, p_flaglock + 1 )
            where codtype 	= TO_NUMBER(p_type)
            and   flaglock 	= p_flaglock;

            -- 'Type d'investissement modifié
            pack_global.recuperer_message(20972, '%s1', 'Code type d''investissement ' || p_type, NULL, l_msg);
            p_message := l_msg;

            EXCEPTION
            WHEN NO_DATA_FOUND THEN
                pack_global.recuperer_message( 20969, '%s1', p_type, NULL, l_msg);
                p_message := l_msg;
                raise_application_error( -20969, l_msg );
            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

          end;

       END update_investissement;

       /******************** PROCEDURE delete_investissement ******************/

       PROCEDURE delete_investissement ( p_type  in VARCHAR2,
                                         p_lib_type  in VARCHAR2,
                                         p_flaglock  in investissements.flaglock%TYPE,
                                         p_message   out VARCHAR2
                                   )IS
       l_msg VARCHAR2(1024);
       referential_integrity EXCEPTION;
       PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

       BEGIN
          -- Initialiser le message retour
          p_message := '';

          begin
        	   DELETE FROM investissements
        		      WHERE codtype = TO_NUMBER(p_type)
        			  AND flaglock = p_flaglock;
               EXCEPTION
               WHEN referential_integrity THEN
               -- habiller le msg erreur
               --pack_global.recuperation_integrite(-2292);
               pack_global.recuperer_message( 20970, '%s1', p_type,'%s2','type d''investissement', NULL, l_msg);
               p_message := l_msg;
               raise_application_error( -20970, l_msg );
        	   WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
          end;

          IF SQL%NOTFOUND THEN
    	   -- 'Accès concurrent'
    	    pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
            raise_application_error( -20999, l_msg );
          ELSE
    	   -- 'Le type d'investissement p_type a été supprimé'
    	   pack_global.recuperer_message( 20973, '%s1', 'Code type d''investissement ' || p_type, NULL, l_msg);
          END IF;

          p_message := l_msg;

       END delete_investissement;

       /******************** PROCEDURE select_investissement ******************/

       PROCEDURE select_investissement_c ( p_type     in VARCHAR2,
                                         --p_userid         IN VARCHAR2,
                                         p_curseur IN OUT investissementCurType,
                                         p_message  out VARCHAR2
                                )IS
       l_msg VARCHAR2(1024);

       BEGIN

            OPEN   p_curseur FOR SELECT
                        TO_CHAR(codtype) as codtype,
                     	lib_type,
                     	TO_CHAR(inv.codposte) as codposte,
                        lib_poste,
                     	TO_CHAR(inv.codnature) as codnature,
                        lib_nature,
                        inv.flaglock
              FROM  investissements inv, poste po, nature nat
              WHERE codtype = TO_NUMBER(p_type)
              and inv.codposte = po.codposte
              and inv.codnature = nat.codnature;

              pack_global.recuperer_message( 20968, '%s1', p_type, NULL, l_msg);
              p_message := l_msg;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

       END select_investissement_c;

       PROCEDURE select_investissement_m ( p_type     in VARCHAR2,
                                         --p_userid         IN VARCHAR2,
                                         p_curseur IN OUT investissementCurType,
                                         p_message  out VARCHAR2
                                )IS
       l_msg VARCHAR2(1024);

       BEGIN

            OPEN   p_curseur FOR SELECT
                        TO_CHAR(codtype) as codtype,
                     	lib_type,
                     	TO_CHAR(inv.codposte) as codposte,
                        lib_poste,
                     	TO_CHAR(inv.codnature) as codnature,
                        lib_nature,
                        inv.flaglock
              FROM  investissements inv, poste po, nature nat
              WHERE codtype = TO_NUMBER(p_type)
              and inv.codposte = po.codposte
              and inv.codnature = nat.codnature;

              pack_global.recuperer_message( 20969, '%s1', p_type, NULL, l_msg);
              p_message := l_msg;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

       END select_investissement_m;


END pack_investissement;
/
CREATE OR REPLACE PACKAGE pack_isac AS


   PROCEDURE recuperer_message( 	p_id_msg        IN NUMBER,
                                	p_tag           IN VARCHAR2,
                                	p_replace_value IN VARCHAR2,
			       	p_focus         IN VARCHAR2,
	                        	p_msg           OUT VARCHAR2);

   PROCEDURE recuperer_message( 	p_id_msg         IN NUMBER,
                                	p_tag1           IN VARCHAR2,
                                	p_replace_value1 IN VARCHAR2,
                                	p_tag2           IN VARCHAR2,
                                	p_replace_value2 IN VARCHAR2,
			       	p_focus          IN VARCHAR2,
	                      	p_msg            OUT VARCHAR2);

   PROCEDURE recuperer_message( 	p_id_msg         IN NUMBER,
                                	p_tag1           IN VARCHAR2,
                                	p_replace_value1 IN VARCHAR2,
                                	p_tag2           IN VARCHAR2,
                                	p_replace_value2 IN VARCHAR2,
                                	p_tag3           IN VARCHAR2,
                                	p_replace_value3 IN VARCHAR2,
				p_focus          IN VARCHAR2,
	                        	p_msg            OUT VARCHAR2);


END pack_isac;
/

CREATE OR REPLACE PACKAGE BODY pack_isac AS


   PROCEDURE recuperer_message( 	p_id_msg        IN NUMBER,
                                	p_tag           IN VARCHAR2,
                                	p_replace_value IN VARCHAR2,
 			       	p_focus         IN VARCHAR2,
	                       	p_msg           OUT VARCHAR2
                              ) IS
      l_msgerr VARCHAR2(1024);
   BEGIN

   p_msg := NULL;
   l_msgerr := NULL;

   -- Récupération et enrichissement du message

      SELECT REPLACE( limsg, p_tag, p_replace_value) ||
             DECODE( p_focus, NULL,
                     NULL, 'FOCUS=' || p_focus)
      INTO   p_msg
      FROM   isac_message
      WHERE  id_msg = p_id_msg;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         l_msgerr := 'Code message '    ||
                     TO_CHAR( p_id_msg) ||
                     ' inexistant' ;

         raise_application_error( -20998, l_msgerr);

      WHEN OTHERS THEN
         raise_application_error( -20998, SQLERRM);

   END recuperer_message;


   PROCEDURE recuperer_message( 	p_id_msg         IN NUMBER,
                                	p_tag1           IN VARCHAR2,
                                	p_replace_value1 IN VARCHAR2,
                                	p_tag2           IN VARCHAR2,
                                	p_replace_value2 IN VARCHAR2,
			  	p_focus          IN VARCHAR2,
	                       	p_msg            OUT VARCHAR2
                              ) IS
      l_msgerr VARCHAR2(1024);
   BEGIN

   p_msg := NULL;
   l_msgerr := NULL;

   -- Récupération et enrichissement du message

      SELECT REPLACE( REPLACE( limsg, p_tag1, p_replace_value1),
                      p_tag2, p_replace_value2) ||
             DECODE( p_focus, NULL,
                     NULL, 'FOCUS=' || p_focus)
      INTO   p_msg
      FROM   isac_message
      WHERE  id_msg = p_id_msg;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         l_msgerr := 'Code message '    ||
                     TO_CHAR( p_id_msg) ||
                     ' inexistant' ;

         raise_application_error( -20998, l_msgerr);

      WHEN OTHERS THEN
         raise_application_error( -20998, SQLERRM);

   END recuperer_message;

   PROCEDURE recuperer_message( 	p_id_msg         IN NUMBER,
                                	p_tag1           IN VARCHAR2,
                                	p_replace_value1 IN VARCHAR2,
                                	p_tag2           IN VARCHAR2,
                                	p_replace_value2 IN VARCHAR2,
                                	p_tag3           IN VARCHAR2,
                                	p_replace_value3 IN VARCHAR2,
				p_focus          IN VARCHAR2,
	                     	p_msg            OUT VARCHAR2
                              ) IS
      l_msgerr VARCHAR2(1024);
   BEGIN

   p_msg := NULL;
   l_msgerr := NULL;

   -- Récupération et enrichissement du message

      SELECT REPLACE( REPLACE( REPLACE( limsg,
                                        p_tag1,
                                        p_replace_value1),
                               p_tag2,
                               p_replace_value2),
                       p_tag3,
                       p_replace_value3) ||
             DECODE( p_focus, NULL,
                     NULL, 'FOCUS=' || p_focus)
      INTO   p_msg
      FROM   isac_message
      WHERE  id_msg = p_id_msg;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         l_msgerr := 'Code message '    ||
                     TO_CHAR( p_id_msg) ||
                     ' inexistant' ;

         raise_application_error( -20998, l_msgerr);

      WHEN OTHERS THEN
         raise_application_error( -20998, SQLERRM);

   END recuperer_message;



END pack_isac;
/
CREATE OR REPLACE PACKAGE pack_isac_affectation AS
PROCEDURE insert_affectation (	p_ident		IN VARCHAR2,
				p_pid		IN isac_affectation.pid%TYPE,
				p_sous_tache 	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                      		p_message    	OUT VARCHAR2
			);


PROCEDURE select_affectation (	p_ident		IN VARCHAR2,
				p_pid		IN isac_affectation.pid%TYPE,
				p_userid     	IN VARCHAR2,
				p_ressourceout  OUT VARCHAR2,
				p_ligneout	OUT VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                      		p_message    	OUT VARCHAR2
			);

PROCEDURE delete_affectation ( 	p_ident		IN VARCHAR2,
				p_sous_tache	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                      		p_message    	OUT VARCHAR2
			);
PROCEDURE select_stressource (	p_ident		IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_ressourceout  OUT VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                      		p_message    	OUT VARCHAR2
			);

END pack_isac_affectation;
/

CREATE OR REPLACE PACKAGE BODY pack_isac_affectation AS
--*************************************************************************************************
-- Procédure insert_affectation
--
-- Permet d'affecter une sous-tache à la ressource
--
-- Appelée dans la page iaffect.htm
--
-- ************************************************************************************************

PROCEDURE insert_affectation (	p_ident		IN VARCHAR2,
				p_pid		IN isac_affectation.pid%TYPE,
				p_sous_tache 	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                      		p_message    	OUT VARCHAR2
			) IS
l_pos1 NUMBER(10);
l_pos2 NUMBER(10);
l_etape NUMBER(10);
l_tache NUMBER(10);
l_sous_tache NUMBER(10);
libstache VARCHAR2(35);
BEGIN
  p_nbcurseur := 0;
  p_message:='';

	-- p_sous_tache est de la forme "etape-tache-sous_tache"
	l_pos1 := INSTR(p_sous_tache,'-',1,1);
	l_pos2 := INSTR(p_sous_tache,'-',1,2);
	l_etape := SUBSTR(p_sous_tache,1,l_pos1-1);
	l_tache := TO_NUMBER( SUBSTR(p_sous_tache,l_pos1+1,l_pos2-l_pos1-1));
	l_sous_tache := TO_NUMBER( SUBSTR(p_sous_tache,l_pos2+1,LENGTH(p_sous_tache)-l_pos2+1));

if l_tache IS NULL then
		pack_isac.recuperer_message(20014, null,null,null, p_message);
        	raise_application_error(-20014,p_message);
end if;


	insert into isac_affectation (ident,pid,etape,tache,sous_tache)
	values (to_number(p_ident),p_pid,l_etape,l_tache,l_sous_tache);

	commit;
	--message 20012, 'La sous-tâche %s1 a été affectéé à la ressource %s2'
	select asnom into libstache
	from isac_sous_tache
	where sous_tache=l_sous_tache;

	pack_isac.recuperer_message(20012, '%s1',libstache,'%s2',p_ident,NULL, p_message);

EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
	-- la sous-tâche a déjà été affectée à cette ressource
		pack_isac.recuperer_message(20004, null,null,null, p_message);
        		raise_application_error(-20004,p_message);
END insert_affectation;

--*************************************************************************************************
-- Procédure select_affectation
--
-- Permet de vérifier que le code ressource, la ligne BIP et sa clé existent et
-- d'afficher les données de la ressource et de la ligne BIP
-- Appelée dans la page icaffect.htm
--
-- ************************************************************************************************
PROCEDURE select_affectation (	p_ident		IN VARCHAR2,
				p_pid		IN isac_affectation.pid%TYPE,
				p_userid     	IN VARCHAR2,
				p_ressourceout  OUT VARCHAR2,
				p_ligneout	OUT VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                      		p_message    	OUT VARCHAR2
			) IS
l_rnom VARCHAR2(100);

BEGIN
  p_nbcurseur := 0;
  p_message:='';
	--Vérifier l'existence du code ressource
	BEGIN

		select rnom||' '||rprenom into l_rnom
		from ressource
		where ident=to_number(p_ident);

	p_ressourceout := l_rnom||' - '||p_ident;

		select PID||' - '||PNOM into p_ligneout
		from LIGNE_BIP where PID=p_pid;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		-- Message : ressource inexistante
		pack_global.recuperer_message(20131, '%s1', p_ident,'IDENT', p_message);
        		raise_application_error(-20131,p_message);
	END;


END select_affectation;
--*************************************************************************************************
-- Procédure delete_affectation
--
-- Permet de supprimer l'affectation de la sous-tâche à la ressource et les consommés associés
-- Appelée dans la page ilaffect.htm à partir du bouton "Supprimer"
--
-- ************************************************************************************************
PROCEDURE delete_affectation ( 	p_ident		IN VARCHAR2,
				p_sous_tache	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                      		p_message    	OUT VARCHAR2
			) IS
l_pos1 NUMBER(10);
l_pos2 NUMBER(10);
l_pos3 NUMBER(10);
l_pid ligne_bip.pid%TYPE;
l_etape NUMBER(10);
l_tache NUMBER(10);
l_sous_tache NUMBER(10);
l_libstache VARCHAR2(50);
l_rnom VARCHAR2(30);
l_moismens datdebex.moismens%TYPE;
l_adatestatut ligne_bip.adatestatut%TYPE;
l_pid_ff ligne_bip.pid%TYPE;
l_anneecourante VARCHAR2(4);
l_conso NUMBER;


BEGIN
  p_nbcurseur := 0;
  p_message:='';

  --on recupere l annee courante
  	select to_char(datdebex,'YYYY') into  l_anneecourante
        from datdebex;

  -- p_sous_tache est de la forme "pid-etape-tache-sous_tache"
	l_pos1 := INSTR(p_sous_tache,'-',1,1);
	l_pos2 := INSTR(p_sous_tache,'-',1,2);
	l_pos3 := INSTR(p_sous_tache,'-',1,3);
	l_pid := SUBSTR(p_sous_tache,1,l_pos1-1);
	l_etape := TO_NUMBER( SUBSTR(p_sous_tache,l_pos1+1,l_pos2-l_pos1-1));
	l_tache := TO_NUMBER( SUBSTR(p_sous_tache,l_pos2+1,l_pos3-l_pos2-1));
	l_sous_tache :=TO_NUMBER( SUBSTR(p_sous_tache,l_pos3+1,LENGTH(p_sous_tache)-l_pos3+1));


 BEGIN

  --on verifie qu il n y a pas de consomme sur l annee
  	SELECT  nvl(sum(c.cusag),0) INTO l_conso
 	FROM isac_consomme c,isac_affectation a
 	WHERE c.sous_tache(+)=a.sous_tache
 	AND a.sous_tache=l_sous_tache
 	AND to_char(c.cdeb,'YYYY')=l_anneecourante
 	AND a.ident=to_number(p_ident)
 	AND a.ident=c.ident
	;
		if l_conso<>0 then
		pack_isac.recuperer_message(20031, NULL,NULL, NULL, p_message);
               	raise_application_error( -20031, p_message );
		end if;
  END;

  BEGIN

	select acst||'-'||asnom into l_libstache
	from isac_sous_tache
	where sous_tache=l_sous_tache;

	select rnom into l_rnom
	from ressource
	where ident=to_number(p_ident);

	delete isac_consomme
	where ident=to_number(p_ident)
	and sous_tache=l_sous_tache;

	delete isac_affectation
	where ident=to_number(p_ident)
	and sous_tache=l_sous_tache;

	commit;


	--Sous-tâche supprimée pour la ressource
	pack_isac.recuperer_message(20002, '%s1', 'Sous-tâche '''||l_libstache||''' affectée à la ressource '''||p_ident||' - '||l_rnom||'''', NULL, p_message);
  END;

END delete_affectation;

--*************************************************************************************************
-- Procédure select_stressource
--
-- Permet de vérifier l'existence du code ressource et d'afficher les données relatives à la ressource
-- Appelée dans la page igaffect.htm
--
-- ************************************************************************************************
PROCEDURE select_stressource (	p_ident		IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_ressourceout  OUT VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                      		p_message    	OUT VARCHAR2
			) IS

l_rnom VARCHAR2(50);
l_exist NUMBER;
BEGIN
  p_nbcurseur := 0;
  p_message:='';

  --Vérifier que la ressource existe dans la BIP
	select rnom||' '||rprenom into l_rnom
	from ressource
	where ident=to_number(p_ident);

	p_ressourceout := l_rnom||' - '||p_ident;

	--Vérifier si la ressource est déjà affectée au moins à une sous-tâche
	Begin
	select 1 into l_exist
	from isac_affectation
	where ident= to_number(p_ident)
	and rownum=1;

	Exception
	WHEN NO_DATA_FOUND THEN
	-- Aucune sous-tâche pour la ressource
		pack_isac.recuperer_message( 20005 , NULL, NULL, NULL,  p_message);
         	raise_application_error(-20005 , p_message);

	End;


EXCEPTION
	WHEN NO_DATA_FOUND THEN
	-- Message : ressource inexistante
	pack_global.recuperer_message(20131, '%s1', p_ident, NULL, p_message);
        raise_application_error(-20131,p_message);

END select_stressource;

END pack_isac_affectation;
/
CREATE OR REPLACE PACKAGE pack_isac_alimentation AS
PROCEDURE insert_pmw (P_LOGDIR in varchar2);

END pack_isac_alimentation;
/

CREATE OR REPLACE PACKAGE BODY pack_isac_alimentation AS
-- Gestions exceptions
-- -------------------
CALLEE_FAILED exception;
pragma exception_init( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !

PROCEDURE insert_pmw (P_LOGDIR in varchar2) IS


L_HFILE utl_file.file_type;
L_RETCOD number;
l_jj_carre number;
l_mm_carre number;
l_aa_carre number;
l_datedujour varchar2(10);
l_nextmens varchar2(10);
l_exist number;
l_tot_ligne number;
l_insert_ligne number;
l_exist_ligne number;
l_num_tp VERSION_TP.NUMTP%TYPE;

BEGIN
	-- Init de la trace
	-- ----------------

	L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , 'ISAC_ALIMENTATION', L_HFILE );

	if ( L_RETCOD <> 0 ) then
		raise_application_error( TRCLOG_FAILED_ID,
		                         'Erreur : Gestion du fichier LOG impossible',
		                         false );
	end if;

	-- Trace Start
	-- -----------
	TRCLOG.TRCLOG( L_HFILE, 'Debut du traitement ISAC' );

	-- Calcul du carré du jour,du mois et de l'année de traitement
	select	POWER(TO_NUMBER(TO_CHAR(sysdate,'dd')),2),
		POWER(TO_NUMBER(TO_CHAR(sysdate,'mm')),2),
		POWER(TO_NUMBER(TO_CHAR(sysdate,'yy')),2),
		to_char(sysdate,'dd/mm/yyyy'),
		to_char(cmensuelle,'dd/mm/yyyy')
		into l_jj_carre,l_mm_carre,l_aa_carre, l_datedujour, l_nextmens
	from datdebex;


---------------------------------------------------------------------------------------------------------
	-- ALIMENTATION DE PMW_LIGNE_BIP
---------------------------------------------------------------------------------------------------------
	TRCLOG.TRCLOG( L_HFILE, '---------------------------------------');
	TRCLOG.TRCLOG( L_HFILE, 'ALIMENTATION DE LA TABLE PMW_LIGNE_BIP');
	TRCLOG.TRCLOG( L_HFILE, '---------------------------------------');
	l_tot_ligne := 0;
	l_insert_ligne := 0;

	-- On initialise le numero de version de la remontee BIP
	SELECT numtp INTO l_num_tp
	FROM version_tp
	WHERE dattp IN (SELECT MAX(dattp) FROM version_tp)
	;

	-- On prend toutes les lignes BIP d'ISAC
	select count(distinct pid)  into l_insert_ligne
	from isac_etape
	where  pid not in (select pid from pmw_ligne_bip);

	insert into pmw_ligne_bip (pid,pmwbipvers,p_jj_carre,p_mm_carre,p_aa_carre)
	(select distinct pid ,l_num_tp,l_jj_carre,l_mm_carre,l_aa_carre
	from isac_etape
	where  pid not in (select pid from pmw_ligne_bip));


	--TRCLOG.TRCLOG( L_HFILE, 'Nombre Total de lignes BIP :'||l_tot_ligne);
	TRCLOG.TRCLOG( L_HFILE, l_insert_ligne ||' lignes insérées');


---------------------------------------------------------------------------------------------------------
	-- ALIMENTATION DE PMW_ACTIVITE
---------------------------------------------------------------------------------------------------------
	TRCLOG.TRCLOG( L_HFILE, '---------------------------------------');
	TRCLOG.TRCLOG( L_HFILE, 'ALIMENTATION DE LA TABLE PMW_ACTIVITE');
	TRCLOG.TRCLOG( L_HFILE, '---------------------------------------');
	l_insert_ligne := 0;

	-- On prend toutes les sous-tâches d'ISAC
	select count(distinct st.pid||e.ecet||t.acta||st.acst ) into l_insert_ligne
	from  isac_sous_tache st, isac_tache t, isac_etape e, datdebex d
	where   st.tache=t.tache
	and t.etape=e.etape
	and st.pid not in (select pid from pmw_activite );


	insert into pmw_activite (pid,acet,acta,acst,aiet,aist,asta,
				adeb,afin,ande,anfi,asnom,adur)
	(select distinct st.pid as PID, e.ecet ACET, t.acta ACTA, st.acst ACST,
			 e.typetape AIET, st.aist AIST, st.asta ASTA,st.adeb ADEB, st.afin AFIN,
			 st.ande ANDE, st.anfi ANFI,SUBSTR(st.asnom,1,15) ASNOM, st.adur ADUR
	from  isac_sous_tache st, isac_tache t, isac_etape e
	where   st.tache=t.tache
	and t.etape=e.etape
	and st.pid not in (select pid from pmw_activite ));


	--TRCLOG.TRCLOG( L_HFILE, 'Nombre Total de lignes à insérer:'||l_tot_ligne);
	TRCLOG.TRCLOG( L_HFILE, l_insert_ligne ||' lignes insérées');
	--TRCLOG.TRCLOG( L_HFILE, l_exist_ligne ||' lignes déjà existantes' );

---------------------------------------------------------------------------------------------------------
	-- ALIMENTATION DE PMW_AFFECTA
---------------------------------------------------------------------------------------------------------
	TRCLOG.TRCLOG( L_HFILE, '---------------------------------------');
	TRCLOG.TRCLOG( L_HFILE, 'ALIMENTATION DE LA TABLE PMW_AFFECTA');
	TRCLOG.TRCLOG( L_HFILE, '---------------------------------------');
	l_insert_ligne := 0;

	-- On prend toutes les affectations d'ISAC + cumul des consommés pour l'année en cours
	select count(1) into  l_insert_ligne
	from (select a.pid as PID, e.ecet TCET, t.acta TCTA, st.acst TCST,
		TO_CHAR(a.ident,'FM00000')||'*' TIRES,
		 sum(cusag) TACTU
	from isac_consomme c,isac_affectation a, isac_sous_tache st, isac_tache t, isac_etape e, datdebex d
	where   c.sous_tache=a.sous_tache
	and a.sous_tache=st.sous_tache
	and st.tache=t.tache
	and t.etape=e.etape
	and TRUNC(cdeb,'YEAR')= TRUNC(d.datdebex,'YEAR')
        and a.pid not in (select pid from pmw_affecta )
	group by a.pid,e.ecet,t.acta,st.acst,a.ident);


      	insert into pmw_affecta (pid,tcet,tcta,tcst,tires,tactu)
    	(select a.pid as PID, e.ecet TCET, t.acta TCTA, st.acst TCST,
		TO_CHAR(a.ident,'FM00000')||'*' TIRES,
		 sum(cusag) TACTU
	from isac_consomme c,isac_affectation a, isac_sous_tache st, isac_tache t, isac_etape e, datdebex d
	where   c.sous_tache=a.sous_tache
        and a.sous_tache=st.sous_tache
	and st.tache=t.tache
	and t.etape=e.etape
	and TRUNC(cdeb,'YEAR')= TRUNC(d.datdebex,'YEAR')
         and a.pid not in (select pid from pmw_affecta )
	group by a.pid,e.ecet,t.acta,st.acst,a.ident);


	TRCLOG.TRCLOG( L_HFILE, l_insert_ligne ||' lignes insérées');


---------------------------------------------------------------------------------------------------------
	-- ALIMENTATION DE PMW_CONSOMM
---------------------------------------------------------------------------------------------------------
	l_tot_ligne := 0;
	l_insert_ligne := 0;

	TRCLOG.TRCLOG( L_HFILE, '---------------------------------------');
	TRCLOG.TRCLOG( L_HFILE, 'ALIMENTATION DE LA TABLE PMW_CONSOMM');
	TRCLOG.TRCLOG( L_HFILE, '---------------------------------------');

	-- On prend tous les consommés d'ISAC pour l'année en cours
	select count(c.pid||e.ecet||t.acta||st.acst||
		TO_CHAR(c.ident,'FM00000')||TO_CHAR(c.cdeb,'YYYY/MM/DD') )
	into l_insert_ligne
	from isac_consomme c, isac_sous_tache st, isac_tache t, isac_etape e, datdebex d
	where  c.sous_tache=st.sous_tache
	and st.tache=t.tache
	and t.etape=e.etape
	and TRUNC(cdeb,'YEAR')= TRUNC(d.datdebex,'YEAR')
	and c.pid in (  select distinct pid from isac_consomme
			minus
			select distinct pid from pmw_consomm );


	insert into pmw_consomm (pid,ccet,ccta,ccst,cires,cdeb,cdur,cusag,chtyp)
	select c.pid as PID, e.ecet CCET, t.acta CCTA, st.acst CCST, TO_CHAR(c.ident,'FM00000')||'*' CIRES,
		c.cdeb CDEB, st.adur CDUR, c.cusag CUSAG,'1' CHTYP
	from isac_consomme c, isac_sous_tache st, isac_tache t, isac_etape e, datdebex d
	where c.sous_tache=st.sous_tache
	and st.tache=t.tache
	and t.etape=e.etape
	and TRUNC(cdeb,'YEAR')= TRUNC(d.datdebex,'YEAR')
	and c.pid in (  select distinct pid from isac_consomme
			minus
			select distinct pid from pmw_consomm );

	--TRCLOG.TRCLOG( L_HFILE, 'Nombre Total de lignes à insérer:'||l_tot_ligne);
	TRCLOG.TRCLOG( L_HFILE, l_insert_ligne ||' lignes insérées');


	-- Trace Stop
	-- ----------
	TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ISAC'  );
	TRCLOG.CLOSETRCLOG( L_HFILE );


	commit;
EXCEPTION
	WHEN OTHERS THEN
	  	ROLLBACK;
END insert_pmw;


END pack_isac_alimentation;
/
CREATE OR REPLACE PACKAGE Pack_Isac_Conso AS
TYPE ressource_ViewType IS RECORD ( 	IDENT     	VARCHAR2(5),
                                    	RESSOURCE     	VARCHAR2(100),
					MOIS 		VARCHAR2(7),
					NBMOIS 		NUMBER,
					KeyList4 	VARCHAR2(60),
					KeyList5 	VARCHAR2(7),
					KeyList6 	VARCHAR2(7)
                                     );

TYPE ressourceCurType IS REF CURSOR RETURN ressource_ViewType;


PROCEDURE update_conso_chaine(	p_chaine	IN VARCHAR2,
									   						  		  		 p_userid 	IN VARCHAR2,
                        									 				 p_nbcurseur     OUT INTEGER,
                        									 				 p_message       OUT VARCHAR2
															 				 );


PROCEDURE update_conso(	p_chaine1	IN VARCHAR2,
		  							   						 p_chaine2	IN VARCHAR2,
															 p_chaine3	IN VARCHAR2,
															 p_chaine4	IN VARCHAR2,
		  							   						 p_chaine5	IN VARCHAR2,
															 p_chaine6	IN VARCHAR2,
									   			             p_userid 	IN VARCHAR2,
                       	                                     p_nbcurseur     OUT INTEGER,
                                                             p_message       OUT VARCHAR2
			                                                ) ;



PROCEDURE select_ressource(	p_ident 	IN VARCHAR2,
			    	p_userid 	IN VARCHAR2,
			    	p_curressource 	IN OUT ressourceCurType,
			   	p_nbpages       OUT VARCHAR2,
                             	p_numpage       OUT VARCHAR2,
				p_menu		OUT VARCHAR2,
                             	p_nbcurseur     OUT INTEGER,
                             	p_message       OUT VARCHAR2
			);

 PROCEDURE annulation_conso(	p_chaine	IN VARCHAR2,
				p_userid 	IN VARCHAR2
			);


END Pack_Isac_Conso ;
/

CREATE OR REPLACE PACKAGE BODY Pack_Isac_Conso AS
--*************************************************************************************************
-- Procédure annulation_conso
--
-- Cette procédure sert à passer à l'écran igconso.htm lors d'une annulation
--
-- Appelée dans la page ilconso.htm
--
-- ************************************************************************************************
 PROCEDURE annulation_conso(	p_chaine	IN VARCHAR2,
				p_userid 	IN VARCHAR2
			) IS
 ligne VARCHAR2(30000);
 BEGIN
   ligne :='';
   --ligne :=p_chaine;
 END annulation_conso;
--*************************************************************************************************
-- Procédure update_conso
--
-- Permet de modifier les conso d'une ressource
--
-- Appelée dans la page ilconso.htm
--
-- ************************************************************************************************
PROCEDURE update_conso(	p_chaine1	IN VARCHAR2,
		  							   						 p_chaine2	IN VARCHAR2,
															 p_chaine3	IN VARCHAR2,
															 p_chaine4	IN VARCHAR2,
		  							   						 p_chaine5	IN VARCHAR2,
															 p_chaine6	IN VARCHAR2,
									   			             p_userid 	IN VARCHAR2,
                       	                                     p_nbcurseur     OUT INTEGER,
                                                             p_message       OUT VARCHAR2
			                                                ) IS
BEGIN


      IF(p_chaine1 IS NOT NULL)THEN
	                update_conso_chaine(	p_chaine1, p_userid, p_nbcurseur, p_message );

	  			    IF(p_chaine2 IS NOT NULL)THEN
						  	    update_conso_chaine(	p_chaine2, p_userid, p_nbcurseur, p_message );

	   							 IF(p_chaine3 IS NOT NULL)THEN
	  											 update_conso_chaine(	p_chaine3, p_userid, p_nbcurseur, p_message );

												   IF(p_chaine4 IS NOT NULL)THEN
	    			   								   				update_conso_chaine(	p_chaine4, p_userid, p_nbcurseur, p_message );

	  			    																	IF(p_chaine5 IS NOT NULL)THEN

	  							 																	 update_conso_chaine(	p_chaine5, p_userid, p_nbcurseur, p_message );

	   							 																	 IF(p_chaine6 IS NOT NULL)THEN
	  																								 			    update_conso_chaine(	p_chaine6, p_userid, p_nbcurseur, p_message );
												 												 	 END IF;
																						END IF;
	  													END IF;
								END IF;
					END IF;
	  END IF;


END 	update_conso;






PROCEDURE update_conso_chaine(	p_chaine	IN VARCHAR2,
											   								 p_userid 	IN VARCHAR2,
                        													 p_nbcurseur     OUT INTEGER,
                        													 p_message       OUT VARCHAR2
			) IS
l_msg VARCHAR2(500);
l_length NUMBER(7);
l_chaine VARCHAR2(32000);
l_pos NUMBER(7);
l_pos1 NUMBER(7);
i NUMBER(7);
l_ident VARCHAR2(5);
l_ligne VARCHAR2(32000);
l_pid LIGNE_BIP.pid%TYPE;
l_etape NUMBER(10);
l_tache NUMBER(10);
l_sous_tache NUMBER(10);
l_point1 NUMBER(7);
l_point2 NUMBER(7);
l_point3 NUMBER(7);
l_point4 NUMBER(7);
l_separateur NUMBER(7);
l_separateur1 NUMBER(7);
l_ligne_conso VARCHAR2(32000);
l_mois NUMBER(2);
l_conso VARCHAR2(100);
l_exist NUMBER(1);
l_annee VARCHAR2(4);
l_mois_saisie NUMBER(2);
l_datemens DATE;
l_count NUMBER(3);
l_rnom RESSOURCE.rnom%TYPE;
l_rprenom RESSOURCE.rprenom%TYPE;
l_mois_courant VARCHAR2(7);

BEGIN
p_message :='';
--p_chaine du type ':PID;ETAPE;TACHE;SOUS_TACHE;:PID1;ETAPE1;TACHE1;SOUS_TACHE1;'
	l_length := LENGTH(p_chaine);
	l_ident := SUBSTR(p_chaine,1,INSTR(p_chaine,':',1,1)-1);


	FOR i IN 1..l_length LOOP
		l_pos := INSTR(p_chaine,':',1,i);
		l_pos1 := INSTR(p_chaine,':',1,i+1);
		l_ligne := SUBSTR(p_chaine,l_pos+1,l_pos1-l_pos-1);
		l_point1 := INSTR(l_ligne,';',1,1);
		l_point2 := INSTR(l_ligne,';',1,2);
		l_point3 := INSTR(l_ligne,';',1,3);
		l_point4 := INSTR(l_ligne,';',1,4);

--dbms_output.put_line('ligne:'||l_ligne);

		l_pid := SUBSTR(l_ligne,1,l_point1-1);
		l_etape := TO_NUMBER(SUBSTR(l_ligne, l_point1+1, l_point2-l_point1-1));
		l_tache := TO_NUMBER(SUBSTR(l_ligne, l_point2+1, l_point3-l_point2-1));
		l_sous_tache := TO_NUMBER(SUBSTR(l_ligne, l_point3+1, l_point4-l_point3-1));


		FOR j IN 1..LENGTH(l_ligne) LOOP
			l_separateur := INSTR(l_ligne,';',l_point4,j);
			l_separateur1 := INSTR(l_ligne,';',l_point4,j+1);

			l_ligne_conso := SUBSTR(l_ligne,l_separateur+1,l_separateur1-l_separateur-1);


		--Rechercher le mois de consommé
			l_mois:=TO_NUMBER(SUBSTR(l_ligne_conso,INSTR(l_ligne_conso,'_',1,2)+1,INSTR(l_ligne_conso,'=',1,1)-INSTR(l_ligne_conso,'_',1,2)-1));


		--Rechercher le consommé
			l_conso:=SUBSTR(l_ligne_conso,INSTR(l_ligne_conso,'=',1,1)+1,LENGTH(l_ligne_conso)-INSTR(l_ligne_conso,'=',1,1));


		--Rechercher si la sous-tâche a déjà un consommé pour le mois
		   BEGIN
			SELECT TO_CHAR(DATDEBEX,'YYYY') INTO l_annee
			FROM DATDEBEX;

			SELECT 1 INTO l_exist
			FROM ISAC_CONSOMME
			WHERE ident=TO_NUMBER(l_ident)
			AND sous_tache=l_sous_tache
			AND TO_CHAR(cdeb,'MM/YYYY')=TO_CHAR(l_mois,'FM00')||'/'||l_annee;

			--Modifier le consommé si le consommé n'est pas nul
		   IF l_conso IS NOT NULL THEN
			UPDATE ISAC_CONSOMME
			SET cusag=TO_NUMBER(l_conso)
			WHERE ident=TO_NUMBER(l_ident)
			AND sous_tache=l_sous_tache
			AND TO_CHAR(cdeb,'MM/YYYY')=TO_CHAR(l_mois,'FM00')||'/'||l_annee;

		   ELSE
			DELETE ISAC_CONSOMME
			WHERE ident=TO_NUMBER(l_ident)
			AND sous_tache=l_sous_tache
			AND TO_CHAR(cdeb,'MM/YYYY')=TO_CHAR(l_mois,'FM00')||'/'||l_annee;

		   END IF;

	   		COMMIT;


	             EXCEPTION
			WHEN NO_DATA_FOUND THEN
			--pas de consommé pour la sous-tâche
			IF (l_conso!='' OR l_conso IS NOT NULL) THEN
			   --Ajouter le nouveau consommé
				INSERT INTO ISAC_CONSOMME (ident,pid,ETAPE,TACHE,sous_tache,cdeb,cusag)
				VALUES (TO_NUMBER(l_ident),l_pid,l_etape,l_tache,l_sous_tache,TO_DATE('01/'||TO_CHAR(l_mois,'FM00')||'/'||l_annee,'DD/MM/YYYY'),TO_NUMBER(l_conso));
			END IF;
		   END;

		IF (INSTR(l_ligne,';',l_point4,j+2)=0) THEN
				EXIT;
		END IF;
		END LOOP;

		IF (INSTR(p_chaine,':',1,i+2)=0) THEN
			EXIT;
		END IF;
	END LOOP;
	COMMIT;

END update_conso_chaine;


--*************************************************************************************************
-- Procédure select_ressource
--
-- Permet de vérifier l'existence de la ressource
--
-- Appelée dans la page igconso.htm
--
-- ************************************************************************************************
PROCEDURE select_ressource(	p_ident 	IN VARCHAR2,
			    		p_userid 	IN VARCHAR2,
			    		p_curressource 	IN OUT ressourceCurType,
			    		p_nbpages       OUT VARCHAR2,
                             			p_numpage       OUT VARCHAR2,
					p_menu		OUT VARCHAR2,
                             			p_nbcurseur     OUT INTEGER,
                             			p_message       OUT VARCHAR2
			) IS
l_count NUMBER(3);
l_nb_saisie NUMBER;
l_msg VARCHAR2(500);
l_cpident SITU_RESS_FULL.ident%TYPE;
l_datemens DATE;
l_annee DATE;
l_mois_saisie VARCHAR2(10);
l_nbmois NUMBER(2);
l_nbpages  NUMBER(5);
l_menu VARCHAR2(25);
BEGIN

p_numpage := 'NumPage#1';

-- Compter le nombre de sous-tâches pour la ressource
	SELECT COUNT(*) INTO l_count
	FROM ISAC_AFFECTATION
	WHERE ident=TO_NUMBER(p_ident);

 	l_nbpages := CEIL(l_count/10);
         p_nbpages := 'NbPages#'|| l_nbpages;

-- 19/12/2002 : nom du menu courant
	l_menu := Pack_Global.lire_globaldata(p_userid).menutil;
	p_menu := 'Menu#'||l_menu;

-- Nb de mois saisissables
	SELECT cmensuelle,DATDEBEX INTO l_datemens,l_annee
	FROM DATDEBEX;
	--l_mois_saisie := TO_NUMBER(TO_CHAR(ADD_MONTHS(l_datemens,-1),'MM'));

      l_mois_saisie :=TO_CHAR(ADD_MONTHS(l_datemens,-1),'MM/YYYY');
	  l_nbmois :=TO_NUMBER(TO_CHAR(ADD_MONTHS(l_datemens,-1),'MM'));


	  --on compte  le nombre de saisie apres le cmensuelle s'il y on a
	  SELECT COUNT(*) INTO l_nb_saisie
      FROM ISAC_CONSOMME
      WHERE ident=TO_NUMBER(p_ident)
	  AND TO_CHAR(cdeb,'yyyy') = TO_CHAR(l_datemens,'yyyy')
      AND TO_NUMBER(TO_CHAR(cdeb,'MM')) > TO_NUMBER(TO_CHAR(ADD_MONTHS(l_datemens,-1),'MM'));

	--s'il existe des consommés après  la cmensuelle on affiche toute l'année
	IF(l_nb_saisie <> 0)THEN
	   l_nbmois := 12;
	END IF;


	IF l_count=0 THEN
	-- Aucune sous-tâche pour la ressource
		Pack_Isac.recuperer_message( 20005 , NULL, NULL, NULL, l_msg);
         	RAISE_APPLICATION_ERROR(-20005 , l_msg); --On veut récupérer le menu si erreur dans frameisac.htm
	ELSE
	OPEN p_curressource  FOR
	SELECT 	IDENT,
	         	RNOM||' '||RPRENOM||' - '||IDENT RESSOURCE ,
		l_mois_saisie  MOIS,
		l_nbmois  NBMOIS,
		RNOM||' '||RPRENOM KeyList4,
		l_mois_saisie  KeyList5,
		TO_CHAR(l_count) KeyList6
	FROM RESSOURCE
	WHERE ident=TO_NUMBER(p_ident);
	END IF;

	 p_message := l_msg;

END select_ressource;



END Pack_Isac_Conso ;
/
CREATE OR REPLACE PACKAGE Pack_Isac_Copie AS


TYPE RefCurTyp IS REF CURSOR;

--*********************************************************************
-- Liste des lignes à copier : elles ont au moins une étape
-- *******************************************************************
   PROCEDURE lister_pid1( p_userid  IN VARCHAR2,
                          p_curseur IN OUT RefCurTyp
                             );
--*********************************************************************
-- Liste des lignes à renseigner : elles n'ont aucune étape
-- *******************************************************************
   PROCEDURE lister_pid2( p_userid  IN VARCHAR2,
                          p_curseur IN OUT RefCurTyp
                             );
--********************************************************************************************************************
-- Procédure de copie de la structure d'une ligne BIP vers une autre ligne BIP qui n'a aucune structure
-- paramètres : 	- p_pid1 : ligne BIP à copier
--			- p_pid2 : ligne BIP qui doît être renseigné
-- *******************************************************************************************************************
	PROCEDURE insert_struct ( p_pid1 	    IN LIGNE_BIP.pid%TYPE,
				              p_pid2     	IN LIGNE_BIP.pid%TYPE,
				  			  p_userid     	IN  VARCHAR2,
				  			  p_affecter    IN VARCHAR2,
                              p_message    	OUT VARCHAR2
                            );



--*********************************************************************
-- Liste des ressources origines
-- *******************************************************************
   PROCEDURE lister_ident1( p_userid  IN VARCHAR2,
                            p_curseur IN OUT RefCurTyp
                          );
--*********************************************************************
-- Liste des ressources déstinations
-- *******************************************************************
   PROCEDURE lister_ident2( p_userid  IN VARCHAR2,
                            p_curseur IN OUT RefCurTyp
                          );

--********************************************************************************************************************
-- Procédure de copie les affectations d'une ressource à une autre ressource
-- paramètres : 	- p_pid1 : ressource origine
--			        - p_pid2 : ressource déstination
-- *******************************************************************************************************************
PROCEDURE insert_affectation ( 	p_ident1     IN RESSOURCE.ident%TYPE,
							    p_ident2 	 IN RESSOURCE.ident%TYPE,
							    p_userid     IN  VARCHAR2,
							    p_message    OUT VARCHAR2
                              );





END Pack_Isac_Copie;
/

CREATE OR REPLACE PACKAGE BODY Pack_Isac_Copie AS
--*********************************************************************
-- Liste des lignes à copier : elles ont au moins une étape
-- *******************************************************************
   PROCEDURE lister_pid1(  p_userid  IN     VARCHAR2,
                           p_curseur IN OUT RefCurTyp
                             ) IS
l_lst_chefs_projets VARCHAR2(255);
req                               VARCHAR2(800);

BEGIN
        l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;


				 req := ' SELECT pid,pid||'' - ''||l.pnom   '
		         || '	FROM LIGNE_BIP l, DATDEBEX d  '
		         || '	WHERE  l.pcpi IN ('|| l_lst_chefs_projets ||')  '
	          	 || '   AND pid IN (SELECT pid FROM ISAC_ETAPE WHERE pid=l.pid) '
				 || '   AND (adatestatut > ADD_MONTHS(d.moismens,-1) OR adatestatut IS NULL ) '
				 || '	ORDER BY 1 ';


 OPEN p_curseur FOR   req;

END lister_pid1;

--*********************************************************************
-- Liste des lignes à renseigner : elles n'ont aucune étape
-- *******************************************************************
   PROCEDURE lister_pid2( 	p_userid  IN     VARCHAR2,
                                p_curseur IN OUT RefCurTyp
                             ) IS
l_lst_chefs_projets VARCHAR2(255);
req                               VARCHAR2(800);

BEGIN
        l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;


		 req := ' SELECT pid,pid||'' - ''||l.pnom   '
		         || '	FROM LIGNE_BIP l, DATDEBEX d  '
		         || '	WHERE  l.pcpi IN ('|| l_lst_chefs_projets ||')  '
	          	 || '   AND pid NOT IN (SELECT pid FROM ISAC_ETAPE WHERE pid=l.pid) '
				 || '   AND (adatestatut > ADD_MONTHS(d.moismens,-1) OR adatestatut IS  NULL ) '
				 || '	ORDER BY 1 ';


        OPEN p_curseur FOR   req;


END lister_pid2;


--********************************************************************************************************************
-- Procédure de copie de la structure d'une ligne BIP vers une autre ligne BIP qui n'a aucune structure
-- paramètres : 	- p_pid1 : ligne BIP à copier
--			- p_pid2 : ligne BIP qui doît être renseigné
-- *******************************************************************************************************************
PROCEDURE insert_struct ( 	p_pid1       IN LIGNE_BIP.pid%TYPE,
							p_pid2 	     IN LIGNE_BIP.pid%TYPE,
							p_userid     IN  VARCHAR2,
							p_affecter   IN VARCHAR2,
                            p_message    OUT VARCHAR2
                        )  IS
l_exist NUMBER(1);
BEGIN
	--On teste si la ligne à remplir n'a bien aucune structure
	BEGIN
	SELECT  DISTINCT 1 INTO l_exist
	FROM ISAC_ETAPE
	WHERE pid=p_pid2;

	IF (l_exist=1) THEN
		--La structure de la ligne %s1 n'est pas vide. Opération annulée
		Pack_Isac.recuperer_message(20018, '%s1',p_pid2, NULL,p_message);
               	RAISE_APPLICATION_ERROR( -20018,p_message);
	END IF;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN NULL;

	END;

	--copier les étapes de la ligne vers une ligne vide
	INSERT INTO ISAC_ETAPE ( ETAPE,
				 PID ,
				 ECET,
 				 LIBETAPE,
				 TYPETAPE,
 				 FLAGLOCK     )
	(SELECT  SEQ_ETAPE.NEXTVAL,
		p_pid2,
		ecet,
		libetape,
		typetape,
		0
	FROM ISAC_ETAPE WHERE pid=p_pid1);

	--copier les tâches de la ligne vers une ligne vide
	INSERT INTO ISAC_TACHE (TACHE,
				PID,
				ETAPE  ,
				ACTA ,
				LIBTACHE,
				FLAGLOCK)
	(SELECT  SEQ_TACHE.NEXTVAL,
		e2.pid,
		e2.ETAPE,
		t1.acta,
		t1.libtache,
		0
	FROM ISAC_TACHE t1, ISAC_ETAPE e1, ISAC_ETAPE e2
	 WHERE t1.ETAPE=e1.ETAPE
	AND e1.ecet=e2.ecet
	AND t1.pid=p_pid1
	AND e2.pid=p_pid2);

	--copier les sous-tâches de la ligne vers une ligne vide
	INSERT INTO ISAC_SOUS_TACHE (   SOUS_TACHE,
 					PID ,
 					ETAPE,
 					TACHE ,
 					ACST   ,
 					ASNOM ,
 					AIST   ,
 					ASTA    ,
 					ADEB   ,
 					AFIN   ,
 					ANDE ,
 					ANFI  ,
 					ADUR ,
 					FLAGLOCK       )
	(SELECT  SEQ_SOUS_TACHE.NEXTVAL,
		t2.pid,
		t2.ETAPE,
		t2.TACHE,
		st1.acst,
		asnom,
		aist,
		asta,
		adeb,
		afin,
		ande,
		anfi,
		adur,
		0
	FROM 	ISAC_SOUS_TACHE st1,
		 ISAC_TACHE t1, ISAC_TACHE t2 ,
		ISAC_ETAPE e1, ISAC_ETAPE e2
	WHERE e1.ecet=e2.ecet
		AND e1.ETAPE=t1.ETAPE
		AND e2.ETAPE=t2.ETAPE
		AND t1.acta=t2.acta
		AND st1.TACHE= t1.TACHE
		AND st1.pid=p_pid1
		AND t2.pid=p_pid2);

	--copier les affectations de la ligne vers une ligne vide
	--affceter des ressources est OUI

	IF(p_affecter = 'OUI')THEN

	     INSERT INTO ISAC_AFFECTATION (	SOUS_TACHE,
					 				  	IDENT,
									    PID,
										ETAPE,
										TACHE
									  )
		(SELECT  st2.sous_tache,
		       a1.ident,
		       st2.pid,
			   st2.ETAPE,
			   st2.TACHE
	    FROM ISAC_AFFECTATION a1,
		     ISAC_SOUS_TACHE st1, ISAC_SOUS_TACHE st2,
			 ISAC_TACHE t1, ISAC_TACHE t2 ,
			 ISAC_ETAPE e1, ISAC_ETAPE e2
	   WHERE  e1.ecet=e2.ecet
		      AND e1.ETAPE=t1.ETAPE
			  AND e2.ETAPE=t2.ETAPE
			  AND t1.acta=t2.acta
			  AND st1.TACHE= t1.TACHE
			  AND st2.TACHE=t2.TACHE
			  AND st1.acst=st2.acst
			  AND a1.sous_tache=st1.sous_tache
			  AND a1.pid=st1.pid
			  AND a1.pid=p_pid1
			  AND st2.pid=p_pid2);
	END IF;

	COMMIT;
          p_message:='Structure copiée';
EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		RAISE_APPLICATION_ERROR( -20997, SQLERRM);

END insert_struct;




--*********************************************************************
-- Liste des ressources origines
-- *******************************************************************
PROCEDURE lister_ident1(  p_userid  IN     VARCHAR2,
                           p_curseur IN OUT RefCurTyp
                             ) IS
l_lst_chefs_projets VARCHAR2(255);
req                               VARCHAR2(800);
BEGIN

	l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;


		 req := ' SELECT  DISTINCT TO_CHAR(r.ident) ,r.rnom||'' ''||r.rprenom||'' - ''||r.ident LIB  '
		         || '	FROM SITU_RESS_FULL f, RESSOURCE r, ISAC_AFFECTATION ia  '
		         || '	WHERE f.ident=ia.ident  '
		         || '	 AND r.ident=f.ident  '
				 || '	AND ( f.cpident IN ('|| l_lst_chefs_projets ||')  '
	             || '	 OR f.ident IN ('|| l_lst_chefs_projets ||') )  '
		         || '	AND f.type_situ=''N'' '
		         || '	ORDER BY LIB		';


 OPEN p_curseur FOR   req;

END lister_ident1;

--*********************************************************************
-- Liste des ressources déstinations
-- *******************************************************************
PROCEDURE lister_ident2( 	p_userid  IN     VARCHAR2,
                                p_curseur IN OUT RefCurTyp
                             ) IS
l_lst_chefs_projets VARCHAR2(255);
req                               VARCHAR2(800);
BEGIN

	l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;

	 req := ' SELECT  DISTINCT TO_CHAR(r.ident) ,r.rnom||'' ''||r.rprenom||'' - ''||r.ident LIB  '
		         || '	FROM SITU_RESS_FULL f, RESSOURCE r, DATDEBEX d  '
		         || '	WHERE  r.ident=f.ident  '
				 || '  AND (TRUNC(f.datsitu,''YEAR'') <=TRUNC(d.DATDEBEX,''YEAR'') OR f.datsitu IS NULL)  '
		         || '  AND (TRUNC(f.datdep,''YEAR'') >=TRUNC(d.DATDEBEX,''YEAR'') OR f.datdep IS NULL)  '
				 || '	AND ( f.cpident IN ('|| l_lst_chefs_projets ||')  '
	             || '	 OR f.ident IN ('|| l_lst_chefs_projets ||') )  '
		         || '	AND f.type_situ=''N'' '
		         || '	ORDER BY LIB		';


		 OPEN p_curseur FOR   req;

END lister_ident2;



--********************************************************************************************************************
-- Procédure de copie les affectations d'une ressource à une autre ressource
-- paramètres : 	- p_ident1 : ressource origine
--			        - p_ident2 : ressource déstination
-- *******************************************************************************************************************
PROCEDURE insert_affectation ( 	p_ident1     IN RESSOURCE.ident%TYPE,
							    p_ident2 	 IN RESSOURCE.ident%TYPE,
							    p_userid     IN  VARCHAR2,
							    p_message    OUT VARCHAR2
                              ) IS
l_lst_chefs_projets VARCHAR2(255);

BEGIN
        l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;

	  INSERT INTO ISAC_AFFECTATION (	SOUS_TACHE,
					 				  	IDENT,
									    PID,
										ETAPE,
										TACHE
									)
		(SELECT 	ia.sous_tache,
		            p_ident2,
		            ia.pid,
		  			ia.ETAPE,
					ia.TACHE
		FROM ISAC_AFFECTATION ia
		WHERE ia.ident=p_ident1
		--On affect que des sous taches non affectées
		AND NOT EXISTS (SELECT 1 FROM ISAC_AFFECTATION
		         WHERE ident=p_ident2 AND sous_tache=ia.sous_tache)
	    --uniquement les lignes bip dans isac_etape et
		--leurs chef de projet est le même que l'utilisateur
		AND ia.pid IN ( SELECT l.pid
					    FROM LIGNE_BIP l, ISAC_ETAPE e , DATDEBEX d
					    WHERE INSTR(l_lst_chefs_projets,TO_CHAR(l.pcpi, 'FM00000')) > 0
					    AND l.pid=e.pid
					    AND ( l.adatestatut IS NULL
					       OR l.adatestatut > ADD_MONTHS(d.moismens,-1))
					   )


		);

	COMMIT;
          p_message:='Affectation effectuée';
EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		RAISE_APPLICATION_ERROR( -20997, SQLERRM);


END insert_affectation;



END Pack_Isac_Copie;
/
CREATE OR REPLACE PACKAGE     pack_isac_copier_coller AS
       PROCEDURE insert_sstache (
                		p_pid_src       IN VARCHAR2,
                                p_pid_dest      IN VARCHAR2,
                                p_sous_tache    IN VARCHAR2,
                		p_tache         IN VARCHAR2,
                                p_userid        IN VARCHAR2,
                		p_message     	OUT VARCHAR2
                        );
END pack_isac_copier_coller;
/

CREATE OR REPLACE PACKAGE BODY     pack_isac_copier_coller AS
       PROCEDURE insert_sstache (
                                p_pid_src       IN VARCHAR2,
                                p_pid_dest      IN VARCHAR2,
                                p_sous_tache    IN VARCHAR2,
                    		p_tache         IN VARCHAR2,
                                p_userid        IN VARCHAR2,
                    		p_message       OUT VARCHAR2
                        ) IS
       l_pos1       NUMBER(10);
       l_pos2       NUMBER(10);
       l_etape      NUMBER(10);
       l_tache      NUMBER(10);
       l_etape_dest NUMBER(10);
       l_tache_dest NUMBER(10);
       l_sous_tache NUMBER(10);

       l_acst isac_sous_tache.ACST%type;
       l_acta isac_tache.ACTA%type;
       -- libellé de la sous-tache
       l_asnom isac_sous_tache.ASNOM%type;
       l_aist isac_sous_tache.AIST%type;
       l_asta isac_sous_tache.ASTA%type;
       l_adeb isac_sous_tache.ADEB%type;
       l_afin isac_sous_tache.AFIN%type;
       l_ande isac_sous_tache.ANDE%type;
       l_anfi isac_sous_tache.ANFI%type;
       l_adur isac_sous_tache.ADUR%type;

       l_libtache isac_tache.LIBTACHE%type;

       l_sstache_max binary_integer;
       l_sstache_count binary_integer;
       l_sstache_seq number;
       l_max_stache NUMBER(10);
       l_new_stache NUMBER(10);
       l_ident isac_affectation.IDENT%type;

       BEGIN
        p_message:='';

        -- p_sous_tache est de la forme "etape-tache-sous_tache"
	-- si c est vide
		if p_sous_tache=' ' then
		pack_global.recuperer_message( 20043, NULL, NULL, NULL, p_message) ;
                raise_application_error(-20043, p_message);
		end if;

        l_pos1  := INSTR(p_sous_tache,'-', 1, 1);
        l_pos2  := INSTR(p_sous_tache,'-', 1, 2);
        l_etape := TO_NUMBER(SUBSTR(p_sous_tache, 1, l_pos1-1));
        l_tache := TO_NUMBER( SUBSTR(p_sous_tache, l_pos1+1, l_pos2 - l_pos1 - 1));
        l_sous_tache := TO_NUMBER( SUBSTR(p_sous_tache, l_pos2+1, LENGTH(p_sous_tache) - l_pos2+1));


        -- p_tache est de la forme "etape-tache"

	-- si c est vide
	if p_tache=' ' then
	pack_global.recuperer_message( 20042, '%s1', p_pid_dest, NULL, p_message) ;
             raise_application_error(-20042, p_message);
	end if;
        l_pos1       := INSTR(p_tache, '-', 1, 1);
        l_etape_dest := TO_NUMBER(SUBSTR(p_tache, 1, l_pos1-1));
        l_tache_dest := TO_NUMBER( SUBSTR(p_tache, l_pos1+1, LENGTH(p_tache) - l_pos1+1));



        --on recupere le numero de tache l_acta
        select acta into l_acta
        from isac_tache
        where PID =  p_pid_dest
            and etape=l_etape_dest
	    and tache=l_tache_dest;

            -- on compte le nombre de sous taches
            select count(*) into l_sstache_count from isac_sous_tache st
            where st.PID =  p_pid_dest
            and st.etape=l_etape_dest
	    and st.tache=l_tache_dest;


            --cas particulier : il existe une sous tache de numero 99, on récupère le message d'erreur
            select max(to_number(acst)) into l_max_stache
            from isac_sous_tache st
            where st.PID =  p_pid_dest
            and st.etape=l_etape_dest
	    and st.tache=l_tache_dest;

            if (l_sstache_count >=   99) or (l_max_stache = 99) then
               --le max (99) de sous-tâches autorisées pour la tâche %s1 est atteint.
             pack_global.recuperer_message( 20041, '%s1', l_acta, NULL, p_message) ;
             raise_application_error(-20041, p_message);


            end if;



       if (l_tache_dest IS NULL OR l_sous_tache IS NULL) then
            -- Dernier identifiant atteint
                pack_isac.recuperer_message(20014, null,null,null, p_message);
            raise_application_error(-20014, p_message);
       end if;

      --calcul du numéro de sous-tache
        select NVL(MAX(TO_NUMBER(acst)),0)+1 into l_new_stache
	from isac_sous_tache
	where pid=p_pid_dest
	and etape=l_etape_dest
	and tache=l_tache_dest;

	l_acst := to_char(l_new_stache,'FM00');

       select libtache into l_libtache
       from isac_tache where tache=l_tache_dest;

       select  ASNOM, AIST, ASTA, ADEB,
              AFIN, ANDE, ANFI, ADUR
       into  l_asnom, l_aist, l_asta, l_adeb,
            l_afin, l_ande, l_anfi, l_adur
       from isac_sous_tache ist
       where ist.SOUS_TACHE = l_sous_tache;


        insert into isac_sous_tache (sous_tache, pid, etape, tache, acst, asnom, aist,
                                     asta, adeb, afin, ande, anfi, adur, flaglock)
        values (SEQ_SOUS_TACHE.nextval, p_pid_dest, l_etape_dest, l_tache_dest, l_acst, l_asnom, l_aist,
                l_asta, l_adeb, l_afin, l_ande, l_anfi, l_adur, 0
               );




        -- copier les affectations de la ligne vers une ligne vide
	insert into isac_affectation (	SOUS_TACHE,
					IDENT ,
					PID     ,
					ETAPE  ,
					TACHE          )
	(select sous_tache.sous_tache,
		affect.ident,
		sous_tache.pid,
		sous_tache.etape,
		sous_tache.tache
	from isac_affectation affect,isac_sous_tache sous_tache
	where  affect.pid=p_pid_src
	and affect.etape=l_etape
	and affect.tache=l_tache
	and affect.sous_tache=l_sous_tache
	and sous_tache.pid=p_pid_dest
	and sous_tache.etape=l_etape_dest
	and sous_tache.tache=l_tache_dest
	and sous_tache.acst=l_acst);
	commit;



        --message 20982, 'La sous-tâche %s1 a été affectéé à la ligne bip %s2'
        --pack_global.recuperer_message( 20982, '%s1', rtrim(l_asnom), '%s2', p_pid_dest, NULL,  p_message);

        pack_global.recuperer_message( 20982, '%s1', rtrim(l_asnom), '%s2', l_libtache, '%s3', p_pid_dest, NULL,  p_message) ;

EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
        -- la sous-tâche %s1 a déjà été affectée à la ligne bip %s2
            pack_global.recuperer_message( 20040, '%s1', rtrim(l_asnom), '%s2', l_libtache,null, p_message);
            raise_application_error(-20040, p_message);
       -- WHEN OTHERS THEN
         --  rollback;
          --  raise_application_error(-20997, sqlerrm);



       END insert_sstache;


END pack_isac_copier_coller;
/
CREATE OR REPLACE PACKAGE pack_isac_etape AS


 TYPE etapeCurType IS REF CURSOR RETURN isac_etape%ROWTYPE;


  PROCEDURE verif_type_etape ( 	p_pid 	   IN isac_etape.pid%TYPE,
				p_etape    IN VARCHAR2,
				p_typetape IN VARCHAR2,
				p_message  OUT VARCHAR2);


PROCEDURE delete_etape (p_pid     	IN isac_etape.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                       	p_message    	OUT VARCHAR2
                        );

PROCEDURE update_etape (p_etape		IN VARCHAR2,
			p_pid     	IN isac_etape.pid%TYPE,
			p_ecet 		IN VARCHAR2,
			p_typetape	IN VARCHAR2,
			p_libetape 	IN VARCHAR2,
			p_flaglock      IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                      	p_message    	OUT VARCHAR2
                        );

PROCEDURE select_etape (p_pid     	IN isac_etape.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_curEtape     	IN OUT etapeCurType,
			p_nbcurseur    	OUT INTEGER,
                      	p_message    	OUT VARCHAR2
                        );

PROCEDURE insert_etape (p_pid     	IN isac_etape.pid%TYPE,
			p_ecet 		IN VARCHAR2,
			p_typetape	IN VARCHAR2,
			p_libetape 	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
               	        p_message    	OUT VARCHAR2
                        );

PROCEDURE select_etape_suivante (p_pid     	IN  isac_etape.pid%TYPE,
				 p_userid     	IN  VARCHAR2,
				 p_etape  	OUT VARCHAR2,
			 	 p_nbcurseur    OUT INTEGER,
                                 p_message    	OUT VARCHAR2
                                );
END pack_isac_etape;
/

CREATE OR REPLACE PACKAGE  BODY pack_isac_etape AS

-- *****************************************************************************************************
-- Procédure verif_type_etape
-- Vérifie que le type d'étape convient pour la ligne BIP
-- appelée dans les procédures insert_etape et update_etape
-- *****************************************************************************************************
  PROCEDURE verif_type_etape ( 	p_pid 	   IN isac_etape.pid%TYPE,
				p_etape    IN VARCHAR2,
				p_typetape IN VARCHAR2,
				p_message  OUT VARCHAR2) IS

l_typproj NUMBER;
l_count NUMBER;
l_typetape VARCHAR2(2);

  BEGIN
	-- Vérifier le type de projet
	select to_number(typproj) into l_typproj
	from ligne_bip
	where pid=p_pid;

	-- Projet de type ABSENCE
	IF l_typproj=7 THEN
		-- Est-ce qu'il existe déjà une étape ES?
		BEGIN

		select typetape into l_typetape
		from isac_etape
		where pid=p_pid
		and typetape='ES';

		--Message d'erreur : Une seule étape ES pour ce projet de type ABSENCE
		pack_isac.recuperer_message(20006, null,null,'TYPETAPE', p_message);
        		raise_application_error(-20006,p_message);

		EXCEPTION
		WHEN NO_DATA_FOUND THEN
			--Vérifier que le type d'étape entré est bien ES
			IF p_typetape!='ES' THEN
			--Message d'erreur : Etape ES obligatoire pour ce projet de type ABSENCE
		  	   pack_isac.recuperer_message(20007, null,null,'TYPETAPE', p_message);
        			   raise_application_error(-20007,p_message);
			END IF;

		END;

	END IF;

  END verif_type_etape;

--*************************************************************************************************
-- Procédure delete_etape
--
-- Permet de supprimer une étape et les tâches,sous-tâches,affectations,consommés associés
-- Appelée dans la page iletape.htm à partir du bouton "Supprimer
--
-- ************************************************************************************************

PROCEDURE delete_etape (p_pid     	IN isac_etape.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
                       ) IS


l_ecet VARCHAR2(2);
l_libetape VARCHAR2(35);
l_test NUMBER;
l_anneecourante VARCHAR2(4);
l_conso NUMBER;

BEGIN
p_message:='';

  BEGIN

  --test pour savoir si la tache comprend des sous-taches avec du FF sur une ligne fermée
	SELECT 1 into l_test
	FROM isac_sous_tache sst,isac_etape e,ligne_bip lb,datdebex dx
	WHERE lb.pid(+)=substr(sst.aist,3,4)
	AND e.etape=to_number(p_etape)
	AND e.etape=sst.etape
	AND lb.adatestatut is not null
	AND lb.adatestatut <= add_months(dx.moismens,-1)
	AND rownum=1
	;

	IF l_test=1 THEN
		pack_isac.recuperer_message(20025, NULL, NULL, NULL, p_message);
               	raise_application_error( -20025, p_message );
	END IF;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		NULL;
  END;

  BEGIN
  --on recupere l annee courante
  	select to_char(datdebex,'YYYY') into  l_anneecourante
        from datdebex;

  --on verifie qu il n y a pas de consomme sur l annee
  	SELECT  nvl(sum(c.cusag),0) INTO l_conso
 	FROM isac_consomme c,isac_etape e
 	WHERE c.etape(+)=e.etape
 	AND e.etape=to_number(p_etape)
 	AND to_char(c.cdeb,'YYYY')=l_anneecourante
	;
		if l_conso<>0 then
		pack_isac.recuperer_message(20030, NULL,NULL, NULL, p_message);
               	raise_application_error( -20030, p_message );
		end if;
  END;

  BEGIN
	select ecet,libetape into l_ecet, l_libetape
	from isac_etape
	where pid=p_pid
	and etape=to_number(p_etape);

	--Supprimer les tâches,sous-tâches,affections,consommés
	delete isac_consomme
	where pid=p_pid
	and etape=to_number(p_etape);

	delete isac_affectation
	where pid=p_pid
	and etape=to_number(p_etape);

	delete isac_sous_tache
	where pid=p_pid
	and etape=to_number(p_etape);

	delete isac_tache
	where pid=p_pid
	and etape=to_number(p_etape);

	delete isac_etape
	where pid=p_pid
	and etape=to_number(p_etape);

	commit;

	--Etape supprimée
	pack_isac.recuperer_message(20002, '%s1', 'Etape '||l_ecet||' - '||l_libetape, NULL, p_message);
  END;

END delete_etape;

--*************************************************************************************************
-- Procédure update_etape
--
-- Permet de modifier une étape
-- Appelée dans la page imetape.htm
--
-- ************************************************************************************************

PROCEDURE update_etape (p_etape		IN VARCHAR2,
			p_pid     	IN isac_etape.pid%TYPE,
			p_ecet 		IN VARCHAR2,
			p_typetape	IN VARCHAR2,
			p_libetape 	IN VARCHAR2,
			p_flaglock      IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
                        ) IS

l_count NUMBER(1);
l_msg VARCHAR2(255);
l_old_ecet VARCHAR2(2);
l_typetape VARCHAR2(2);

BEGIN

  p_nbcurseur := 0;
  p_message:='';
  l_msg:='';

  -- Recherche de l'ancien numéro d'étape de l'étape
	select ecet, typetape into l_old_ecet, l_typetape
	from isac_etape
	where pid=p_pid
	and etape=to_number(p_etape);

	if l_typetape!=p_typetape then
	--Controler le type d'étape de la ligne BIP
		verif_type_etape ( p_pid,p_etape,p_typetape,p_message );
	end if;

	select count(etape) into l_count
	from isac_etape
	where pid=p_pid
	and ecet=p_ecet
	and ecet!=l_old_ecet;

	if (l_count!=0) then
	--Vous ne pouvez pas modifier le numéro d'une étape qui existe déjà
		pack_isac.recuperer_message(20001,'%s1', 'une étape', 'ECET', l_msg);
         		raise_application_error( -20001, l_msg);
	else
	-- Modification de l'étape
		update isac_etape
		set 	ecet=p_ecet,
			typetape=p_typetape,
			libetape=p_libetape,
			flaglock=to_number(decode(p_flaglock, 1000000, 0, p_flaglock + 1))
		where pid=p_pid
		and etape=to_number(p_etape)
		and flaglock = to_number(p_flaglock,'FM9999999');

		IF SQL%NOTFOUND THEN  -- Acces concurrent
        			pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         			raise_application_error( -20999, l_msg );
      		END IF;
		commit;
	end if;

END update_etape;



--*************************************************************************************************
-- Procédure select_etape
--
-- Permet d'afficher les champs modifiables d'une étape
-- Appelée dans la page iletape.htm à partir du bouton "Modifier"
--
-- ************************************************************************************************
PROCEDURE select_etape (p_pid     	IN isac_etape.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_curEtape     	IN OUT etapeCurType,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
                        ) IS
l_ecet  VARCHAR2(2);
l_typetape  VARCHAR2(2);
l_libetape  VARCHAR2(30);
l_flaglock VARCHAR2(30);
l_test NUMBER;

BEGIN
  p_nbcurseur := 0;
  p_message:='';

   BEGIN

  --test pour savoir si la tache comprend des sous-taches avec du FF sur une ligne fermée
	SELECT 1 into l_test
	FROM isac_sous_tache sst,isac_etape e,ligne_bip lb,datdebex dx
	WHERE lb.pid(+)=substr(sst.aist,3,4)
	AND e.etape=to_number(p_etape)
	AND e.etape=sst.etape
	AND lb.adatestatut is not null
	AND lb.adatestatut <= add_months(dx.moismens,-1)
	AND rownum=1
	;

	IF l_test=1 THEN
		pack_isac.recuperer_message(20023, NULL, NULL, NULL, p_message);
               	raise_application_error( -20023, p_message );
	END IF;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		NULL;
  END;

  BEGIN

      OPEN p_curEtape FOR
	select *
	from isac_etape
	where pid=p_pid
	and etape=to_number(p_etape) ;
  END;

END select_etape;

--*************************************************************************************************
-- Procédure insert_etape
--
-- Permet de créer une étape
-- Appelée dans la page icetape.htm
--
-- ************************************************************************************************
PROCEDURE insert_etape (p_pid     	IN isac_etape.pid%TYPE,
			p_ecet 		IN VARCHAR2,
			p_typetape	IN VARCHAR2,
			p_libetape 	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
                                ) IS

l_etape NUMBER;
l_count NUMBER;

BEGIN
  p_nbcurseur := 0;
  p_message:='';

	-- On compte le nombre d'étape de même numéro
	select count(*) into l_count from isac_etape where pid=p_pid and ecet=p_ecet;
	If l_count = 0 THEN
		select SEQ_ETAPE.nextval into l_etape
		from dual;
		verif_type_etape ( p_pid,l_etape,p_typetape,p_message );

		insert into isac_etape (etape,pid,ecet,typetape,libetape,flaglock)
		values (l_etape,p_pid,p_ecet,p_typetape,p_libetape,0);
		commit;
	-- S'il y a déjà ce numéro d'étape d'enregistré on renvoie une erreur.
	ELSE
		pack_global.recuperer_message(20044,NULL, NULL, NULL, p_message);
		raise_application_error( -20044, p_message );
	END IF;

END insert_etape;


--*************************************************************************************************
-- Procédure select_etape_suivante
--
-- Permet d'afficher le numéro de la nouvelle étape lors de la création d'une étape
-- Appelée dans la page iletape.htm à partir du bouton "Créer"
--
-- ************************************************************************************************
PROCEDURE select_etape_suivante (p_pid     	IN  isac_etape.pid%TYPE,
				 p_userid     	IN  VARCHAR2,
				 p_etape  	OUT VARCHAR2,
				 p_nbcurseur    OUT INTEGER,
                                 p_message    	OUT VARCHAR2
                                ) IS

l_ecet number;
l_msg VARCHAR2(255);

BEGIN
 p_nbcurseur := 1;
 p_message:='';
 l_msg:='';

	select NVL(MAX(TO_NUMBER(ecet)),0)+1 into l_ecet
	from isac_etape
	where pid=p_pid;

p_etape :=to_char(l_ecet,'FM00');

if l_ecet>99 then
--99 étapes maximum par ligne BIP
	pack_isac.recuperer_message(20015, NULL,NULL, NULL, l_msg);
         	raise_application_error( -20015, l_msg);

end if;

p_message:=l_msg;
END select_etape_suivante;
END pack_isac_etape;
/
CREATE OR REPLACE PACKAGE pack_isac_sous_tache AS
 PROCEDURE verif_aist ( p_pid IN isac_sous_tache.pid%TYPE,
			p_etape IN VARCHAR2,
			p_aist IN VARCHAR2,
			p_result OUT VARCHAR2,
			p_message OUT VARCHAR2);

PROCEDURE delete_sous_tache (	p_pid     	IN isac_sous_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_tache 	IN VARCHAR2,
				p_sous_tache 	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                       	  	p_message    	OUT VARCHAR2
                        );

PROCEDURE update_sous_tache(	p_sous_tache	IN VARCHAR2,
				p_pid     	IN isac_sous_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_tache		IN VARCHAR2,
				p_acst		IN VARCHAR2,
				p_aist		IN VARCHAR2,
				p_asnom		IN VARCHAR2,
				p_adeb		IN VARCHAR2,
				p_afin		IN VARCHAR2,
				p_ande		IN VARCHAR2,
				p_anfi		IN VARCHAR2,
				p_asta		IN VARCHAR2,
				p_adur		IN VARCHAR2,
				p_paramlocal	IN VARCHAR2,
				p_flaglock      IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                       	  	p_message    	OUT VARCHAR2
			);
TYPE stacheRec IS RECORD     (	SOUS_TACHE	VARCHAR2(20),
				ACST		VARCHAR2(2),
				AIST		VARCHAR2(6),
				ASNOM		VARCHAR2(35),
				ADEB		VARCHAR2(10),
				AFIN		VARCHAR2(10),
				ANDE		VARCHAR2(10),
				ANFI		VARCHAR2(10),
				ASTA		VARCHAR2(2),
				ADUR		VARCHAR2(5),
				PARAMLOCAL	VARCHAR2(5),
				FLAGLOCK	VARCHAR2(10)
				);
  TYPE stacheCurType IS REF CURSOR RETURN stacheRec;

PROCEDURE select_sous_tache (	p_pid     	IN isac_sous_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_tache		IN VARCHAR2,
				p_sous_tache    IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_curstache    	IN OUT stacheCurType,
				p_nbcurseur    	OUT INTEGER,
                      	   	p_message    	OUT VARCHAR2
			  );
PROCEDURE insert_sous_tache ( 	p_pid		IN isac_sous_tache.pid%TYPE,
				p_etape		IN VARCHAR2,
				p_tache		IN VARCHAR2,
				p_acst		IN VARCHAR2,
				p_aist		IN VARCHAR2,
				p_asnom		IN VARCHAR2,
				p_adeb		IN VARCHAR2,
				p_afin		IN VARCHAR2,
				p_ande		IN VARCHAR2,
				p_anfi		IN VARCHAR2,
				p_asta		IN VARCHAR2,
				p_adur		IN VARCHAR2,
				p_paramlocal	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                 		p_message    	OUT VARCHAR2
			    ) ;

PROCEDURE select_new_sous_tache (p_pid		IN isac_sous_tache.pid%TYPE,
				 p_etape	IN VARCHAR2,
				 p_tache	IN VARCHAR2,
				 p_userid     	IN VARCHAR2,
				 p_acst		OUT VARCHAR2,
				 p_nbcurseur    OUT INTEGER,
                 		 p_message    	OUT VARCHAR2
			    );

PROCEDURE select_tache ( p_pid		IN isac_sous_tache.pid%TYPE,
			p_tache		IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_keylist3out   OUT VARCHAR2,
			p_keylist4out   OUT VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                 	p_message    	OUT VARCHAR2
			    );



END pack_isac_sous_tache ;
/

CREATE OR REPLACE PACKAGE BODY pack_isac_sous_tache AS
-- ****************************************************************
-- Procedure verif_aist
-- Verifie que le type de la sous-t¿che convient pour la ligne BIP
-- utilisee dans les procedures insert_sous_tache et update_sous_tache
-- ****************************************************************

  PROCEDURE verif_aist (p_pid IN isac_sous_tache.pid%TYPE,
			p_etape IN VARCHAR2,
			p_aist IN VARCHAR2,
			p_result  OUT VARCHAR2,
			p_message OUT VARCHAR2) IS
l_typproj NUMBER;
l_count NUMBER;
l_typetape VARCHAR2(2);
l_moismens DATE;
l_adatestatut DATE;

  BEGIN
  p_result:='';

	--on recupere le mois de mensuelle
	SELECT moismens INTO l_moismens
	FROM datdebex;

	-- Recherche du type d'etape
	select typetape into l_typetape
	from isac_etape
	where etape=to_number(p_etape);


	IF l_typetape='ES' THEN  --TYPE ES
	-- Verifier le type de projet
	select to_number(typproj) into l_typproj
	from ligne_bip
	where pid=p_pid;
		IF l_typproj=7 THEN --Projet de type ABSENCE
			IF p_aist not in ('CONGES','ABSDIV','MOBILI','CLUBUT','FORFAC','ACCUEI',
				'FORMAT','SEMINA','INTEGR','FORHUM','FOREAO','FORINF',
				'FOREXT','FORINT','COLOQU','RTT','PARTIE','DEMENA') or p_aist is null THEN
--Message d'erreur : Type de sous-tache incorrect pour la ligne BIP.Entrez un autre type de sous-tache
				pack_isac.recuperer_message(20010,null,null,'AIST',p_message);
        				raise_application_error(-20010,p_message);


			END IF;
		ELSE --Projet !=ABSENCE
			IF p_aist not in ('FM','EN','ST') or p_aist is null THEN
			--Message d'erreur
				pack_isac.recuperer_message(20010,null,null,'AIST',p_message);
        				raise_application_error(-20010,p_message);
			END IF;

		END IF;

	ELSE --TYPE non ES
		IF p_aist='HEUSUP' THEN null;
		-- si sous tache EN dans etape PACTE : OK
		ELSIF l_typetape IN ('OP','CA','CP','CT','IG','HD','CC','CH') AND p_aist='EN' THEN NULL;
		ELSIF (p_aist='' or p_aist is null) THEN null;
		ELSIF substr(p_aist,1,2) in ('FF','DF') THEN
			select count(*) into l_count
			from ligne_bip
			where pid=rtrim(substr(p_aist,3,4));
			if l_count=0 then
			--Message d'erreur:ce n'est pas un code ligne BIP
			     pack_isac.recuperer_message(20011,'%s1',substr(p_aist,3,4),'AIST',p_message);
        			     raise_application_error(-20011,p_message);
			end if;
			select adatestatut into l_adatestatut
			from ligne_bip
			where pid=rtrim(substr(p_aist,3,4))
			;
			if l_adatestatut is not null and l_adatestatut <= add_months(l_moismens,-1) then
				 pack_isac.recuperer_message(20019,'%s1',substr(p_aist,3,4),'AIST',p_message);
        			 raise_application_error(-20019,p_message);
			end if;

		ELSE
			p_result :='Autre chose';
		END IF;

	END IF;

  END;


--*************************************************************************************************
-- Procedure delete_sous_tache
--
-- Permet de supprimer une sous_tache
-- Appelee dans la page iltache.htm a partir du bouton "Supprimer"
--
-- ************************************************************************************************
PROCEDURE delete_sous_tache (	p_pid     	IN isac_sous_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_tache 	IN VARCHAR2,
				p_sous_tache 	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                       	  	p_message    	OUT VARCHAR2
                        ) IS
l_acst VARCHAR2(2);
l_asnom VARCHAR2(35);
l_anneecourante VARCHAR2(4);
l_conso NUMBER;
l_moismens datdebex.moismens%TYPE;
l_adatestatut ligne_bip.adatestatut%TYPE;
l_pid ligne_bip.pid%TYPE;
BEGIN
  p_message:='';

BEGIN
  --on recupere le mois de mensuelle
	SELECT moismens INTO l_moismens
	FROM datdebex;

  --on récupère la date de statut de la ligne en FF
	SELECT adatestatut,l.pid INTO l_adatestatut,l_pid
			FROM ligne_bip l,isac_sous_tache i
			WHERE l.pid(+)=substr(i.aist,3,4)
			AND i.sous_tache=to_number(p_sous_tache)
			;
			if l_adatestatut is not null and l_adatestatut <= add_months(l_moismens,-1) then
				 pack_isac.recuperer_message(20021, '%s1', l_pid, NULL, p_message);
               			 raise_application_error( -20021, p_message );
			end if;
  END;

BEGIN
  --on recupere l annee courante
  	select to_char(datdebex,'YYYY') into  l_anneecourante
        from datdebex;

  --on verifie qu il n y a pas de consomme sur l annee
  	SELECT  nvl(sum(c.cusag),0) INTO l_conso
 	FROM isac_consomme c,isac_sous_tache sst
 	WHERE c.sous_tache(+)=sst.sous_tache
 	AND sst.sous_tache=to_number(p_sous_tache)
 AND to_char(c.cdeb,'YYYY')=l_anneecourante
	;
		if l_conso<>0 then
		pack_isac.recuperer_message(20028, NULL,NULL, NULL, p_message);
               	raise_application_error( -20028, p_message );
		end if;
  END;

  BEGIN
	select acst,asnom into l_acst, l_asnom
	from isac_sous_tache
	where sous_tache=to_number(p_sous_tache);

	--Supprimer les sous-t¿ches,affections,consommes
	delete isac_consomme
	where sous_tache=to_number(p_sous_tache);

	delete isac_affectation
	where sous_tache=to_number(p_sous_tache);

	delete isac_sous_tache
	where sous_tache=to_number(p_sous_tache);


	commit;

	--Sous-tache supprimee
	pack_isac.recuperer_message(20002, '%s1', 'Sous-tache '||l_acst||' - '||l_asnom, NULL, p_message);
  END;

END delete_sous_tache;



--*************************************************************************************************
-- Procedure update_sous_tache
--
-- Permet de modifier une sous_tache
-- Appelee dans la page imstache.htm
--
-- ************************************************************************************************
PROCEDURE update_sous_tache(	p_sous_tache	IN VARCHAR2,
				p_pid     	IN isac_sous_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_tache		IN VARCHAR2,
				p_acst		IN VARCHAR2,
				p_aist		IN VARCHAR2,
				p_asnom		IN VARCHAR2,
				p_adeb		IN VARCHAR2,
				p_afin		IN VARCHAR2,
				p_ande		IN VARCHAR2,
				p_anfi		IN VARCHAR2,
				p_asta		IN VARCHAR2,
				p_adur		IN VARCHAR2,
				p_paramlocal	IN VARCHAR2,
				p_flaglock      IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                       	  	p_message    	OUT VARCHAR2
			) IS

l_count NUMBER(1);
l_msg VARCHAR2(255);
l_old_acst VARCHAR2(2);
l_flaglock NUMBER(7);
l_result VARCHAR2(255);
l_aist VARCHAR2(6);
BEGIN
  p_nbcurseur := 0;
  p_message:='';
  l_msg:='';
  l_flaglock := to_number(p_flaglock,'FM9999999');

  --Contr¿le du type de la sous-t¿che
	verif_aist(p_pid,p_etape,p_aist,l_result,p_message);

	if l_result='Autre chose' then
		l_aist := NULL;
	else l_aist := p_aist;
	end if;

  -- Recherche de l'ancien numero de la sous-t¿che
	select acst into l_old_acst
	from isac_sous_tache
	where sous_tache=to_number(p_sous_tache);

	select count(sous_tache) into l_count
	from isac_sous_tache
	where pid=p_pid
	and etape=to_number(p_etape)
	and tache=to_number(p_tache)
	and acst=p_acst
	and acst!=l_old_acst;

	if (l_count!=0) then
	--Vous ne pouvez pas modifier le numero d'une sous-t¿che qui existe dej¿
		pack_isac.recuperer_message(20001, '%s1','une sous-t¿che', 'ACST', l_msg);
         	raise_application_error( -20001, l_msg);

	else
	-- Modification de l'etape
		update isac_sous_tache
		set 	acst=p_acst,
			asnom=p_asnom,
			aist=l_aist,
			asta=p_asta,
			adeb=to_date(p_adeb,'DD/MM/YYYY'),
			afin=to_date(p_afin,'DD/MM/YYYY'),
			ande=to_date(p_ande,'DD/MM/YYYY'),
			anfi=to_date(p_anfi,'DD/MM/YYYY'),
			adur=to_number(p_adur),
			param_local=p_paramlocal,
			flaglock=decode(l_flaglock, 1000000, 0, l_flaglock + 1)
		where sous_tache=to_number(p_sous_tache)
		and flaglock = l_flaglock;

		IF SQL%NOTFOUND THEN  -- Acces concurrent
        			pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         		raise_application_error( -20999, l_msg );
      		END IF;

		commit;
	end if;

	p_message:=l_msg;

END update_sous_tache;
-- ************************************************************************************************
-- Procedure select_sous_tache
--
-- Permet d'afficher les donnees de la sous-t¿che pour modification
-- Appelee dans la page ilstache.htm, bouton "Modifier"
--
-- ************************************************************************************************
PROCEDURE select_sous_tache (	p_pid     	IN isac_sous_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_tache		IN VARCHAR2,
				p_sous_tache    IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_curstache    	IN OUT stacheCurType,
				p_nbcurseur    	OUT INTEGER,
                      	   	p_message    	OUT VARCHAR2
			  ) IS
l_moismens datdebex.moismens%TYPE;
l_adatestatut ligne_bip.adatestatut%TYPE;
l_pid ligne_bip.pid%TYPE;

BEGIN
p_nbcurseur := 0;
p_message:='';

  BEGIN
  --on recupere le mois de mensuelle
	SELECT moismens INTO l_moismens
	FROM datdebex;

  --on récupère la date de statut de la ligne en FF
	SELECT adatestatut,l.pid INTO l_adatestatut,l_pid
			FROM ligne_bip l,isac_sous_tache i
			WHERE l.pid(+)=substr(i.aist,3,4)
			AND i.sous_tache=to_number(p_sous_tache)
			;
			if l_adatestatut is not null and l_adatestatut <= add_months(l_moismens,-1) then
				 pack_isac.recuperer_message(20020, '%s1', l_pid, NULL, p_message);
               			 raise_application_error( -20020, p_message );
			end if;
  END;

	BEGIN
	OPEN p_curstache FOR
	select to_char(sous_tache) SOUS_TACHE,
		ACST,
		AIST,
		ASNOM,
		to_char(adeb,'DD/MM/YYYY') ADEB,
		to_char(afin,'DD/MM/YYYY') AFIN,
		to_char(ande,'DD/MM/YYYY') ANDE,
		to_char(anfi,'DD/MM/YYYY') ANFI,
		ASTA,
		to_char(adur) ADUR,
		PARAM_LOCAL,
		to_char(flaglock) FLAGLOCK
	from isac_sous_tache
	where sous_tache=to_number(p_sous_tache);
	END;


END select_sous_tache;
-- ************************************************************************************************
-- Procedure insert_sous_tache
--
-- Permet de creer une sous-t¿che
-- Appelee dans la page icstache.htm
--
-- ************************************************************************************************
PROCEDURE insert_sous_tache ( 	p_pid		IN isac_sous_tache.pid%TYPE,
				p_etape		IN VARCHAR2,
				p_tache		IN VARCHAR2,
				p_acst		IN VARCHAR2,
				p_aist		IN VARCHAR2,
				p_asnom		IN VARCHAR2,
				p_adeb		IN VARCHAR2,
				p_afin		IN VARCHAR2,
				p_ande		IN VARCHAR2,
				p_anfi		IN VARCHAR2,
				p_asta		IN VARCHAR2,
				p_adur		IN VARCHAR2,
				p_paramlocal	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                 		p_message    	OUT VARCHAR2
			    ) IS
l_result VARCHAR2(255);
l_aist VARCHAR2(6);
l_count NUMBER;
BEGIN
  	--Contr¿le du type de la sous-t¿che
	verif_aist(p_pid,p_etape,p_aist,l_result,p_message);

	if l_result='Autre chose' then
		l_aist := NULL;
	else l_aist := p_aist;
	end if;


	-- On compte le nombre de sous-tâche de même numéro
	select count(*) into l_count
	from isac_sous_tache
	where pid=p_pid
	  and etape=to_number(p_etape)
	  and tache=to_number(p_tache)
	  and acst=p_acst;
	-- si le numéro à attribuer est bien unique,
	If l_count = 0 THEN
 		-- Creation de la sous-tache
		insert into isac_sous_tache (pid,etape,tache,sous_tache,
			acst,asnom,aist,asta,adeb,afin,ande,anfi,adur,param_local,flaglock)
		values (p_pid,to_number(p_etape),to_number(p_tache),SEQ_SOUS_TACHE.nextval,
			p_acst,p_asnom,l_aist,p_asta,TO_DATE(p_adeb,'DD/MM/YYYY'),TO_DATE(p_afin,'DD/MM/YYYY'),
			TO_DATE(p_ande,'DD/MM/YYYY'),TO_DATE(p_anfi,'DD/MM/YYYY'),p_adur,p_paramlocal,0);
		commit;
	-- S'il y a déjà ce numéro de sous-tâche d'enregistré on renvoie une erreur.
	ELSE
		pack_global.recuperer_message(20046,NULL, NULL, NULL, p_message);
		raise_application_error( -20046, p_message );
	END IF;



END insert_sous_tache;

--*************************************************************************************************
-- Procedure select_new_sous_tache
--
-- Permet d'afficher la nouvelle sous-t¿che lors de la creation
-- Appelee dans la page ilstache.htm (bouton="Creer)
--
-- ************************************************************************************************
PROCEDURE select_new_sous_tache (p_pid		IN isac_sous_tache.pid%TYPE,
				 p_etape	IN VARCHAR2,
				 p_tache	IN VARCHAR2,
				 p_userid     	IN VARCHAR2,
				 p_acst		OUT VARCHAR2,
				 p_nbcurseur    OUT INTEGER,
                 		 p_message    	OUT VARCHAR2
			    ) IS
l_new_stache NUMBER(10);
l_msg VARCHAR2(255);
BEGIN
p_message:='';
  l_msg:='';

	select NVL(MAX(TO_NUMBER(acst)),0)+1 into l_new_stache
	from isac_sous_tache
	where pid=p_pid
	and etape=to_number(p_etape)
	and tache=to_number(p_tache);

p_acst := to_char(l_new_stache,'FM00');

if l_new_stache>99 then
--99 sous-taches maximum par t¿che
		pack_isac.recuperer_message(20017, NULL,NULL, NULL, l_msg);
         	raise_application_error( -20017, l_msg);

end if;
p_message:=l_msg;
END select_new_sous_tache;

--*************************************************************************************************
-- Procedure select_tache
--
-- Permet d'afficher l'etape et la t¿che choisie pour la gestion des sous-t¿ches
-- Appelee dans la page igstache.htm
--
-- ************************************************************************************************
PROCEDURE select_tache (p_pid		IN isac_sous_tache.pid%TYPE,
			p_tache		IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_keylist3out   OUT VARCHAR2,
			p_keylist4out   OUT VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                 	p_message    	OUT VARCHAR2
			    ) IS
l_etape NUMBER(10);
l_tache NUMBER(10);
l_pos NUMBER(10);
l_libetape VARCHAR2(100);
l_libtache VARCHAR2(100);
BEGIN
  p_nbcurseur := 0;
  p_message:='';
	-- p_tache est de la forme "etape-tache"
	l_pos := INSTR(p_tache,'-',1,1);
	l_etape := TO_NUMBER( SUBSTR(p_tache,1,l_pos-1));
	l_tache := TO_NUMBER( SUBSTR(p_tache,l_pos+1,LENGTH(p_tache)-l_pos+1));

	select e.ecet||'-'||e.libetape , t.acta||'-'||t.libtache
	into l_libetape,l_libtache
	from isac_tache t, isac_etape e
	where t.etape=e.etape
	and t.tache=l_tache;

	p_keylist3out := l_libetape;
	p_keylist4out := l_libtache;

END select_tache;
END pack_isac_sous_tache ;
/
CREATE OR REPLACE PACKAGE pack_isac_tache AS

 TYPE tacheCurType IS REF CURSOR RETURN isac_tache%ROWTYPE;

PROCEDURE delete_tache  (p_pid     	IN isac_tache.pid%TYPE,
			 p_etape 	IN VARCHAR2,
			 p_tache 	IN VARCHAR2,
			 p_userid     	IN VARCHAR2,
			 p_nbcurseur    OUT INTEGER,
                         p_message    	OUT VARCHAR2
                        );

PROCEDURE update_tache(	p_tache		IN VARCHAR2,
			p_pid     	IN isac_tache.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_acta		IN VARCHAR2,
			p_libtache	IN VARCHAR2,
			p_flaglock      IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
			);

PROCEDURE select_tache (p_pid     	IN isac_tache.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_tache		IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_curtache    	IN OUT tacheCurType,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
			  ) ;

PROCEDURE insert_tache(	p_pid     	IN isac_tache.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_acta		IN VARCHAR2,
			p_libtache	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
			);

PROCEDURE select_tache_suivante(p_pid     	IN isac_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_acta		OUT VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                         	p_message    	OUT VARCHAR2
			    );




PROCEDURE select_liste_tache (	p_pid     	IN isac_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_keylist2      OUT VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                         	p_message    	OUT VARCHAR2
			    );


END pack_isac_tache;
/

CREATE OR REPLACE PACKAGE  BODY pack_isac_tache AS
--*************************************************************************************************
-- Procédure delete_tache
--
-- Permet de supprimer une tâche
-- Appelée dans la page iltache.htm à partir du bouton "Supprimer"
--
-- ************************************************************************************************
PROCEDURE delete_tache (p_pid     	IN isac_tache.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_tache 	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
                        ) IS

l_acta VARCHAR2(2);
l_libtache VARCHAR2(35);
l_test NUMBER;
l_anneecourante VARCHAR2(4);
l_conso NUMBER;
BEGIN
p_message:='';

  BEGIN

  --test pour savoir si la tache comprend des sous-taches avec du FF sur une ligne fermée
	SELECT 1 into l_test
	FROM isac_sous_tache sst,isac_tache t,ligne_bip lb,datdebex dx
	WHERE lb.pid(+)=substr(sst.aist,3,4)
	AND t.tache=to_number(p_tache)
	AND t.tache=sst.tache
	AND t.etape=sst.etape
	AND lb.adatestatut is not null
	AND lb.adatestatut <= add_months(dx.moismens,-1)
	AND rownum=1
	;

	IF l_test=1 THEN
		pack_isac.recuperer_message(20024, NULL, NULL, NULL, p_message);
               	raise_application_error( -20024, p_message );
	END IF;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		NULL;
  END;

  BEGIN
  --on recupere l annee courante
  	select to_char(datdebex,'YYYY') into  l_anneecourante
        from datdebex;

  --on verifie qu il n y a pas de consomme sur l annee
  	SELECT  nvl(sum(c.cusag),0) INTO l_conso
 	FROM isac_consomme c,isac_tache t
 	WHERE c.tache(+)=t.tache
 	AND t.tache=to_number(p_tache)
 	AND to_char(c.cdeb,'YYYY')=l_anneecourante
	;
		if l_conso<>0 then
		pack_isac.recuperer_message(20029, NULL,NULL, NULL, p_message);
               	raise_application_error( -20029, p_message );
		end if;
  END;

  BEGIN
	select acta,libtache into l_acta, l_libtache
	from isac_tache
	where tache=to_number(p_tache);

	--Supprimer les tâches,sous-tâches,affections,consommés
	delete isac_consomme
	where pid=p_pid
	and etape=to_number(p_etape)
	and tache=to_number(p_tache);

	delete isac_affectation
	where pid=p_pid
	and etape=to_number(p_etape)
	and tache=to_number(p_tache);


	delete isac_sous_tache
	where pid=p_pid
	and etape=to_number(p_etape)
	and tache=to_number(p_tache);


	delete isac_tache
	where pid=p_pid
	and etape=to_number(p_etape)
	and tache=to_number(p_tache);



	commit;

	--tache supprimée
	pack_isac.recuperer_message(20002, '%s1', 'Tâche '||l_acta||' - '||l_libtache, NULL, p_message);
  END;

END delete_tache;

--*************************************************************************************************
-- Procédure update_tache
--
-- Permet de modifier une tâche
-- Appelée dans la page imtache.htm
--
-- ************************************************************************************************
PROCEDURE update_tache(	p_tache		IN VARCHAR2,
			p_pid     	IN isac_tache.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_acta		IN VARCHAR2,
			p_libtache	IN VARCHAR2,
			p_flaglock      IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
			) IS

l_count NUMBER(1);
l_msg VARCHAR2(255);
l_old_acta VARCHAR2(2);
BEGIN
  p_nbcurseur := 0;
  p_message:='';
  l_msg:='';

  -- Recherche de l'ancien numéro de la tâche
	select acta into l_old_acta
	from isac_tache
	where tache=to_number(p_tache);

	select count(tache) into l_count
	from isac_tache
	where pid=p_pid
	and etape=to_number(p_etape)
	and acta=p_acta
	and acta!=l_old_acta;

	if (l_count!=0) then
	--Vous ne pouvez pas modifier le numéro d'une tâche qui existe déjà
		pack_isac.recuperer_message(20001, '%s1','une tâche', 'ACTA', l_msg);
         	raise_application_error( -20001, l_msg);

	else
	-- Modification de l'étape
		update isac_tache
		set 	acta=p_acta,
			libtache=p_libtache,
			flaglock=to_number(decode(p_flaglock, 1000000, 0, p_flaglock + 1))
		where  tache=to_number(p_tache)
		and flaglock = to_number(p_flaglock,'FM9999999');

		IF SQL%NOTFOUND THEN  -- Acces concurrent
        			pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         		raise_application_error( -20999, l_msg );
      		END IF;


	commit;
	end if;

	p_message:=l_msg;

END update_tache;

--*************************************************************************************************
-- Procédure select_tache
--
-- Permet d'afficher les champs modifiables d'une tâche
-- Appelée dans la page iltache.htm à partir du bouton "Modifier"
--
-- ************************************************************************************************
PROCEDURE select_tache (p_pid     	IN isac_tache.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_tache		IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_curtache    	IN OUT tacheCurType,
			p_nbcurseur    	OUT INTEGER,
                         p_message    	OUT VARCHAR2
			  ) IS

l_test NUMBER;

BEGIN
  p_nbcurseur := 0;
  p_message:='';

  BEGIN

  --test pour savoir si la tache comprend des sous-taches avec du FF sur une ligne fermée
	SELECT 1 into l_test
	FROM isac_sous_tache sst,isac_tache t,ligne_bip lb,datdebex dx
	WHERE lb.pid(+)=substr(sst.aist,3,4)
	AND t.tache=to_number(p_tache)
	AND t.tache=sst.tache
	AND t.etape=sst.etape
	AND lb.adatestatut is not null
	AND lb.adatestatut <= add_months(dx.moismens,-1)
	AND rownum=1
	;

	IF l_test=1 THEN
		pack_isac.recuperer_message(20022, NULL, NULL, NULL, p_message);
               	raise_application_error( -20022, p_message );
	END IF;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		NULL;
  END;

  BEGIN
	OPEN p_curtache FOR
	select *
	from isac_tache
	where tache=to_number(p_tache);
  END;


END select_tache;

--*************************************************************************************************
-- Procédure insert_tache
--
-- Permet de créer une tâch
-- Appelée dans la page ictache.htm
--
-- ************************************************************************************************
PROCEDURE insert_tache(	p_pid     	IN isac_tache.pid%TYPE,
			p_etape 	IN VARCHAR2,
			p_acta		IN VARCHAR2,
			p_libtache	IN VARCHAR2,
			p_userid     	IN VARCHAR2,
			p_nbcurseur    	OUT INTEGER,
                        p_message    	OUT VARCHAR2
			) IS

l_count NUMBER;
BEGIN
  p_nbcurseur := 0;
  p_message:='';

	-- On compte le nombre de tâche de même numéro
	select count(*) into l_count
	from isac_tache
	where pid=p_pid
	  and acta=p_acta
	  and etape=to_number(p_etape);
	-- si le numéro à attribuer est bien unique,
	If l_count = 0 THEN
		insert into isac_tache (pid,etape,tache,acta,libtache,flaglock)
		values (p_pid,to_number(p_etape),SEQ_TACHE.nextval,p_acta,p_libtache,0);
		commit;
	-- S'il y a déjà ce numéro de tâche d'enregistré on renvoie une erreur.
	ELSE
		pack_global.recuperer_message(20045,NULL, NULL, NULL, p_message);
		raise_application_error( -20045, p_message );
	END IF;

END insert_tache;

--*************************************************************************************************
-- Procédure select_tache_suivante
--
-- Permet d'afficher le numéro de la nouvelle tâche lors de la création
-- Appelée dans la page iltache.htm à partir du bouton "Créer"
--
-- ************************************************************************************************
PROCEDURE select_tache_suivante(p_pid     	IN isac_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_acta		OUT VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                         	p_message    	OUT VARCHAR2
			    ) IS
l_acta number;
l_msg VARCHAR2(255);
BEGIN
 p_nbcurseur := 1;

 l_msg:='';
 p_message:='';
	select NVL(MAX(TO_NUMBER(acta)),0)+1 into l_acta
	from isac_tache
	where --pid=p_pid and
	 etape=to_number(p_etape);

p_acta :=  to_char(l_acta,'FM00');

if l_acta>99 then
--99 taches maximum par étape
		pack_isac.recuperer_message(20016, NULL,NULL, NULL, l_msg);
         	raise_application_error( -20016, l_msg);

end if;
p_message:=l_msg;

END select_tache_suivante;

--*************************************************************************************************
-- Procédure select_liste_tache
--
-- Permet d'afficher le numéro de l'étape et son libellé
-- Appelée dans la page igtache.htm
--
-- ************************************************************************************************
PROCEDURE select_liste_tache (	p_pid     	IN isac_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
				p_userid     	IN VARCHAR2,
				p_keylist2      OUT VARCHAR2,
				p_nbcurseur    	OUT INTEGER,
                         	p_message    	OUT VARCHAR2
                        	) IS

l_ecet  VARCHAR2(2);
l_libetape VARCHAR2(30);
BEGIN
  p_nbcurseur := 0;
  p_message:='';
	select ecet,libetape into l_ecet,l_libetape
	from isac_etape
	where pid=p_pid
	and etape=to_number(p_etape) ;

	p_keylist2:=l_ecet||'-'||l_libetape;

END select_liste_tache;

END pack_isac_tache;
/
CREATE OR REPLACE PACKAGE pack_libelles AS

-- Retourne le libéllé du CA payeur
PROCEDURE get_lib_codcamo ( 	p_codcamo		IN	VARCHAR2,
				p_lib_codcamo		OUT	entite_structure.licoes%TYPE,
				p_message		OUT 	VARCHAR2
				);

-- Retourne le libéllé du CA payeur si facturable
PROCEDURE get_lib_codcamo_facturable ( 	p_codcamo		IN	VARCHAR2,
				p_lib_codcamo		OUT	entite_structure.licoes%TYPE,
				p_message		OUT 	VARCHAR2
				);

-- Retourne le libéllé du code client
PROCEDURE get_lib_clicode ( 	p_clicode		IN	client_mo.clicode%TYPE,
				p_clilib		OUT	client_mo.clilib%TYPE,
				p_message		OUT 	VARCHAR2
				);

-- Retourne le libéllé du Code DPG
PROCEDURE get_lib_coddpg ( 	p_codsg		  	IN  struct_info.codsg%TYPE,
				p_lib_codsg      	OUT struct_info.libdsg%TYPE,
				p_message	  	OUT VARCHAR2
				);

END pack_libelles;
/

CREATE OR REPLACE PACKAGE BODY pack_libelles AS
-- Retourne le libéllé du CA payeur
PROCEDURE get_lib_codcamo ( 	p_codcamo		IN	VARCHAR2,
			    	p_lib_codcamo		OUT	entite_structure.licoes%TYPE,
			    	p_message		OUT 	VARCHAR2
			    	) IS
BEGIN
	-- On recherche de lib dans la table entite_structure
	SELECT 	licoes INTO p_lib_codcamo
	FROM 	entite_structure
	WHERE	codcamo=TO_NUMBER(p_codcamo);

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		BEGIN
			-- On recherche de lib dans la table centre_activite
			SELECT 	clibca INTO p_lib_codcamo
			FROM 	centre_activite
			WHERE	codcamo=TO_NUMBER(p_codcamo);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				pack_global.recuperer_message( 2007, NULL, NULL, NULL, p_message);
		END;
	WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM);
END get_lib_codcamo;

-- Retourne le libéllé du CA payeur si facturable
PROCEDURE get_lib_codcamo_facturable ( 	p_codcamo		IN	VARCHAR2,
			    	p_lib_codcamo		OUT	entite_structure.licoes%TYPE,
			    	p_message		OUT 	VARCHAR2
			    	) IS
BEGIN
	-- On recherche de lib dans la table centre_activite
	SELECT 	c.clibca INTO p_lib_codcamo
	FROM 	centre_activite c , datdebex d
	WHERE	c.codcamo=TO_NUMBER(p_codcamo)
	and NVL(c.cdfain,0) <> 3
	and (c.cdateferm  is null or c.cdateferm >= d.moismens);
	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		pack_global.recuperer_message( 20984, NULL, NULL, NULL, p_message);
END get_lib_codcamo_facturable;


-- Retourne le libéllé du code client
PROCEDURE get_lib_clicode ( 	p_clicode		IN	client_mo.clicode%TYPE,
				p_clilib		OUT	client_mo.clilib%TYPE,
				p_message		OUT 	VARCHAR2
				) IS

BEGIN
	-- On recherche de lib dans la table client_mo
	SELECT 	clilib INTO p_clilib
	FROM 	client_mo
	WHERE	clicode=p_clicode;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		pack_global.recuperer_message( 4, '%s1', p_clicode, NULL, p_message);
	WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM);

END get_lib_clicode;

-- Retourne le libéllé du code DPG
PROCEDURE get_lib_coddpg ( 	p_codsg		  IN	struct_info.codsg%TYPE,
				p_lib_codsg	  OUT	struct_info.libdsg%TYPE,
				p_message	  OUT 	VARCHAR2
				) IS

BEGIN
	-- On recherche de lib dans la table struct_info
	SELECT 	libdsg
	INTO    p_lib_codsg
	FROM 	struct_info
	WHERE	codsg=p_codsg;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		pack_global.recuperer_message( 20311, NULL, NULL, NULL, p_message);
	WHEN OTHERS THEN
		raise_application_error( -20997, SQLERRM);

END get_lib_coddpg;


END pack_libelles;
/
CREATE OR REPLACE PACKAGE  pack_LigCont AS

   TYPE LigContRecType IS RECORD (
                               soccont      ligne_cont.soccont%TYPE,  -- char(4)
                               soclib       societe.soclib%TYPE,
                               numcont      ligne_cont.numcont%TYPE,  -- char(15)
                               cav          ligne_cont.cav%TYPE,      -- char(2)
                               lcnum        ligne_cont.lcnum%TYPE,    -- char(2)
                               ident        VARCHAR2(5),              -- number(5)
                               rnom         ressource.rnom%TYPE,
                               rprenom      ressource.rprenom%TYPE,
                               lcprest      ligne_cont.lcprest%TYPE,  -- char(3)
                               lresdeb      VARCHAR2(10),             -- date
                               lresfin      VARCHAR2(10),             -- date
                               cout         VARCHAR2(20), -- number(12.2) table situ_ress
                               lccouact      VARCHAR2(20), -- number(12.2) table contrat
			       proporig	    varchar2(20), -- number(10,2) table ligne_cont
                               flaglock     VARCHAR2(20)
                              );

   TYPE LigContCurType IS REF CURSOR RETURN LigContRecType;

   PROCEDURE ctrl_RglGestion (p_mode    IN VARCHAR2,
			      p_soccont   IN ligne_cont.soccont%TYPE,  -- char(4)
			      p_numcont   IN ligne_cont.numcont%TYPE,  -- char(15)
			      p_cav       IN ligne_cont.cav%TYPE,      -- char(2)
			      p_lresdeb   IN VARCHAR2,  -- date
			      p_lresfin   IN VARCHAR2,  -- date
			      p_lcprest   IN ligne_cont.lcprest%TYPE, -- char(3)
			      p_message         OUT VARCHAR2
			      );

   PROCEDURE select_forinsert (
                             p_soccont    IN  ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib     IN  societe.soclib%TYPE,
                             p_numcont    IN  ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav        IN  ligne_cont.cav%TYPE,      -- char(2)
                             p_ident      IN  VARCHAR2,                 -- number(5)
                             p_userid     IN  VARCHAR2,
                             p_soccontOut OUT VARCHAR2,
                             p_soclibOut  OUT VARCHAR2,
                             p_numcontOut OUT VARCHAR2,
                             p_cavOut     OUT VARCHAR2,
                             p_identOut   OUT VARCHAR2,
                             p_rnomOut    OUT VARCHAR2,
                             p_rprenomOut OUT VARCHAR2,
                             p_coutOUT    OUT VARCHAR2,
                             p_modeout    OUT VARCHAR2,
                             p_nbcurseur  OUT INTEGER,
                             p_message    OUT VARCHAR2
                             );

   PROCEDURE select_LigCont (
                             p_mode  IN VARCHAR2,
                             p_soccont      IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib       IN societe.soclib%TYPE,
                             p_numcont      IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav          IN ligne_cont.cav%TYPE,      -- char(2)
                             p_lcnum        IN ligne_cont.lcnum%TYPE,    -- char(2)
                             p_userid       IN VARCHAR2,
                             p_curLigCont   IN OUT LigContCurType,
                             p_nbcurseur       OUT INTEGER,
                             p_message         OUT VARCHAR2
                            );

   PROCEDURE select_LigContAjout (
                             p_soccont      IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_numcont      IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav          IN ligne_cont.cav%TYPE,      -- char(2)
                             p_userid       IN VARCHAR2,
                             p_soclib    OUT VARCHAR2 ,
                             p_nbcurseur       OUT INTEGER,
                             p_message         OUT VARCHAR2
                            );

   PROCEDURE Insert_LigCont (
                             p_soccont   IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib    IN societe.soclib%TYPE,
                             p_numcont   IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav       IN ligne_cont.cav%TYPE,      -- char(2)
                             p_lcnum     IN ligne_cont.lcnum%TYPE,    -- char(2)
                             p_ident     IN VARCHAR2,                 -- number(5)
                             p_rnom      IN ressource.rnom%TYPE,
                             p_rprenom   IN ressource.rprenom%TYPE,
                             p_lcprest   IN ligne_cont.lcprest%TYPE,  -- char(3)
                             p_lresdeb   IN VARCHAR2,             -- date
                             p_lresfin   IN VARCHAR2,             -- date
                             p_cout      IN VARCHAR2, -- number(12.2) table situ_ress
                             p_lccouact  IN VARCHAR2, -- number(12.2) table contrat
			     p_proporig  IN VARCHAR2, -- number(10,2) table ligne_cont
                             p_userid    IN VARCHAR2,
                             p_nbcurseur       OUT INTEGER,
                             p_message         OUT VARCHAR2
                            ) ;

   PROCEDURE update_ligcont (
                             p_soccont   IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib    IN societe.soclib%TYPE,
                             p_numcont   IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav       IN ligne_cont.cav%TYPE,      -- char(2)
                             p_lcnum     IN ligne_cont.lcnum%TYPE,    -- char(2)
                             p_ident     IN VARCHAR2,                 -- number(5)
                             p_rnom      IN ressource.rnom%TYPE,
                             p_rprenom   IN ressource.rprenom%TYPE,
                             p_lcprest   IN ligne_cont.lcprest%TYPE,  -- char(3)
                             p_lresdeb   IN VARCHAR2,             -- date
                             p_lresfin   IN VARCHAR2,             -- date
                             p_coutDsit  IN VARCHAR2, -- number(12.2) table situ_ress
                             p_lccouact  IN VARCHAR2, -- number(12.2) table contrat
			     p_proporig  IN VARCHAR2, -- number(10,2) table ligne_cont
                             p_flaglock  IN VARCHAR2,
                             p_userid    IN VARCHAR2,
                             p_nbcurseur       OUT INTEGER,
                             p_message         OUT VARCHAR2
                            ) ;

   PROCEDURE delete_LigCont (
                             p_soccont   IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib    IN societe.soclib%TYPE,
                             p_numcont   IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav       IN ligne_cont.cav%TYPE,      -- char(2)
                             p_lcnum     IN ligne_cont.lcnum%TYPE,    -- char(2)
                             p_ident     IN VARCHAR2,                 -- number(5)
                             p_rnom      IN ressource.rnom%TYPE,
                             p_rprenom   IN ressource.rprenom%TYPE,
                             p_lcprest   IN ligne_cont.lcprest%TYPE,  -- char(3)
                             p_lresdeb   IN VARCHAR2,             -- date
                             p_lresfin   IN VARCHAR2,             -- date
                             p_cout      IN VARCHAR2, -- number(12.2) table situ_ress
                             p_lccouact  IN VARCHAR2, -- number(12.2) table contrat
			     p_proporig  IN VARCHAR2, -- number(10,2) table ligne_cont
                             p_userid    IN VARCHAR2,
                             p_nbcurseur       OUT INTEGER,
                             p_message         OUT VARCHAR2
                            ) ;


END  pack_LigCont;
/

CREATE OR REPLACE PACKAGE BODY  pack_LigCont AS

   -- *************************************************************************
   -- ctrl_RglGestion
   -- *************************************************************************
   PROCEDURE ctrl_RglGestion (p_mode    IN VARCHAR2,
			      p_soccont   IN ligne_cont.soccont%TYPE,  -- char(4)
			      p_numcont   IN ligne_cont.numcont%TYPE,  -- char(15)
			      p_cav       IN ligne_cont.cav%TYPE,      -- char(2)
			      p_lresdeb   IN VARCHAR2,  -- date
			      p_lresfin   IN VARCHAR2,  -- date
			      p_lcprest   IN ligne_cont.lcprest%TYPE, -- char(3)
			      p_message         OUT VARCHAR2
                            ) IS
      l_msg VARCHAR2(1024);
      l_datdeb DATE;
      l_datfin DATE;
      l_codprest ligne_cont.lcprest%TYPE;

   BEGIN

      -- Cas Creation ou Modification
      IF (p_mode = 'insert') OR (p_mode = 'update') THEN
         -- RG1 : Dates de début et de fin de prestation doivent être comprises
         -- entre dates de début et de fin de contrat.
         BEGIN
            SELECT c.cdatdeb, c.cdatfin
            INTO   l_datdeb, l_datfin
            FROM   contrat c
            WHERE  c.soccont = p_soccont
              AND  c.numcont = RPAD(p_numcont,15)
              AND  c.cav = p_cav;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
                   -- Erreur message "Contrat inexistant"
                   pack_global.recuperer_message(20280, NULL, NULL, NULL, l_msg);
                   raise_application_error(-20280,l_msg);
            WHEN OTHERS THEN
                   raise_application_error(-20997,SQLERRM);
         END;


         IF TO_DATE(p_lresdeb,'dd/mm/yyyy') > TO_DATE(p_lresfin,'dd/mm/yyyy') THEN
            -- La date de fin doit être supérieure ou égale à la date de début
            pack_global.recuperer_message(20284, null, null, 'LRESDEB', l_msg);
            raise_application_error(-20284, l_msg);

         ELSIF  ( TO_DATE(p_lresdeb,'dd/mm/yyyy') < l_datdeb ) OR
                ( TO_DATE(p_lresdeb,'dd/mm/yyyy') > l_datfin ) OR
                ( TO_DATE(p_lresfin,'dd/mm/yyyy') < l_datdeb ) OR
                ( TO_DATE(p_lresfin,'dd/mm/yyyy') > l_datfin ) THEN

            -- message : Dates de début et de fin de prestation doivent être comprises
            -- entre dates de début et de fin de contrat.
            pack_global.recuperer_message(20435, null, null, 'LRESDEB', l_msg);
            raise_application_error(-20435, l_msg);
         END IF;

	 -- TEST sur la validité de la prestation
	 BEGIN
	    SELECT  prestation
	      INTO  l_codprest
	      FROM  prestation
	      WHERE prestation = p_lcprest
	      AND   upper(top_actif) = 'O';

	 EXCEPTION
	    WHEN no_data_found THEN
	      pack_global.recuperer_message(20246, '%s1', p_lcprest, 'LCPREST', l_msg);
	    raise_application_error( -20246, l_msg);
	    WHEN OTHERS THEN
	      raise_application_error(-20997,SQLERRM);
	 END;

      END IF; -- Fin de Cas Creation ou Modification

   END ctrl_RglGestion;

   -- *************************************************************************
   -- select_forinsert
   -- *************************************************************************
   PROCEDURE select_forinsert (
                             p_soccont    IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib     IN societe.soclib%TYPE,
                             p_numcont    IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav        IN ligne_cont.cav%TYPE,      -- char(2)
                             p_ident      IN VARCHAR2,                 -- number(5)
                             p_userid     IN VARCHAR2,
                             p_soccontOut OUT VARCHAR2,
                             p_soclibOut  OUT VARCHAR2,
                             p_numcontOut OUT VARCHAR2,
                             p_cavOut     OUT VARCHAR2,
                             p_identOut   OUT VARCHAR2,
                             p_rnomOut    OUT VARCHAR2,
                             p_rprenomOut OUT VARCHAR2,
                             p_coutOUT    OUT VARCHAR2,
                             p_modeout    OUT VARCHAR2,
                             p_nbcurseur  OUT INTEGER,
                             p_message    OUT VARCHAR2
                             ) IS

      l_msg        VARCHAR2(1024);
      l_rnom       ressource.rnom%TYPE;
      l_rprenom    ressource.rprenom%TYPE;
      l_cout       situ_ress.cout%TYPE;
      l_ident      ressource.ident%TYPE;
      l_datsitu    date;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      p_soccontOut :=  p_soccont;
      p_soclibOut  :=  p_soclib;
      p_numcontOut :=  p_numcont;
      p_cavOut     :=  p_cav;
      p_identOut      :=  p_ident;

      -- Test de l'existance de ressource et recherche de son nom
      BEGIN
         SELECT rnom, rprenom
         INTO   l_rnom, l_rprenom
         FROM   ressource
         WHERE  ident = TO_NUMBER(p_ident);
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            -- Message : Code ressource inexistant
            pack_global.recuperer_message(20437, '%s1', p_ident, NULL, l_msg);
            raise_application_error(-20437, l_msg);
         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;


      -- Test d'appartenance de la ressource à la societe,
      -- Si la prestation
      l_cout:=0;
      BEGIN
	   SELECT sr.ident, sr.datsitu, sr.cout
         INTO     l_ident, l_datsitu, l_cout
 	   FROM   situ_ress sr, ressource r
 	   WHERE  sr.ident = r.ident
           AND    (sr.ident, sr.datsitu) = (SELECT ident, MAX(datsitu)
                                          FROM situ_ress
                                          WHERE ident = TO_NUMBER(p_ident)
                                          AND (soccode = p_soccont
                                               or upper(PRESTATION) = 'FIC')
                                          GROUP BY ident
                                          );
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            -- Message : La ressource %s1 n'appartient pas à la société %s2.
            pack_global.recuperer_message(20438, '%s1', p_ident, '%s2', p_soccont, NULL, l_msg);
            raise_application_error(-20438, l_msg);
         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      p_rnomOut :=  l_rnom;
      p_rprenomOut := l_rprenom;
      p_modeout := 'insert';
      p_coutOut :=  TO_CHAR(l_cout,'FM9999999999D00');

   END select_forinsert;


   -- *************************************************************************
   -- select_LigCont
   -- *************************************************************************
   PROCEDURE select_LigCont (
                             p_mode IN VARCHAR2,
                             p_soccont     IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib      IN societe.soclib%TYPE,
                             p_numcont     IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav         IN ligne_cont.cav%TYPE,      -- char(2)
                             p_lcnum       IN ligne_cont.lcnum%TYPE,    -- char(2)
                             p_userid      IN VARCHAR2,
                             p_curLigCont  IN OUT LigContCurType,
                             p_nbcurseur      OUT INTEGER,
                             p_message        OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      BEGIN
            OPEN p_curLigCont FOR
               SELECT l.soccont,
                      s.soclib,
                      l.numcont,
                      l.cav,
                      l.lcnum,
                      to_char(l.ident,'FM99999'),
                      r.rnom,
                      r.rprenom,
                      l.lcprest,
                      TO_CHAR(l.lresdeb,'dd/mm/yyyy'),
                      TO_CHAR(l.lresfin,'dd/mm/yyyy'),
                      TO_CHAR(sr.cout,'FM9999999999D00'),
                      TO_CHAR(l.lccouact,'FM9999999999D00'),
		      TO_CHAR(nvl(l.proporig,0),'FM9999990D00'),
                      TO_CHAR(c.flaglock)
              FROM    ligne_cont l, contrat c,societe s, ressource r,
                      situ_ress sr
              WHERE   c.soccont = l.soccont
                AND   c.numcont = l.numcont
                AND   c.cav = l.cav
                AND   l.ident = r.ident
                AND   r.ident = sr.ident
                AND   l.soccont = p_soccont
                AND   l.numcont = RPAD(p_numcont,15)
                AND   l.cav = p_cav
                AND   l.lcnum = p_lcnum
                AND   s.soccode = p_soccont
                AND   (sr.ident, sr.datsitu) = (SELECT ident, MAX(datsitu)
                                                FROM situ_ress
                                                WHERE ident = TO_NUMBER(r.ident)
                                                GROUP BY ident
                                                );
      EXCEPTION
            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
      END; -- fin de select

 -- dbms_output.put_line('lcnum = ' || p_lcnum);
   END select_LigCont;

PROCEDURE select_LigContAjout (
                             p_soccont      IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_numcont      IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav          IN ligne_cont.cav%TYPE,      -- char(2)
                             p_userid       IN VARCHAR2,
                              p_soclib    OUT VARCHAR2 ,
                             p_nbcurseur       OUT INTEGER,
                             p_message         OUT VARCHAR2
                            )IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      BEGIN
            SELECT s.soclib INTO p_soclib
            FROM    societe s
              WHERE s.soccode = p_soccont
                ;
      END; -- fin de select


   END select_LigContAjout;

   -- *************************************************************************
   -- Insert_LigCont
   -- *************************************************************************
   PROCEDURE Insert_LigCont (
                             p_soccont   IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib    IN societe.soclib%TYPE,
                             p_numcont   IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav       IN ligne_cont.cav%TYPE,      -- char(2)
                             p_lcnum     IN ligne_cont.lcnum%TYPE,    -- number(2)
                             p_ident     IN VARCHAR2,                 -- number(5)
                             p_rnom      IN ressource.rnom%TYPE,
                             p_rprenom   IN ressource.rprenom%TYPE,
                             p_lcprest   IN ligne_cont.lcprest%TYPE,  -- char(3)
                             p_lresdeb   IN VARCHAR2,                 -- date
                             p_lresfin   IN VARCHAR2,                 -- date
                             p_cout      IN VARCHAR2,        -- number(12.2) table situ_ress
                             p_lccouact  IN VARCHAR2,        -- number(12.2) table contrat
			     p_proporig  IN VARCHAR2, -- number(10,2) table ligne_cont
                             p_userid    IN VARCHAR2,
                             p_nbcurseur    OUT INTEGER,
                             p_message      OUT VARCHAR2
                            ) IS
   l_msg VARCHAR2(1024);
   l_maxlcnum ligne_cont.lcnum%TYPE;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

       ctrl_RglGestion ('insert',p_soccont,p_numcont,p_cav,p_lresdeb,p_lresfin, p_lcprest, p_message);

      -- lcnum est partie de la clé de la table ligne_cont.
      -- Pour inserer une nouvelle ligne, on prend le dernier lcnum de la societe
      -- et on y ajoute 1.
      BEGIN
         SELECT max(l.lcnum)      -- S'il ne trouve pas la function d'agregat
         INTO   l_maxlcnum        -- empeche le leve de l'exception when no data found.
         FROM   ligne_cont l
         WHERE  l.soccont = p_soccont
           AND  l.numcont = RPAD(p_numcont,15)
           AND  l.cav = p_cav;
      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF l_maxlcnum is null THEN
         l_maxlcnum := 0;
      END IF;

      BEGIN
       INSERT INTO ligne_cont(soccont,
                              numcont,
                              cav,
                              lcnum,
                              ident,
                              lcprest,
                              lresdeb,
                              lresfin,
                              lccouact,
                              lccouinit,
                              lfraisdep,  -- char(1)
                              lastreinte, -- char(1)
                              lheursup,   -- char(1)
                              lcdatact,    -- date
			      proporig
                             )
         VALUES (p_soccont,
                 RPAD(p_numcont,15),
                 p_cav,
                 l_maxlcnum + 1,
                 TO_NUMBER(p_ident),
                 p_lcprest,
                 TO_DATE(p_lresdeb,'dd/mm/yyyy'),
                 TO_DATE(p_lresfin,'dd/mm/yyyy'),
                 TO_NUMBER(p_lccouact),
                 TO_NUMBER(p_lccouact),
                 null,
                 null,
                 null,
                 null,
		 TO_NUMBER(p_proporig)
                );

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN

            -- Ligne contrat déjà existant
            pack_global.recuperer_message(20285,NULL, NULL, NULL, l_msg);
            raise_application_error(-20285 , l_msg );

         WHEN OTHERS THEN

            raise_application_error( -20997, SQLERRM );
      END;  -- fin d'insert

      IF SQL%NOTFOUND THEN
         -- Accès concurrent sur les mêmes données,\nveuillez recharger vos données
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         -- Ligne contrat %s1 créee pour le contrat %s2
         pack_global.recuperer_message(4004,'%s1',l_maxlcnum + 1,'%s2',p_numcont, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END insert_LigCont;

-- *************************************************************************
-- update_ligcont
-- *************************************************************************
   PROCEDURE update_ligcont (
                             p_soccont   IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib    IN societe.soclib%TYPE,
                             p_numcont   IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav       IN ligne_cont.cav%TYPE,      -- char(2)
                             p_lcnum     IN ligne_cont.lcnum%TYPE,    -- char(2)
                             p_ident     IN VARCHAR2,                 -- number(5)
                             p_rnom      IN ressource.rnom%TYPE,
                             p_rprenom   IN ressource.rprenom%TYPE,
                             p_lcprest   IN ligne_cont.lcprest%TYPE,  -- char(3)
                             p_lresdeb   IN VARCHAR2,             -- date
                             p_lresfin   IN VARCHAR2,             -- date
                             p_coutDsit  IN VARCHAR2, -- number(12.2) table situ_ress
                             p_lccouact  IN VARCHAR2, -- number(12.2) table contrat
			     p_proporig  IN VARCHAR2, -- number(10,2) table ligne_cont
                             p_flaglock  IN VARCHAR2,
                             p_userid    IN VARCHAR2,
                             p_nbcurseur       OUT INTEGER,
                             p_message         OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);
      l_filcode filiale_cli.filcode%TYPE;
      l_topfer  struct_info.topfer%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      ctrl_RglGestion ('update',p_soccont,p_numcont,p_cav,p_lresdeb,p_lresfin, p_lcprest, p_message);

      -- UPDATE ligne contrat
      BEGIN
         UPDATE ligne_cont
         SET lcprest  = p_lcprest,
             lresdeb  = TO_DATE(p_lresdeb, 'DD/MM/YYYY'),
             lresfin  = TO_DATE(p_lresfin, 'DD/MM/YYYY'),
             lccouact = TO_NUMBER(p_lccouact),
	     proporig = TO_NUMBER(p_proporig)
         WHERE soccont = p_soccont
         AND   numcont = RPAD(p_numcont,15)
         AND   cav     = p_cav
         AND   lcnum   = p_lcnum;
      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;


      IF SQL%NOTFOUND THEN
         -- Accès concurrent sur les mêmes données,\nveuillez recharger vos données
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         -- 'Ligne contrat %s1 modifiée pour le contrat %s2'
         pack_global.recuperer_message(4003,'%s1',p_lcnum,'%s2',p_numcont, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END update_ligcont;
   -- *************************************************************************
   -- delete_LigCont
   -- *************************************************************************
   PROCEDURE delete_LigCont (
                             p_soccont   IN ligne_cont.soccont%TYPE,  -- char(4)
                             p_soclib    IN societe.soclib%TYPE,
                             p_numcont   IN ligne_cont.numcont%TYPE,  -- char(15)
                             p_cav       IN ligne_cont.cav%TYPE,      -- char(2)
                             p_lcnum     IN ligne_cont.lcnum%TYPE,    -- char(2)
                             p_ident     IN VARCHAR2,                 -- number(5)
                             p_rnom      IN ressource.rnom%TYPE,
                             p_rprenom   IN ressource.rprenom%TYPE,
                             p_lcprest   IN ligne_cont.lcprest%TYPE,  -- char(3)
                             p_lresdeb   IN VARCHAR2,             -- date
                             p_lresfin   IN VARCHAR2,             -- date
                             p_cout      IN VARCHAR2, -- number(12.2) table situ_ress
                             p_lccouact  IN VARCHAR2, -- number(12.2) table contrat
			     p_proporig  IN VARCHAR2, -- number(10,2) table ligne_cont
                             p_userid    IN VARCHAR2,
                             p_nbcurseur       OUT INTEGER,
                             p_message         OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM ligne_cont l
           WHERE l.soccont  = p_soccont
             AND l.numcont  = p_numcont
             AND l.cav      = p_cav
             AND l.lcnum    = p_lcnum;
      EXCEPTION
          WHEN OTHERS THEN
              raise_application_error(-20997, SQLERRM);
      END;


      IF SQL%NOTFOUND THEN
         -- Accès concurrent sur les mêmes données,\nveuillez recharger vos données
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         -- Ligne contrat %s1 supprimée pour le contrat %s2.
            pack_global.recuperer_message(4005,'%s1',p_lcnum,'%s2',p_numcont, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END delete_LigCont;
END  pack_LigCont;
/
CREATE OR REPLACE PACKAGE Pack_Ligne_Bip AS


   -- definition d'un enregistrement de la table ligne_bip pour la gestion  des entetes

   TYPE ligne_bip_ViewType IS RECORD ( PID         	LIGNE_BIP.PID%TYPE,
                                       PCLE        	LIGNE_BIP.PCLE%TYPE,
                                       PNOM        	LIGNE_BIP.PNOM%TYPE,
                                       ASTATUT     	LIGNE_BIP.ASTATUT%TYPE,
                                       LIBSTATUT   	CODE_STATUT.LIBSTATUT%TYPE,
				       TOPFER      	LIGNE_BIP.TOPFER%TYPE,
                                       ADATESTATUT 	VARCHAR2(10),
                                       TYPPROJ     	TYPE_PROJET.TYPPROJ%TYPE,
                                       LIBTYP      	TYPE_PROJET.LIBTYP%TYPE,
                                       ARCTYPE     	LIGNE_BIP.ARCTYPE%TYPE,
                                       LIBTYP2	   	TYPE_ACTIVITE.LIBARC%TYPE,
                                       CODPSPE     	LIGNE_BIP.CODPSPE%TYPE,
                                       TOPTRI      	LIGNE_BIP.TOPTRI%TYPE,
                                       DPCODE      	CHAR(5),
                                       PDATDEBPRE  	VARCHAR2(7),
                                       ICPI        	LIGNE_BIP.ICPI%TYPE,
                                       CODSG       	LIGNE_BIP.CODSG%TYPE,
                                       AIRT        	LIGNE_BIP.AIRT%TYPE,
                                       PCPI        	LIGNE_BIP.PCPI%TYPE,
                                       CLICODE     	LIGNE_BIP.CLICODE%TYPE,
                                       CLILIB	   	CLIENT_MO.CLILIB%TYPE,
                                       CODCAMO     	LIGNE_BIP.CODCAMO%TYPE,
                                       LIB_CODCAMO	ENTITE_STRUCTURE.LICOES%TYPE,
                                       PNMOUVRA    	LIGNE_BIP.PNMOUVRA%TYPE,
				       METIER      	LIGNE_BIP.METIER%TYPE,
				       POBJET 	   	LIGNE_BIP.POBJET%TYPE,
				       PZONE 	   	LIGNE_BIP.PZONE%TYPE,
				       CLICODE_OPER 	LIGNE_BIP.CLICODE_OPER%TYPE,
				       CLILIB_OPER 	CLIENT_MO.CLILIB%TYPE,
				       SOUS_TYPO        LIGNE_BIP.SOUS_TYPE%TYPE,
				       LIBSOUSTYPE      SOUS_TYPOLOGIE.LIBSOUSTYPE%TYPE,
				       CODBR		BRANCHES.CODBR%TYPE,
                                       FLAGLOCK    	LIGNE_BIP.FLAGLOCK%TYPE,
									   CODREP		LIGNE_BIP.CODREP%TYPE,
									   LIBCODREP	RJH_TABREPART.LIBREP%TYPE
					);


   -- définition du curseur sur la table ligne_bip pour la gestion de l'entete du projet

   TYPE ligne_bipCurType IS REF CURSOR RETURN ligne_bip_ViewType;


   FUNCTION SplitLongLine (chaine VARCHAR2) RETURN VARCHAR2;

   FUNCTION controle_obj (objet VARCHAR2) RETURN VARCHAR2;

   PROCEDURE maj_ligne_bip_logs(p_pid		IN LIGNE_BIP_LOGS.pid%TYPE,
   				p_user_log	IN LIGNE_BIP_LOGS.user_log%TYPE,
   				p_colonne	IN LIGNE_BIP_LOGS.colonne%TYPE,
   				p_valeur_prec	IN LIGNE_BIP_LOGS.valeur_prec%TYPE,
   				p_valeur_nouv	IN LIGNE_BIP_LOGS.valeur_nouv%TYPE,
   				p_commentaire	IN LIGNE_BIP_LOGS.commentaire%TYPE
   				);

   PROCEDURE select_ligne_bip ( p_pnom         IN VARCHAR2,
                                p_pid          IN CHAR,
                                p_userid       IN VARCHAR2,
				p_duplic       IN VARCHAR2,
                                p_curLigne_bip IN OUT ligne_bipCurType,
                                p_nbcurseur    OUT INTEGER,
                                p_message      OUT VARCHAR2
                              );

   PROCEDURE insert_ligne_bip (
			       p_pnom       	IN VARCHAR2,
                               p_typproj    	IN CHAR,
			       p_pdatdebpre 	IN CHAR,
                               p_arctype    	IN VARCHAR2,
 			       p_toptri     	IN CHAR,
                               p_codpspe    	IN CHAR,
                               p_icpi       	IN CHAR,
 			       p_airt       	IN CHAR,
                               p_dpcode     	IN CHAR,
                               p_codsg      	IN CHAR,
                               p_pcpi       	IN CHAR,
                               p_clicode    	IN CHAR,
                               p_codcamo    	IN CHAR,
                               p_pnmouvra   	IN CHAR,
			       p_metier     	IN CHAR, --aur
                               p_liste_objet	IN VARCHAR2,
			       p_pobjet     	IN VARCHAR2,
			       p_pzone     	IN VARCHAR2,
			       p_clicode_oper	IN VARCHAR2,
			       p_sous_typo	IN VARCHAR2,
			       p_codrep	IN VARCHAR2,
                               p_userid     	IN VARCHAR2,
                               p_pid        	OUT CHAR,
                               p_pcle       	OUT CHAR,
                               p_nbcurseur  	OUT INTEGER,
                               p_message    	OUT VARCHAR2
                              );


   PROCEDURE calcul_pid ( p_pid IN OUT VARCHAR2 );

   PROCEDURE calcul_base_35 ( p_pidMax IN VARCHAR2,
                              p_pid IN OUT VARCHAR2 );

   PROCEDURE calcul_cle ( p_pid IN VARCHAR2,
                          p_cle OUT VARCHAR2 );


   PROCEDURE update_ligne_bip ( p_typproj     	IN CHAR,
				p_pid         	IN CHAR,
                                p_pcle        	IN CHAR,
                                p_pnom        	IN VARCHAR2,
                                p_astatut     	IN CHAR,
				p_topfer      	IN CHAR,
                                p_adatestatut 	IN CHAR,
                           	p_pdatdebpre  	IN CHAR,
                                p_arctype     	IN VARCHAR2,
			       	p_toptri      	IN CHAR,
                                p_codpspe     	IN CHAR,
                                p_icpi        	IN CHAR,
			       	p_airt        	IN CHAR,
                                p_dpcode      	IN CHAR,
                                p_codsg       	IN CHAR,
                                p_pcpi        	IN CHAR,
                                p_clicode     	IN CHAR,
                                p_codcamo     	IN CHAR,
                                p_pnmouvra    	IN CHAR,
                                p_metier      	IN CHAR,  --aur nouvelle valeur
				p_pobjet      	IN VARCHAR2,
			       	p_liste_objet 	IN VARCHAR2,
				p_pzone       	IN VARCHAR2,
				p_clicode_oper	IN VARCHAR2,
				p_sous_typo	IN VARCHAR2,
			        p_flaglock    	IN NUMBER,
				p_codrep	IN VARCHAR2,
                                p_userid      	IN VARCHAR2,
                                p_nbcurseur   	OUT INTEGER,
                                p_message     	OUT VARCHAR2
                              );

PROCEDURE RECUPERER_CODE_BRANCHE(p_clicode		IN	CLIENT_MO.clicode%TYPE,
				p_codbr		OUT	VARCHAR2,
				p_message		OUT 	VARCHAR2);

PROCEDURE REMISE_A_ZERO(p_pid		IN	LIGNE_BIP.pid%TYPE,
                        p_userid   	IN VARCHAR2,
                        p_message	OUT 	VARCHAR2);

END Pack_Ligne_Bip;
/

CREATE OR REPLACE PACKAGE BODY Pack_Ligne_Bip AS

   FUNCTION SplitLongLine (chaine VARCHAR2) RETURN VARCHAR2 IS
	pos NUMBER;
	aux VARCHAR2(100);
   BEGIN
	IF (LENGTH(chaine) <= 60) OR chaine IS NULL THEN
		RETURN(chaine);
	ELSE
		aux := SUBSTR (chaine,1,60);
		pos := INSTR(aux,' ',-1,1);
-- on traite ici le cas des mots de + de 60 caracteres (genre testeurs fous ou endormis sur le clavier)
		IF (pos=0) THEN
			pos:=60;
		END IF;
		RETURN ( SUBSTR(chaine,1,pos-1) || CHR(10) || SplitLongLine (SUBSTR(chaine,pos+1)));
  	END IF;
   END;


  FUNCTION controle_obj (objet VARCHAR2) RETURN VARCHAR2 IS
	l_nbligne 	NUMBER;
      	ligne		VARCHAR2(2000);
      	objet_split	VARCHAR2(2000);
      	chaine		VARCHAR2(2000);
      	pos 		NUMBER;
      	msg 		VARCHAR(1024);

   BEGIN
	-- chaque ligne de l'objet doit faire moins de 60 caractères
	-- sinon au 60ème caractère on met un retour chariot

	-- recherche de la première ligne , on récupère la chaine de caractères qui va jusqu'au premier retour chariot
	--et on répète les opérations jusqu'à la dernière ligne
	objet_split:='';
	chaine:=REPLACE(objet, CHR(13), '');
	chaine:=RTRIM(chaine, CHR(10));
 	<<boucle>> LOOP
		pos := INSTR(chaine,CHR(10));
		IF (pos=0) THEN
			ligne:=chaine;
			chaine:='';
		ELSE
			ligne := SUBSTR(chaine,1,pos-1);
			chaine:= SUBSTR(chaine, pos+1);
		END IF;

	-- test la longueur de la  ligne
		objet_split := objet_split || CHR(10) || SplitLongLine (ligne);

		EXIT boucle WHEN chaine IS NULL;
	END LOOP;
-- suppression du 1er retour chariot
	objet_split:=SUBSTR(objet_split, 2);

      -- On vérifie que le champ objet ne dépasse pas 5 lignes
	l_nbligne := INSTR(objet_split,CHR(10), 1, 5);
	IF (l_nbligne>0) THEN
		--Le champ objet ne doit pas dépasser 5 lignes
		Pack_Global.recuperer_message(20378, NULL, NULL, 'LISTE_OBJET', msg);
                RAISE_APPLICATION_ERROR(-20378, msg);

	END IF;
        RETURN(objet_split);
   END;

------------------------------------------------------------------------------------------------------

   PROCEDURE calcul_pid ( p_pid IN OUT VARCHAR2 ) IS
      pidMax VARCHAR2(4);
      tampon NUMBER(1);
   BEGIN

      -- Attention la requete :
      -- SELECT MAX(PID) INTO pidMax FROM LIGNE_BIP;
      -- ne marche pas (la base 35 est construite selon ordre
      -- binaire des lettres puis des chiffres en vigueur en EBCDIC
      -- sur le site central IBM...
      -- => conversions necessaires pour recuperer la
      --    valeur pid maximale dans la table.


	SELECT 1
	INTO tampon
	FROM LIGNE_BIP
	WHERE LENGTH(RTRIM(pid))=4
	AND ROWNUM=1;

      	SELECT CONVERT( MAX( CONVERT( pid, 'WE8EBCDIC500' ) ),
                	      'WE8PC850',
                	      'WE8EBCDIC500'
                	    )
      	INTO pidMax
      	FROM LIGNE_BIP
      	WHERE LENGTH(RTRIM(pid))=4;

      	calcul_base_35( pidMax, p_pid );

   EXCEPTION

   	WHEN NO_DATA_FOUND THEN
   		SELECT CONVERT( MAX( CONVERT( pid, 'WE8EBCDIC500' ) ),
                	      'WE8PC850',
                	      'WE8EBCDIC500'
                	    )
      		INTO pidMax
      		FROM LIGNE_BIP;

      		IF pidMax IS NULL THEN
        		 p_pid := 'AAA';
      		ELSE
         		calcul_base_35( pidMax, p_pid );
      		END IF;

   END calcul_pid;

------------------------------------------------------------------------------------------------------

   PROCEDURE calcul_base_35 ( p_pidMax IN VARCHAR2,
                              p_pid    IN OUT VARCHAR2
                            ) IS
	msg VARCHAR(1024);
	base35 CHAR(35) := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789';
	base26 CHAR(26) := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	position NUMBER;
	pidMax VARCHAR2(4);
	longueur NUMBER;

   BEGIN
      -- debut calcul
      -- copie parametre

      pidMax := p_pidMax;

      -- On détermine s'il sagit d'un pid à 3 ou 4 caractères
      SELECT LENGTH(RTRIM(pidMax)) INTO longueur
      FROM dual;

      -- On garde un triatement spécifique pour les PID à 3 caractères en attendant
      -- que tous les PID soient sur 4.
      IF longueur = 3 THEN
           -- calcul de la valeur en base 35 du dernier caractere pour incrementation
           position := INSTR( base35, SUBSTR( pidMax,3, 1) );

           IF position < 35 THEN
             -- incrementer simplement le dernier caractere
             p_pid := SUBSTR( pidMax, 1, 2) || SUBSTR( base35, position+1, 1 );

           ELSE
              -- if faut incrementer le caractere du milieu
              position := INSTR( base35, SUBSTR( pidMax, 2, 1) );

              IF position < 35 THEN
                 -- incrementer simplement le caractere du milieu
                 -- le dernier caractere est 'A'
                 p_pid := SUBSTR(pidMax,1,1)||SUBSTR( base35, position+1, 1 ) ||'A';

              ELSE
                      -- if faut incrementer le premier caractere
                 position := INSTR( base26, SUBSTR( pidMax, 1, 1) );

                 IF position < 26 THEN
                    -- les 2 derniers caracteres sont 'AA'

                    p_pid := SUBSTR( base26, position+1, 1 ) || 'AA';
                 ELSE
                    -- on passe aux pid à 4 caracteres
                    p_pid :='AAAA';

                 END IF;
              END IF;
           END IF;
      ELSE
      	   -- calcul de la valeur en base 35 du dernier caractere pour incrementation
           position := INSTR( base35, SUBSTR( pidMax,4, 1) );

           IF position < 35 THEN
             -- incrementer simplement le dernier caractere
             p_pid := SUBSTR( pidMax, 1, 3) || SUBSTR( base35, position+1, 1 );

           ELSE
              -- if faut incrementer le 3eme caractere
              position := INSTR( base35, SUBSTR( pidMax, 3, 1) );

              IF position < 35 THEN
                 -- incrementer simplement le 3eme caractere, le dernier caractere est 'A'
                 p_pid := SUBSTR(pidMax,1,2)||SUBSTR( base35, position+1, 1 ) ||'A';

              ELSE
                  -- Il faut incrementer le 2eme caractere
                  position := INSTR( base35, SUBSTR( pidMax, 2, 1) );

                  IF position < 35 THEN
                 	-- incrementer simplement le 2EME caractere les derniers sont 'AA'
                 	p_pid := SUBSTR(pidMax,1,1)||SUBSTR( base35, position+1, 1 ) ||'AA';

                   ELSE
				        -- if faut incrementer le premier caractere
                           position := INSTR( base26, SUBSTR( pidMax, 1, 1) );

                           IF position < 26 THEN
                              -- les 2 derniers caracteres sont 'AA'

                              p_pid := SUBSTR( base26, position+1, 1 ) || 'AAA';
                           ELSE
                              -- probleme => theoriquement plus de code dispo
                              -- 'DERNIER IDENTIFIANT ATTEINT'

                              Pack_Global.recuperer_message(20014, NULL, NULL, NULL, msg);
                              RAISE_APPLICATION_ERROR( -20014, msg );
                           END IF;
                   END IF;
             END IF;
           END IF;
      END IF;


      IF p_pid IN ( 'ASH', 'BAD', 'BAF', 'BIT', 'CUL', 'CON', 'DIR',
                    'SAG', 'SAT', 'SIM', 'CIF', 'SIF', 'SMP',
                    'ANAL','ANUS','BITE','BUSH','CACA','CATO','CFDT','CFTC','CHIE','COCU','CUCU' ) THEN

         -- identifiants interdits
         -- => Relancer le calcul

         pidMax := p_pid;
         calcul_base_35( pidMax, p_pid );
      END IF;


   END calcul_base_35;


---------------------------------------------------------------------------------------------------------------
   PROCEDURE calcul_cle ( p_pid IN VARCHAR2,
                          p_cle OUT VARCHAR2
                        ) IS
      base36 CHAR(36) := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      position_1 NUMBER;
      position_2 NUMBER;
      position_3 NUMBER;
      position_4 NUMBER;
      valeur_C1 NUMBER;
      valeur_C2 NUMBER;
      valeur_C3 NUMBER;
      char_D1 CHAR;
      char_D2 CHAR;
      char_D3 CHAR;
      longueur NUMBER;

   BEGIN
      position_1 := INSTR( base36, SUBSTR( p_pid, 1, 1) );
      position_2 := INSTR( base36, SUBSTR( p_pid, 2, 1) );
      position_3 := INSTR( base36, SUBSTR( p_pid, 3, 1) );
      position_4 := INSTR( base36, SUBSTR( p_pid, 4, 1) );

      valeur_C1 := MOD((31*position_3) + (11*position_2) + 2, 36) + 1;

      valeur_C2 := MOD((7*position_3) + (23*position_1) + 2, 36) + 1;

      char_D1 := SUBSTR( base36, valeur_C1, 1);
      char_D2 := SUBSTR( base36, valeur_C2, 1);


-- On détermine s'il sagit d'un pid à 3 ou 4 caractères
      SELECT LENGTH(RTRIM(p_pid)) INTO longueur
      FROM dual;

	IF longueur = 3 THEN

          	-- la cle est la concatenation des 2 caracteres calcules

          	p_cle := char_D1||char_D2;

	ELSE

          	-- la cle doit comporter un troisieme caractere.
          	-- On calcule a nouveau

          	valeur_C1 := MOD((30*position_2) + (17*position_4) + 2, 36) + 1;
          	valeur_C2 := MOD((11*position_2) + (31*position_3) + 2, 36) + 1;
          	valeur_C3 := MOD((23*position_1) + (7*position_3) + 2, 36) + 1;

          	char_D1 := SUBSTR( base36, valeur_C1, 1);
          	char_D2 := SUBSTR( base36, valeur_C2, 1);
          	char_D3 := SUBSTR( base36, valeur_C3, 1);

          	p_cle := char_D1||char_D2||char_D3;

	END IF;

   END calcul_cle;


   -- Procédure pour remplir les logs de MAJ de la ligne BIP
   PROCEDURE maj_ligne_bip_logs(p_pid		IN LIGNE_BIP_LOGS.pid%TYPE,
   				p_user_log	IN LIGNE_BIP_LOGS.user_log%TYPE,
   				p_colonne	IN LIGNE_BIP_LOGS.colonne%TYPE,
   				p_valeur_prec	IN LIGNE_BIP_LOGS.valeur_prec%TYPE,
   				p_valeur_nouv	IN LIGNE_BIP_LOGS.valeur_nouv%TYPE,
   				p_commentaire	IN LIGNE_BIP_LOGS.commentaire%TYPE
   				) IS
   BEGIN

	IF (UPPER(LTRIM(RTRIM(NVL(p_valeur_prec, 'NULL')))) <> UPPER(LTRIM(RTRIM(NVL(p_valeur_nouv, 'NULL'))))) THEN
		INSERT INTO LIGNE_BIP_LOGS
			(pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
		VALUES
			(p_pid, SYSDATE, p_user_log, p_colonne, p_valeur_prec, p_valeur_nouv, p_commentaire);

	END IF;
	-- Pas de commit  car en cas d'erreur la MAJ n'est pas enregistrée et il ne faut donc pas créer de ligne

   END maj_ligne_bip_logs;



   PROCEDURE select_ligne_bip ( p_pnom         IN VARCHAR2,
                                p_pid          IN CHAR,
                                p_userid       IN VARCHAR2,
				p_duplic       IN VARCHAR2,
                                p_curLigne_bip IN OUT ligne_bipCurType,
                                p_nbcurseur    OUT INTEGER,
                                p_message      OUT VARCHAR2
                              ) IS
      msg 		VARCHAR(1024);
      l_pid 		LIGNE_BIP.pid%TYPE;
      tmp_codsg 	LIGNE_BIP.codsg%TYPE;
      TEST 		NUMBER;
      l_habilitation 	VARCHAR2(10);

   BEGIN
IF (p_pid IS NOT NULL) THEN

         BEGIN

            -- Verifier que le projet existe pour la modification

            SELECT pid INTO l_pid
            FROM LIGNE_BIP
            WHERE pid = p_pid;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN

               -- Code projet %s1 inexistant

               Pack_Global.recuperer_message(20504, '%s1', p_pid, NULL, msg);
               RAISE_APPLICATION_ERROR( -20504, msg );
            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         -- test de l'habilitation
         BEGIN
           SELECT codsg INTO tmp_codsg
           FROM   LIGNE_BIP
           WHERE  pid = p_pid;

         EXCEPTION
           WHEN OTHERS THEN
 RAISE_APPLICATION_ERROR( -20997, SQLERRM);

         END;

  -- ====================================================================
      -- 12/02/2001 : Test appartenance du DPG au perimetre de l'utilisateur
      -- ====================================================================

      IF(p_duplic <> 'OUI') THEN

        l_habilitation := Pack_Habilitation.fhabili_me(tmp_codsg, p_userid);

        IF l_habilitation='faux' THEN
                -- Vous n'etes pas autorise a modifier cette ligne BIP, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier cette ligne BIP, son DPG est '||tmp_codsg, 'PID', msg);
                RAISE_APPLICATION_ERROR(-20365, msg);
        END IF;

      END IF;

      	-- 26/07/2004 : Vérification que les codes Projets et Dossiers Projets sont bien actifs.
      	BEGIN
            SELECT lb.pid INTO l_pid
            FROM LIGNE_BIP lb, DOSSIER_PROJET dp, PROJ_INFO pi
            WHERE lb.dpcode = dp.dpcode
              AND lb.icpi = pi.icpi
              AND (pi.statut IS NULL OR pi.statut ='O' OR pi.statut ='N')
              AND dp.actif = 'O'
              AND lb.pid = p_pid;

        EXCEPTION
           WHEN NO_DATA_FOUND THEN
           	Pack_Global.recuperer_message(20757, NULL,  NULL, 'PID', msg);
           	RAISE_APPLICATION_ERROR(-20757, msg);

           WHEN OTHERS THEN
		RAISE_APPLICATION_ERROR( -20997, SQLERRM);

        END;


      END IF;



      OPEN p_curLigne_bip FOR
         SELECT lb.PID,
                lb.PCLE,
                lb.PNOM,
                cs.ASTATUT,
                cs.LIBSTATUT,
		lb.TOPFER,
                TO_CHAR( lb.ADATESTATUT , 'MM/YYYY') AS ADATESTATUT,
                tp.TYPPROJ,
                tp.LIBTYP,
                lb.ARCTYPE,
                ta.LIBARC,
                lb.CODPSPE,
                lb.TOPTRI,
                LPAD(lb.DPCODE,5, '0'),
                TO_CHAR( lb.PDATDEBPRE , 'MM/YYYY') AS PDATDEBPRE ,
                lb.ICPI,
                lb.CODSG,
                lb.AIRT,
                lb.PCPI,
                lb.CLICODE,
                cm.CLILIB,
                lb.CODCAMO,
                NVL(es.LICOES, ca.CLIBCA),
                lb.PNMOUVRA,
                lb.METIER, --aur
		lb.POBJET,
		lb.PZONE,
		lb.CLICODE_OPER,
		cm1.CLILIB,
		NVL(lb.SOUS_TYPE,'0'),
		st.libsoustype,
		TO_CHAR(b.CODBR),
                lb.FLAGLOCK,
				lb.CODREP,
				rjh.LIBREP
         FROM LIGNE_BIP 	lb,
              TYPE_PROJET 	tp,
              TYPE_ACTIVITE 	ta,
              CODE_STATUT 	cs,
              CLIENT_MO 	cm,
              CLIENT_MO		cm1,
              CENTRE_ACTIVITE	ca,
              ENTITE_STRUCTURE	es,
              DIRECTIONS d,
              SOUS_TYPOLOGIE st,
              BRANCHES b,
			  RJH_TABREPART rjh
         WHERE pid = p_pid
         AND lb.typproj = tp.typproj (+)
         AND lb.arctype = ta.arctype (+)
         AND lb.astatut = cs.astatut (+)
         AND lb.codcamo = es.codcamo (+)
         AND lb.codcamo = ca.codcamo (+)
         AND lb.clicode = cm.clicode (+)
         AND lb.clicode_oper = cm1.clicode (+)
         AND cm.clidir= d.coddir (+)
         AND d.CODBR=b.CODBR (+)
         AND lb.sous_type = st.sous_type (+)
		 AND lb.CODREP = rjh.CODREP (+)
         ;

   END select_ligne_bip;


   PROCEDURE insert_ligne_bip (
			       p_pnom       	IN VARCHAR2,
                               p_typproj    	IN CHAR,
			       p_pdatdebpre 	IN CHAR,
                               p_arctype    	IN VARCHAR2,
 			       p_toptri     	IN CHAR,
                               p_codpspe    	IN CHAR,
                               p_icpi       	IN CHAR,
 			       p_airt       	IN CHAR,
                               p_dpcode     	IN CHAR,
                               p_codsg      	IN CHAR,
                               p_pcpi       	IN CHAR,
                               p_clicode    	IN CHAR,
                               p_codcamo    	IN CHAR,
                               p_pnmouvra   	IN CHAR,
                               p_metier      	IN CHAR,
                               p_liste_objet   	IN VARCHAR2,
			       p_pobjet     	IN VARCHAR2,
			       p_pzone     	IN VARCHAR2,
			       p_clicode_oper	IN VARCHAR2,
			       p_sous_typo	IN VARCHAR2,
			       p_codrep	IN VARCHAR2,
                               p_userid     	IN VARCHAR2,
                               p_pid        	OUT CHAR,
                               p_pcle       	OUT CHAR,
                               p_nbcurseur  	OUT INTEGER,
                               p_message    	OUT VARCHAR2
                              ) IS

 CODCAMO_MULTI	VARCHAR2(6) := '77777';
 msg 		VARCHAR(1024);
 l_ident 	NUMBER(5);
 l_pid 		VARCHAR2(4);  -- variable locale pid (p_pid ne peut etre lue (OUT))
 l_pcle 	VARCHAR2(3);
 topfer 	CHAR(1); -- variable locale pour recuperer les tops fermeture
 l_menutil 	VARCHAR2(255);
 l_habilitation VARCHAR2(10);
 l_nbligne 	NUMBER;
 l_icodproj	PROJ_INFO.icodproj%TYPE;
 l_user		LIGNE_BIP_LOGS.user_log%TYPE;
 l_datdeb	REPARTITION_LIGNE.datdeb%TYPE;
 l_test 	CHAR(1) ; -- utilisée dans un test d'existance

 referential_integrity EXCEPTION;
 PRAGMA EXCEPTION_INIT( referential_integrity, -2291);
 objet_split 	VARCHAR2(2000);
   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';
      l_user := SUBSTR(Pack_Global.lire_globaldata(p_userid).idarpege, 1, 30);

         BEGIN
            SELECT ident INTO l_ident
            FROM RESSOURCE
            WHERE ident = TO_NUMBER(p_pcpi)
            AND rtype = 'P';

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20503, '%s1', p_pcpi,
                                              'PCPI', msg);
               RAISE_APPLICATION_ERROR( -20503, msg);
            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;


         -- Code dept/pole/groupe > 1

         IF TO_NUMBER(p_codsg) <= 1 THEN

            -- Erreur applicative

            Pack_Global.recuperer_message(20223, NULL, NULL, 'CODSG', msg);
            RAISE_APPLICATION_ERROR( -20223, msg);
         END IF;

	-- centre_activite fermé ou non facturable
	BEGIN
		SELECT 	'1' INTO l_test
		FROM 	CENTRE_ACTIVITE c , DATDEBEX d
		WHERE	c.codcamo=TO_NUMBER(p_codcamo)
		AND NVL(c.cdfain,0) <> 3
		AND (c.cdateferm  IS NULL OR c.cdateferm >= d.moismens);
		EXCEPTION
		WHEN NO_DATA_FOUND THEN
			Pack_Global.recuperer_message( 20984, NULL, NULL, NULL, msg);
			RAISE_APPLICATION_ERROR( -20984, msg);
           	WHEN OTHERS THEN
               		RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;


      -- ====================================================================
      -- 12/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me(p_codsg, p_userid);
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce DPG 20364
		Pack_Global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', msg);
                RAISE_APPLICATION_ERROR(-20364, msg);
	END IF;

	-- controle du paramètre p_pobjet
	objet_split := controle_obj (p_pobjet);


            -- Calculer le pid et la cle de controle pcle

            calcul_pid ( l_pid );

            calcul_cle( RTRIM(l_pid), l_pcle );

            -- Inserer la ligne bip
            -- valeurs saisies
            -- Top facturation a 'O'
            -- top fiche PETAT 'M' projet mis a jour


        BEGIN


            INSERT INTO LIGNE_BIP ( pid,
                                    pcle,
                                    pnom,
                                    typproj,
                                    arctype,
                                    codpspe,
                                    toptri,
                                    dpcode,
                                    pdatdebpre,
                                    icpi,
                                    codsg,
                                    airt,
                                    pcpi,
                                    clicode,
                                    pnmouvra,
                                    codcamo,
				    pobjet,
				    pzone,
                                    pconsn1,
                                    pdecn1,
                                    pcactop,
                                    petat,
			      	    METIER,
                                    clicode_oper,
                                    sous_type,
                                    topfer,
				    flaglock,
					codrep)
            VALUES ( RTRIM(l_pid),
                     l_pcle,
                     p_pnom,
                     p_typproj,
                     p_arctype,
                     RTRIM(p_codpspe),
                     p_toptri,
                     DECODE(p_dpcode, NULL, 0, p_dpcode),
                     TO_DATE( p_pdatdebpre, 'MM/YYYY'),
                     p_icpi,
                     p_codsg,
                     p_airt,
                     p_pcpi,
                     p_clicode,
                     p_pnmouvra,
                     DECODE( p_codcamo, '', 0, p_codcamo ),
		     objet_split,
		     p_pzone,
                     0,
                     0,
                     'O',
                     'M',
		     p_metier,
		     NVL(p_clicode_oper, p_clicode),
		     p_sous_typo,
		     'N',		-- par defaut TOPFER='N'
		     0,
			 p_codrep);

             -- On loggue le type, la typologie, le CA payeur, le topfer
            maj_ligne_bip_logs(l_pid, l_user, 'Type', NULL, p_typproj, 'Création de la ligne BIP');
            maj_ligne_bip_logs(l_pid, l_user, 'Typologie', NULL, p_arctype, 'Création de la ligne BIP');
            maj_ligne_bip_logs(l_pid, l_user, 'CA payeur', NULL, p_codcamo, 'Création de la ligne BIP');
            maj_ligne_bip_logs(l_pid, l_user, 'Top fermeture', NULL, 'N', 'Création de la ligne BIP');
			maj_ligne_bip_logs(l_pid, l_user, 'Code métier', NULL, p_metier, 'Création de la ligne BIP');
			maj_ligne_bip_logs(l_pid, l_user, 'Code application', NULL, p_airt, 'Création de la ligne BIP');


          EXCEPTION
            WHEN referential_integrity THEN
	      IF (p_clicode_oper IS NULL) AND (INSTR(SQLERRM, 'CLICODE_128') > 0) THEN
		      	-- Si le message est relatif au clicode_oper
		      	-- Alors que c'est le clicode, on donne le message du clicode
	      		Pack_Global.recuperer_message(20732, NULL, NULL, 'CLICODE', msg);
	      		RAISE_APPLICATION_ERROR( -20732, msg);
	      ELSE
	              	-- habiller le msg erreur
	              	Pack_Global.recuperation_integrite(-2291);
	      END IF;

            -- Ne pas intercepter les autres exceptions
            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);

          END;



            -- Verifications apres integrites
            -- Structure SG non fermee
            -- Recuperer le top fermeture du code sg
	l_menutil := Pack_Global.lire_globaldata(p_userid).menutil;
        BEGIN
            SELECT TOPFER INTO topfer
            FROM STRUCT_INFO
            WHERE CODSG = TO_NUMBER(p_codsg);

          EXCEPTION
            WHEN NO_DATA_FOUND THEN
               NULL;
            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
          END;


          IF (topfer = 'F') AND (l_menutil != 'DIR') THEN
               	-- Erreur applicative
          	Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', msg);
             	RAISE_APPLICATION_ERROR( -20274, msg);
          END IF;

         --client mo non fermee
         -- Recuperer le top fermeture du client mo
         BEGIN
            SELECT CLITOPF INTO topfer
            FROM CLIENT_MO
            WHERE LTRIM(RTRIM(CLICODE)) = LTRIM(RTRIM(p_clicode));

          EXCEPTION
            WHEN NO_DATA_FOUND THEN
               NULL;
            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
          END;

          IF (topfer = 'F') AND (l_menutil != 'DIR') THEN
             	-- Erreur applicative
           	Pack_Global.recuperer_message(20018, NULL, NULL, 'CLICODE', msg);
             	RAISE_APPLICATION_ERROR( -20018, msg);
          END IF;

         -- client mo Opérationnel non fermee
         -- Recuperer le top fermeture du client mo
         IF p_clicode_oper IS NOT NULL THEN
	         BEGIN
	            SELECT CLITOPF INTO topfer
	            FROM CLIENT_MO
	            WHERE LTRIM(RTRIM(CLICODE)) = LTRIM(RTRIM(p_clicode_oper));

	          EXCEPTION
	            WHEN NO_DATA_FOUND THEN
	               NULL;
	            WHEN OTHERS THEN
	               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	          END;
	  END IF;


          IF (topfer = 'F') AND (l_menutil != 'DIR') THEN
             	-- Erreur applicative
           	Pack_Global.recuperer_message(20026, NULL, NULL, 'CLICODE_OPER', msg);
             	RAISE_APPLICATION_ERROR( -20026, msg);
          END IF;


	  -- Si c'est une ligne Grand T1
	  -- On la passe dans le statut à immobiliser.
	  BEGIN
	  	IF (p_typproj = '1 ') AND (p_arctype='T1' OR p_dpcode <> '00000') THEN
	  		UPDATE LIGNE_BIP
	  		SET astatut ='O'
	  		WHERE pid=l_pid;
	  		-- On logue la modif
	  		maj_ligne_bip_logs(l_pid, l_user, 'Statut', NULL, 'O', 'Création de la ligne BIP');
		END IF;
	  EXCEPTION
	     WHEN OTHERS THEN
	     	Pack_Global.recuperer_message(20929, '%s1', 'Pas de statut', '%s2', 'A immobiliser', NULL, msg);
             	RAISE_APPLICATION_ERROR( -20929, msg);
	  END;


	  -- Si le CA saisit correspond avec le code de m_facturation,
	  -- On saisit le CA 0 dans la table repartition_ligne avec un taux de 100%
	  IF (p_codcamo=CODCAMO_MULTI) THEN
	  	SELECT ADD_MONTHS(DATDEBEX, -1) INTO l_datdeb FROM DATDEBEX WHERE ROWNUM<2;
	  	INSERT INTO REPARTITION_LIGNE
	  	       (pid, codcamo, tauxrep, datdeb)
	  	VALUES (l_pid, 0, 100, l_datdeb);
	  END IF;


          -- 'Le projet '||p_pnom||'\nest créé avec
          -- le code suivant :\n'||l_pid||' clé : '||l_pcle;

          Pack_Global.recuperer_message(5, '%s1', p_pnom, '%s2', l_pid, '%s3', l_pcle, NULL, msg);
          p_message := msg;


   END insert_ligne_bip;


  PROCEDURE update_ligne_bip ( 	p_typproj     	IN CHAR,
				p_pid         	IN CHAR,
                                p_pcle        	IN CHAR,
                                p_pnom        	IN VARCHAR2,
                                p_astatut     	IN CHAR,
				p_topfer      	IN CHAR,
                                p_adatestatut 	IN CHAR,
       		               	p_pdatdebpre  	IN CHAR,
                                p_arctype     	IN VARCHAR2,
			       	p_toptri      	IN CHAR,
                                p_codpspe     	IN CHAR,
                                p_icpi        	IN CHAR,
			       	p_airt        	IN CHAR,
                                p_dpcode      	IN CHAR,
                                p_codsg       	IN CHAR,
                                p_pcpi        	IN CHAR,
                                p_clicode     	IN CHAR,
                                p_codcamo     	IN CHAR,
                                p_pnmouvra    	IN CHAR,
				p_metier      	IN CHAR, --aur nouvelle valeur
				p_pobjet      	IN VARCHAR2,
			       	p_liste_objet 	IN VARCHAR2,
				p_pzone       	IN VARCHAR2,
				p_clicode_oper  IN VARCHAR2,
				p_sous_typo  IN VARCHAR2,
                                p_flaglock    	IN NUMBER,
				p_codrep  IN VARCHAR2,
                                p_userid      	IN VARCHAR2,
                                p_nbcurseur   	OUT INTEGER,
                                p_message     	OUT VARCHAR2
                              )IS
 CODCAMO_MULTI	VARCHAR2(6)	:= '77777';
 msg 		VARCHAR(1024);
 l_ident 	NUMBER(5); -- variable locale pour le tester le chef de projet
 topfer 	CHAR(1);    -- variable locale pour recuperer les tops fermeture
 l_menutil 	VARCHAR2(255);
 l_habilitation VARCHAR2(10);
 l_icodproj	PROJ_INFO.icodproj%TYPE;

 l_user		LIGNE_BIP_LOGS.user_log%TYPE;
 -- Valeurs précédentes pour les logs
 l_typproj	LIGNE_BIP.typproj%TYPE;
 l_arctype	LIGNE_BIP.arctype%TYPE;
 l_codcamo	LIGNE_BIP.codcamo%TYPE;
 l_topfer	LIGNE_BIP.topfer%TYPE;
 l_astatut	LIGNE_BIP.astatut%TYPE;
 l_adatestatut	LIGNE_BIP.adatestatut%TYPE;
 l_metier	LIGNE_BIP.METIER%TYPE;
 l_airt	LIGNE_BIP.airt%TYPE;
 l_datdeb	REPARTITION_LIGNE.datdeb%TYPE;
 l_test 	CHAR(1) ; -- utilisée dans un test d'existance


 referential_integrity EXCEPTION;
 PRAGMA EXCEPTION_INIT( referential_integrity, -2291);
 objet_split	VARCHAR2(2000);

   BEGIN
      -- positionner le nb de curseurs ==> 0
      -- initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      l_user := SUBSTR(Pack_Global.lire_globaldata(p_userid).idarpege, 1, 30);

      -- le Chef de projet doit exister et être une personne
      BEGIN
         SELECT ident INTO l_ident
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_pcpi)
         AND rtype = 'P';

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            Pack_Global.recuperer_message(20503, '%s1', p_pcpi, 'PCPI', msg);
            RAISE_APPLICATION_ERROR( -20503, msg);

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- Code dept/pole/groupe> 1

      IF TO_NUMBER(p_codsg) <= 1 THEN

         -- Erreur applicative

         Pack_Global.recuperer_message(20223, NULL, NULL, 'CODSG', msg);
         RAISE_APPLICATION_ERROR( -20223, msg);
      END IF;

	-- centre_activite fermé ou non facturable
	BEGIN
		SELECT 	'1' INTO l_test
		FROM 	CENTRE_ACTIVITE c , DATDEBEX d
		WHERE	c.codcamo=TO_NUMBER(p_codcamo)
		AND NVL(c.cdfain,0) <> 3
		AND (c.cdateferm  IS NULL OR c.cdateferm >= d.moismens);
		EXCEPTION
		WHEN NO_DATA_FOUND THEN
			Pack_Global.recuperer_message( 20984, NULL, NULL, NULL, msg);
			RAISE_APPLICATION_ERROR( -20984, msg);
           	WHEN OTHERS THEN
               		RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;


      -- ====================================================================
      -- 12/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me(p_codsg, p_userid);
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce DPG 20364
		Pack_Global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', msg);
                RAISE_APPLICATION_ERROR(-20364, msg);
	END IF;


	-- controle du paramètre p_pobjet : il ne doit y avoir que 5 lignes qui font au max 60 caractères
	objet_split := controle_obj(p_pobjet);

        BEGIN
            -- On récupère les valeurs précédentes pour les logs
            SELECT typproj, arctype, codcamo, topfer, astatut, adatestatut, METIER,airt
            INTO l_typproj, l_arctype, l_codcamo, l_topfer, l_astatut, l_adatestatut, l_metier,l_airt
            FROM LIGNE_BIP
            WHERE pid=p_pid
            AND flaglock = p_flaglock;


            UPDATE LIGNE_BIP
            SET pnom 		= p_pnom,
                astatut 	= p_astatut,
		topfer	 	= p_topfer,
                adatestatut 	= TO_DATE(p_adatestatut, 'MM/YYYY'),
                typproj 	= p_typproj,
                arctype 	= p_arctype,
                codpspe 	= RTRIM(p_codpspe),
                toptri 		= p_toptri,
                dpcode 		= DECODE(p_dpcode,'', '00000', p_dpcode),
                pdatdebpre 	= TO_DATE(p_pdatdebpre, 'MM/YYYY'),
                icpi 		= DECODE(p_icpi,'', 'P0000', p_icpi),
                codsg 		= TO_NUMBER(p_codsg),
                airt 		= DECODE(p_airt,'', 'A0000', p_airt),
                pcpi 		= p_pcpi,
                clicode 	= p_clicode,
                codcamo		= p_codcamo,
                pnmouvra 	= p_pnmouvra,
                METIER		= p_metier,  --aur
		pobjet 		= objet_split,
		pzone		= p_pzone,
		clicode_oper    = p_clicode_oper,
		sous_type	= p_sous_typo,
                flaglock 	= DECODE(p_flaglock, 1000000, 0, p_flaglock + 1),
				codrep      = p_codrep
            WHERE pid = p_pid
            AND flaglock = p_flaglock;

             -- On loggue le type, la typologie, le CA payeur, le topfer, le statut, la date de statut
            maj_ligne_bip_logs(p_pid, l_user, 'Type', l_typproj, p_typproj, 'Modification de la ligne BIP');
            maj_ligne_bip_logs(p_pid, l_user, 'Typologie', l_arctype, p_arctype, 'Modification de la ligne BIP');
            maj_ligne_bip_logs(p_pid, l_user, 'CA payeur', TO_CHAR(l_codcamo), p_codcamo, 'Modification de la ligne BIP');
            maj_ligne_bip_logs(p_pid, l_user, 'Top fermeture', l_topfer, p_topfer, 'Modification de la ligne BIP');
            maj_ligne_bip_logs(p_pid, l_user, 'Statut', l_astatut, p_astatut, 'Modification de la ligne BIP');
            maj_ligne_bip_logs(p_pid, l_user, 'Date statut', TO_CHAR(l_adatestatut, 'MM/YYYY'), p_adatestatut, 'Modification de la ligne BIP');

			--ajout fiche 299
			maj_ligne_bip_logs(p_pid, l_user, 'Code métier  ', l_metier, p_metier, 'Modification de la ligne BIP');
            maj_ligne_bip_logs(p_pid, l_user, 'Code application  ', l_airt, p_airt, 'Modification de la ligne BIP');


         EXCEPTION
            WHEN referential_integrity THEN
              -- habiller le msg erreur
              Pack_Global.recuperation_integrite(-2291);

              -- Ne pas intercepter les autres exceptions

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF SQL%NOTFOUND THEN
            Pack_Global.recuperer_message(20999, NULL, NULL, NULL, msg);
            RAISE_APPLICATION_ERROR( -20999, msg );
         ELSE
            Pack_Global.recuperer_message(5009, '%s1', p_pid, NULL, msg);
            p_message := msg;
         END IF;

         -- Verifications apres integrites
         -- Structure SG non fermee
         -- Recuperer le top fermeture du code sg

         BEGIN
            SELECT TOPFER INTO topfer
            FROM STRUCT_INFO
            WHERE CODSG = TO_NUMBER(p_codsg);

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               NULL;
            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
          END;

	 l_menutil := Pack_Global.lire_globaldata(p_userid).menutil;

         IF (topfer = 'F') AND (l_menutil != 'DIR') THEN

            -- Erreur applicative

            Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', msg);
            RAISE_APPLICATION_ERROR( -20274, msg );
         END IF;


	 -- Si le CA saisit correspond avec le code de m_facturation et que l'ancien ne correspond pas
	 -- On saisit le CA 0 dans la table repartition_ligne avec un taux de 100%
	 IF ((p_codcamo=CODCAMO_MULTI) AND (l_codcamo != CODCAMO_MULTI)) THEN
	  	SELECT ADD_MONTHS(DATDEBEX, -1) INTO l_datdeb FROM DATDEBEX WHERE ROWNUM<2;
	         --
	         -- Vérifie qu'il n'existe pas déjà des lignes dans répartition ligne
	         --
	         BEGIN
	            SELECT DISTINCT '1' INTO l_test
	            FROM REPARTITION_LIGNE
	            WHERE PID = p_pid;

	         EXCEPTION
	            WHEN NO_DATA_FOUND THEN
	      	  	-- Insère une première répartition
		  	INSERT INTO REPARTITION_LIGNE
		  	       (pid, codcamo, tauxrep, datdeb)
		  	VALUES (p_pid, l_codcamo, 100, l_datdeb);

	            WHEN OTHERS THEN
	               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	          END;
	 END IF;


	 l_menutil := Pack_Global.lire_globaldata(p_userid).menutil;
         IF (topfer = 'F') AND (l_menutil != 'DIR') THEN
            -- Erreur applicative
            Pack_Global.recuperer_message(20018, NULL, NULL, 'CLICODE', msg);
            RAISE_APPLICATION_ERROR( -20018, msg );
         END IF;

   END update_ligne_bip;

PROCEDURE RECUPERER_CODE_BRANCHE(p_clicode		IN	CLIENT_MO.clicode%TYPE,
				p_codbr		OUT	VARCHAR2,
				p_message		OUT 	VARCHAR2)
			IS
msg 		VARCHAR(1024);
BEGIN
	SELECT TO_CHAR(d.CODBR) INTO p_codbr
	FROM CLIENT_MO c,DIRECTIONS d, BRANCHES b
	WHERE c.clicode=p_clicode
	AND d.coddir=c.clidir
	AND b.CODBR=d.CODBR;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
			Pack_Global.recuperer_message( 4, '%s1', p_clicode, NULL, p_message);
	WHEN OTHERS THEN
	               RAISE_APPLICATION_ERROR( -20997, SQLERRM);


END 	RECUPERER_CODE_BRANCHE;

---------------------------------------------------------------------------------------------------------------
PROCEDURE REMISE_A_ZERO(p_pid		IN	    LIGNE_BIP.pid%TYPE,
                        p_userid   	IN      VARCHAR2,
                        p_message	OUT 	VARCHAR2)
			IS
msg 		    VARCHAR(1024);
l_user		    LIGNE_BIP_LOGS.user_log%TYPE;
l_dertrait	    VARCHAR2(10);
l_adatestatut	VARCHAR2(10);
l_annee	        NUMBER(4);
l_cusag	        NUMBER(12,2);
l_xcusag        NUMBER(12,2);
l_xcusagW       NUMBER(12,2);

BEGIN
 -- initialiser le message retour
      p_message := '';

 -- récupérer le user
 l_user := SUBSTR(Pack_Global.lire_globaldata(p_userid).idarpege, 1, 30);

   BEGIN
	SELECT TO_CHAR(DERTRAIT,'dd/mm/yyyy'),TO_NUMBER(TO_CHAR(MOISMENS,'yyyy'))
	INTO   l_dertrait, l_annee
	FROM DATDEBEX;

	SELECT TO_CHAR(ADATESTATUT,'dd/mm/yyyy')
	INTO   l_adatestatut
	FROM LIGNE_BIP
	WHERE  pid = p_pid;

	SELECT CUSAG, XCUSAG
	INTO   l_cusag, l_xcusag
	FROM CONSOMME
	WHERE  annee = l_annee
	AND pid = p_pid;


    -- Test pour savoir si la Ligne BIP est Fermée
	IF ( l_adatestatut IS NOT NULL AND l_adatestatut <= l_dertrait) THEN
	   	  Pack_Global.recuperer_message( 20371, '%s1', p_pid, NULL, p_message);
		  RAISE_APPLICATION_ERROR( -20371, p_message );
	ELSE  -- Update des tables CONS_SSTACHE_RESS_MOIS et de CONSOMME
	   -- CONS_SSTACHE_RES_MOIS
	      UPDATE CONS_SSTACHE_RES_MOIS
	      SET cusag = 0
	      WHERE pid = p_pid;
       -- CONSOMME
	      l_xcusagW := l_xcusag;
	      l_xcusagW  := (l_xcusag - l_cusag);
	      UPDATE CONSOMME
	      SET cusag  = 0,
	          xcusag = l_xcusagW
	      WHERE pid = p_pid
	      AND annee = l_annee;

       -- On logue la modification
	      maj_ligne_bip_logs(p_pid, l_user, 'CUSAG', NULL, '0', 'Remise à zéro du consommé');

	   -- Retour message informatif de mise à jour
	      Pack_Global.recuperer_message(20027, '%s1', p_pid,  NULL, msg);
          p_message := msg;
	END IF;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
			Pack_Global.recuperer_message( 20504, '%s1', p_pid, NULL, p_message);
	WHEN OTHERS THEN
	        RAISE_APPLICATION_ERROR( -20997, SQLERRM);

   END;

END 	REMISE_A_ZERO;
---------------------------------------------------------------------------------------------------------------

END Pack_Ligne_Bip;
/
CREATE OR REPLACE PACKAGE     pack_ligne_bip_mo AS

   -- definition d'un enregistrement de la table ligne_bip pour la gestion  des entetes

   TYPE ligne_bip_ViewType IS RECORD ( PID          LIGNE_BIP.PID%TYPE,
   				       ANNEE 	    CHAR(4),
                                       CODCAMO      LIGNE_BIP.CODCAMO%TYPE,
                                       TYPPROJ      LIGNE_BIP.TYPPROJ%TYPE,
                                       ARCTYPE      LIGNE_BIP.ARCTYPE%TYPE,
                                       TOPTRI       LIGNE_BIP.TOPTRI%TYPE,
                                       LIBSTATUT    CODE_STATUT.LIBSTATUT%TYPE,
                                       TOPFER       LIGNE_BIP.TOPFER%TYPE,
                                       ADATESTATUT  CHAR(10),
                                       ICPI         LIGNE_BIP.ICPI%TYPE,
                                       ILIBEL       PROJ_INFO.ILIBEL%TYPE,
                                       AIRT	    LIGNE_BIP.AIRT%TYPE,
                                       ALIBEL       APPLICATION.ALIBEL%TYPE,
                                       DPCODE       LIGNE_BIP.DPCODE%TYPE,
                                       DPLIB        DOSSIER_PROJET.DPLIB%TYPE,
                                       CODPSPE      LIGNE_BIP.CODPSPE%TYPE,
                                       LIBPSPE      PROJ_SPE.LIBPSPE%TYPE,
                                       CODSG        LIGNE_BIP.CODSG%TYPE,
                                       LIBDSG       STRUCT_INFO.LIBDSG%TYPE,
                                       RNOM         RESSOURCE.RNOM%TYPE,
                                       METIER       LIGNE_BIP.METIER%TYPE,
                                       PNOM         LIGNE_BIP.PNOM%TYPE,
                                       PNMOUVRA     LIGNE_BIP.PNMOUVRA%TYPE,
                                       CLICODE      LIGNE_BIP.CLICODE%TYPE,
                                       CLILIB       CLIENT_MO.CLILIB%TYPE,
                                       CLICODE_OPER LIGNE_BIP.CLICODE_OPER%TYPE,
                                       CLILIB_OPER  VARCHAR2(50),
                                       POBJET       LIGNE_BIP.POBJET%TYPE,
                                       BNMONT       VARCHAR2(12),
                                       BPMONTME     VARCHAR2(12),
                                       ANMONT       VARCHAR2(12),
                                       REESTIME     VARCHAR2(12),
                                       ESTIMPLURIAN VARCHAR2(12),
                                       CUSAG 	    VARCHAR2(12),
                                       BPMONTMO     VARCHAR2(12),
                                       FLAG 	    budget.FLAGLOCK%TYPE,
                                       FLAGLOCK     ligne_bip.FLAGLOCK%TYPE
					);

  -- définition du curseur sur la table ligne_bip pour la gestion de l'entete du projet

   TYPE ligne_bipCurType IS REF CURSOR RETURN ligne_bip_ViewType;



	PROCEDURE select_ligne_bip_mo ( p_pid          IN ligne_bip.pid%TYPE,
                                	p_date         IN CHAR,
                                	p_global       IN VARCHAR2,
                                	p_curLigne_bip IN OUT ligne_bipCurType,
                                	p_nbcurseur    OUT INTEGER,
                                	p_message      OUT VARCHAR2
                              );

	PROCEDURE update_ligne_bip_mo (	p_pid         	IN ligne_bip.pid%TYPE,
					p_date 		IN CHAR,
					p_codcamo 	IN CHAR,
					p_typproj 	IN CHAR,
					p_arctype 	IN VARCHAR2,
					p_toptri 	IN CHAR,
					p_libstatut 	IN CHAR,
					p_topfer 	IN CHAR,
					p_adatestatut 	IN CHAR,
					p_icpi 		IN CHAR,
					p_ilibel 	IN CHAR,
					p_airt 		IN CHAR,
					p_alibel 	IN CHAR,
					p_dpcode 	IN ligne_bip.dpcode%TYPE,
					p_dplib 	IN dossier_projet.dplib%TYPE,
					p_codpspe 	IN CHAR,
					p_libpspe 	IN CHAR,
					p_codsg       	IN char,
					p_libdsg 	IN CHAR,
					p_rnom 		IN CHAR,
					p_metier 	IN CHAR,
					p_pnom        	IN CHAR,
	 				p_pnmouvra    	IN CHAR,
	 				p_clicode     	IN char,
	 				p_clilib 	IN CHAR,
	 				p_liste_objet 	IN varchar2,
					p_pobjet     	IN varchar2,
					p_bnmont 	IN VARCHAR2,
					p_bpmontme 	IN VARCHAR2,
					p_anmont 	IN VARCHAR2,
					p_reestime 	IN VARCHAR2,
					p_estimplurian 	IN VARCHAR2,
					p_cusag 	IN VARCHAR2,
					p_bpmontmo 	IN VARCHAR2,
					p_flag 		IN number,
					p_flaglock    	IN number,
					p_global      	IN VARCHAR2,
		                        p_nbcurseur   	OUT INTEGER,
                		        p_message     	OUT VARCHAR2
                              );

END pack_ligne_bip_mo;
/

CREATE OR REPLACE PACKAGE BODY     pack_ligne_bip_mo AS

PROCEDURE select_ligne_bip_mo ( p_pid          	IN ligne_bip.pid%TYPE,
                                p_date      	IN CHAR,
                                p_global      	IN VARCHAR2,
                                p_curLigne_bip 	IN OUT ligne_bipCurType,
                                p_nbcurseur    	OUT INTEGER,
                                p_message      	OUT VARCHAR2
                              ) IS
	msg 		VARCHAR(1024);
	l_pid 		ligne_bip.pid%TYPE;
	l_perimo 	VARCHAR2(255);
	l_clicode 	ligne_bip.clicode%TYPE;
	l_typproj 	ligne_bip.typproj%TYPE;
	l_habilitation 	boolean;
      	l_annee		VARCHAR2(4);
    	l_topfer    	ligne_bip.topfer%TYPE;
    	l_statut	ligne_bip.astatut%TYPE;

BEGIN

  	 BEGIN
            SELECT pid INTO l_pid
            FROM ligne_bip
            WHERE pid = p_pid;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN
               -- Code projet %s1 inexistant
               pack_global.recuperer_message(20504, '%s1', p_pid, NULL, msg);
               raise_application_error( -20504, msg );
            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);
	  END;


	-- test sur le TYPE
	BEGIN
		SELECT typproj INTO l_typproj
	 	FROM ligne_bip
		WHERE pid=p_pid;

	 EXCEPTION
           WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);
	END;
	IF l_typproj = 7 THEN
       --('vous n etes pas autorisé à modifier cette ligne bip')
       pack_global.recuperer_message(20365, '%s1',  'modifier cette ligne BIP','PID', msg);
	   raise_application_error(-20365,  msg);
   	END IF;


    -- Test si la ligne bip est ouverte : Ajout S LALLIER 24/12/03
    BEGIN
      select topfer, astatut into l_topfer, l_statut
      from ligne_bip where pid = p_pid;

      IF ( (l_topfer = 'O') OR (l_statut='A') OR (l_statut='D') ) THEN
            -- Ligne bip %s1 fermée
            pack_global.recuperer_message(20981, '%s1', p_pid, NULL, msg);
            p_message := msg;
            raise_application_error(-20981, msg);
      END IF;
    END;

         -- Controle habilitation Departement et pole
	BEGIN
	 SELECT clicode INTO l_clicode
	 FROM ligne_bip
	 WHERE pid=p_pid
	 ;

	 l_perimo := pack_global.lire_globaldata(p_global).perimo;

--raise_application_error(-20000,'MO:'||l_codperimo||' dir: ' ||p_clicode);

         EXCEPTION
           WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);

         END;

      -- ====================================================================
      -- 27/05/2002 : Test appartenance au perimetre MO
      -- ====================================================================
     	l_habilitation := pack_habilitation.fverif_habili_mo(l_perimo, l_clicode );
	IF l_habilitation=false THEN
		pack_global.recuperer_message(20201, '%s1',p_pid,NULL, msg);
 		raise_application_error(-20201,msg);
	END IF;


      	-- ====================================================================
      	--  Pas de proposé sur une année passée
      	-- ====================================================================
	SELECT TO_CHAR (datdebex, 'YYYY')
	INTO l_annee
	FROM datdebex
	WHERE rownum < 2;

	IF TO_NUMBER(p_date) < TO_NUMBER(l_annee) THEN
		--('vous n etes pas autorisé à faire des proposés sur une année passée')
       		pack_global.recuperer_message(20365, '%s1',  'faire des proposés sur une année passée','ANNEE', msg);
	   	raise_application_error(-20365,  msg);
	END IF;

-----------------------------------------------------------
--curseur ramenant les infos sur la ligne bip
-----------------------------------------------------------
BEGIN
OPEN p_curLigne_bip FOR
	SELECT lb.PID,
	p_date AS ANNEE,
	lb.CODCAMO, --CA payeur
	lb.TYPPROJ, --type
	lb.ARCTYPE, --typologie
	lb.TOPTRI,
	cs.LIBSTATUT,--statut comptable
	lb.TOPFER,--top fermeture
	TO_CHAR( lb.ADATESTATUT , 'MM/YYYY') AS ADATESTATUT, --date du statut
	lb.ICPI, --code projet
	pi.ILIBEL, --libelle projet
	lb.AIRT, --code irt
	a.ALIBEL,--libelle application
	lb.DPCODE,--code dossier projet
	dp.DPLIB, --libelle dossier projet
	lb.codpspe, -- projet special
	ps.LIBPSPE, --libelle projet special
	lb.CODSG, --DPG
	st.LIBDSG, --libelle DPG
	r.RNOM, --nom chef de projet
	lb.METIER,
	lb.PNOM, --libelle ligne BIP
	rtrim(lb.PNMOUVRA), --nom du correspondant MO
	lb.CLICODE, --direction cliente
	cm.CLILIB,--direction cliente
	lb.CLICODE_OPER, -- Code Client Opérationnel
	lb.CLICODE_OPER || '-' || cm2.CLILIB, -- Client Opérationnel
	lb.POBJET, --zone de texte
	DECODE( b.BNMONT,NULL,',00',TO_CHAR(b.BNMONT, 'FM9999999990D00')) AS BNMONT,  --budget notifie
        DECODE(b.BPMONTME,NULL,',00',TO_CHAR(b.BPMONTME, 'FM9999999990D00')) AS BPMONTME,--propose ME
        DECODE(b.ANMONT,NULL,',00',TO_CHAR(b.ANMONT, 'FM9999999990D00')) AS ANMONT,--arbitre
        DECODE(b.REESTIME,NULL,',00',TO_CHAR(b.REESTIME, 'FM9999999990D00')) AS REESTIME,--re-estime ME
        DECODE(lb.ESTIMPLURIAN,NULL,',00',TO_CHAR(lb.ESTIMPLURIAN, 'FM9999999990D00')) AS ESTIMPLURIAN,--estimation pluriannuelle
        DECODE(c.CUSAG ,NULL,',00',TO_CHAR(c.CUSAG , 'FM9999999990D00')) AS CUSAG,--realise
        DECODE( b.BPMONTMO ,NULL,',00',TO_CHAR( b.BPMONTMO , 'FM9999999990D00')) AS BPMONTMO,--propose MO
        NVL (b.flaglock,0) , --flaglock de la TABLE budget
	lb.FLAGLOCK

	FROM  ligne_bip lb,
              struct_info st,
              ressource r,
              code_statut cs,
              dossier_projet dp,
              proj_spe ps,
              proj_info pi,
              client_mo cm,
              client_mo cm2,
              application a,
              budget b,
              consomme c
      WHERE lb.pid = p_pid
      AND lb.pid = b.pid(+)
      AND lb.pid = c.pid(+)
      AND lb.codsg=st.codsg
      AND r.ident=lb.pcpi
      AND lb.airt=a.airt
      AND cs.astatut(+)=lb.astatut
      AND lb.icpi=pi.icpi
      AND lb.dpcode=dp.dpcode
      AND lb.codpspe=ps.codpspe(+)
      AND cm.clicode=lb.clicode
      AND cm2.clicode=lb.clicode_oper
      AND b.annee(+) = TO_NUMBER(p_date)
      AND c.annee(+) = TO_NUMBER(p_date)
     ;
  EXCEPTION
         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

      pack_global.recuperer_message(5010, NULL, NULL, NULL, msg);
      p_message := msg;


END select_ligne_bip_mo;

-------------------------------------------------------------
-- procedure qui modifie une ligne bip (menu client)
-------------------------------------------------------------
PROCEDURE update_ligne_bip_mo(	p_pid         	IN ligne_bip.pid%TYPE,
				p_date 		IN CHAR,
				p_codcamo 	IN CHAR,
				p_typproj 	IN CHAR,
				p_arctype 	IN VARCHAR2,
				p_toptri 	IN CHAR,
				p_libstatut 	IN CHAR,
				p_topfer 	IN CHAR,
				p_adatestatut 	IN CHAR,
				p_icpi 		IN CHAR,
				p_ilibel 	IN CHAR,
				p_airt 		IN CHAR,
				p_alibel 	IN CHAR,
				p_dpcode 	IN ligne_bip.dpcode%TYPE,
				p_dplib 	IN dossier_projet.dplib%TYPE,
				p_codpspe 	IN CHAR,
				p_libpspe 	IN CHAR,
				p_codsg       	IN char,
				p_libdsg 	IN CHAR,
				p_rnom 		IN CHAR,
				p_metier 	IN CHAR,
				p_pnom        	IN CHAR,
	 			p_pnmouvra    	IN CHAR,
	 			p_clicode     	IN char,
	 			p_clilib 	IN CHAR,
	 			p_liste_objet 	IN varchar2,
				p_pobjet     	IN varchar2,
				p_bnmont 	IN VARCHAR2,
				p_bpmontme 	IN VARCHAR2,
				p_anmont 	IN VARCHAR2,
				p_reestime 	IN VARCHAR2,
				p_estimplurian 	IN VARCHAR2,
				p_cusag 	IN VARCHAR2,
				p_bpmontmo 	IN VARCHAR2,
				p_flag 		IN number,
				p_flaglock    	IN number,
				p_global      	IN VARCHAR2,
		                p_nbcurseur   	OUT INTEGER,
                		p_message     	OUT VARCHAR2
                              )IS
      msg 		    VARCHAR(1024);
      topfer 		    CHAR(1);    -- variable locale pour recuperer les tops fermeture
      l_menutil 	    VARCHAR2(255);
      l_habilitation 	    BOOLEAN ;
      l_perimo 		    VARCHAR2(255);
      l_direction 	    client_mo.clicode%TYPE;

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT( referential_integrity, -2291);
      objet_split	    VARCHAR2(2000);
   BEGIN

      -- positionner le nb de curseurs ==> 0
      -- initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


   -- Controle habilitation Departement et pole
	BEGIN

    l_perimo := pack_global.lire_globaldata(p_global).perimo;

    EXCEPTION
      WHEN OTHERS THEN
        raise_application_error( -20997, SQLERRM);

    END;

    -- ====================================================================
    -- 27/05/2002 : Test appartenance au perimetre MO
    -- ====================================================================
   	l_habilitation := pack_habilitation.fverif_habili_mo(l_perimo, p_clicode);

	IF l_habilitation=false THEN
		-- Vous n'etes pas habilite à ce DPG
		pack_global.recuperer_message(20364, '%s1', 'à ce périmètre','', msg);
                raise_application_error(-20364, msg);
	END IF;

	-- controle du paramètre p_pobjet : il ne doit y avoir que 5 lignes qui font au max 60 caractères
	objet_split := pack_ligne_bip.controle_obj(p_pobjet);

--raise_application_error(-20000,',p_flaglock :'||p_flaglock||'et l_flaglock :'||l_flaglock);
-- UPDATE des 2 TABLES concernees : LIGNE_BIP, BUDGET
         BEGIN
            UPDATE ligne_bip
            SET
            pnom=p_pnom ,
            clicode=p_clicode,
            pnmouvra=p_pnmouvra,
            pobjet=objet_split,
            flaglock = decode(p_flaglock, 1000000, 0, p_flaglock + 1)
            WHERE pid = p_pid
            AND flaglock=p_flaglock
            ;

           EXCEPTION
            WHEN referential_integrity THEN
              -- habiller le msg erreur
              pack_global.recuperation_integrite(-2291);

              -- Ne pas intercepter les autres exceptions
            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);
         END;

         IF SQL%NOTFOUND THEN
            pack_global.recuperer_message(20999, NULL, NULL, NULL, msg);
            raise_application_error( -20999, msg );
         ELSE
            pack_global.recuperer_message(20277, '%s1', p_pid, NULL, msg);
            p_message := msg;
         END IF;



      BEGIN
       	UPDATE budget
      	SET
            bpmontmo=TO_NUMBER(p_bpmontmo),
            flaglock = decode(p_flag, 1000000, 0, p_flag + 1)
            WHERE pid=p_pid
            AND annee=TO_NUMBER(p_date)
            AND flaglock=p_flag
            ;
        EXCEPTION
        WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM );
      END;

-- il n'y a pas de ligne budget pour ce pid --> On la cree
	IF SQL%NOTFOUND THEN
		INSERT INTO budget ( 	ANNEE,
 					PID,
 					BNMONT,
 					BPMONTME,
 					BPMONTME2,
 					ANMONT,
 					BPDATE,
 					RESERVE,
 					APDATE,
 					APMONT,
 					BPMONTMO,
 					REESTIME,
 					FLAGLOCK)
			VALUES 	(p_date,
				 p_pid,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 TO_NUMBER (p_bpmontmo),
				 NULL,
				 0);
	pack_global.recuperer_message(20277, '%s1', p_pid, NULL, msg);
        p_message := msg;
	END IF;

   END update_ligne_bip_mo;


END pack_ligne_bip_mo;
/
CREATE OR REPLACE PACKAGE pack_ligne_bip_pp AS


   PROCEDURE insert_ligne_bip_pp ;
   PROCEDURE insert_ligne_bip_pp_copie ;

END pack_ligne_bip_pp;
/

CREATE OR REPLACE PACKAGE BODY pack_ligne_bip_pp AS


PROCEDURE insert_ligne_bip_pp IS

 l_pid 		VARCHAR2(4);  -- variable locale pid (p_pid ne peut etre lue (OUT))
 l_pcle 	VARCHAR2(3);

BEGIN

	DECLARE
	CURSOR c_bip IS
	SELECT	PNOM, TYPPROJ, PDATDEBPRE, ARCTYPE,
	TOPTRI, CODPSPE, AIRT, ICPI,
	CODSG, PCPI, CLICODE, CLICODE_OPER,
	CODCAMO, PNMOUVRA, METIER, POBJET
	FROM LIGNE_BIP_PP_PID;



	BEGIN


			FOR un_bip IN c_bip LOOP
				--
        		-- Calculer le pid et la cle de controle pcle


            	pack_ligne_bip.calcul_pid ( l_pid );

           		 pack_ligne_bip.calcul_cle( rtrim(l_pid), l_pcle );
   				--
				--
				INSERT INTO LIGNE_BIP
				(PID, PCLE , FLAGLOCK, TOPFER, PCACTOP, PCONSN1, PDECN1, PETAT, DPCODE,
				PNOM, TYPPROJ, PDATDEBPRE, ARCTYPE,
				TOPTRI, CODPSPE, AIRT, ICPI,
				CODSG, PCPI, CLICODE, CLICODE_OPER,
				CODCAMO, PZONE, METIER, POBJET)
				VALUES
				( rtrim(l_pid), l_pcle, 0, 'N', 'O', 0 , 0 , 'M', 0,
				un_bip.PNOM, un_bip.TYPPROJ, un_bip.PDATDEBPRE, un_bip.ARCTYPE,
				un_bip.TOPTRI,
				DECODE(un_bip.CODPSPE,'',NULL,' ',NULL,un_bip.CODPSPE),
				un_bip.AIRT, un_bip.ICPI,
				un_bip.CODSG, un_bip.PCPI, un_bip.CLICODE, un_bip.CLICODE_OPER,
				un_bip.CODCAMO, 'NEWT9', un_bip.METIER, un_bip.POBJET);

				COMMIT;

		END LOOP;
		COMMIT;

	END;
END insert_ligne_bip_pp;



PROCEDURE insert_ligne_bip_pp_copie IS

 l_pid 		VARCHAR2(4);  -- variable locale pid (p_pid ne peut etre lue (OUT))
 l_pcle 	VARCHAR2(3);

BEGIN

	DECLARE
	CURSOR c_bip IS
	SELECT	PID
	FROM LIGNE_BIP_PP_PID;



	BEGIN


			FOR un_bip IN c_bip LOOP
				--
        		-- Calculer le pid et la cle de controle pcle


            	pack_ligne_bip.calcul_pid ( l_pid );

           		 pack_ligne_bip.calcul_cle( rtrim(l_pid), l_pcle );
   				--
				--
			INSERT INTO BIP.LIGNE_BIP (
			   PID, PJCAMON1, ASTATUT,
			   ADATESTATUT, TTRMENS, TTRFBIP,
			   TVAEDN, TDEBINN, TDATFHP,
			   TDATFHR, TDATFHN, TDATEBR,
			   TARCPROC, PDATDEBPRE, PDATFINPRE,
			   PTYPEN1, PCACTOP, PCONSN1,
			   PDECN1, PMOYCEN, PSITDED,
			   PNMOUVRA, PCLE, PETAT,
			   PNOM, PCPI, TOPTRI,
			   FLAGLOCK, TYPPROJ, ICPI,
			   CODPSPE, CODCAMO, DPCODE,
			   CODSG, ARCTYPE, AIRT,
			   CLICODE, POBJET, PZONE,
			   TOPFER, METIER, CAAMORT,
			   DUREEAMORT, ESTIMPLURIAN, CLICODE_OPER,
			   SOUS_TYPE, CODREP, P_SAISIE )
			 select
			    rtrim(l_pid), PJCAMON1, ASTATUT,
			   ADATESTATUT, TTRMENS, TTRFBIP,
			   TVAEDN, TDEBINN, TDATFHP,
			   TDATFHR, TDATFHN, TDATEBR,
			   TARCPROC, PDATDEBPRE, PDATFINPRE,
			   PTYPEN1, PCACTOP, PCONSN1,
			   PDECN1, PMOYCEN, l.pid ,
			   PNMOUVRA, l_pcle, PETAT,
			   PNOM, PCPI, TOPTRI,
			   FLAGLOCK, TYPPROJ, ICPI,
			   CODPSPE, CODCAMO, DPCODE,
			   CODSG, ARCTYPE, AIRT,
			   CLICODE, POBJET,  'NEWT9',
			   TOPFER, METIER, CAAMORT,
			   DUREEAMORT, ESTIMPLURIAN, CLICODE_OPER,
			   SOUS_TYPE, CODREP, P_SAISIE
			   from ligne_bip l
			   where l.pid= un_bip.PID;

		END LOOP;
		COMMIT;

	END;
END insert_ligne_bip_pp_copie;


END pack_ligne_bip_pp;
/
CREATE OR REPLACE PACKAGE pack_ligne_fact AS

 TYPE FactSelectRec IS RECORD (soclib       societe.soclib%TYPE,
                               socfact      facture.socfact%TYPE,
                               numfact      facture.numfact%TYPE,
                               typfact      facture.typfact%TYPE,
                               datfact      varchar2(20),
                               fmoiacompta  varchar2(20),
                               fmontht      varchar2(20),
                               fstatut1     facture.fstatut1%TYPE,
                               flaglock     VARCHAR2(20),
                               soccont      facture.soccont%TYPE,
                               cav          facture.cav%TYPE,
                               numcont      facture.numcont%TYPE,
                               fenrcompta   varchar2(20),
                               faccsec      varchar2(20),
                               fregcompta   varchar2(20),
                               fenvsec      varchar2(20),      -- date reglement demande
                               fcodcompta   varchar2(20),
                               fdeppole     varchar2(20),
                               ftva         varchar2(20),
                               comcode      varchar2(20),       -- table contrat pour Modifier
                               codsg        varchar2(7)        -- table contrat
                              );

   TYPE VideRec IS RECORD     (filcode      filiale_cli.filcode%TYPE);

   TYPE LigfSelect IS RECORD  (socfact      facture.socfact%TYPE,
                               soclib       societe.soclib%TYPE,
                               numcont      facture.numcont%TYPE,
                               cav          facture.cav%TYPE,
                               numfact      facture.numfact%TYPE,
                               typfact      facture.typfact%TYPE,
                               datfact      VARCHAR2(20),
                               lnum         VARCHAR2(10),
                               ident        VARCHAR2(10),
                               rnom         ressource.rnom%TYPE,
                               rprenom      ressource.rprenom%TYPE,
                               lmontht      VARCHAR2(10),
                               lmoisprest   VARCHAR2(10),
                               lcodcompta   VARCHAR2(20)
                              );

   TYPE SelectCurVide IS REF CURSOR RETURN VideRec;
   TYPE FactSelectCur IS REF CURSOR RETURN FactSelectRec;
   TYPE LigfSelectCur IS REF CURSOR RETURN LigfSelect;

   PROCEDURE maj_flaglock_fact (l_socfact        IN facture.socfact%TYPE,
                                l_numfact        IN facture.numfact%TYPE,
                                l_typfact        IN facture.typfact%TYPE,
                                l_datfact        IN VARCHAR2,
                                l_flaglock       IN VARCHAR2,
                                l_flaglockout       OUT VARCHAR2
                                );

   PROCEDURE verif_codecompta  (c_codcompta      IN VARCHAR2       -- code comptable
                               );

 PROCEDURE verif_rapprochement (l_socfact       IN facture.socfact%TYPE,
                                l_ident         IN VARCHAR2,
                                l_lmontht       IN VARCHAR2,
                                l_lmoisprest    IN VARCHAR2,
                                l_message          OUT VARCHAR2
                               );

   PROCEDURE verif_periode_contrat (v_socfact    IN facture.socfact%TYPE,
                                    v_numcont    IN facture.numcont%TYPE,
                                    v_cav        IN facture.cav%TYPE,
                                    v_lmoisprest IN VARCHAR2         -- mois prestation DD/YYYY
                               );

-- *********** OK
   PROCEDURE insert_ligne_fact(p_mode         IN VARCHAR2,
                               p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_ident          IN VARCHAR2,
                               p_rnom           IN ressource.rnom%TYPE,
                               p_rprenom        IN ressource.rprenom%TYPE,
                               p_lmontht        IN VARCHAR2,
                               p_lmoisprest     IN VARCHAR2,
                               p_lcodcompta     IN VARCHAR2,
                               p_lnum           IN VARCHAR2,
                               p_fmontht        IN VARCHAR2,
                               p_ftva           IN VARCHAR2,
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_fmonthtout        OUT VARCHAR2,
                               p_ftvaout           OUT VARCHAR2,
                               p_flaglockout       OUT VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              );

-- ************ OK
   PROCEDURE update_ligne_fact(p_mode         IN VARCHAR2,
                               p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_ident          IN VARCHAR2,
                               p_rnom           IN ressource.rnom%TYPE,
                               p_rprenom        IN ressource.rprenom%TYPE,
                               p_lmontht        IN VARCHAR2,
                               p_lmoisprest     IN VARCHAR2,
                               p_lcodcompta     IN VARCHAR2,
                               p_lnum           IN VARCHAR2,
                               p_fmontht        IN VARCHAR2,
                               p_ftva           IN VARCHAR2,
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_fmonthtout        OUT VARCHAR2,
                               p_ftvaout           OUT VARCHAR2,
	   		       p_flaglockout       OUT VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              );

-- **************** OK
  PROCEDURE delete_ligne_fact (p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_ident          IN VARCHAR2,
                               p_rnom           IN ressource.rnom%TYPE,
                               p_rprenom        IN ressource.rprenom%TYPE,
                               p_lmontht        IN VARCHAR2,
                               p_lmoisprest     IN VARCHAR2,
                               p_lcodcompta     IN ligne_fact.lcodcompta%TYPE,
                               p_lnum           IN VARCHAR2,
                               p_fmontht        IN VARCHAR2,
                               p_ftva           IN VARCHAR2,
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_fmonthtout        OUT VARCHAR2,
                               p_ftvaout           OUT VARCHAR2,
                               p_flaglockout       OUT VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              );
-- **************** OK
  PROCEDURE update_facture_majlig (p_mode        IN VARCHAR2,
                               	   p_socfact       IN facture.socfact%TYPE,
                            	   p_soclib        IN societe.soclib%TYPE,
                            	   p_numcont       IN facture.numcont%TYPE,
                            	   p_cav           IN facture.cav%TYPE,
                            	   p_numfact       IN facture.numfact%TYPE,
                            	   p_typfact       IN facture.typfact%TYPE,
                            	   p_datfact       IN VARCHAR2,
                            	   p_fmontht       IN VARCHAR2,
                            	   p_ftva          IN VARCHAR2,
                            	   p_clelf         IN VARCHAR2,
                            	   p_flaglock      IN VARCHAR2,
                            	   p_userid        IN VARCHAR2,
                            	   p_flaglockout      OUT VARCHAR2,
                            	   p_soclibout        OUT VARCHAR2,
                            	   p_socfactout       OUT VARCHAR2,
                            	   p_numfactout       OUT VARCHAR2,
                            	   p_typfactout       OUT VARCHAR2,
                            	   p_datfactout       OUT VARCHAR2,
                            	   p_nbcurseur        OUT INTEGER,
                            	   p_message          OUT VARCHAR2
                              );

-- **************** OK
  PROCEDURE select_ligne_fact (p_mode      IN VARCHAR2,
                               p_socfact     IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_fmontht     IN VARCHAR2,
                               p_ftva        IN VARCHAR2,
                               p_clelf       IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_curselect   IN OUT LigfSelectCur,
                               p_fmonthtout     OUT VARCHAR2,
                               p_ftvaout        OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              );
-- **************** OK
  PROCEDURE select_ident_ress (p_socfact     IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_listeress   IN VARCHAR2,
                               p_ident       IN VARCHAR2,
                               p_fmontht     IN VARCHAR2,
                               p_ftva        IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_socfactout     OUT VARCHAR2,
                               p_soclibout      OUT VARCHAR2,
                               p_numcontout     OUT VARCHAR2,
                               p_cavout         OUT VARCHAR2,
                               p_numfactout     OUT VARCHAR2,
                               p_typfactout     OUT VARCHAR2,
                               p_datfactout     OUT VARCHAR2,
                               p_identout       OUT VARCHAR2,
                               p_rnomout        OUT VARCHAR2,
                               p_rprenomout     OUT VARCHAR2,
                               p_fmonthtout     OUT VARCHAR2,
                               p_ftvaout        OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              ) ;

END pack_ligne_fact;
/

CREATE OR REPLACE PACKAGE BODY pack_ligne_fact AS
-- **************************************************************************************
-- **************************************************************************************
--
-- Controle et Mise à jour du Flaglock Facture
--
-- ***********************************************
   PROCEDURE maj_flaglock_fact (l_socfact        IN facture.socfact%TYPE,
                                l_numfact        IN facture.numfact%TYPE,
                                l_typfact        IN facture.typfact%TYPE,
                                l_datfact        IN VARCHAR2,
                                l_flaglock       IN VARCHAR2,
                                l_flaglockout       OUT VARCHAR2
                                ) IS

      l_msg        VARCHAR2(200);
      referential_integrity EXCEPTION;
      PRAGMA       EXCEPTION_INIT(referential_integrity, -2292);
   -- =======================================
   -- Mise à jour du flaglock de la facture
   -- =======================================
   BEGIN
      UPDATE  facture
      SET    flaglock  = decode(l_flaglock, 1000000, 0, l_flaglock + 1)
      WHERE  socfact   = l_socfact
        AND  numfact   = l_numfact
        AND  typfact   = l_typfact
        AND  datfact   = TO_DATE(l_datfact,'DD/MM/YYYY')
        AND  flaglock  = l_flaglock;

		IF SQL%NOTFOUND THEN  -- Acces concurrent
			pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
			raise_application_error( -20999, l_msg );
		ELSE
			l_flaglockout :=  (l_flaglock + 1);
		END IF;

   EXCEPTION
      WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2292);
      WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
   END maj_flaglock_fact;


-- ***********************************************
--
--       Verification code comptable
--
-- ***********************************************
   PROCEDURE verif_codecompta  (c_codcompta     IN VARCHAR2       -- code comptable
                               ) IS

      l_msg       VARCHAR2(1024);
      l_comcode   code_compt.comcode%TYPE;

   -- ===================================================
   -- Test Existence du code comptable pour Ligne Fcature
   -- ===================================================
   BEGIN
      SELECT comcode INTO l_comcode FROM code_compt
            WHERE  comcode = c_codcompta ;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN             -- msg Code comptable invalide
           pack_global.recuperer_message(20110, NULL, NULL, 'LCODCOMPTA', l_msg);
           raise_application_error(-20110,l_msg);
      WHEN OTHERS THEN
           raise_application_error(-20997,SQLERRM);
   END verif_codecompta;


-- ******************************************************************
--
-- Verification Mois Prestation  vs  Periode de validite du contrat
--
-- ******************************************************************
   PROCEDURE verif_periode_contrat (v_socfact      IN     facture.socfact%TYPE,
                                    v_numcont      IN     facture.numcont%TYPE,
                                    v_cav          IN     facture.cav%TYPE,
                                    v_lmoisprest   IN     VARCHAR2         -- mois prestation DD/YYYY
                               )  IS
      l_msg       VARCHAR2(512);
      l_msg2      VARCHAR2(128);
      l_cdatdeb   contrat.cdatdeb%TYPE;
      l_cdatfin   contrat.cdatfin%TYPE;

   BEGIN
      -- on est sur que le contrat/avenant doit se trouver soit dans contrat, soit dans histo_contrat
      -- mais pas dans les deux tables
      SELECT chc.datdeb , chc.datfin INTO  l_cdatdeb, l_cdatfin
      FROM (
            SELECT  c.cdatdeb datdeb, c.cdatfin  datfin
            FROM contrat c
            WHERE  c.soccont = v_socfact
               AND c.numcont = v_numcont
               AND c.cav     = v_cav
            UNION
            SELECT  hc.cdatdeb datdeb, hc.cdatfin  datfin
            FROM  histo_contrat hc
            WHERE  hc.soccont = v_socfact
               AND hc.numcont = v_numcont
               AND hc.cav     = v_cav
           ) chc  ;

      -- Verifier le mois de prestation
      -- 18/05/2000 : on ne s'interesse uniquement au mois
      l_cdatdeb := to_date(to_char(l_cdatdeb,'MM/YYYY'),'MM/YYYY') ;
      l_cdatfin := to_date(to_char(l_cdatfin,'MM/YYYY'),'MM/YYYY') ;

      IF (to_date(v_lmoisprest,'MM/YYYY') < l_cdatdeb)  OR  (to_date(v_lmoisprest,'MM/YYYY') > l_cdatfin )
            THEN   -- Msg Mois de prestation doit etre entre cdatdeb et cdatfin
               l_msg2 := to_char(l_cdatdeb,'MM/YYYY') || ' et ' || to_char(l_cdatfin,'MM/YYYY');
               pack_global.recuperer_message(20141, '%s1', l_msg2, 'LMOISPREST', l_msg);
               raise_application_error(-20141,l_msg);
      END IF;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN     -- Msg Facture refernce a un contrat/avenant inexistant
            pack_global.recuperer_message(20107, NULL, NULL, NULL, l_msg);
            raise_application_error(-20107,l_msg);
      WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);

   END verif_periode_contrat;


-- ******************************************************************************
--
--  Verification Rapprochement du Montant de la ligne de facture
--
--  Modif 09/02/00 QHL : test via la table proplus
--
-- ******************************************************************************
 PROCEDURE verif_rapprochement (l_socfact     IN facture.socfact%TYPE,
                                l_ident         IN VARCHAR2,
                                l_lmontht       IN VARCHAR2,
                                l_lmoisprest    IN VARCHAR2,
                                l_message          OUT VARCHAR2
                               ) IS

   l_NbJoursTravail	PROPLUS.cusag%TYPE;	-- cumul du nb de jours travaillés
   l_cout_total      	PROPLUS.cout%TYPE;   -- Cout total
   l_msg             	VARCHAR2(5000);
   l_rapprochement    	ligne_fact.lrapprocht%TYPE;
   l_tot_fact		NUMBER(12,2);
   l_liste_fact  	VARCHAR2(5000);
   l_ecart 		NUMBER(12,2);
   l_rapprocht		VARCHAR2(5000);
   -- --------------------------------------------------------------------
   --  Curseur d'extraction du cout et du consomme pour le mois demandé
   -- --------------------------------------------------------------------
   CURSOR cur_coutcons  ( cl_socfact     IN facture.socfact%TYPE,
                          cl_ident       IN VARCHAR2,
                          cl_lmoisprest  IN VARCHAR2
                        ) IS
  	   SELECT   P1.cusag , P1.cout
	   FROM	proplus P1
	   WHERE P1.tires      = to_number(cl_ident,'FM99999')
	   AND	P1.societe    = cl_socfact
	   AND	P1.cdeb       = to_date(cl_lmoisprest,'MM/YYYY')
	   AND (     P1.aist not in ( 'FORMAT','CONGES', 'ABSDIV','MOBILI','PARTIE', 'RTT','RTT   ')
		   OR	P1.aist    IS NULL
		 );

   -- -------------------------------------------------------------------------------
   --  Curseur qui ramène toutes les lignes de facture de la ressource pour le mois
   -- -------------------------------------------------------------------------------
   CURSOR cur_lignefact ( cl_socfact     IN facture.socfact%TYPE,
                          cl_ident       IN VARCHAR2,
                          cl_lmoisprest  IN VARCHAR2
                        ) IS
	SELECT lf.lnum,lf.typfact, lf.numfact, lf.socfact,decode(lf.typfact,'A',-1,1)*lmontht lmontht
	FROM ligne_fact lf , facture fac
	WHERE lf.numfact=fac.numfact
	AND   lf.socfact=fac.socfact
	AND   lf.datfact=fac.datfact
	AND   lf.typfact=fac.typfact
	AND   lf.ident=to_number(cl_ident,'FM99999')
	AND   lf.lmoisprest=to_date(cl_lmoisprest,'MM/YYYY')
	AND   lf.socfact    = cl_socfact
	AND   (fac.fmodreglt!=8 or fac.fmodreglt is null)
	AND   lf.lcodcompta NOT IN (6350001, 6350002, 6398001)
	order by lf.typfact desc, lf.numfact
	;


   BEGIN
      l_message := '';
	-----------------------------------------------------------
	-- Calcul du consommé de la ressource pour le mois choisi
	-----------------------------------------------------------
      	l_cout_total := 0;
      	FOR ligne_pp IN cur_coutcons (l_socfact, l_ident, l_lmoisprest)
         LOOP
            l_cout_total := l_cout_total + (ligne_pp.cusag * ligne_pp.cout);
      	END LOOP;

	----------------------------------------------------------
	-- Calcul du montant facturé pour la ressource et le mois
	----------------------------------------------------------
	l_tot_fact := 0;
	l_liste_fact := '';

	FOR rec_fact IN cur_lignefact (l_socfact, l_ident, l_lmoisprest)
         LOOP
            	l_tot_fact := l_tot_fact + NVL(rec_fact.lmontht,0);
		l_liste_fact := l_liste_fact||' numfact : '||rec_fact.numfact||
				', montant : '||to_char(rec_fact.lmontht,'FM999999990D00')||'\n ' ;
      	END LOOP;

	l_ecart := l_tot_fact - l_cout_total ;
	l_liste_fact:= l_liste_fact||
			' \n Total facture(s): '||to_char(l_tot_fact,'FM999999990D00')||
			' \n Total consommé: '||to_char(l_cout_total,'FM999999990D00')||
			' \n Ecart : '||to_char(l_ecart,'FM999999990D00');

	if ABS(l_ecart)<=1 then
		l_rapprocht:='RAPPROCHEMENT JUSTE :  \n ---------------------------------------------- \n ';
	else
		l_rapprocht:='NON RAPPROCHEMENT : \n ------------------------------------------- \n ';

	end if;

	pack_global.recuperer_message(20366, '%s1', l_rapprocht||'Mois de prestation : '||l_lmoisprest||' \n '||l_liste_fact, NULL, l_msg);
        raise_application_error(-20366,l_msg);


   EXCEPTION
      WHEN NO_DATA_FOUND THEN   -- msg Pas de consommé pour le mois demandé
         pack_global.recuperer_message(20130, NULL, NULL, NULL, l_msg);
         raise_application_error(-20130, l_msg);
      WHEN OTHERS THEN
         raise_application_error(-20997,SQLERRM);

   END verif_rapprochement;



-- ********************************************************************************************
-- ********************************************************************************************
--
-- INSERT_ligne_fact :
--
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE insert_ligne_fact(p_mode         IN VARCHAR2,
                               p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_ident          IN VARCHAR2,
                               p_rnom           IN ressource.rnom%TYPE,
                               p_rprenom        IN ressource.rprenom%TYPE,
                               p_lmontht        IN VARCHAR2,
                               p_lmoisprest     IN VARCHAR2,
                               p_lcodcompta     IN VARCHAR2,
                               p_lnum           IN VARCHAR2,
                               p_fmontht        IN VARCHAR2,
                               p_ftva           IN VARCHAR2,
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_fmonthtout        OUT VARCHAR2,
                               p_ftvaout           OUT VARCHAR2,
                               p_flaglockout       OUT VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              ) IS

      l_msg         VARCHAR2(1024);
      l_lnum        NUMBER(2);
      l_numfact     ligne_fact.numfact%TYPE;
      l_ftva        facture.ftva%TYPE;
      l_fdeppole    facture.fdeppole%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA        EXCEPTION_INIT(referential_integrity, -2291);
      l_cdeb        cons_sstache_res_mois.cdeb%TYPE;
      l_cdur        cons_sstache_res_mois.cdur%TYPE;
      l_cusag       cons_sstache_res_mois.cusag%TYPE;
      l_flag_rappro NUMBER(1);
      l_consht      ligne_fact.lmontht%TYPE;
      l_cout        situ_ress.cout%TYPE;
      l_flaglockout VARCHAR2(20);
      l_comcode     code_compt.comcode%TYPE;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';
      p_fmonthtout :=  p_fmontht   ;
      p_ftvaout    :=  p_ftva      ;

      -- ===================================================
      -- Test Flaglock de la facture est toujours bonne, Si oui, on l'incremente de 1
      -- Si non Erreur  Acces concurrent
      -- ===================================================
      maj_flaglock_fact(p_socfact,p_numfact,p_typfact,p_datfact,p_flaglock,l_flaglockout);
      p_flaglockout := l_flaglockout;

      -- ===========================================================
      -- Test Mois Prestation  vs  Periode de validite du contrat si facture associée à un contrat
      -- ===========================================================
      IF p_numcont!='' or p_numcont is not null  THEN
		verif_periode_contrat(p_socfact, p_numcont, p_cav, p_lmoisprest);
	END IF;
      -- ===================================================
      -- Test Existence du code comptable dans CODE_COMPT
      -- ===================================================
      verif_codecompta(p_lcodcompta);


      -- Selection du ftva et du code fdeppole de la facture
      SELECT fdeppole,ftva  INTO l_fdeppole, l_ftva
	 FROM  facture
      WHERE (socfact = p_socfact AND typfact = p_typfact
            AND datfact = to_date(p_datfact,'DD/MM/YYYY') AND numfact = rpad(p_numfact,15) );


-- 18/05/2000 on prend la tva de la facture au lieu de la table tva !
--      SELECT tva  INTO l_ftva  FROM tva
--      WHERE datetva = (SELECT max(datetva) FROM tva ) ;


      -- Quel est le prochain numero de la ligne de facture ?
      SELECT  MAX(lnum) INTO l_lnum     FROM ligne_fact
      WHERE  (socfact = p_socfact
          AND typfact = p_typfact
          AND datfact = to_date(p_datfact,'DD/MM/YYYY')
          AND numfact = rpad(p_numfact,15) );

      -- attention sql%found est toujours vrai car on a fait une operation MAX

      l_lnum := NVL(l_lnum,0) + 1 ;

      BEGIN
         INSERT INTO ligne_fact
                  (lnum,
                  lmontht,
                  lcodcompta,
                  ldeppole,
                  lmoisprest,
                  socfact,
                  typfact,
                  datfact,
                  numfact,
                  tva,
                  ident
                  )
         VALUES ( l_lnum,
                  to_number(p_lmontht,'FM99999999D00'),
                  p_lcodcompta,
                  l_fdeppole,
                  to_date(p_lmoisprest,'MM/YYYY'),
                  p_socfact,
                  p_typfact,
                  to_date(p_datfact,'DD/MM/YYYY'),
                  p_numfact,
                  p_ftva,                               --     l_ftva,
                  to_number(p_ident,'99999')
                  );
      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2291);

         WHEN  DUP_VAL_ON_INDEX THEN  -- Probl de création de la ligne de facture!
            pack_global.recuperer_message(20113,NULL, NULL, NULL, l_msg);
            raise_application_error(-20113 , l_msg );

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM );
      END;

      IF SQL%FOUND THEN  -- OK Msg  Ligne de facture créée
         pack_global.recuperer_message(2203,NULL,NULL,NULL,l_msg);
         p_message := l_msg;
      END IF;

      -- =====================================
      -- Si tout va bien Test Rapprochement
      -- =====================================
      IF p_mode = 'Rapprochement' THEN

           verif_rapprochement(p_socfact, p_ident, p_lmontht, p_lmoisprest, l_msg);
            p_message := p_message || l_msg;
      END IF;   -- Fin du cas Rapprochement

END insert_ligne_fact;




-- ********************************************************************************************************
-- ********************************************************************************************************
--
-- UPDATE_ligne_fact   - possible que si fstatut1 = 'AE' ou 'SE' ou 'IN' déjà contrôlé lors du select_ligne_fact
--
-- ********************************************************************************************************
-- ********************************************************************************************************
   PROCEDURE update_ligne_fact(p_mode         IN VARCHAR2,
                               p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_ident          IN VARCHAR2,
                               p_rnom           IN ressource.rnom%TYPE,
                               p_rprenom        IN ressource.rprenom%TYPE,
                               p_lmontht        IN VARCHAR2,
                               p_lmoisprest     IN VARCHAR2,
                               p_lcodcompta     IN VARCHAR2,
                               p_lnum           IN VARCHAR2,
                               p_fmontht        IN VARCHAR2,
                               p_ftva           IN VARCHAR2,
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_fmonthtout        OUT VARCHAR2,
                               p_ftvaout           OUT VARCHAR2,
			       p_flaglockout       OUT VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              ) IS

      l_msg        VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA       EXCEPTION_INIT(referential_integrity, -2291);
      l_cdeb       cons_sstache_res_mois.cdeb%TYPE;
      l_cdur       cons_sstache_res_mois.cdur%TYPE;
      l_cusag      cons_sstache_res_mois.cusag%TYPE;
      l_flag_rappro NUMBER(1);
      l_consht     ligne_fact.lmontht%TYPE;
      l_cout       situ_ress.cout%TYPE;
      l_flaglockout  VARCHAR2(20);


   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';
		p_flaglockout	:=  p_flaglock ;
      p_fmonthtout   :=  p_fmontht  ;
      p_ftvaout      :=  p_ftva     ;

      -- ===========================================================
      -- Test Mois Prestation  vs  Periode de validite du contrat
      -- ===========================================================
      verif_periode_contrat(p_socfact, p_numcont, p_cav, p_lmoisprest);

      -- ===================================================
      -- Test Existence du code comptable dans CODE_COMPT
      -- ===================================================
      verif_codecompta(p_lcodcompta);

      -- ===================================================
      -- Test Flaglock de la facture est toujours bonne, Si oui, on l'incremente de 1
      -- Si non Erreur  Acces concurrent
      -- ===================================================
      maj_flaglock_fact(p_socfact,p_numfact,p_typfact,p_datfact,p_flaglock,l_flaglockout);
      p_flaglockout := l_flaglockout;

      -- =======================================
      --  OK update de la ligne la facture
      -- =======================================
      BEGIN
         UPDATE ligne_fact
         SET   lmontht     = to_number(p_lmontht,'FM999999D00'),
               lmoisprest  = to_date(p_lmoisprest,'MM/YYYY'),
               lcodcompta  = p_lcodcompta
         WHERE  lnum     = p_lnum
           AND  socfact  = p_socfact
           AND  numfact  = rpad(p_numfact,15)
           AND  typfact  = p_typfact
           AND  datfact  = to_date(p_datfact,'DD/MM/YYYY');

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2291);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%FOUND THEN  -- Msg Ligne de facture modifiée
         pack_global.recuperer_message(2204,NULL,NULL,NULL, l_msg);
         p_message := l_msg;
      ELSE    -- SQL Not found : Msg Problème de modification de la ligne de facture
         pack_global.recuperer_message(20114,NULL, NULL, NULL, l_msg);
         raise_application_error( -20114, l_msg );
      END IF;


      -- =====================================
      -- Si tout va bien Test Rapprochement
      -- =====================================
      IF p_mode= 'Rapprochement' THEN

            verif_rapprochement(p_socfact, p_ident, p_lmontht, p_lmoisprest, l_msg);
            p_message := l_msg;

      END IF;   -- Fin du cas Rapprochement

END update_ligne_fact;



-- ********************************************************************************************
-- ********************************************************************************************
--
-- DELETE_ligne_fact  :
--
-- ********************************************************************************************
-- ********************************************************************************************
  PROCEDURE delete_ligne_fact (p_socfact        IN facture.socfact%TYPE,
                               p_soclib         IN societe.soclib%TYPE,
                               p_numcont        IN facture.numcont%TYPE,
                               p_cav            IN facture.cav%TYPE,
                               p_numfact        IN facture.numfact%TYPE,
                               p_typfact        IN facture.typfact%TYPE,
                               p_datfact        IN VARCHAR2,
                               p_ident          IN VARCHAR2,
                               p_rnom           IN ressource.rnom%TYPE,
                               p_rprenom        IN ressource.rprenom%TYPE,
                               p_lmontht        IN VARCHAR2,
                               p_lmoisprest     IN VARCHAR2,
                               p_lcodcompta     IN ligne_fact.lcodcompta%TYPE,
                               p_lnum           IN VARCHAR2,
                               p_fmontht        IN VARCHAR2,
                               p_ftva           IN VARCHAR2,
                               p_flaglock       IN VARCHAR2,
                               p_userid         IN VARCHAR2,
                               p_fmonthtout        OUT VARCHAR2,
                               p_ftvaout           OUT VARCHAR2,
                               p_flaglockout       OUT VARCHAR2,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              ) IS

      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
      l_exist number;
      l_lnum number;

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      -- l'utilisateur a déjà fait un select pour visualiser avant, ici on est sur que
      -- la facture existe et donc la seule difference ne concernera que le Flaglock

      p_nbcurseur := 0;
      p_message := '';

      p_flaglockout :=  p_flaglock ;
      p_fmonthtout  :=  p_fmontht  ;
      p_ftvaout     :=  p_ftva     ;


      -- =======================================
      -- Mise à jour du flaglock de la facture
      -- =======================================
      BEGIN
         UPDATE  facture
         SET    flaglock  = decode(p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  socfact   = p_socfact
           AND  numfact   = p_numfact
           AND  typfact   = p_typfact
           AND  datfact   = TO_DATE(p_datfact,'DD/MM/YYYY')
           AND  flaglock  = p_flaglock;

			IF SQL%NOTFOUND THEN  -- Acces concurrent
				pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
				raise_application_error( -20999, l_msg );
			ELSE
				p_flaglockout :=  (p_flaglock + 1);
			END IF;

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2292);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END;

      -- =============================================================================
      -- 06/10/2000 : Suppression impossible s'il existe des lignes de facture après
      -- ===============================================================================
	BEGIN


		select max(lnum) into l_exist
		from ligne_fact
		where
		      socfact = p_socfact
           	 AND  numfact = rpad(p_numfact,15)
           	 AND  typfact = p_typfact
           	 AND  datfact = to_date(p_datfact,'DD/MM/YYYY') ;

		IF l_exist!=to_number(p_lnum) then
		 --suppression impossible, on ne peut supprimer que la dernière ligne de facture
		pack_global.recuperer_message(20326,NULL,NULL,NULL, l_msg);
         	p_message := l_msg;
      	else

      	-- =======================================
     	 -- OK Delete de la  ligne de facture
     	 -- =======================================
      	BEGIN
         	DELETE FROM ligne_fact
         	WHERE  lnum    = p_lnum
           	AND  socfact = p_socfact
           	AND  numfact = rpad(p_numfact,15)
           	AND  typfact = p_typfact
           	AND  datfact = to_date(p_datfact,'DD/MM/YYYY') ;
      	EXCEPTION
         	WHEN referential_integrity THEN
              		pack_global.recuperation_integrite(-2292);
         	WHEN OTHERS THEN
               		raise_application_error(-20997, SQLERRM);
      	END;

      IF SQL%FOUND THEN
         -- Ligne de facture supprimée
         pack_global.recuperer_message(2205,NULL,NULL,NULL, l_msg);
         p_message := l_msg;
      END IF;
	end if;
end;
   END delete_ligne_fact;


-- ********************************************************************************************
-- ********************************************************************************************
--
-- UPDATE_facture_majlig : Ecran Lignes de facture - bouton 'VALIDER'
--       Update de la facture avec le montant HT + tva via l'écran màj lignes
--       Si OK on passera à l'écran Dates de suivi Facture
-- Quand    Qui  Procedure impactée + Quoi
-- -------- ---  ----------------------------------------------------------------------------------------
-- 18/01/00 QHL  update_facture_majlig : Si fact. sans contrat Alors Update Facture et ecran suivant
--                           Si fact avec contrat Alors MontantHT doit égale Somme(MontantHT ligne_fact)
--
-- 19/10/00 NCM  Mise à jour de la tva dans ligne_fact si chgt de code tva dans la facture
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE update_facture_majlig (p_mode     IN VARCHAR2,
                               p_socfact     IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_fmontht     IN VARCHAR2,
                               p_ftva        IN VARCHAR2,
                               p_clelf       IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_soclibout      OUT VARCHAR2,
                               p_socfactout     OUT VARCHAR2,
                               p_numfactout     OUT VARCHAR2,
                               p_typfactout     OUT VARCHAR2,
                               p_datfactout     OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              ) IS

      l_msg         VARCHAR2(500) ;
      l_msg2        VARCHAR2(500);
      l_soclib      societe.soclib%TYPE ;
      l_socfact     facture.socfact%TYPE ;
      p_filcode     filiale_cli.filcode%TYPE ;
      referential_integrity EXCEPTION;
      PRAGMA        EXCEPTION_INIT(referential_integrity, -2291);
      l_sumlmontht  NUMBER(12,2);
      l_countlf     NUMBER(12,2);

   BEGIN

      p_socfactout :=  p_socfact;
      p_soclibout  :=  p_soclib;
      p_numfactout :=  p_numfact;
      p_typfactout :=  p_typfact;
      p_datfactout :=  p_datfact;

      l_sumlmontht := 0;
      l_countlf    := 0;
      l_msg        := '';
      l_msg2       := '';

      -- ******************************************************************
      --
      -- * Si Facture sans contrat Alors Update facture et on passe à Dates de suivi
      -- * Si facture avec contrat
      --   Alors on passe à Dates de suivi que si MontantTotalHT=Somme(MontantHT ligne fact)
      --   Si OK , UPDATE facture avec le MontantTotalHT et le TVA  puis passer aux 'Dates de Suivi'
      --
      -- ******************************************************************

      IF p_numcont IS NOT NULL  THEN
         BEGIN
            -- ==================================================
            -- CAS  FACTURE AVEC CONTRAT
            -- Lire les lignes de facture et faire la somme
            -- ==================================================
            SELECT  SUM(lmontht), COUNT(lmontht)
               INTO l_sumlmontht, l_countlf
            FROM  ligne_fact
            WHERE    socfact  = p_socfact
               AND   typfact  = p_typfact
               AND   datfact  = to_date(p_datfact,'DD/MM/YYYY')
               AND   numfact  = rpad(p_numfact,15) ;

            IF l_countlf = 0  THEN
               -- ============================================================
               -- Erreur : Lignes de facture inexistantes pour cette facture
               -- ============================================================
               pack_global.recuperer_message(20120,NULL, NULL, NULL, l_msg);
               raise_application_error( -20120, l_msg);
            ELSIF ((to_number(p_fmontht,'FM99999999D00')) <> l_sumlmontht) THEN
               -- ==================================================================================
               -- Erreur : Montant total HT différent de la somme des montants des lignes de facture
               -- ==================================================================================
               pack_global.recuperer_message(20121,'%s1',p_fmontht,'%s2',l_sumlmontht, NULL, l_msg);
               raise_application_error( -20121, l_msg);
            END IF;
         END;
      END IF;


      -- =============================================
      -- Màj de la facture
      -- =============================================
      BEGIN
         UPDATE FACTURE
         SET   fmontht   = to_number(p_fmontht,'FM99999999D00'),
               fmontttc  = (to_number(p_fmontht,'FM99999999D00')*(1+(to_number(p_ftva,'FM999D00')/100))),
               ftva      = to_number(p_ftva,'FM999D00'),
               flaglock  = decode(p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  socfact  = p_socfact
           AND  numfact  = rpad(p_numfact,15)
           AND  typfact  = p_typfact
           AND  datfact  = to_date(p_datfact,'DD/MM/YYYY')
           AND  flaglock = p_flaglock;

         IF SQL%NOTFOUND THEN  -- Acces concurrent
            pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
            raise_application_error( -20999, l_msg );
         ELSE
            --
            -- Msg Facture %s1 MODIFIEE
            --
            p_flaglockout :=  (p_flaglock + 1) ;
            pack_global.recuperer_message(2201,'%s1',p_numfact, NULL, l_msg);
            p_message := l_msg;

         END IF;

      EXCEPTION
         WHEN referential_integrity THEN
            pack_global.recuperation_integrite(-2291);
         WHEN OTHERS THEN
               raise_application_error(-20997, SQLERRM);
      END; -- End bloc màj facture


      -- ====================================================
      -- Mise à jour des dates FREGCOMPTA et FACCSEC si null
      -- ====================================================
      BEGIN
         UPDATE FACTURE
         SET    fregcompta = sysdate,
                faccsec    = sysdate
         WHERE     socfact    = p_socfact
              AND  numfact    = rpad(p_numfact,15)
              AND  typfact    = p_typfact
              AND  datfact    = to_date(p_datfact,'DD/MM/YYYY')
              AND  fregcompta is null
              AND  faccsec    is null
         ;
      END;

      -- ===================================================================================================
      -- 19/10/2000 : Mise à jour de la tva des lignes de facture si chgt de tva après création de la ligne
      -- ====================================================================================================
      BEGIN
	UPDATE LIGNE_FACT
	SET tva=to_number(p_ftva,'FM999D00')
	WHERE socfact  = p_socfact
           AND  numfact  = rpad(p_numfact,15)
           AND  typfact  = p_typfact
           AND  datfact  = to_date(p_datfact,'DD/MM/YYYY') ;


      END;
   END update_facture_majlig;   -- End bloc If Valider



-- ********************************************************************************************
-- ********************************************************************************************
--
-- SELECT_ligne_fact
-- Cas a tester : 1) Bouton Creer Lignes de facture
--                2) Bouton Modifier ou Supprimer + sélection de lignes de facture
--
-- ********************************************************************************************
-- ********************************************************************************************
  PROCEDURE select_ligne_fact (p_mode      IN VARCHAR2,
                               p_socfact     IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_fmontht     IN VARCHAR2,
                               p_ftva        IN VARCHAR2,
                               p_clelf       IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_curselect   IN OUT LigfSelectCur,
                               p_fmonthtout     OUT VARCHAR2,
                               p_ftvaout        OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              ) IS

      l_msg         VARCHAR2(1024) ;
      l_lnum        VARCHAR2(20);
      l_ident       VARCHAR2(20);
      l_rnom        VARCHAR2(40);
      l_rprenom     VARCHAR2(20);
      l_lmontht     VARCHAR2(20);
      l_lmoisprest  VARCHAR2(20);
      l_lcodcompta  VARCHAR2(20);


   BEGIN
      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur   := 1;
      p_message     := '';
      p_flaglockout :=  p_flaglock;
      p_fmonthtout  :=  p_fmontht ;
      p_ftvaout     := p_ftva    ;


  -- ************************************************************************
  --
  --  Cas CREER : il n'y a rien a faire, on passe
  --  à l'écran "Saisir l'identifiant d'une ressource"
  --
  -- ************************************************************************

   IF p_mode = 'insert' THEN  NULL;
   END IF;  -- Fin du cas creation


   -- ******************************************************************
   --
   -- Cas  MODIFIER  ou  SUPPRIMER (lignes de factures) les infos sont
   -- contenues dans clelf qu'il suffit de les extraire
   --
   -- ******************************************************************

   IF (p_mode = 'update' OR p_mode = 'delete') THEN
		BEGIN
			pack_liste_lignes_fact.xcle_ligne_fact(p_clelf, 0,
				l_lnum, l_ident, l_rnom, l_rprenom,
				l_lmontht, l_lmoisprest, l_lcodcompta) ;

 		   -- Retour du curseur
			OPEN p_curselect FOR
				SELECT   p_socfact   ,
							p_soclib    ,
							p_numcont   ,
							p_cav       ,
							p_numfact   ,
							p_typfact   ,
							p_datfact   ,
							l_lnum      ,
							l_ident     ,
							l_rnom      ,
							l_rprenom   ,
							l_lmontht   ,
							l_lmoisprest,
							l_lcodcompta
			FROM dual;
		END;
   END IF;  -- Fin du cas  MODIFIER ou SUPPRIMER

END select_ligne_fact;



-- ********************************************************************************************
-- ********************************************************************************************
--
-- SELECT_ident_ress  : filtre identifiant ressource
--
-- Quand    Qui  Procedure impactée + Quoi
-- -------- ---  ----------------------------------------------------------------------------------------
-- 18/01/00 QHL  * select_ident_ress : ajout controle existence de Identifiant ressource appartenant à société
--               on recherche dans ligne_cont et Histo_ligne_cont
--
--
-- ********************************************************************************************
-- ********************************************************************************************
   PROCEDURE select_ident_ress (p_socfact     IN facture.socfact%TYPE,
                               p_soclib      IN societe.soclib%TYPE,
                               p_numcont     IN facture.numcont%TYPE,
                               p_cav         IN facture.cav%TYPE,
                               p_numfact     IN facture.numfact%TYPE,
                               p_typfact     IN facture.typfact%TYPE,
                               p_datfact     IN VARCHAR2,
                               p_listeress   IN VARCHAR2,
                               p_ident       IN VARCHAR2,
                               p_fmontht     IN VARCHAR2,
                               p_ftva        IN VARCHAR2,
                               p_flaglock    IN VARCHAR2,
                               p_userid      IN VARCHAR2,
                               p_socfactout     OUT VARCHAR2,
                               p_soclibout      OUT VARCHAR2,
                               p_numcontout     OUT VARCHAR2,
                               p_cavout         OUT VARCHAR2,
                               p_numfactout     OUT VARCHAR2,
                               p_typfactout     OUT VARCHAR2,
                               p_datfactout     OUT VARCHAR2,
                               p_identout       OUT VARCHAR2,
                               p_rnomout        OUT VARCHAR2,
                               p_rprenomout     OUT VARCHAR2,
                               p_fmonthtout     OUT VARCHAR2,
                               p_ftvaout        OUT VARCHAR2,
                               p_flaglockout    OUT VARCHAR2,
                               p_nbcurseur      OUT INTEGER,
                               p_message        OUT VARCHAR2
                              ) IS

      l_msg       VARCHAR2(1024) ;
      l_rnom      ressource.rnom%TYPE;
      l_rprenom   ressource.rprenom%TYPE;

   BEGIN
         -- Positionner le nb de curseurs ==> 0
         -- Initialiser le message retour
         p_nbcurseur  := 1;
         p_message    := '';
         p_socfactout :=  p_socfact   ;
         p_soclibout  :=  p_soclib    ;
         p_numcontout :=  p_numcont   ;
         p_cavout     :=  p_cav       ;
         p_numfactout :=  p_numfact   ;
         p_typfactout :=  p_typfact   ;
         p_datfactout :=  p_datfact   ;
         p_identout   :=  p_ident     ;
         p_fmonthtout :=  p_fmontht   ;
         p_ftvaout    :=  p_ftva      ;

      BEGIN
       IF p_numcont!='' or p_numcont is not null THEN          -- FACTURE AVEC CONTRAT
	   SELECT frnom, frprenom INTO l_rnom, l_rprenom
         FROM (
               SELECT r.rnom frnom, r.rprenom frprenom
               FROM  ligne_cont lc, ressource r
               WHERE	    r.ident    =  lc.ident
                     AND rownum     = 1
                     AND lc.soccont = p_socfact
                     AND r.ident    = to_number(p_ident,'FM99999')
               UNION
               SELECT r.rnom frnom, r.rprenom frprenom
               FROM  histo_ligne_cont hlc, ressource r
               WHERE		 r.ident     =  hlc.ident
                     AND rownum      = 1
                     AND hlc.soccont = p_socfact
                     AND r.ident     = to_number(p_ident,'FM99999')
             )
         WHERE rownum = 1;
	ELSE								-- FACTURE SANS CONTRAT
		SELECT rnom,rprenom INTO l_rnom, l_rprenom
		FROM ressource
		WHERE ident = to_number(p_ident,'FM99999');
	END IF;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN     -- Msg Code ressource inexistant
               pack_global.recuperer_message(20131, '%s1', p_ident, NULL, l_msg);
               raise_application_error(-20131,l_msg);

         WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
      END;

         p_rnomout    :=  l_rnom;
         p_rprenomout :=  l_rprenom;
         p_flaglockout:=  p_flaglock;



END select_ident_ress;

END pack_ligne_fact;
/
CREATE OR REPLACE PACKAGE pack_ligne_oscar AS


   PROCEDURE maj_ligne_oscar;

END pack_ligne_oscar;
/

CREATE OR REPLACE PACKAGE BODY pack_ligne_oscar AS

   PROCEDURE maj_ligne_oscar IS

	L_ANNEE NUMBER;
	L_ANNEE1 NUMBER;
	l_top_oscar char(2);
	l_pid varchar2(4);

-- non modification des lignes SBAN par DIST

	CURSOR ligne_oscar IS
        SELECT i.pid,notifie,code_mo,resp_mo,objectif_mo,i.propo_mo_n1
        FROM imp_oscar_tmp i,client_mo c,ligne_bip lb
        WHERE lb.clicode=c.clicode
	AND  i.pid = lb.pid
        AND c.top_oscar='O'
        AND i.code_mo IN (SELECT clicode FROM client_mo
				WHERE top_oscar='O')
	;


	BEGIN

	SELECT TO_NUMBER(TO_CHAR(datdebex,'YYYY')) INTO L_ANNEE
	FROM datdebex;

	SELECT TO_NUMBER(TO_CHAR(datdebex,'YYYY'))+1 INTO L_ANNEE1
	FROM datdebex;

	FOR oscar IN ligne_oscar LOOP

-- mise a jour du nom de la maitrise d'ouvrage


		UPDATE ligne_bip
		SET pnmouvra=SUBSTR(oscar.resp_mo,1,15)
		WHERE pid=oscar.pid
		;

		IF SQL%ROWCOUNT=0 THEN
			UPDATE imp_oscar_tmp
			SET erreur='O'
			WHERE pid=oscar.pid;
		END IF;


-- mise a jour du code client


		UPDATE ligne_bip
		SET clicode=oscar.code_mo
		WHERE pid=oscar.pid
		;


		IF SQL%ROWCOUNT=0 THEN
			UPDATE imp_oscar_tmp
			SET erreur='O'
			WHERE pid=oscar.pid;
		END IF;


-- mise a jour des donnees budgetaire : proposé mo de l'année

		UPDATE budget
		SET bpmontmo=oscar.notifie
		WHERE pid=oscar.pid
		AND annee=L_ANNEE
		;

		IF SQL%ROWCOUNT=0 THEN
			BEGIN
				SELECT lb.pid INTO l_pid FROM ligne_bip lb
				WHERE lb.pid = oscar.pid;

				INSERT INTO budget(pid,annee,bpmontmo,flaglock)
				VALUES (oscar.pid,L_ANNEE,oscar.notifie,0);
				-- VALUES (oscar.pid,L_ANNEE1,oscar.notifie,0);

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
				UPDATE imp_oscar_tmp
				SET erreur='O'
				WHERE pid=oscar.pid;
			END;

		END IF;


-- mise a jour des donnees budgetaire : proposé mo de l'année+1

		UPDATE budget
		SET bpmontmo=oscar.propo_mo_n1
		WHERE pid=oscar.pid
		AND annee=L_ANNEE1
		;

		IF SQL%ROWCOUNT=0 THEN
			BEGIN
				SELECT lb.pid INTO l_pid FROM ligne_bip lb
				WHERE lb.pid = oscar.pid;

				INSERT INTO budget(pid,annee,bpmontmo,flaglock)
				VALUES (oscar.pid,L_ANNEE1,oscar.propo_mo_n1,0);

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
				UPDATE imp_oscar_tmp
				SET erreur='O'
				WHERE pid=oscar.pid;
			END;

		END IF;

-- mise a jour des donnees budgetaire : réestimé de l'année en cours
		BEGIN
			SELECT nvl(sti.top_oscar,'N') INTO l_top_oscar
			FROM struct_info sti,ligne_bip lb
			WHERE sti.codsg = lb.codsg
			and lb.pid = oscar.pid;

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				UPDATE imp_oscar_tmp
				SET erreur='O'
				WHERE pid=oscar.pid;
				l_top_oscar := 'N';
		END;

		IF l_top_oscar = 'O' THEN

			UPDATE budget
			SET reestime=oscar.objectif_mo
			WHERE pid=oscar.pid
			AND annee=L_ANNEE
			;

			IF SQL%ROWCOUNT=0 THEN
				INSERT INTO budget(pid,annee,reestime,flaglock)
				VALUES (oscar.pid,L_ANNEE,oscar.objectif_mo,0);
			END IF;
		END IF;
	END LOOP;

	COMMIT;

   END maj_ligne_oscar;

END pack_ligne_oscar;
/
CREATE OR REPLACE PACKAGE pack_liste_activites AS

   TYPE activites_ListeViewType IS RECORD(  	CODE_ACTIVITE   VARCHAR2(12),
  						LIB_ACTIVITE     VARCHAR2(60)
					  );

   TYPE activites_listeCurType IS REF CURSOR RETURN activites_ListeViewType;

   TYPE ligne_ListeViewType IS RECORD(  PID   ligne_bip.codsg%TYPE,
   					LIB   VARCHAR2(50)
				);

   TYPE ligne_listeCurType IS REF CURSOR RETURN ligne_ListeViewType;

   PROCEDURE lister_activites_dpg( 	p_codsg 	IN VARCHAR2,
   					p_userid 	IN VARCHAR2,
   					p_curseur 	IN OUT activites_listeCurType
                             	);

   PROCEDURE lister_ligne_dpg( 	p_codsg 	IN VARCHAR2,
   				p_code_activite IN VARCHAR2,
   				p_userid 	IN VARCHAR2,
   				p_curseur 	IN OUT ligne_listeCurType
                             	);

END pack_liste_activites;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_activites AS
   PROCEDURE lister_activites_dpg( 	p_codsg IN VARCHAR2,
   					p_userid IN VARCHAR2,
   					p_curseur IN OUT activites_listeCurType
                             ) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN


      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_userid)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

	BEGIN
        	OPEN   p_curseur FOR
        	SELECT '',
               ' ' LIB_ACTIVITEß
        	FROM dual
       	     UNION
              	SELECT 	code_activite CODE_ACTIVITEß,
              		code_activite || ' - ' || lib_activite LIB_ACTIVITEß
              	FROM  ree_activites
              	WHERE codsg = TO_NUMBER(p_codsg) and type = 'N'
              	order by 2;

      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
       END;
        END IF;
     END IF;


  END lister_activites_dpg;

  PROCEDURE lister_ligne_dpg( 	p_codsg 	IN VARCHAR2,
   				p_code_activite IN VARCHAR2,
   				p_userid 	IN VARCHAR2,
   				p_curseur 	IN OUT ligne_listeCurType
                             ) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_userid)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

	BEGIN
        	OPEN   p_curseur FOR
              	SELECT 	pid PID,
			pid || ' - ' || pnom LIB
		FROM  ligne_bip lb, datdebex d
		where lb.CODSG = p_codsg
		and   lb.TYPPROJ <> '7'
		and   ( lb.adatestatut is null or lb.adatestatut>= d.datdebex )
		and not exists ( SELECT ralb.pid
				 FROM ree_activites_ligne_bip ralb
				 WHERE ralb.CODSG = p_codsg
				 AND   ralb.pid = lb.pid )
		ORDER BY pid	 ;


      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
       END;
        END IF;
     END IF;


  END lister_ligne_dpg;

END pack_liste_activites;
/
CREATE OR REPLACE PACKAGE pack_liste_actualites AS

   TYPE actualites_ListeViewType IS RECORD(  CODE_ACTU   actualite.code_actu%TYPE,
  		TITRE       actualite.titre%TYPE,
  		DATE_AFFICHE  VARCHAR2(20),
  		DATE_DEBUT    VARCHAR2(20),
  		DATE_FIN      VARCHAR2(20),
  		VALIDE        CHAR(3),
  		DERNIERE_MINUTE CHAR(3)
					                                          );
 TYPE accueil_actu_ListeViewType IS RECORD(  CODE_ACTU   actualite.code_actu%TYPE,
  		TITRE       actualite.titre%TYPE,
  		TEXTE       actualite.texte%TYPE,
  		DATE_AFFICHE  VARCHAR2(20),
  		URL         actualite.url%TYPE,
  		DATE_TRI    actualite.date_affiche%TYPE

					                                          );

   TYPE actualites_listeCurType IS REF CURSOR RETURN actualites_ListeViewType;
   TYPE accueil_actu_listeCurType IS REF CURSOR RETURN accueil_actu_ListeViewType;

   PROCEDURE lister_actualites( p_userid IN VARCHAR2,
   				p_curseur IN OUT actualites_listeCurType
                             );


   PROCEDURE lister_actualites_accueil( p_profils IN VARCHAR2,
   					p_derniere_minute IN VARCHAR2,
   					p_userid IN VARCHAR2,
   					p_curseur IN OUT accueil_actu_listeCurType
                             );

END pack_liste_actualites;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_actualites AS
PROCEDURE lister_actualites(   p_userid IN VARCHAR2,
				p_curseur IN OUT actualites_listeCurType

                             ) IS



      	l_msg	VARCHAR2(1024);
 	l_code_actu number(5);
   	l_actu_rowcount BINARY_INTEGER;




      	BEGIN
      	BEGIN

             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 	CODE_ACTU,
  		TITRE       ,
  		to_char(DATE_AFFICHE,'DD/MM/YYYY') as  DATE_AFFICHE,
  		to_char(DATE_DEBUT,'DD/MM/YYYY') as  DATE_DEBUT,
  		to_char(DATE_FIN,'DD/MM/YYYY') as DATE_FIN,
  		decode(VALIDE,'O','Oui','Non')  as VALIDE,
  		decode(DERNIERE_MINUTE,'O','Oui','Non')  as DERNIERE_MINUTE

             FROM   actualite

             ORDER BY CODE_ACTU desc;

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
           --a modifier
               pack_global.recuperer_message( 20366 , '%s1', 'La liste est vide', '', l_msg);
               raise_application_error(-20366 , l_msg);

           WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);
	END;

	BEGIN

	l_actu_rowcount :=0;
	select count(*) into l_actu_rowcount
	from actualite;

	if l_actu_rowcount = 0 then

	pack_global.recuperer_message( 20366 , '%s1', 'La liste est vide', '', l_msg);

        raise_application_error(-20366 , l_msg);
        end if;
	END;
  	END lister_actualites;

PROCEDURE lister_actualites_accueil( p_profils IN VARCHAR2,
					p_derniere_minute IN VARCHAR2,
   					p_userid IN VARCHAR2,
   					p_curseur IN OUT accueil_actu_listeCurType
                             ) IS



      	l_msg	VARCHAR2(1024);
 	l_code_actu number(5);
 	l_valide CHAR(1):='O';
      	BEGIN
      	BEGIN

             -- On récupère les lignes correspondante

	     OPEN p_curseur FOR
	     SELECT DISTINCT	decode (NOM_FICHIER, '', 0, a.CODE_ACTU)  as CODE_ACTU   ,
  				TITRE       ,
  				TEXTE       ,
  				to_char(DATE_AFFICHE,'DD/MM/YYYY') as DATE_AFFICHE,
  				decode(URL, NULL,' ',URL) as URL,
  				date_affiche as DATE_TRI
             FROM   	actualite	   a,
             		lien_profil_actu    l
             WHERE 	a.code_actu= l.code_actu
			AND ( (INSTR( upper(p_profils), upper(l.CODE_PROFIL))>0)
				  OR (upper(l.CODE_PROFIL)='POURTOUS') )
			AND derniere_minute = p_derniere_minute
			AND VALIDE = l_valide
			AND sysdate between DATE_DEBUT and DATE_FIN


             ORDER BY DATE_TRI desc;

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
           --a modifier
               pack_global.recuperer_message( 20366 , '%s1', 'La liste est vide', '', l_msg);
               raise_application_error(-20366 , l_msg);

           WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);
	END;

  	END lister_actualites_accueil;
END pack_liste_actualites;
/
CREATE OR REPLACE PACKAGE pack_liste_agence AS

   TYPE Agence_ListeViewType IS RECORD( id      agence.socfour%TYPE,
					libelle CHAR(40)
                                      );

   TYPE agence_listeCurType IS REF CURSOR RETURN Agence_ListeViewType;

   PROCEDURE lister_agence( p_soccode   IN agence.soccode%TYPE,
                            p_curseur   IN OUT agence_listeCurType
                          );

END pack_liste_agence;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_agence AS

   PROCEDURE lister_agence ( p_soccode IN agence.soccode%TYPE,
			     p_curseur IN OUT agence_listeCurType
                           ) IS
   BEGIN

      OPEN p_curseur FOR
	SELECT socfour,
	       rpad( socfour, 15, ' ')  ||
		 rpad( socflib, 25, ' ')
	FROM 	 agence
	WHERE  soccode = p_soccode;

   END lister_agence;

END pack_liste_agence;
/
CREATE OR REPLACE PACKAGE     pack_liste_appli AS

TYPE lib_ListeViewType IS RECORD(    	AIRT	CHAR(5),
					LIB	VARCHAR2(60)
                                         );

   TYPE lib_listeCurType IS REF CURSOR RETURN lib_ListeViewType;


   -- Liste des applis pour le menu référentiel
   PROCEDURE lister_appli_ref(	p_userid   IN 	  VARCHAR2,
             	       		p_curseur  IN OUT lib_listeCurType
            );

END pack_liste_appli;
/

CREATE OR REPLACE PACKAGE BODY     pack_liste_appli AS

-- Liste des applis pour le menu référentiel
PROCEDURE lister_appli_ref(	p_userid   IN 	  VARCHAR2,
             	       		p_curseur  IN OUT lib_listeCurType) IS
l_doss_proj 	VARCHAR2(255);
l_projet	VARCHAR2(255);
l_appli		VARCHAR2(255);
BEGIN
   l_doss_proj := pack_global.lire_doss_proj(p_userid);
   l_projet    := pack_global.lire_projet(p_userid);
   l_appli    := pack_global.lire_appli(p_userid);

   IF (l_appli IS NULL) AND (l_projet IS NULL) AND (l_doss_proj IS NULL) THEN
   	OPEN p_curseur FOR
        	-- Ligne vide
        	SELECT '' CODE,
        	       '' LIB
        	FROM DUAL;

   ELSIF (INSTR(UPPER(l_doss_proj), 'TOUS') > 0) OR (INSTR(UPPER(l_projet), 'TOUS') > 0) OR (INSTR(UPPER(l_appli), 'TOUS') > 0) THEN

	OPEN p_curseur FOR
  	    -- La première ligne est "Toutes"
  	    SELECT 	' TOUS' airt,
  	    		'Toutes' LIB
  	    FROM dual
  	    -- La seconde liste est la liste des projets actifs
  	    UNION
	    SELECT  	a.airt,
	    	     	a.airt ||' - ' ||ltrim(rtrim(a.alibel)) LIB
	    FROM application a, ligne_bip lb, datdebex d
	    WHERE a.airt = lb.airt
	      AND ((lb.adatestatut IS NULL) OR (lb.adatestatut >= d.datdebex))
	    ORDER BY airt;
   ELSE
	OPEN p_curseur FOR
  	    -- La première ligne est "Tous"
  	    SELECT 	' TOUS' airt,
  	    		'Toutes' LIB
  	    FROM dual
  	    -- La seconde liste est la liste des applications de l'habilitation
  	    UNION
	    SELECT  	a.airt,
	    	     	a.airt ||' - ' ||ltrim(rtrim(a.alibel)) LIB
	    FROM application a, ligne_bip lb, datdebex d
	    WHERE a.airt = lb.airt
	      AND ((lb.adatestatut IS NULL) OR (lb.adatestatut >= d.datdebex))
	      AND INSTR(l_appli, a.airt) > 0
  	    -- La troisième liste est la liste des applications liées aux projets de l'habilitation
  	    UNION
	    SELECT  	a.airt,
	    	     	a.airt ||' - ' ||ltrim(rtrim(a.alibel)) LIB
	    FROM application a, ligne_bip lb, proj_info pi, datdebex d
	    WHERE a.airt = lb.airt
	      AND lb.icpi = pi.icpi
	      AND ((lb.adatestatut IS NULL) OR (lb.adatestatut >= d.datdebex))
	      AND INSTR(l_projet, pi.icpi) > 0
	    -- La quatrieme liste est la liste des applications rattachés au dossiers_projets de l'habilitation
	    UNION
	    SELECT  	a.airt,
	    	     	a.airt ||' - ' ||ltrim(rtrim(a.alibel)) LIB
	    FROM application a, ligne_bip lb, datdebex d
	    WHERE a.airt = lb.airt
	      AND ((lb.adatestatut IS NULL) OR (lb.adatestatut >= d.datdebex))
	      AND INSTR(l_doss_proj, TO_CHAR(lb.dpcode, 'FM00000')) > 0
	    ORDER BY airt;
   END IF;
EXCEPTION
	WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);
END lister_appli_ref;

END pack_liste_appli;
/
CREATE OR REPLACE PACKAGE pack_liste_bjh_anomalies AS

TYPE anomalies_p_RecType IS RECORD (cle    VARCHAR2(8),
                                    lib    VARCHAR2(150));

   TYPE anomalies_p_CurType IS REF CURSOR RETURN anomalies_p_RecType;

   PROCEDURE lister_bjh_anomalies(  p_matricule IN CHAR,
				    p_ident 	IN CHAR,
                                    p_userid  	IN VARCHAR2,
                                    p_curseur 	IN OUT anomalies_p_CurType
                                   );

END pack_liste_bjh_anomalies;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_bjh_anomalies AS
----------------------------------- SELECT -----------------------------------
   PROCEDURE lister_bjh_anomalies ( p_matricule IN CHAR,
				    p_ident 	IN CHAR,
	                            p_userid    IN VARCHAR2,
                                    p_curseur   IN OUT anomalies_p_CurType
                                 ) IS
   BEGIN
	IF p_matricule is not null THEN
        OPEN p_curseur FOR
     		SELECT
            	LPAD(NVL(TO_CHAR(mois,'FM00'), '  '),2,' ')||LPAD(NVL(typeabsence, '      '),6,' '),
	     		LPAD(NVL(TO_CHAR(mois,'FM00'), '  '),2,' ')	||'     '||
	     		LPAD(NVL(typeabsence, '      '),6,' ')		||'     '||
	     		LPAD(NVL(TO_CHAR(coutbip, 'FM990.0'),'     '),5,' ')		||'     '||
            	LPAD(NVL(TO_CHAR(coutgip, 'FM990.0'),'     '),5,' ')		||'     '||
            	LPAD(NVL(TO_CHAR(coutbip-coutgip, 'FM990.0'),'     '),5,' ')	||'     '||
            	DECODE(validation1 , null,'non','oui')
      	FROM bjh_anomalies
      	WHERE matricule = SUBSTR(p_matricule,1,7)
      	ORDER BY mois,typeabsence DESC;
	ELSE
	  OPEN p_curseur FOR
     		SELECT
            	LPAD(NVL(TO_CHAR(mois,'FM00'), '  '),2,' ')||LPAD(NVL(typeabsence, '      '),6,' '),
	     		LPAD(NVL(TO_CHAR(mois,'FM00'), '  '),2,' ')	||'     '||
	     		LPAD(NVL(typeabsence, '      '),6,' ')		||'     '||
	     		LPAD(NVL(TO_CHAR(coutbip, 'FM990.0'),'     '),5,' ')		||'     '||
            	LPAD(NVL(TO_CHAR(coutgip, 'FM990.0'),'     '),5,' ')		||'     '||
            	LPAD(NVL(TO_CHAR(coutbip-coutgip, 'FM990.0'),'     '),5,' ')	||'     '||
            	DECODE(validation1 , null,'non','oui')
      	FROM bjh_anomalies a,(select distinct matricule, ident from bjh_ressource) e
      	WHERE a.matricule = e.matricule
		AND e.ident=to_number(p_ident)
      	ORDER BY mois,typeabsence DESC;
	END IF;


   END lister_bjh_anomalies;

END pack_liste_bjh_anomalies;
/
CREATE OR REPLACE PACKAGE pack_liste_bjh_matricule AS

TYPE matricule_p_RecType IS RECORD (cle    VARCHAR2(8),
                                    lib    VARCHAR2(150));

   TYPE matricule_p_CurType IS REF CURSOR RETURN matricule_p_RecType;

   PROCEDURE lister_bjh_matricule(     p_codsg   IN VARCHAR2,
                                       p_userid  IN VARCHAR2,
                                       p_curseur IN OUT matricule_p_CurType
                                      );




END pack_liste_bjh_matricule;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_bjh_matricule AS

----------------------------------- SELECT -----------------------------------
   PROCEDURE lister_bjh_matricule (p_codsg   IN VARCHAR2,
	                           p_userid  IN VARCHAR2,
                                   p_curseur IN OUT matricule_p_CurType
                                       ) IS

   l_codsg varchar2(7);

   BEGIN
	if substr(LPAD(p_codsg,7,'0'),4,2)='**' then
		l_codsg := substr(LPAD(p_codsg,7,'0'),1,3)||'%';
	else
		if substr(LPAD(p_codsg,7,'0'),6,2)='**' then
			l_codsg := substr(LPAD(p_codsg,7,'0'),1,5)||'%';
		else
			l_codsg := LPAD(p_codsg,7,'0');
		end if;

	end if;


      OPEN p_curseur FOR
      SELECT DISTINCT
            a.matricule,
		RPAD(SUBSTR(r.nom,1,23),23,' ')||' '||
	        RPAD(SUBSTR(r.prenom,1,20),20,' ')||' '||
		LPAD(r.ident,5,' ')||' '||
		RPAD(SUBSTR(a.matricule,1,7),7,' ')
      FROM bjh_anomalies a, bjh_ressource r
      WHERE a.matricule = r.matricule
      AND to_char(r.codsg, 'FM0000000') like l_codsg
      ORDER BY RPAD(SUBSTR(r.nom,1,23),23,' ')||' '||RPAD(SUBSTR(r.prenom,1,20),20,' ')||' '||LPAD(r.ident,5,' ')||' '||RPAD(SUBSTR(a.matricule,1,7),7,' ');


   END lister_bjh_matricule;

END pack_liste_bjh_matricule;
/
CREATE OR REPLACE PACKAGE Pack_Liste_Branche AS

TYPE branche_Type IS RECORD (codbr		NUMBER(2),
                  	     libbr 		VARCHAR2(30)
				);

      TYPE brancheCurType IS REF CURSOR RETURN branche_Type;

PROCEDURE lister_branche (p_userid     IN VARCHAR2,
                          p_curbranche IN OUT brancheCurType,
			  p_nbcurseur  OUT INTEGER,
                          p_message    OUT VARCHAR2
                       );


TYPE direction_Type IS RECORD (coddir		NUMBER(2),
                  	       		  						  	 			   libdir 		VARCHAR2(30)
																		  );

      TYPE directionCurType IS REF CURSOR RETURN direction_Type;

PROCEDURE lister_direction (p_userid                 IN VARCHAR2,
                         			   	  		   		   p_curdirection        IN OUT directionCurType
			  											   );


END Pack_Liste_Branche;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Branche AS

PROCEDURE lister_branche (p_userid     IN VARCHAR2,
                          p_curbranche IN OUT brancheCurType,
			  p_nbcurseur  OUT INTEGER,
                          p_message    OUT VARCHAR2
                      ) IS

     l_msg VARCHAR(1024);

   BEGIN

      BEGIN
         OPEN p_curbranche FOR
		SELECT
			codbr,
			libbr
		FROM BRANCHES
		;

      EXCEPTION
         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM );
      END;

   END lister_branche;


PROCEDURE lister_direction (p_userid                 IN VARCHAR2,
                         			   	  		   		   p_curdirection        IN OUT directionCurType
			  											   ) IS

    l_msg VARCHAR(1024);

   BEGIN

      BEGIN
         OPEN p_curdirection FOR
		 SELECT '',
		                    ' ' libdir
		 FROM 		DIRECTIONS
		 UNION
        SELECT
			TO_CHAR(coddir),
			 libdir
		FROM DIRECTIONS
		ORDER BY libdir;


      EXCEPTION
         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM );
      END;

   END lister_direction;



END Pack_Liste_Branche;
/
CREATE OR REPLACE PACKAGE pack_liste_ca_ligne_bip AS
   TYPE CA_ListeViewType IS RECORD	 (pid        repartition_ligne.pid%TYPE,
					  datdeb     VARCHAR2(7),
                                          datfin     VARCHAR2(7),
                                          codcamo    VARCHAR2(6),
                                          libcamo    centre_activite.clibrca%TYPE,
                                          clicode    repartition_ligne.clicode%TYPE,
                                          cliclib    client_mo.clilib%TYPE,
                                          tauxrep    VARCHAR2(8)
                                         );
   TYPE CA_listeCurType IS REF CURSOR RETURN CA_ListeViewType;

   PROCEDURE lister_ca_ligne (p_pid     IN repartition_ligne.pid%TYPE,
                              p_userid  IN VARCHAR2,
                              p_curseur IN OUT CA_listeCurType
                             );

   TYPE CA_util_ListeViewType IS RECORD	 (codcamo    VARCHAR2(6),
                                          lib    VARCHAR2(40)
                                         );
   TYPE CA_util_listeCurType IS REF CURSOR RETURN CA_util_ListeViewType;

   PROCEDURE lister_ca_utilisateur ( p_userid  IN VARCHAR2,
               			p_curseur IN OUT CA_util_listeCurType
              );

   PROCEDURE lister_ca_niv0_utilisateur ( p_userid  IN VARCHAR2,
               			p_curseur IN OUT CA_util_listeCurType
              );

END pack_liste_ca_ligne_bip;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_ca_ligne_bip AS
   PROCEDURE lister_ca_ligne( p_pid     IN repartition_ligne.pid%TYPE,
                              p_userid  IN VARCHAR2,
                              p_curseur IN OUT CA_listeCurType
                             ) IS
   BEGIN
       OPEN p_curseur FOR
             SELECT 	RTRIM(LTRIM(pid)) 		,
             		TO_CHAR(datdeb, 'MM/YYYY') 	,
             		TO_CHAR(datfin, 'MM/YYYY') 	,
             		TO_CHAR(rl.codcamo)		,
             		ca.clibrca			,
             		rl.clicode			,
             		cm.clilib			,
             		TO_CHAR(tauxrep, 'FM99999D00')
             FROM     repartition_ligne rl , centre_activite ca, client_mo cm
             WHERE    pid = p_pid
               AND    rl.codcamo = ca.codcamo
               AND    rl.clicode = cm.clicode (+)
	     ORDER BY datdeb desc, tauxrep;

   END lister_ca_ligne;

--
-- Liste les CA qui ont été déclarés dans le RTFE pour un utilisateur
-- ( On utilise entite_structure pour retrouver le libelle )
-- Utilisé dans les habilitations par référentiels
--
   PROCEDURE lister_ca_utilisateur ( p_userid  IN VARCHAR2,
               			p_curseur IN OUT CA_util_listeCurType
              ) IS

   l_ca_payeur VARCHAR2(255);

   BEGIN
      l_ca_payeur := pack_global.lire_globaldata(p_userid).ca_payeur;

      BEGIN

      -- Cas particulier si on a TOUS dans la liste des ca Payeurs , dans ce cas
      -- On affiche tous les CA rattachés aux clients

      if trim(upper(l_ca_payeur)) = 'TOUS' THEN

         OPEN  p_curseur FOR
         SELECT distinct e.codcamo,
         	to_char(e.codcamo)||' - '||nvl(e.liloes,'') lib
         FROM entite_structure e, client_mo c
         WHERE e.codcamo=c.codcamo
         AND c.codcamo is not null
	 ORDER BY 1;

       else
         OPEN  p_curseur FOR
	   SELECT distinct e.codcamo,
          	to_char(e.codcamo)||' - '||nvl(e.liloes,'') lib
           FROM entite_structure e, client_mo c
           WHERE e.codcamo=c.codcamo
           AND c.codcamo is not null
	   AND c.clicode IN (
	          SELECT clicoderatt FROM vue_clicode_hierarchie v, client_mo cl
	          WHERE v.clicode = cl.clicode
	          AND (INSTR(l_ca_payeur, cl.codcamo) > 0 )  )
	  ORDER BY 1;

       end if;

      EXCEPTION

          WHEN OTHERS THEN
             raise_application_error(-20997, SQLERRM);
      END;

   END lister_ca_utilisateur;

--
-- Liste les CA de niveau 0 qui ont été déclarés dans le RTFE pour un utilisateur
-- ( On utilise entite_structure pour retrouver le libelle )
-- Utilisé dans les habilitations par référentiels
--
   PROCEDURE lister_ca_niv0_utilisateur ( p_userid  IN VARCHAR2,
               			p_curseur IN OUT CA_util_listeCurType
              ) IS

   l_ca_payeur VARCHAR2(255);

   BEGIN
      l_ca_payeur := pack_global.lire_globaldata(p_userid).ca_payeur;

      BEGIN

      -- Cas particulier si on a TOUS dans la liste des ca Payeurs , dans ce cas
      -- On affiche tous les CA rattachés aux clients

      if trim(upper(l_ca_payeur)) = 'TOUS' THEN

         OPEN  p_curseur FOR
         SELECT distinct c.codcamo,
         	to_char(c.codcamo)||' - '||nvl(c.clibrca,'') lib
         FROM centre_activite c
         WHERE c.cdateferm is null
	 ORDER BY 1;

       else
         OPEN  p_curseur FOR
         SELECT distinct c.codcamo,
         	to_char(c.codcamo)||' - '||nvl(c.clibrca,'') lib
         FROM centre_activite c
         WHERE c.cdateferm is null
         AND ( (INSTR(l_ca_payeur, codcamo) > 0)
            OR (INSTR(l_ca_payeur, caniv1) > 0)
            OR (INSTR(l_ca_payeur, caniv2) > 0)
            OR (INSTR(l_ca_payeur, caniv3) > 0)
            OR (INSTR(l_ca_payeur, caniv4) > 0) )
	 ORDER BY 1;
       end if;

      EXCEPTION

          WHEN OTHERS THEN
             raise_application_error(-20997, SQLERRM);
      END;

   END lister_ca_niv0_utilisateur;

END pack_liste_ca_ligne_bip;
/
CREATE OR REPLACE PACKAGE Pack_Liste_Cfrais AS


  TYPE RefCurTyp IS REF CURSOR;



   PROCEDURE lister_cfrais(p_userid  IN VARCHAR2,
             		   p_curseur IN OUT Pack_Liste_Dynamique.liste_dyn
            );



   -- ------------------------------------------------------------------------
   --  BAA Le 24/06/2005
   -- Nom        : lister_centres_frais
   -- Auteur     : BAA
   -- Decription : cette methode
   -- Paramètres : p_centres_frais (IN)  contien la liste des codes des centres
   --              de frais separé par ,
   --              curseur (out)l  a date en cours
   --
   -- ------------------------------------------------------------------------



   PROCEDURE lister_centres_frais(p_centres_frais  IN VARCHAR2,
             		              p_curseur IN OUT RefCurTyp
                                 );



END Pack_Liste_Cfrais;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Cfrais AS

PROCEDURE lister_cfrais(p_userid  IN VARCHAR2,
	                p_curseur IN OUT Pack_Liste_Dynamique.liste_dyn
            ) IS

BEGIN
      OPEN p_curseur FOR
	SELECT ' '  AS codcfrais,
	       ' '
	FROM dual
	UNION
	SELECT
           TO_CHAR(codcfrais) AS codcfrais,
           RPAD(TO_CHAR(codcfrais),3,' ')||' '||libcfrais
	  FROM CENTRE_FRAIS
ORDER BY 1;

   EXCEPTION
       WHEN OTHERS THEN
          RAISE_APPLICATION_ERROR(-20997, SQLERRM);

   END lister_cfrais;


  PROCEDURE lister_centres_frais(p_centres_frais  IN VARCHAR2,
             		              p_curseur IN OUT RefCurTyp
                                 ) IS


   str_query VARCHAR2(255);
   req                            VARCHAR2(800);


  BEGIN


		  req := ' SELECT TO_CHAR(CODCFRAIS) AS CODCFRAIS, '
		  || ' TO_CHAR(CODCFRAIS)||'' - ''||LIBCFRAIS AS LIBCFRAIS '
		  || ' FROM CENTRE_FRAIS '
		  || ' WHERE CODCFRAIS in ('|| p_centres_frais ||')  ' ;



        OPEN p_curseur FOR   req;




   EXCEPTION
       WHEN OTHERS THEN
          RAISE_APPLICATION_ERROR(-20997, SQLERRM);

   END lister_centres_frais;


END Pack_Liste_Cfrais;
/
CREATE OR REPLACE PACKAGE pack_liste_cfrais_compo AS


   PROCEDURE lister_cfrais_compo(p_codcfrais 	IN VARCHAR2,
				 p_userid 	IN VARCHAR2,
             			 p_curseur 	IN OUT pack_liste_dynamique.liste_dyn
          );

END pack_liste_cfrais_compo;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_cfrais_compo AS

PROCEDURE lister_cfrais_compo(	p_codcfrais 	IN VARCHAR2,
				p_userid 	IN VARCHAR2,
             			p_curseur 	IN OUT pack_liste_dynamique.liste_dyn
           ) IS

BEGIN

      OPEN p_curseur FOR
	select 	codbddpg||decode(topfer,'F','F','O') as DPG,
	       	NVL(substr(codbddpg,1,2),'  ')||' '||NVL(substr(codbddpg,3,2),'  ')||' '||NVL(substr(codbddpg,5,7),'      ') ||'  '||
		NVL(RPAD(libbddpg,28,' '),'                      ') ||'  '||
		NVL(RPAD(decode(codhabili,'br',	 'Branche'
					 ,'dir', 'Direction'
					 ,'dpt', 'Département'
					 ,'pole','Pôle',
					 'Groupe'),11,' '),'             ')||'  '||
		NVL(decode(topfer,'F','F','O'),' ')
	from compo_centre_frais
	where codcfrais=to_number(p_codcfrais)
	order by codhabili;


   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_cfrais_compo;
END pack_liste_cfrais_compo;
/
CREATE OR REPLACE PACKAGE pack_liste_code_statut AS

   PROCEDURE lister_statuts_ligne_bip(p_userid IN VARCHAR2,
             			p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

   PROCEDURE lister_statuts_projet(p_userid IN VARCHAR2,
             			p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

END pack_liste_code_statut;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_code_statut AS

----------------------------------- SELECT -----------------------------------
   PROCEDURE lister_statuts_ligne_bip (p_userid  IN VARCHAR2,
               			 p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   BEGIN

      OPEN p_curseur FOR

      -- Sélection des intitulés
      SELECT
           astatut,
           libstatut
      FROM code_statut
      UNION
      -- Permet d'afficher le vide
      SELECT '', 'Pas de statut'
      FROM DUAL;


   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_statuts_ligne_bip;



   PROCEDURE lister_statuts_projet (p_userid  IN VARCHAR2,
               			 p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   BEGIN

      OPEN p_curseur FOR
      SELECT
           astatut,
           libstatut
      FROM code_statut
      WHERE astatut IN ('O','A','D','N','Q','R')
      UNION
      -- Permet d'afficher le vide
      SELECT '', 'Pas de statut'
      FROM DUAL;

   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_statuts_projet;

END pack_liste_code_statut;
/
CREATE OR REPLACE PACKAGE pack_liste_contrats AS

   TYPE contrats_p_RecType IS RECORD (clelc    VARCHAR2(37),
                                      liste    VARCHAR2(57));

   TYPE contrats_p_CurType IS REF CURSOR RETURN contrats_p_RecType;

   PROCEDURE lister_contrats (p_socfact IN facture.socfact%TYPE,
                              p_typfact IN facture.typfact%TYPE,
                              p_datfact IN VARCHAR2,
                              p_numfact IN facture.numfact%TYPE,
                              p_soccont IN contrat.soccont%TYPE,
                              p_cav     IN contrat.cav%TYPE,
                              p_numcont IN contrat.numcont%TYPE,
                              p_rnom    IN ressource.rnom%TYPE,
                              p_userid  IN VARCHAR2,
                              p_curseur IN OUT contrats_p_CurType
                             );

   PROCEDURE xcle_contrat    (c_clelc       IN VARCHAR2,  -- cle lister contrat ou cont hist
                              c_flaglib     IN NUMBER,    -- flag retourner valeur avec libellé ou non
                              c_numcont        OUT VARCHAR2,
                              c_cav            OUT VARCHAR2,
                              c_comcode        OUT VARCHAR2,
                              c_codsg          OUT VARCHAR2
                             );


END pack_liste_contrats;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_contrats AS

    PROCEDURE lister_contrats (p_socfact IN facture.socfact%TYPE,
                               p_typfact IN facture.typfact%TYPE,
                               p_datfact IN VARCHAR2,
                               p_numfact IN facture.numfact%TYPE,
                               p_soccont IN contrat.soccont%TYPE,
                               p_cav     IN contrat.cav%TYPE,
                               p_numcont IN contrat.numcont%TYPE,
                               p_rnom    IN ressource.rnom%TYPE,
                               p_userid  IN VARCHAR2,
                               p_curseur IN OUT contrats_p_CurType
                             ) IS

    l_like_numcont  varchar2(16);
    l_like_rnom     varchar2(31);
    l_filcode       contrat.filcode%TYPE;
    l_centre_frais  centre_frais.codcfrais%TYPE;
    p_where 	    varchar2(50);
    BEGIN

        -- ========================================================================
        -- On recupere le code filiale et on prepare numcont et rnom en template
        -- ========================================================================
        l_filcode      := pack_global.lire_globaldata(p_userid).filcode;
        l_like_numcont := RTRIM(p_numcont) || '%' ;
        l_like_rnom    := RTRIM(p_rnom) || '%' ;

	-- ===================================================================
	-- On récupère le centre de frais de l'utilisateur
	-- ==================================================================
	l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

	-- =============================================================
        -- La largeur de la liste_contrats est limité à 57 caractères
        -- cle = numcont(15)+cav(2)+comcode(11)+codsg(6)=34+3';'=37
        -- =============================================================

    IF l_centre_frais=0 then    -- le centre de frais 0 donne tous les droits à l'utilisateur

         OPEN p_curseur FOR

        SELECT  (RTRIM(c.numcont) || ';' || RTRIM(c.cav) || ';' || RTRIM(c.comcode) ||
          ';' || c.codsg)  as Clelc,
            RPAD(c.numcont,15) ||
            ' '  || RPAD(c.cav,2) ||
            ' '  || TO_CHAR(r.ident,'99999') ||
            ' '  || RPAD(r.rnom,5) ||
            ' '  || NVL(TO_CHAR(lc.lresdeb,'ddmmyyyy'),'        ') ||
            ' '  || NVL(TO_CHAR(lc.lresfin,'ddmmyyyy'),'        ') ||
            ' '  || LPAD(TO_CHAR(TRUNC(lc.lccouact),'FM99999'),5)   as Liste_contrats
        FROM  ligne_cont lc, contrat c , ressource r
        WHERE   r.ident = lc.ident
            AND lc.soccont =  c.soccont
            AND lc.cav     =  c.cav
            AND lc.numcont =  c.numcont
            AND c.soccont  =  p_socfact
            AND c.filcode  =  l_filcode
            AND c.numcont like l_like_numcont
            AND r.rnom    like l_like_rnom
        ORDER BY Clelc;
    ELSE       -- seuls les contrats appartenant au centre de frais sont sélectionnés
	OPEN p_curseur FOR

        SELECT  (RTRIM(c.numcont) || ';' || RTRIM(c.cav) || ';' || RTRIM(c.comcode) ||
          ';' || c.codsg)  as Clelc,
            RPAD(c.numcont,15) ||
            ' '  || RPAD(c.cav,2) ||
            ' '  || TO_CHAR(r.ident,'99999') ||
            ' '  || RPAD(r.rnom,5) ||
            ' '  || NVL(TO_CHAR(lc.lresdeb,'ddmmyyyy'),'        ') ||
            ' '  || NVL(TO_CHAR(lc.lresfin,'ddmmyyyy'),'        ') ||
            ' '  || LPAD(TO_CHAR(TRUNC(lc.lccouact),'FM99999'),5)   as Liste_contrats
        FROM  ligne_cont lc, contrat c , ressource r
        WHERE   r.ident = lc.ident
            AND lc.soccont =  c.soccont
            AND lc.cav     =  c.cav
            AND lc.numcont =  c.numcont
            AND c.soccont  =  p_socfact
            AND c.filcode  =  l_filcode
            AND c.numcont like l_like_numcont
            AND r.rnom    like l_like_rnom
	    AND c.ccentrefrais = l_centre_frais
        ORDER BY Clelc;

    END IF;

   END lister_contrats;


-- **************************************************************************************
--    Extraire les infos de la cle Lister contrats ou contrats historisés
-- **************************************************************************************
   PROCEDURE xcle_contrat    (c_clelc       IN VARCHAR2,  -- cle lister contrat ou cont hist
                              c_flaglib     IN NUMBER,    -- flag retourner valeur avec libellé ou non
                              c_numcont        OUT VARCHAR2,
                              c_cav            OUT VARCHAR2,
                              c_comcode        OUT VARCHAR2,
                              c_codsg          OUT VARCHAR2
                             ) IS

      pos1   integer;
      pos2   integer;
      pos3   integer;
      lgth   integer;
   BEGIN
      pos1 := INSTR( c_clelc, ';', 1, 1);
      pos2 := INSTR( c_clelc, ';', 1, 2);
      pos3 := INSTR( c_clelc, ';', 1, 3);
      lgth := LENGTH( c_clelc);

      IF c_flaglib = 1 THEN
         BEGIN
           c_numcont    := 'NUMCONT#' || substr( c_clelc, 1, pos1-1);
           c_cav        := 'CAV#'     || substr( c_clelc, pos1+1, pos2-pos1-1);
           c_comcode    := 'COMCODE#' || substr( c_clelc, pos2+1, pos3-pos2-1);
           c_codsg      := 'CODSG#'   || substr( c_clelc, pos3+1, lgth-pos3);


         END;
      ELSE
         BEGIN
           c_numcont    := substr( c_clelc, 1, pos1-1);
           c_cav        := substr( c_clelc, pos1+1, pos2-pos1-1);
           c_comcode    := substr( c_clelc, pos2+1, pos3-pos2-1);
           c_codsg      := substr( c_clelc, pos3+1, lgth-pos3);
         END;
      END IF;

   END xcle_contrat;

END pack_liste_contrats;
/
CREATE OR REPLACE PACKAGE pack_liste_ContRess AS

  TYPE LigCont_RecType IS RECORD (clelc    VARCHAR2(2),  -- cle ligne contrat
				  liste    VARCHAR2(100)); -- reste de ligne de la liste

  TYPE LigCont_CurType IS REF CURSOR RETURN LigCont_RecType;

PROCEDURE lister_ContRess (p_soccont   IN contrat.soccont%TYPE,
			   p_numcont   IN contrat.numcont%TYPE,
			   p_cav       IN contrat.cav%TYPE,
			   p_userid    IN VARCHAR2,
			   p_curseur   IN OUT LigCont_CurType
			  );
END pack_liste_ContRess;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_ContRess AS

PROCEDURE lister_ContRess(p_soccont   IN contrat.soccont%TYPE,
			  p_numcont   IN contrat.numcont%TYPE,
			  p_cav       IN contrat.cav%TYPE,
			  p_userid    IN VARCHAR2,
			  p_curseur   IN OUT LigCont_CurType
			 ) IS

BEGIN

   -- La largeur de la liste_RessCont est limité à 28 caractères
   -- La clé cachée est l'identifiant

   OPEN p_curseur FOR
     SELECT  TO_CHAR(lc.lcnum,'FM99') as CleR,
       TO_CHAR(r.ident,'99999') ||
       '  '  || substr(RPAD(r.rnom,20), 1, 20) ||
       '  '  || rpad(nvl(r.rprenom,' '),15) ||
       '  '  || lpad(TO_char((lc.lccouact),'FM99999990D00'),11)   as Liste_RessCont
       FROM  ligne_cont lc,
       ressource r
       WHERE r.ident    =  lc.ident
       AND lc.soccont =  p_soccont
       AND lc.cav     =  p_cav
       AND lc.numcont =  RPAD(p_numcont,15)
       ORDER BY lc.lcnum;

END lister_ContRess;

-- Pour Tester sous SQLPlus
-- > set serveroutput on
-- > var cur refcursor

-- > exec pack_liste_ContRess.lister_ContRess('','','SOPR','B980621424','01','S935709;;;;01;',:cur)

END pack_liste_ContRess;
/
CREATE OR REPLACE PACKAGE pack_liste_cont_hist AS

   TYPE contrats_p_RecType IS RECORD (clelc    VARCHAR2(30),
                                      liste    VARCHAR2(57));

   TYPE contrats_p_CurType IS REF CURSOR RETURN contrats_p_RecType;


   PROCEDURE lister_cont_hist (p_socfact IN facture.socfact%TYPE,
                               p_typfact IN facture.typfact%TYPE,
                               p_datfact IN VARCHAR2,
                               p_numfact IN facture.numfact%TYPE,
                               p_soccont IN contrat.soccont%TYPE,
                               p_cav     IN contrat.cav%TYPE,
                               p_numcont IN contrat.numcont%TYPE,
                               p_rnom    IN ressource.rnom%TYPE,
                               p_userid  IN VARCHAR2,
                               p_curseur IN OUT contrats_p_CurType
                             );

-- Pour Procedure xcle_contrat(c_clelc,c_flaglib,c_numcont,c_cav,c_comcode,c_codsg);
--  Voir dans package  pack_liste_contrats.lister_contrats

END pack_liste_cont_hist;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_cont_hist AS


-- **************************************************************************************
--    Liste des contrats historisés
-- **************************************************************************************
    PROCEDURE lister_cont_hist (p_socfact IN facture.socfact%TYPE,
                              	p_typfact IN facture.typfact%TYPE,
                              	p_datfact IN VARCHAR2,
                              	p_numfact IN facture.numfact%TYPE,
                              	p_soccont IN contrat.soccont%TYPE,
                              	p_cav     IN contrat.cav%TYPE,
                              	p_numcont IN contrat.numcont%TYPE,
                              	p_rnom    IN ressource.rnom%TYPE,
                              	p_userid  IN VARCHAR2,
                              	p_curseur IN OUT contrats_p_CurType
                             ) IS

    l_like_numcont  varchar2(16);
    l_like_rnom     varchar2(31);
    l_filcode       contrat.filcode%TYPE;
    l_centre_frais  centre_frais.codcfrais%TYPE;

    BEGIN

        -- ========================================================================
        -- On recupere le code filiale et on prepare numcont et rnom en template
        -- ========================================================================
        l_filcode      := pack_global.lire_globaldata(p_userid).filcode;
        l_like_numcont := RTRIM(p_numcont) || '%' ;
        l_like_rnom    := RTRIM(p_rnom) || '%' ;

--       DBMS_OUTPUT.PUT_LINE('DEBUT ,' || l_like_numcont || ',' || l_like_rnom || ',' || l_filcode );

	-- ===================================================================
	-- On récupère le centre de frais de l'utilisateur
	-- ==================================================================
	l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;


        -- =============================================================
        -- La largeur de la liste_contrats est limité à 57 caractères
        -- cle = numcont(15)+cav(2)+comcode(11)+codsg(6)=34+3';'=37
        -- =============================================================
    IF l_centre_frais=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur

        OPEN p_curseur FOR

        SELECT  (RTRIM(c.numcont) || ';' || RTRIM(c.cav) || ';' || RTRIM(c.comcode) ||
            ';' || TO_CHAR(c.codsg,'FM0000000')) as Clelc,
            RPAD(c.numcont,15) ||
            ' '  || RPAD(c.cav,2) ||
            ' '  || TO_CHAR(r.ident,'99999') ||
            ' '  || RPAD(r.rnom,5) ||
            ' '  || NVL(TO_CHAR(lc.lresdeb,'ddmmyyyy'),'        ') ||
            ' '  || NVL(TO_CHAR(lc.lresfin,'ddmmyyyy'),'        ') ||
            ' '  || LPAD(TO_CHAR(TRUNC(lc.lccouact),'FM99999'),5)   as Liste_contrats
        FROM  histo_ligne_cont lc, histo_contrat c , ressource r
        WHERE   r.ident = lc.ident
            AND lc.soccont =  c.soccont
            AND lc.cav     =  c.cav
            AND lc.numcont =  c.numcont
            AND c.soccont  =  p_socfact
            AND c.filcode  =  l_filcode
            AND c.numcont like l_like_numcont
            AND r.rnom    like l_like_rnom
        ORDER BY Clelc;

    ELSE          -- seuls les contrats appartenant au centre de frais sont sélectionnés

	 OPEN p_curseur FOR

        SELECT  (RTRIM(c.numcont) || ';' || RTRIM(c.cav) || ';' || RTRIM(c.comcode) ||
            ';' || TO_CHAR(c.codsg,'FM0000000')) as Clelc,
            RPAD(c.numcont,15) ||
            ' '  || RPAD(c.cav,2) ||
            ' '  || TO_CHAR(r.ident,'99999') ||
            ' '  || RPAD(r.rnom,5) ||
            ' '  || NVL(TO_CHAR(lc.lresdeb,'ddmmyyyy'),'        ') ||
            ' '  || NVL(TO_CHAR(lc.lresfin,'ddmmyyyy'),'        ') ||
            ' '  || LPAD(TO_CHAR(TRUNC(lc.lccouact),'FM99999'),5)   as Liste_contrats
        FROM  histo_ligne_cont lc, histo_contrat c , ressource r
        WHERE   r.ident = lc.ident
            AND lc.soccont =  c.soccont
            AND lc.cav     =  c.cav
            AND lc.numcont =  c.numcont
            AND c.soccont  =  p_socfact
            AND c.filcode  =  l_filcode
            AND c.numcont like l_like_numcont
            AND r.rnom    like l_like_rnom
            AND c.ccentrefrais=l_centre_frais
        ORDER BY Clelc;



    END IF;
   END lister_cont_hist;


END pack_liste_cont_hist;
/
CREATE OR REPLACE PACKAGE pack_liste_coutstandard AS

	TYPE dpg_std_type is RECORD(
			  	   pcle		varchar2(20),
			  	   pcoutstd	varchar2(200)
					  );

 	TYPE dpg_stdCurType IS REF CURSOR RETURN dpg_std_type;


	PROCEDURE lister_coutstandard (	p_anneestd    IN VARCHAR2,
				     	p_userid      IN VARCHAR2,
                             		p_curdpg_std  IN OUT dpg_stdCurType
				 );
	PROCEDURE lister_coutstandard_sg (	p_anneestd    IN VARCHAR2,
				     	p_userid      IN VARCHAR2,
                             		p_curdpg_std  IN OUT dpg_stdCurType
				 );



END pack_liste_coutstandard;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_coutstandard AS

PROCEDURE lister_coutstandard	(p_anneestd    	IN VARCHAR2,
				 p_userid       IN VARCHAR2,
                         	 p_curdpg_std   IN OUT dpg_stdCurType
				 ) IS

BEGIN
OPEN p_curdpg_std FOR
	select  distinct (TO_CHAR(dpg_bas, 'FM0000000')) as pcle,
                 (
                  '   ' || TO_CHAR(nvl(dpg_bas,0),'FM0000000') ||
                  '               ' || rpad(TO_CHAR(nvl(dpg_haut,0),'FM0000000'),9,' ')
                 ) as pcoutstd
        from cout_std2
        where annee = to_number(p_anneestd)
        order by 2 asc
        ;
END lister_coutstandard;


PROCEDURE lister_coutstandard_sg        (p_anneestd     IN VARCHAR2,
                                 p_userid       IN VARCHAR2,
                                 p_curdpg_std   IN OUT dpg_stdCurType
                                 ) IS
BEGIN
OPEN p_curdpg_std FOR
select  distinct (TO_CHAR(dpg_bas, 'FM0000000')) as pcle,
                 (
                  '   ' || TO_CHAR(nvl(dpg_bas,0),'FM0000000') ||
                  '               ' || rpad(TO_CHAR(nvl(dpg_haut,0),'FM0000000'),9,' ')
                 ) as pcoutstd
        from cout_std_sg
        where annee = to_number(p_anneestd)
        order by 2 asc
        ;
END lister_coutstandard_sg;






END pack_liste_coutstandard;
/
CREATE OR REPLACE PACKAGE pack_liste_departement AS

TYPE departement_ListeViewType IS RECORD( id      client_mo.clicode%TYPE,
			            libelle CHAR(40)
                                        );

TYPE departement_listeCurType IS REF CURSOR RETURN departement_ListeViewType;

PROCEDURE lister_departement(p_curseur IN OUT departement_listeCurType
                                 );

END pack_liste_departement;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_departement AS

   PROCEDURE lister_departement(p_curseur IN OUT departement_listeCurType
                                  ) IS

   BEGIN

      OPEN p_curseur FOR
 	SELECT clicode id,
             clilib libelle
	FROM client_mo
	WHERE CLIPOL = 0
	and CLIDEP <> 0
	order by libelle;

   END lister_departement;

END pack_liste_departement;
/
CREATE OR REPLACE PACKAGE pack_liste_direction AS

   PROCEDURE lister_direction(  p_userid  IN VARCHAR2,
             			p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

END pack_liste_direction;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_direction AS

----------------------------------- SELECT -----------------------------------

   PROCEDURE lister_direction ( p_userid  IN VARCHAR2,
               			p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   l_perimo VARCHAR2(255);

   BEGIN
      l_perimo := pack_global.lire_globaldata(p_userid).perimo;

      BEGIN
         OPEN  p_curseur FOR
         SELECT DISTINCT LPAD(RTRIM(LTRIM(c.clicode)), 5, '0') AS clicode,
         	c.clicode||' - '||nvl(c.clisigle,'')
         FROM client_mo c, vue_clicode_perimo cpmo
         WHERE c.clicode = cpmo.clicode
           AND (INSTR(l_perimo, cpmo.bdclicode) > 0)
           AND c.clitopf='O'
	 ORDER BY 1;



      EXCEPTION

          WHEN OTHERS THEN
             raise_application_error(-20997, SQLERRM);
      END;

   END lister_direction;

END pack_liste_direction;
/
CREATE OR REPLACE PACKAGE pack_liste_direction_mo AS

TYPE dirmo_ListeViewType IS RECORD( id      client_mo.clicode%TYPE,
			            libelle CHAR(40)
                                        );

TYPE dirmo_listeCurType IS REF CURSOR RETURN dirmo_ListeViewType;

PROCEDURE lister_direction_mo(p_userid  IN VARCHAR2,
                              p_curseur IN OUT dirmo_listeCurType
                                 );

END pack_liste_direction_mo;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_direction_mo AS

   PROCEDURE lister_direction_mo(p_userid   IN VARCHAR2,
                                  p_curseur IN OUT dirmo_listeCurType
                                  ) IS
l_perimo VARCHAR2(255);

   BEGIN
l_perimo := pack_global.lire_globaldata(p_userid).perimo;

      OPEN p_curseur FOR
 	SELECT clicode,
             rpad( clicode, 10, ' ') ||
             clilib
	FROM client_mo
	WHERE clicode IN (SELECT clicode
				FROM vue_clicode_perimo
				WHERE INSTR(l_perimo, bdclicode)>0)
	ORDER BY 1;

   END lister_direction_mo;

END pack_liste_direction_mo;
/
CREATE OR REPLACE PACKAGE pack_liste_dirme AS

   PROCEDURE lister_dirme(p_userid  IN VARCHAR2,
            		  p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

 PROCEDURE lister_dirme_notif(p_test IN VARCHAR2,
 				p_userid  IN VARCHAR2,
            		  	p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );


-- -----------------------------------------------------------------
-- Liste les directions ME suivant le périmètre de l'utilisateur
-- -----------------------------------------------------------------
    PROCEDURE lister_dirme_perimetre( p_userid  IN VARCHAR2,
            		  				  p_curseur IN OUT pack_liste_dynamique.liste_dyn
            			  			);
END pack_liste_dirme;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_dirme AS

----------------------------------- SELECT -----------------------------------

   PROCEDURE lister_dirme (p_userid  IN  VARCHAR2,
               		   p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   BEGIN

      OPEN p_curseur FOR SELECT
           coddir,
           coddir||' - '||libbr||'/'||libdir
      FROM directions d, branches b
      WHERE d.codbr = b.codbr AND  topme = 1
      ORDER BY coddir;


   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_dirme;

PROCEDURE lister_dirme_notif (p_test IN VARCHAR2,
				p_userid  IN  VARCHAR2,
               		   	p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   BEGIN
	IF p_test <> '3' THEN
      OPEN p_curseur FOR
      SELECT 	' ' coddir,
  	    		' ' libdir
  	    FROM dual
      UNION
  	    -- ligne "Tous"
  	    SELECT 	' TOUS' coddir,
  	    		'Tous' libdir
  	    FROM dual
  	    UNION

       SELECT
           to_char(coddir),
           coddir||' - '||libbr||'/'||libdir
      FROM directions d, branches b
      WHERE d.codbr = b.codbr AND  topme = 1
      ORDER BY coddir;

ELSE
	OPEN p_curseur FOR
      SELECT 	' ' coddir,
  	    		' ' libdir
  	    FROM dual
      UNION
       SELECT
           to_char(coddir),
           coddir||' - '||libbr||'/'||libdir
      FROM directions d, branches b
      WHERE d.codbr = b.codbr AND  topme = 1
      ORDER BY coddir;
END IF;

   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_dirme_notif;




-- -----------------------------------------------------------------
-- Liste les directions ME suivant le périmètre de l'utilisateur
-- -----------------------------------------------------------------
PROCEDURE lister_dirme_perimetre( p_userid  IN  VARCHAR2,
               		   			  p_curseur IN OUT pack_liste_dynamique.liste_dyn
              					) IS
    l_perime VARCHAR2(255);
    l_dir    VARCHAR2(255);
	l_pos	 NUMBER;
BEGIN
   	-- Récupérer le périmètre de l'utilisateur
   	l_perime := pack_global.lire_globaldata(p_userid).perime ;
	l_dir := '';

	-- On fait une boucle pour récupérer les codes directions qu'on met dans la variable
	-- l_dir qui sera ensuite testée
	while (length(l_perime)>0)
	loop
		if (length(l_dir) > 0) then
		    l_dir := l_dir||','||substr(l_perime,3,2);
		else
			l_dir := substr(l_perime,3,2);
		end if;
	    l_perime := substr(l_perime,13);
	end loop;


    OPEN p_curseur FOR
		SELECT d.coddir, d.coddir||' - '||d.libdir
          FROM directions d
         WHERE ( (INSTR(l_dir, d.coddir)>0) or (INSTR(l_dir,'00')>0) )
		   AND topme = 1
         ORDER BY coddir;


EXCEPTION
   WHEN OTHERS THEN
       raise_application_error(-20997, SQLERRM);

END lister_dirme_perimetre;


END pack_liste_dirme;
/
CREATE OR REPLACE PACKAGE pack_liste_dirmo AS

   PROCEDURE lister_dirmo(p_userid  IN VARCHAR2,
             		  p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

   PROCEDURE lister_dirmo_notif(p_userid  IN VARCHAR2,
             		  p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

   PROCEDURE lister_codmo_notif(p_dirmo IN VARCHAR2,
   				p_userid  IN VARCHAR2,
             		  	p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

END pack_liste_dirmo;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_dirmo AS

----------------------------------- SELECT -----------------------------------

   PROCEDURE lister_dirmo (p_userid  IN VARCHAR2,
               		   p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   BEGIN

      OPEN p_curseur FOR SELECT
           coddir,
           coddir||' - '||libbr||'/'||libdir
      FROM directions d, branches b
      WHERE d.codbr = b.codbr
      ORDER BY coddir;


   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_dirmo;

   PROCEDURE lister_dirmo_notif (p_userid  IN VARCHAR2,
               		   p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   BEGIN

      OPEN p_curseur FOR
      SELECT 	' ' coddir,
  	    		' ' libdir
  	    FROM dual
  	    UNION
      SELECT
           to_char(coddir),
           coddir||' - '||libbr||'/'||libdir libdir
      FROM directions d, branches b
      WHERE d.codbr = b.codbr
      ORDER BY coddir;


   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_dirmo_notif;

   PROCEDURE lister_codmo_notif (p_dirmo IN VARCHAR2,
   				p_userid  IN VARCHAR2,
               		   	p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   BEGIN

      OPEN p_curseur FOR
      SELECT 	' ' clicode,
  	    	' ' libmo
  	    FROM dual
  	    UNION
      SELECT
           clicode,
           clicode ||' - '||clilib libmo
      FROM client_mo cm
      WHERE cm.clidir=p_dirmo
      ORDER BY clicode;


   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_codmo_notif;

END pack_liste_dirmo
;
/
CREATE OR REPLACE PACKAGE pack_liste_dossier_projet AS

TYPE lib_ListeViewType IS RECORD(    	DPCODE	NUMBER(5),
					LIB	VARCHAR2(50)
                                         );

   TYPE lib_listeCurType IS REF CURSOR RETURN lib_ListeViewType;

   TYPE libBudAct_ListeViewType IS RECORD(    	DPCODE	NUMBER(5),
						LIB	VARCHAR2(50),
						BUDACT	NUMBER(10,2)
                                         );

   TYPE libBudAct_listeCurType IS REF CURSOR RETURN libBudAct_ListeViewType;

   -- Méthode qui liste les dossiers projets par codes.
   PROCEDURE lister_dossier_projet(	p_userid  IN VARCHAR2,
             	       			p_curseur IN OUT lib_listeCurType
            );

   -- Méthode qui liste les dossiers projets par ordre alphabétique d'intitulé
   PROCEDURE lister_dprojet_alpha(	p_userid  IN VARCHAR2,
             	       			p_curseur IN OUT lib_listeCurType
            );

   -- Méthode qui liste les dossiers projets seleon l'habilitation par référentiels
   PROCEDURE lister_dprojet_ref(	p_userid  IN VARCHAR2,
             	       			p_curseur IN OUT lib_listeCurType
            );

   -- Méthode qui liste les dossiers projets selon un département
   PROCEDURE lister_doss_proj_dep(	p_clicode  IN client_mo.clicode%TYPE,
					p_annee IN VARCHAR2,
             	       			p_curseur IN OUT libBudAct_listeCurType
            );

   -- Méthode qui liste les dossiers projets pour la notification
   PROCEDURE lister_dprojet_notif(	p_userid  IN VARCHAR2,
             	       			p_curseur IN OUT lib_listeCurType
            );

   -- Méthode qui liste les dossiers projets Actifs et Non Actifs classés par code
   PROCEDURE lister_dprojet_par_code01(	p_userid  IN VARCHAR2,
             	       			p_curseur IN OUT lib_listeCurType
            );

   -- Méthode qui liste les dossiers projets Actifs et Non Actifs classés par code  sans la valeur TOUS
   PROCEDURE lister_dprojet_par_code02(	p_userid  IN VARCHAR2,
             	       			p_curseur IN OUT lib_listeCurType
            );

END pack_liste_dossier_projet;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_dossier_projet AS

PROCEDURE lister_dossier_projet(p_userid  IN VARCHAR2,
             		p_curseur IN OUT lib_listeCurType
            ) IS
BEGIN
    OPEN p_curseur FOR
        -- Ligne vide en haut --
        SELECT '',
               ' ' LIB
        FROM DUAL
        UNION
    	SELECT DISTINCT  TO_CHAR(dpcode, 'FM00000'),
    			 to_char(dpcode, 'FM00000') ||' - '|| ltrim(rtrim(dplib)) LIB
    	FROM dossier_projet
    	WHERE actif = 'O' and dpcode <> 0
    	ORDER BY LIB;

   EXCEPTION
       WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);
   END lister_dossier_projet;



PROCEDURE lister_dprojet_alpha(p_userid  IN VARCHAR2,
             		p_curseur IN OUT lib_listeCurType
            ) IS
BEGIN
    OPEN p_curseur FOR
        -- Ligne vide en haut --
        SELECT '',
               ' ' LIB
        FROM DUAL
        UNION
    	SELECT DISTINCT  TO_CHAR(dpcode),
    			 ltrim(rtrim(dplib)) ||' - '|| to_char(dpcode, 'FM00000')  LIB
    	FROM dossier_projet
    	WHERE actif = 'O'
    	ORDER BY LIB;

EXCEPTION
       WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);
END lister_dprojet_alpha;


-- Méthode qui liste les dossiers projets selon l'habilitation par référentiels
PROCEDURE lister_dprojet_ref(	p_userid  IN VARCHAR2,
             	       		p_curseur IN OUT lib_listeCurType) IS

l_doss_proj VARCHAR2(255);
BEGIN
   l_doss_proj := pack_global.lire_doss_proj(p_userid);

   IF l_doss_proj IS NULL THEN
   	OPEN p_curseur FOR
        	-- Ligne vide --
        	SELECT '' CODE,
        	       '' LIB
        	FROM DUAL;

   ELSIF INSTR(UPPER(l_doss_proj), 'TOUS') > 0 THEN
   	OPEN p_curseur FOR
        	-- Ligne "Tous" en haut --
        	SELECT 'TOUS' CODE,
        	       'Tous' LIB
        	FROM DUAL
        	UNION
    		SELECT   TO_CHAR(dpcode, 'FM00000') CODE,
    			 TO_CHAR(dpcode, 'FM00000') ||' - '|| ltrim(rtrim(dplib))    LIB
    		FROM dossier_projet
    		WHERE actif = 'O'
    		ORDER BY CODE;
   ELSE
   	OPEN p_curseur FOR
        	-- Ligne "Tous" en haut --
        	SELECT 'TOUS' CODE,
        	       'Tous' LIB
        	FROM DUAL
        	UNION
    		SELECT 	TO_CHAR(dpcode, 'FM00000') CODE,
    			TO_CHAR(dpcode, 'FM00000') ||' - '|| ltrim(rtrim(dplib)) LIB
    		FROM dossier_projet
    		WHERE actif = 'O'
    		  AND INSTR(l_doss_proj, TO_CHAR(dpcode, 'FM00000')) > 0
    		ORDER BY CODE;
    END IF;
END lister_dprojet_ref;


PROCEDURE lister_doss_proj_dep(	p_clicode  IN client_mo.clicode%TYPE,
				p_annee  IN VARCHAR2,
             			p_curseur IN OUT libBudAct_listeCurType
            ) IS
BEGIN
    OPEN p_curseur FOR
    	-- récupération des différents dossier projet du departement
    	-- et des eventuelles valeurs de budget deja saisies
	SELECT distinct dp.dpcode DPCODE,
		ltrim(rtrim(dp.dplib))    LIB,
		TO_CHAR(bdp.BUDGETHTR, 'FM9999999990D00') BUDACT
	FROM dossier_projet dp,
		ligne_bip lb,
		budget_dp bdp
	WHERE dp.ACTIF = 'O'
	and lb.CLICODE in (
		select clicoderatt
		from vue_clicode_hierarchie
		where clicode = p_clicode )
	and dp.DPCODE = lb.DPCODE
	and bdp.ANNEE (+)= p_annee
	and bdp.CLICODE (+)= p_clicode
	and bdp.DPCODE (+)= lb.DPCODE
	ORDER BY dp.dpcode;

EXCEPTION
       WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);
END lister_doss_proj_dep;

-- Méthode qui liste les dossiers projets pour la notification
PROCEDURE lister_dprojet_notif(	p_userid  IN VARCHAR2,
             	       		p_curseur IN OUT lib_listeCurType) IS


BEGIN
   	OPEN p_curseur FOR
        	-- Ligne vide --
        	SELECT ' ' CODE,
        	       '' LIB
        	FROM DUAL
           	UNION
    		SELECT   TO_CHAR(dpcode, 'FM00000') CODE,
    			 TO_CHAR(dpcode, 'FM00000') ||' - '|| ltrim(rtrim(dplib))    LIB
    		FROM dossier_projet
    		WHERE actif = 'O'
    		AND dpcode <> 00000
    		AND dpcode <> 70000
    		ORDER BY CODE;

END lister_dprojet_notif;

PROCEDURE lister_dprojet_par_code01(p_userid  IN VARCHAR2,
             		p_curseur IN OUT lib_listeCurType
            ) IS
BEGIN
    OPEN p_curseur FOR
        -- Lignes en haut --
		SELECT  'AUCUN' CODE,
		        'Selectionnez un Dossier Projet'     LIB
        FROM DUAL
        UNION
        SELECT 'TOUS' CODE,
               'TOUS' LIB
        FROM DUAL
        UNION
    	SELECT DISTINCT  TO_CHAR(dpcode, 'FM00000') CODE,
    			 TO_CHAR(dpcode, 'FM00000') ||' - '|| ltrim(rtrim(dplib))    LIB
    	FROM dossier_projet
    	WHERE actif = 'O' or actif = 'N'
    	ORDER BY CODE;

EXCEPTION
       WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);
END lister_dprojet_par_code01;

PROCEDURE lister_dprojet_par_code02(p_userid  IN VARCHAR2,
             		p_curseur IN OUT lib_listeCurType
            ) IS
BEGIN
    OPEN p_curseur FOR
        -- Lignes en haut --
		SELECT  'AUCUN' CODE,
		        'Selectionnez un Dossier Projet'     LIB
        FROM DUAL
        UNION
    	SELECT DISTINCT  TO_CHAR(dpcode, 'FM00000') CODE,
    			 TO_CHAR(dpcode, 'FM00000') ||' - '|| ltrim(rtrim(dplib))    LIB
    	FROM dossier_projet
    	WHERE actif = 'O' or actif = 'N'
    	ORDER BY CODE;

EXCEPTION
       WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);
END lister_dprojet_par_code02;

END pack_liste_dossier_projet;
/
CREATE OR REPLACE PACKAGE pack_liste_dpg_cfrais AS

   PROCEDURE lister_dpg_cfrais( p_codcfrais IN VARCHAR2,
				p_habilitation IN VARCHAR2,
				p_userid IN VARCHAR2,
             			p_curseur IN OUT pack_liste_dynamique.liste_dyn
            			);

END pack_liste_dpg_cfrais;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_dpg_cfrais AS

PROCEDURE lister_dpg_cfrais( p_codcfrais IN VARCHAR2,
				p_habilitation IN VARCHAR2,
				p_userid IN VARCHAR2,
             			p_curseur IN OUT pack_liste_dynamique.liste_dyn
            			)IS

BEGIN

    IF p_habilitation='br' THEN
       		OPEN p_curseur FOR
	        SELECT distinct codbr as DPG,
	 		LPAD(codbr,2,0)||' '||libbr
		FROM branches b
		order by 1;

    ELSIF p_habilitation='dir' THEN
       		OPEN p_curseur FOR
		SELECT distinct d.coddir as DPG,
			LPAD(d.coddir,2,0)||' '||b.libbr||'/'||d.libdir
		FROM directions d,branches b
		where d.codbr=b.codbr
		order by 1;

    ELSIF p_habilitation='dpt' THEN
        	OPEN p_curseur FOR    --pour bien différencier les mêmes codes dep
		SELECT distinct s.topfer||lpad(s.coddep,3,0)||lpad(s.coddir,2,0) as DPG,
			LPAD(s.coddep,3,0)||' '||b.libbr||'/'||d.libdir||'/'||s.sigdep||'  '||s.topfer
		FROM struct_info s, directions d, branches b
		where s.coddir=d.coddir
		and d.codbr=b.codbr
		order by 2;

    ELSIF p_habilitation='pole' THEN
        	OPEN p_curseur FOR
		SELECT distinct topfer||substr(lpad(s.codsg,7,0),1,5)||lpad(s.coddir,2,0) as DPG,
	        substr(lpad(s.codsg,7,0),1,5)||' '||b.libbr||'/'||d.libdir||'/'||s.sigdep||'/'||s.sigpole||'  '||s.topfer
		FROM struct_info s, directions d, branches b
		where s.coddir=d.coddir
		and d.codbr=b.codbr
		order by 2;

    END IF;


   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_dpg_cfrais;

END pack_liste_dpg_cfrais;
/
CREATE OR REPLACE PACKAGE pack_liste_dpg_perime AS

   PROCEDURE lister_dpg_perime(
				p_habilitation  IN VARCHAR2,
				p_userid  	IN VARCHAR2,
             			p_curseur 	IN OUT pack_liste_dynamique.liste_dyn
            			);

END pack_liste_dpg_perime;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_dpg_perime AS

PROCEDURE lister_dpg_perime(
				p_habilitation 	IN VARCHAR2,
				p_userid 	IN VARCHAR2,
             			p_curseur 	IN OUT pack_liste_dynamique.liste_dyn
            			)IS
l_habilitation varchar2(10);
BEGIN
    -- p_habilitation est la concaténation du code périmètre sur 5 caractères et du code habilitation
    l_habilitation:=substr(p_habilitation,6,4);

    IF l_habilitation='br' THEN
       		OPEN p_curseur FOR
	        SELECT distinct codbr as DPG,
	 		LPAD(codbr,2,0)||' '||libbr
		FROM branches b
		order by 1;

    ELSIF l_habilitation='dir' THEN
       		OPEN p_curseur FOR
		SELECT distinct d.coddir as DPG,
			LPAD(d.coddir,2,0)||' '||b.libbr||'/'||d.libdir
		FROM directions d,branches b
		where d.codbr=b.codbr
		order by 1;

    ELSIF l_habilitation='dpt' THEN
        	OPEN p_curseur FOR    --pour bien différencier les mêmes codes dep
		SELECT distinct s.topfer||lpad(s.coddep,3,'0')||lpad(s.coddir,2,'0') as DPG,
			LPAD(s.coddep,3,'0')||' '||b.libbr||'/'||d.libdir||'/'||s.sigdep||' '
		FROM struct_info s, directions d, branches b
		where s.coddir=d.coddir
		and d.codbr=b.codbr
		and s.topfer='O'
		order by 2;

    ELSIF l_habilitation='pole' THEN
        	OPEN p_curseur FOR
		SELECT distinct topfer||substr(lpad(s.codsg,7,'0'),1,5)||lpad(s.coddir,2,'0') as DPG,
	        SUBSTR(lpad(s.codsg,7,'0'),1,5)||' '||b.libbr||'/'||d.libdir||'/'||s.sigdep||'/'||s.sigpole||' '
		FROM struct_info s, directions d, branches b
		where s.coddir=d.coddir
		and d.codbr=b.codbr
		and s.topfer='O'
		order by 2;

    END IF;




   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_dpg_perime;

END pack_liste_dpg_perime;
/
CREATE OR REPLACE PACKAGE pack_liste_dpg_perimo AS

   PROCEDURE lister_dpg_perimo(
				p_habilitation 	IN VARCHAR2,
				p_userid 	IN VARCHAR2,
             			p_curseur 	IN OUT pack_liste_dynamique.liste_dyn
            			);

END pack_liste_dpg_perimo;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_dpg_perimo AS

PROCEDURE lister_dpg_perimo(
				p_habilitation 	IN VARCHAR2,
				p_userid 	IN VARCHAR2,
             			p_curseur 	IN OUT pack_liste_dynamique.liste_dyn
            			)IS
l_habilitation varchar2(10);
BEGIN
    -- p_habilitation est la concaténation du code périmètre sur 5 caractères et du code habilitation
    l_habilitation:=substr(p_habilitation,6,4);

    IF l_habilitation='br' THEN
       		OPEN p_curseur FOR
	        SELECT distinct b.codbr as DPG,
	 		LPAD(b.codbr,2,0)||' '||b.libbr
		FROM client_mo c, directions d, branches b
		where c.clidir=d.coddir
		and d.codbr=b.codbr
		order by 1;

    ELSIF l_habilitation='dir' THEN
       		OPEN p_curseur FOR
		SELECT distinct clidir as DPG,
			clidir||' '||libbr||'/'||clilib
		FROM client_mo c, directions d, branches b
		where  c.clidir=d.coddir
		and d.codbr=b.codbr
		and clitopf='O'
		order by 1;
    END IF;


   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_dpg_perimo;

END pack_liste_dpg_perimo;
/
CREATE OR REPLACE PACKAGE pack_liste_dynamique AS

-- dimensionne pour id nom de var <= 50
--                  libelle ligne de 120 caracteres
-- inutile d'avoir plus de de 120 car on ne doit pas avoir de barre
-- de scrolling horizontale

TYPE liste_dynamique IS RECORD ( id      VARCHAR2(50),
                                 libelle VARCHAR2(120)
                               );

TYPE liste_dyn IS REF CURSOR RETURN liste_dynamique;

END pack_liste_dynamique;
/
CREATE OR REPLACE PACKAGE pack_liste_extraction IS


	PROCEDURE Lister_Extraction(
		p_userid	IN	CHAR,
		p_curseur	IN OUT	pack_liste_dynamique.liste_dyn
	);

END pack_liste_extraction;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_extraction IS

	PROCEDURE Lister_Extraction(
		p_userid	IN	CHAR,
		p_curseur	IN OUT	pack_liste_dynamique.liste_dyn
	) IS

		l_menu 		varchar2(20);
    		l_sousmenus   	VARCHAR2(255);
	BEGIN
		-- Récupération du menu courant et des sous-menus de l'utilisateur
		l_menu := pack_global.lire_globaldata(p_userid).menutil;
   		l_sousmenus := pack_global.lire_globaldata(p_userid).sousmenus;

		-- Recherche les requêtes habilitée
		-- Si un sous-menu plus est renseigné dans la table et qu'il appartient
		-- 	au sous-menu de l'utilisateur on renvoie la ligne
		OPEN p_curseur FOR SELECT DISTINCT
			r.nom_fichier,
				r.libelle
			FROM requete r, requete_profil rp
			WHERE r.nom_fichier=rp.nom_fichier
			AND UPPER(rp.code_profil)=UPPER(l_menu)
			AND	(rp.sous_menu_plus is null OR INSTR(l_sousmenus,rp.sous_menu_plus) > 0 )
			AND 	(rp.sous_menu_moins is null
				OR NOT EXISTS ( SELECT 1
							FROM requete_profil rp2
							WHERE rp.nom_fichier = rp2.nom_fichier
							AND   rp.code_profil = rp2.code_profil
							AND	 INSTR(l_sousmenus,rp2.sous_menu_moins) > 0 )
				);

	EXCEPTION
		WHEN OTHERS THEN
		RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END Lister_Extraction;


END pack_liste_extraction;
/
CREATE OR REPLACE PACKAGE pack_liste_fournisseur AS

   TYPE agence_p_RecType IS RECORD (clelf    VARCHAR2(11),
                                    liste    VARCHAR2(37));

   TYPE agence_p_CurType IS REF CURSOR RETURN agence_p_RecType;

   PROCEDURE lister_fournisseur (p_socfact IN facture.socfact%TYPE,
                              	 p_typfact IN facture.typfact%TYPE,
                              	 p_datfact IN VARCHAR2,
                              	 p_numfact IN facture.numfact%TYPE,
                              	 p_soccont IN contrat.soccont%TYPE,
                              	 p_cav     IN contrat.cav%TYPE,
                              	 p_numcont IN contrat.numcont%TYPE,
                              	 p_rnom    IN ressource.rnom%TYPE,
                             	 p_userid  IN VARCHAR2,
                             	 p_curseur IN OUT agence_p_CurType
                             );
END pack_liste_fournisseur;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_fournisseur AS

    PROCEDURE lister_fournisseur (p_socfact IN facture.socfact%TYPE,
                             	  p_typfact IN facture.typfact%TYPE,
                            	  p_datfact IN VARCHAR2,
                            	  p_numfact IN facture.numfact%TYPE,
                            	  p_soccont IN contrat.soccont%TYPE,
                            	  p_cav     IN contrat.cav%TYPE,
                            	  p_numcont IN contrat.numcont%TYPE,
                            	  p_rnom    IN ressource.rnom%TYPE,
                            	  p_userid  IN VARCHAR2,
                            	  p_curseur IN OUT agence_p_CurType
                             ) IS

    BEGIN
        -- On recupere le code filiale et on prepare numcont et rnom en template

--       DBMS_OUTPUT.PUT_LINE('DEBUT ,' || l_like_numcont || ',' || l_like_rnom || ',' || l_filcode );

         -- La largeur de la liste_fournisseur est limité à 33 caractères????????
        OPEN p_curseur FOR
        SELECT  RPAD(a.socfour,10) as Clelf,
                RPAD(a.socfour,10) || ' ' || RPAD(a.socflib,25) as Liste_fournisseur
        FROM  agence a
        WHERE   a.soccode =  p_socfact
        ORDER BY Clelf;

   END lister_fournisseur;

-- Pour Tester sous SQLPlus
-- > set serveroutput on
-- > var vcur refcursor
-- > set autoprint on
-- > exec pack_liste_fournisseur.lister_fournisseur('SOPR','F','10201999','TOTO','','','','LE','S935708;;;;01;',:vcur)
-- > exec pack_liste_fournisseur.lister_fournisseur('ADMI','','','','','' ,'B980','','S935708;;;;01;',:vcur)
-- > print vcur

END pack_liste_fournisseur;
/
CREATE OR REPLACE PACKAGE pack_liste_groupe AS

   PROCEDURE lister_groupe( p_userid   IN VARCHAR2,
                            p_curseur  IN OUT pack_liste_dynamique.liste_dyn
                        );

END pack_liste_groupe;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_groupe AS

----------------------------------- SELECT -----------------------------------

   PROCEDURE lister_groupe( p_userid   IN VARCHAR2,
                            p_curseur  IN OUT pack_liste_dynamique.liste_dyn
                        ) IS

   l_pole      VARCHAR2(7);
   l_perime    varchar2(255);

   BEGIN
   	l_pole := pack_global.lire_globaldata(p_userid).codpole;
	l_perime := pack_global.lire_globaldata(p_userid).perime;


	IF (l_pole  = '000000' or (INSTR(l_perime, '00000000000')>0)) THEN 	-- Tous les départements et pôles
	    OPEN p_curseur FOR
		SELECT *
		FROM
		   (
		    -- ----------------------------------------------------------------------
		   -- Liste de tous les groupes
		   -- ----------------------------------------------------------------------
		   SELECT to_char(codsg,'FM0000000') AS code,
			to_char(codsg,'FM0000000')|| ' - '  ||
			substr(libdsg,1,12)
	           FROM
			struct_info
		   WHERE
			codsg > 1 and topfer like 'O'
		   -- -----
		   UNION
		   -- -----
		   -- ----------------------------------------------------------------------
		   -- Liste de tous les departements/poles (XXXX)
		   -- ----------------------------------------------------------------------
		   SELECT DISTINCT
			substr(to_char(codsg,'FM0000000'),1,5)||'00' AS code,
			substr(to_char(codsg,'FM0000000'),1,5)||'00'||' - '  ||
			sigdep                                      || '/'   ||
			sigpole
		   FROM
			struct_info
		   WHERE
			codsg > 1 and topfer like 'O'
		   -- -----
		   UNION
		   -- -----
   		   -- ----------------------------------------------------------------------
		   -- Liste de tous les departements (XX**)
		   -- ----------------------------------------------------------------------
		   SELECT DISTINCT
			substr(to_char(codsg,'FM0000000'),1,3) || '0000'  AS code,
			substr(to_char(codsg,'FM0000000'),1,3) || '0000' || ' - '  ||
			rpad(sigdep,6,' ')
		   FROM
			struct_info
		   WHERE
			codsg > 1 and topfer like 'O'
		   -- -----
		   UNION
		   -- -----
   		   -- ----------------------------------------------------------------------
		   -- Code special '0000'
		   -- ----------------------------------------------------------------------
		   SELECT
			'000000' AS code,
			'000000' || ' - ' || rpad('Tous',6,' ')
		   FROM
			dual
		   )  ;

	ELSE	-- liste des dépt et pôles du périmètre ME de l'utilisateur
	   OPEN p_curseur FOR
		SELECT *
		FROM (
		   -- Groupes
		   	SELECT DISTINCT TO_CHAR(me.codsg, 'FM0000000') AS code,
		   			TO_CHAR(me.codsg, 'FM0000000') || ' - ' ||
		   			  substr(s.libdsg,1,12)
		   	FROM    struct_info s,
		   		vue_dpg_perime me
		   	WHERE	s.codsg = me.codsg
		   	    AND s.topfer LIKE 'O'
		   	    AND INSTR(l_perime, me.codbddpg) > 0
		   	    AND me.codhabili IN ('bip', 'br', 'dir', 'dpt', 'pole', 'grpe')
		   UNION
		   -- Pôles
		   	SELECT DISTINCT SUBSTR(TO_CHAR(me.codsg, 'FM0000000'), 1, 5) || '00' AS code,
		   			SUBSTR(TO_CHAR(me.codsg, 'FM0000000'), 1, 5) || '00' || ' - ' ||
		   			  sigdep                                     || '/'  ||
		   			  sigpole
		   	FROM    struct_info s,
		   		vue_dpg_perime me
		   	WHERE	s.codsg = me.codsg
		   	    AND s.topfer LIKE 'O'
		   	    AND INSTR(l_perime, me.codbddpg) > 0
		   	    AND me.codhabili IN ('bip', 'br', 'dir', 'dpt', 'pole')
		   UNION
		   -- Départements
		   	SELECT DISTINCT SUBSTR(TO_CHAR(me.codsg, 'FM0000000'), 1, 3) || '0000' AS code,
		   			SUBSTR(TO_CHAR(me.codsg, 'FM0000000'), 1, 3) || '0000' || ' - ' ||
		   			  RPAD(sigdep, 6, ' ')
		   	FROM    struct_info s,
		   		vue_dpg_perime me
		   	WHERE	s.codsg = me.codsg
		   	    AND s.topfer LIKE 'O'
		   	    AND INSTR(l_perime, me.codbddpg) > 0
		   	    AND me.codhabili IN ('bip', 'br', 'dir', 'dpt')
		);
	END IF;
   END lister_groupe;

END pack_liste_groupe;
/
CREATE OR REPLACE PACKAGE pack_liste_immeuble AS

   PROCEDURE lister_immeuble(p_userid  IN VARCHAR2,
                             p_curseur IN OUT pack_liste_dynamique.liste_dyn
                            );

END pack_liste_immeuble;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_immeuble AS

----------------------------------- SELECT -----------------------------------
   PROCEDURE lister_immeuble (p_userid  IN VARCHAR2,
                              p_curseur IN OUT pack_liste_dynamique.liste_dyn
                             ) IS
   BEGIN

      OPEN p_curseur FOR
      SELECT
           icodimm,
           iadrabr
      FROM immeuble
      ORDER BY 2;

   EXCEPTION
      WHEN OTHERS THEN
        raise_application_error(-20997, SQLERRM);

   END lister_immeuble;

END pack_liste_immeuble;
/
CREATE OR REPLACE PACKAGE pack_liste_investissements AS

   PROCEDURE lister_type(p_userid  IN VARCHAR2,
             	       p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

	PROCEDURE lister_ligne_inv(	p_userid  IN VARCHAR2,
								p_codcamo IN VARCHAR2,--LIGNE_INVESTISSEMENT.CODCAMO%TYPE,
								p_annee   IN VARCHAR2,--LIGNE_INVESTISSEMENT.ANNEE%TYPE,
								p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );


END pack_liste_investissements;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_investissements AS

PROCEDURE lister_type(p_userid  IN VARCHAR2,
             		p_curseur IN OUT pack_liste_dynamique.liste_dyn
            ) IS

BEGIN

   ---- recherche niveau du ca

    OPEN p_curseur FOR
    SELECT
    codtype,
    lib_type
	FROM investissements;

   EXCEPTION

       --WHEN NO_DATA_FOUND THEN BEGIN END;

       WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);

   END lister_type;

PROCEDURE lister_ligne_inv(	p_userid  IN VARCHAR2,
								p_codcamo IN VARCHAR2,--LIGNE_INVESTISSEMENT.CODCAMO%TYPE,
								p_annee   IN VARCHAR2,--LIGNE_INVESTISSEMENT.ANNEE%TYPE,
								p_curseur IN OUT pack_liste_dynamique.liste_dyn
								) IS
BEGIN
	OPEN p_curseur FOR
	SELECT
		codinv,
		codinv || ' - ' || libelle
	FROM
		LIGNE_INVESTISSEMENT
	WHERE
		to_char(CODCAMO) = p_codcamo
	AND to_char(ANNEE) = p_annee;

	EXCEPTION
       --WHEN NO_DATA_FOUND THEN BEGIN END;
       WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);

END lister_ligne_inv;


END pack_liste_investissements;
/
CREATE OR REPLACE PACKAGE Pack_Liste_Isac_Conso AS

FUNCTION f_get_cusag_mois ( 	p_ident 	IN VARCHAR2,
				p_sous_tache 	IN VARCHAR2,
				p_mois 		IN VARCHAR2)
				  RETURN VARCHAR2;
PRAGMA RESTRICT_REFERENCES(f_get_cusag_mois,wnds,wnps);

FUNCTION f_get_adatestatut ( 	p_ident IN VARCHAR2,
				p_sous_tache IN VARCHAR2) RETURN NUMBER;
PRAGMA RESTRICT_REFERENCES(f_get_adatestatut,wnds,wnps);

FUNCTION f_get_total_sstache( 	p_ident 	IN NUMBER,
				p_sous_tache	IN NUMBER,
			 	p_annee 	IN VARCHAR2
			)  RETURN VARCHAR2;
PRAGMA RESTRICT_REFERENCES(f_get_total_sstache,wnds,wnps);


FUNCTION f_get_lib_pid( p_pid 	IN VARCHAR2
			          )  RETURN VARCHAR2;

-- Majuscule pour javascript qui utilise le nom des colonnes pour l'automates.
   TYPE conso_ListeViewType IS RECORD(
				 	MOIS_1 		VARCHAR2(9),
					MOIS_2		VARCHAR2(9),
					MOIS_3 		VARCHAR2(9),
					MOIS_4 		VARCHAR2(9),
					MOIS_5 		VARCHAR2(9),
					MOIS_6 		VARCHAR2(9),
					MOIS_7		VARCHAR2(9),
					MOIS_8		VARCHAR2(9),
					MOIS_9 		VARCHAR2(9),
					MOIS_10 	VARCHAR2(9),
					MOIS_11		VARCHAR2(9),
					MOIS_12		VARCHAR2(9),
					PID		    ISAC_AFFECTATION.pid%TYPE,
					LIB		    LIGNE_BIP.pnom%TYPE,
				   	ETAPE		ISAC_CONSOMME.ETAPE%TYPE,
					ECET		ISAC_ETAPE.ecet%TYPE,
					LIBETAPE 	ISAC_ETAPE.libetape%TYPE,
				    TACHE		ISAC_CONSOMME.TACHE%TYPE,
					ACTA		ISAC_TACHE.acta%TYPE,
					LIBTACHE	ISAC_TACHE.libtache%TYPE,
				   	SOUS_TACHE	ISAC_CONSOMME.sous_tache%TYPE,
					ACST		ISAC_SOUS_TACHE.acst%TYPE,
					ASNOM		ISAC_SOUS_TACHE.asnom%TYPE,
					AIST 		ISAC_SOUS_TACHE.aist%TYPE,
					MOIS_SAISIE     NUMBER(2),
					TOTAL_PID	VARCHAR2(10),
					IDENTIFIANT     VARCHAR2(50),
					TYPETAPE      VARCHAR2(2),
					FERMEE	VARCHAR2(8),
					TYPPROJ	VARCHAR2(2),
					LIBELLE_TRI	VARCHAR2(110),
					TYPE	VARCHAR2(1)
                                         );

   TYPE conso_listeCurType IS REF CURSOR RETURN conso_ListeViewType;

   PROCEDURE lister_isac_conso( 	p_ident    IN VARCHAR2,
                              		p_userid   IN VARCHAR2,
									p_ordre_tri IN VARCHAR2,
                              		p_curseur  IN OUT conso_listeCurType
                             );

END Pack_Liste_Isac_Conso;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Isac_Conso AS
FUNCTION f_get_cusag_mois ( 	p_ident IN VARCHAR2,
				p_sous_tache IN VARCHAR2,
				p_mois IN VARCHAR2) RETURN VARCHAR2 IS
l_cusag NUMBER(7,2);
BEGIN
	SELECT cusag INTO l_cusag FROM ISAC_CONSOMME
	WHERE ident=TO_NUMBER(p_ident)
	AND sous_tache=p_sous_tache
	AND cdeb=TO_DATE('01/'||p_mois);
	IF (l_cusag<1 AND l_cusag>0) THEN
		RETURN TO_CHAR(l_cusag,'FM9990D99');
	ELSE
		RETURN TO_CHAR(l_cusag);
	END IF;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN NULL;

END f_get_cusag_mois;

--fonction qui renvoie 1 ou 0 en fonction de la date de statut et du mois de mensuelle
FUNCTION f_get_adatestatut ( 	p_ident IN VARCHAR2,
				p_sous_tache IN VARCHAR2) RETURN NUMBER IS
l_test NUMBER(1);
l_test_sst NUMBER(1);
l_res NUMBER(1);
BEGIN
	BEGIN
	-- on teste si la ligne Bip est fermée
	SELECT DISTINCT 1 INTO l_test
	FROM LIGNE_BIP lb,ISAC_AFFECTATION c,DATDEBEX dx
	WHERE c.ident=TO_NUMBER(p_ident)
	AND c.sous_tache=p_sous_tache
	AND c.pid=lb.pid
	AND lb.adatestatut IS NOT NULL AND lb.adatestatut <= ADD_MONTHS(dx.moismens,-1);

	EXCEPTION
			WHEN NO_DATA_FOUND THEN
	-- on teste la sous tache
		SELECT DISTINCT 2 INTO l_test_sst
		FROM LIGNE_BIP lb,ISAC_SOUS_TACHE sst,ISAC_AFFECTATION c,DATDEBEX dx
		WHERE c.ident=TO_NUMBER(p_ident)
		AND sst.sous_tache=p_sous_tache
		AND sst.sous_tache=c.sous_tache
		AND SUBSTR(sst.aist,3,4)=lb.pid(+)
		AND lb.adatestatut IS NOT NULL AND lb.adatestatut <= ADD_MONTHS(dx.moismens,-1);
	END;

		IF (l_test_sst!=2 AND l_test!=1) THEN
			l_res := 0;
		ELSE
			 l_res := 1;
		END IF;

	RETURN l_res;
END f_get_adatestatut;

FUNCTION f_get_total_sstache( 	p_ident 	IN NUMBER,
				p_sous_tache	IN NUMBER,
			 	p_annee 	IN VARCHAR2
			)  RETURN VARCHAR2 IS

l_total NUMBER(9,2);
BEGIN
	SELECT SUM(cusag) INTO l_total
	FROM ISAC_CONSOMME
	WHERE ident=p_ident
	AND sous_tache=p_sous_tache
	AND  TO_CHAR(cdeb,'YYYY')=p_annee;

	IF (l_total<1 AND l_total>0) THEN
		RETURN TO_CHAR(l_total,'FM9990D99');
	ELSE
		RETURN TO_CHAR(l_total);
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN 0;


END f_get_total_sstache;


FUNCTION f_get_lib_pid( p_pid 	IN VARCHAR2
			          )  RETURN VARCHAR2 IS

l_lib LIGNE_BIP.PNOM%TYPE;

BEGIN

    l_lib := '';

    SELECT pnom INTO l_lib
           FROM LIGNE_BIP
           WHERE pid=p_pid;

	RETURN l_lib;

END f_get_lib_pid;




PROCEDURE lister_isac_conso(  	p_ident    IN VARCHAR2,
                              			p_userid   IN VARCHAR2,
										p_ordre_tri IN VARCHAR2,
                              			p_curseur  IN OUT conso_listeCurType
                             ) IS
l_datemens DATE;
l_datecourante DATE;
l_mois_saisie NUMBER(2);
l_anneecourante VARCHAR2(4);
l_annee DATE;

   BEGIN
--comparer la date courante par rapport à la date de la mensuelle du mois
	SELECT cmensuelle,TO_CHAR(DATDEBEX,'YYYY'),DATDEBEX INTO l_datemens, l_anneecourante, l_annee
	FROM DATDEBEX;

	l_mois_saisie := TO_NUMBER(TO_CHAR(ADD_MONTHS(l_datemens,-1),'MM'));
	--adatestatut is not null and l_adatestatut <= add_months(l_moismens,-1)

IF(TO_NUMBER(p_ordre_tri) = 1)THEN

	OPEN p_curseur FOR
	-- Récupere les consommés de l'annéé pour la ressource
	SELECT DISTINCT
	f_get_cusag_mois(a.ident,a.sous_tache,'01/'||l_anneecourante) MOIS_1,
	f_get_cusag_mois(a.ident,a.sous_tache,'02/'||l_anneecourante) MOIS_2,
	f_get_cusag_mois(a.ident,a.sous_tache,'03/'||l_anneecourante) MOIS_3,
	f_get_cusag_mois(a.ident,a.sous_tache,'04/'||l_anneecourante) MOIS_4,
	f_get_cusag_mois(a.ident,a.sous_tache,'05/'||l_anneecourante) MOIS_5,
	f_get_cusag_mois(a.ident,a.sous_tache,'06/'||l_anneecourante) MOIS_6,
	f_get_cusag_mois(a.ident,a.sous_tache,'07/'||l_anneecourante) MOIS_7,
	f_get_cusag_mois(a.ident,a.sous_tache,'08/'||l_anneecourante) MOIS_8,
	f_get_cusag_mois(a.ident,a.sous_tache,'09/'||l_anneecourante) MOIS_9,
	f_get_cusag_mois(a.ident,a.sous_tache,'10/'||l_anneecourante) MOIS_10,
	f_get_cusag_mois(a.ident,a.sous_tache,'11/'||l_anneecourante) MOIS_11,
	f_get_cusag_mois(a.ident,a.sous_tache,'12/'||l_anneecourante) MOIS_12,
	a.pid PID, f_get_lib_pid(a.pid), a.ETAPE ETAPE,e.ecet ECET, e.libetape LIBETAPE,
	a.TACHE TACHE,t.acta ACTA,t.libtache LIBTACHE, a.sous_tache SOUS_TACHE, st.acst ACST,st.asnom ASNOM, NVL(st.aist,' ') AIST, l_mois_saisie MOIS_SAISIE,
	f_get_total_sstache(a.ident,a.sous_tache,l_anneecourante) TOTAL_PID,
	a.pid||e.ecet||t.acta||st.acst IDENTIFIANT,
	e.TYPETAPE TYPETAPE,
	DECODE(f_get_adatestatut(a.ident,a.sous_tache),1,'class=inputgras disabled ' ,'class=inputisac ') FERMEE,
	l.typproj typproj,
	ap.alibel || l.typproj || a.pid || e.ecet||t.acta||st.acst LIBELLE_TRI,
	DECODE(TO_NUMBER(l.typproj),'7','7','1') TYPE
	FROM  ISAC_AFFECTATION a, ISAC_SOUS_TACHE st, ISAC_TACHE t, ISAC_ETAPE e, LIGNE_BIP l, APPLICATION ap
	WHERE a.ident=TO_NUMBER(p_ident)
	AND a.sous_tache=st.sous_tache
	AND st.TACHE=t.TACHE
	AND t.ETAPE=e.ETAPE
	AND l.pid=a.pid
	AND ap.airt=l.airt
	ORDER BY TYPE DESC, FERMEE DESC, 27
;

ELSE

OPEN p_curseur FOR
	-- Récupere les consommés de l'annéé pour la ressource
	SELECT DISTINCT
	f_get_cusag_mois(a.ident,a.sous_tache,'01/'||l_anneecourante) MOIS_1,
	f_get_cusag_mois(a.ident,a.sous_tache,'02/'||l_anneecourante) MOIS_2,
	f_get_cusag_mois(a.ident,a.sous_tache,'03/'||l_anneecourante) MOIS_3,
	f_get_cusag_mois(a.ident,a.sous_tache,'04/'||l_anneecourante) MOIS_4,
	f_get_cusag_mois(a.ident,a.sous_tache,'05/'||l_anneecourante) MOIS_5,
	f_get_cusag_mois(a.ident,a.sous_tache,'06/'||l_anneecourante) MOIS_6,
	f_get_cusag_mois(a.ident,a.sous_tache,'07/'||l_anneecourante) MOIS_7,
	f_get_cusag_mois(a.ident,a.sous_tache,'08/'||l_anneecourante) MOIS_8,
	f_get_cusag_mois(a.ident,a.sous_tache,'09/'||l_anneecourante) MOIS_9,
	f_get_cusag_mois(a.ident,a.sous_tache,'10/'||l_anneecourante) MOIS_10,
	f_get_cusag_mois(a.ident,a.sous_tache,'11/'||l_anneecourante) MOIS_11,
	f_get_cusag_mois(a.ident,a.sous_tache,'12/'||l_anneecourante) MOIS_12,
	a.pid PID, f_get_lib_pid(a.pid), a.ETAPE ETAPE,e.ecet ECET, e.libetape LIBETAPE,
	a.TACHE TACHE,t.acta ACTA,t.libtache LIBTACHE, a.sous_tache SOUS_TACHE, st.acst ACST,st.asnom ASNOM, NVL(st.aist,' ') AIST, l_mois_saisie MOIS_SAISIE,
	f_get_total_sstache(a.ident,a.sous_tache,l_anneecourante) TOTAL_PID,
	a.pid||e.ecet||t.acta||st.acst IDENTIFIANT,
	e.TYPETAPE TYPETAPE,
	DECODE(f_get_adatestatut(a.ident,a.sous_tache),1,'class=inputgras disabled ' ,'class=inputisac ') FERMEE,
	l.typproj typproj,
	ap.alibel || l.typproj || a.pid || e.ecet||t.acta||st.acst LIBELLE_TRI,
	DECODE(TO_NUMBER(l.typproj),'7','7','1') TYPE
	FROM  ISAC_AFFECTATION a, ISAC_SOUS_TACHE st, ISAC_TACHE t, ISAC_ETAPE e, LIGNE_BIP l, APPLICATION ap
	WHERE a.ident=TO_NUMBER(p_ident)
	AND a.sous_tache=st.sous_tache
	AND st.TACHE=t.TACHE
	AND t.ETAPE=e.ETAPE
	AND l.pid=a.pid
	AND ap.airt=l.airt
	ORDER BY TYPE DESC, FERMEE DESC, 31
;

END IF;

  END lister_isac_conso;

END Pack_Liste_Isac_Conso;
/
CREATE OR REPLACE PACKAGE Pack_Liste_Isac_Cpident AS

   TYPE cpident_ListeViewType IS RECORD(
				   	CLE		VARCHAR2(100),
					LIBELLE 	VARCHAR2(100)
                                         );


   TYPE cpident_listeCurType IS REF CURSOR RETURN cpident_ListeViewType;

    TYPE RefCurTyp IS REF CURSOR;


   PROCEDURE lister_isac_cpident( 	p_userid  IN VARCHAR2,
                              		p_curseur IN OUT RefCurTyp
                                );

END Pack_Liste_Isac_Cpident;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Isac_Cpident AS

PROCEDURE lister_isac_cpident(
                              	p_userid  IN VARCHAR2,
                              	p_curseur IN OUT RefCurTyp
                             ) IS

l_lst_chefs_projets VARCHAR2(255);
req                            VARCHAR2(800);

BEGIN

	l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;

		req := ' SELECT DISTINCT res.ident CLE, res.rnom ||'' - ''||res.ident LIBELLE  '
                || ' FROM RESSOURCE res, SITU_RESS_FULL sr, DATDEBEX d  '
		        || ' WHERE  res.ident IN ('|| l_lst_chefs_projets ||')  '
			    || ' AND (TRUNC(sr.datsitu,''YEAR'') <=TRUNC(d.DATDEBEX,''YEAR'') OR sr.datsitu IS NULL) '
		        || ' AND (TRUNC(sr.datdep,''YEAR'')>=TRUNC(d.DATDEBEX,''YEAR'') OR sr.datdep IS NULL) '
		        || ' AND res.ident = sr.cpident '
		        || ' AND sr.type_situ=''N'' '
		        || ' ORDER BY LIBELLE ';



        OPEN p_curseur FOR   req;

END lister_isac_cpident;
END Pack_Liste_Isac_Cpident;
/
CREATE OR REPLACE PACKAGE pack_liste_isac_etape AS

   TYPE etape_ListeViewType IS RECORD(
				   	ETAPE		VARCHAR2(100),
					LISTETAPE 	VARCHAR2(100)

                                         );

   TYPE etape_listeCurType IS REF CURSOR RETURN etape_ListeViewType;

   PROCEDURE lister_isac_etape( p_pid     IN isac_etape.pid%TYPE,
                              	p_userid  IN VARCHAR2,
                              	p_curseur IN OUT etape_listeCurType
                             );

END pack_liste_isac_etape;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_isac_etape AS

PROCEDURE lister_isac_etape(  p_pid     IN isac_etape.pid%TYPE,
                              p_userid  IN VARCHAR2,
                              p_curseur IN OUT etape_listeCurType
                             ) IS
l_count number(2);
BEGIN
	select count(*) into l_count
	from isac_etape
	where pid=p_pid;

	IF l_count=0 THEN
	OPEN p_curseur FOR
		select' ',RPAD(' ',36,' ') from dual;
	ELSE
	OPEN p_curseur FOR
		select to_char(etape) ETAPE, RPAD(ECET,2,' ')||' '|| RPAD(LIBETAPE,30,' ')||' '||RPAD(TYPETAPE,2,' ') 		LISTETAPE
		from isac_etape
		where pid=p_pid
		order by ecet;
	END IF;
END lister_isac_etape;
END pack_liste_isac_etape;
/
CREATE OR REPLACE PACKAGE Pack_Liste_Isac_Pid AS

   TYPE RefCurTyp IS REF CURSOR;

   TYPE pid_ListeViewType IS RECORD(
				   	PID	LIGNE_BIP.pid%TYPE,
					PNOM	VARCHAR2(40)
                                         );

   TYPE pid_listeCurType IS REF CURSOR RETURN pid_ListeViewType;

   PROCEDURE lister_isac_pid (
                              	p_userid  IN VARCHAR2,
                              	p_curseur IN OUT RefCurTyp
                             );

   PROCEDURE lister_isac_pid_modif (
                              	p_userid  IN VARCHAR2,
                              	p_curseur IN OUT RefCurTyp
                             );

END Pack_Liste_Isac_Pid ;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Isac_Pid  AS

-- liste des lignes ouvertes sur l'annee pour la liste de CP de l'utilisateur
PROCEDURE lister_isac_pid  (
                         		p_userid  IN VARCHAR2,
                			p_curseur IN OUT RefCurTyp
                             ) IS

l_lst_chefs_projets VARCHAR2(255);
req                               VARCHAR2(800);

BEGIN
	l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;


	      req := ' SELECT pid,pid||'' - ''||l.pnom   '
		         || '	FROM LIGNE_BIP l, DATDEBEX d  '
		         || '	WHERE  l.pcpi IN ('|| l_lst_chefs_projets ||')  '
				 || ' MINUS '
				 || ' SELECT pid,pid||'' - ''||l.pnom   '
				 || ' FROM LIGNE_BIP l, DATDEBEX d  '
				 || '	WHERE  l.pcpi IN ('|| l_lst_chefs_projets ||')  '
				 || ' AND TRUNC(adatestatut,''YEAR'')<TRUNC(d.DATDEBEX,''YEAR'')   '
				 || ' ORDER BY 1 ';

--	             || ' AND (adatestatut > ADD_MONTHS(d.moismens,-1) OR adatestatut IS  NULL ) '
--				 || ' AND ((topfer=''O'' AND TRUNC(adatestatut,''YEAR'')<TRUNC(d.DATDEBEX,''YEAR'')  ) '
--               || ' OR (astatut  IN (''A'',''D'',''C'')  AND TRUNC(adatestatut,''YEAR'')<TRUNC(d.DATDEBEX,''YEAR'') ) ) '


        OPEN p_curseur FOR   req;



END lister_isac_pid ;

-- liste des lignes non fermées depuis un mois pour la liste de CP de l'utilisateur
PROCEDURE lister_isac_pid_modif  (
                         		p_userid  IN VARCHAR2,
                			p_curseur IN OUT RefCurTyp
                             ) IS

l_lst_chefs_projets VARCHAR2(255);
req                               VARCHAR2(800);

BEGIN
	l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;

	  req := ' SELECT pid,pid||'' - ''||l.pnom   '
		         || '	FROM LIGNE_BIP l, DATDEBEX d  '
		         || '	WHERE  l.pcpi IN ('|| l_lst_chefs_projets ||')  '
	             || '   AND (adatestatut > ADD_MONTHS(d.moismens,-1) OR adatestatut IS  NULL ) '
				 || '	ORDER BY 1 ';


        OPEN p_curseur FOR   req;


END lister_isac_pid_modif ;


END Pack_Liste_Isac_Pid ;
/
CREATE OR REPLACE PACKAGE Pack_Liste_Isac_Resscons AS

   TYPE ressource_ListeViewType IS RECORD(
				   	IDENT	VARCHAR2(5),
					LIB	VARCHAR2(50)
                                         );

	 TYPE RefCurTyp IS REF CURSOR;

   TYPE ressource_listeCurType IS REF CURSOR RETURN ressource_ListeViewType;

   PROCEDURE lister_isac_resscons (
                              		p_userid  IN VARCHAR2,
                              		p_curseur IN OUT RefCurTyp
                             );

END Pack_Liste_Isac_Resscons ;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Isac_Resscons AS

PROCEDURE lister_isac_resscons  (
                         		p_userid  IN VARCHAR2,
                			p_curseur IN OUT RefCurTyp
                             ) IS

l_lst_chefs_projets VARCHAR2(600);
req                            VARCHAR2(4000);

BEGIN

	l_lst_chefs_projets := Pack_Global.lire_globaldata(p_userid).chefprojet;


	req := ' SELECT DISTINCT TO_CHAR(r.ident) ,r.rnom||'' - ''||r.ident LIB  '
           || ' FROM SITU_RESS_FULL f, RESSOURCE r, DATDEBEX d  '
		   || ' WHERE f.ident=r.ident '
		   || ' AND (TRUNC(f.datsitu,''YEAR'') <=TRUNC(d.DATDEBEX,''YEAR'') OR f.datsitu IS NULL) '
		   || ' AND (TRUNC(f.datdep,''YEAR'')>=TRUNC(d.DATDEBEX,''YEAR'') OR f.datdep IS NULL) '
		   || ' AND ( f.cpident IN ('|| l_lst_chefs_projets ||')  '
		   || ' OR f.ident IN ('|| l_lst_chefs_projets ||') ) '
		   || ' AND f.type_situ=''N'' '
		   || ' ORDER BY LIB ';



        OPEN p_curseur FOR   req;



END lister_isac_resscons ;
END Pack_Liste_Isac_Resscons;
/
CREATE OR REPLACE PACKAGE pack_liste_isac_restache AS
  TYPE sous_tache_ListeViewType IS RECORD(
				   	SOUS_TACHE VARCHAR2(100),
					LIBELLE	VARCHAR2(500)

                                         );

   TYPE sous_tache_listeCurType IS REF CURSOR RETURN sous_tache_ListeViewType;
PROCEDURE lister_isac_restache( p_ident 	IN VARCHAR2,
                              	p_userid  	IN VARCHAR2,
                              	p_curseur 	IN OUT sous_tache_listeCurType
                             	);
END pack_liste_isac_restache;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_isac_restache AS
PROCEDURE lister_isac_restache( p_ident 	IN VARCHAR2,
                              	p_userid  	IN VARCHAR2,
                              	p_curseur 	IN OUT sous_tache_listeCurType
                             	) IS
l_count number(2);
BEGIN


		OPEN p_curseur FOR
		select et.pid||'-'||st.etape||'-'||st.tache||'-'||st.sous_tache SOUS_TACHE,
		et.pid||' '||et.ecet||'-'||RPAD(SUBSTR(et.libetape,1,25),25,' ')||' '||
		RPAD(et.TYPETAPE,2,' ')||' '||
		ta.acta||'-'||RPAD(SUBSTR(ta.libtache,1,25),25,' ')||
		' '||st.acst||'-'||RPAD(SUBSTR(st.asnom,1,25),25,' ')||
		' ' || RPAD(NVL(st.AIST,' '),6,' ')
		 LIBELLE
		from isac_affectation af, isac_sous_tache st, isac_tache ta, isac_etape et
		where ta.etape=et.etape
		and st.tache=ta.tache
		and af.sous_tache=st.sous_tache
		and af.ident=to_number(p_ident)
		order by et.pid,et.ecet,ta.acta,st.acst;

END lister_isac_restache ;


END pack_liste_isac_restache;
/
CREATE OR REPLACE PACKAGE pack_liste_isac_sous_tache AS

   TYPE sous_tache_ListeViewType IS RECORD(
				   	SOUS_TACHE VARCHAR2(100),
					LIBELLE	VARCHAR2(500)

                                         );

   TYPE sous_tache_listeCurType IS REF CURSOR RETURN sous_tache_ListeViewType;

   PROCEDURE lister_isac_sous_tache( 	p_pid   	IN isac_sous_tache.pid%TYPE,
					p_etape 	IN VARCHAR2,
					p_tache 	IN VARCHAR2,
					p_libetape	IN VARCHAR2,
					p_libtache 	IN VARCHAR2,
                              		p_userid  	IN VARCHAR2,
                              		p_curseur 	IN OUT sous_tache_listeCurType
                             	);

END pack_liste_isac_sous_tache;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_isac_sous_tache AS

PROCEDURE lister_isac_sous_tache( 	p_pid   	IN isac_sous_tache.pid%TYPE,
					p_etape 	IN VARCHAR2,
					p_tache 	IN VARCHAR2,
					p_libetape	IN VARCHAR2,
					p_libtache 	IN VARCHAR2,
                              		p_userid  	IN VARCHAR2,
                              		p_curseur 	IN OUT sous_tache_listeCurType
                             	) IS
l_count number(2);
BEGIN
	select count(*) into l_count
	from isac_sous_tache
	where pid=p_pid
	and etape=to_number(p_etape)
	and tache=to_number(p_tache);

	if l_count=0 then
	OPEN p_curseur FOR
	 select' ',RPAD(' ',65,' ') from dual;
	else
	OPEN p_curseur FOR
	select SOUS_TACHE , RPAD(acst,2,' ')||' '||RPAD(asnom,30,' ')||'   '||RPAD(NVL(aist,' '),6,' ')||' '||
RPAD(NVL(TO_CHAR(ande,'DD/MM/YYYY'),NVL(TO_CHAR(adeb,'DD/MM/YYYY'),' ')),10,' ')||' '||
RPAD(NVL(TO_CHAR(anfi,'DD/MM/YYYY'),NVL(TO_CHAR(afin,'DD/MM/YYYY'),' ')),10,' ')
LIBELLE
	from isac_sous_tache
	where pid=p_pid
	and etape=to_number(p_etape)
	and tache=to_number(p_tache)
	order by acst;
	end if;
END lister_isac_sous_tache;

END pack_liste_isac_sous_tache;
/
CREATE OR REPLACE PACKAGE pack_liste_isac_sstachelb AS


   TYPE sous_tache_ListeViewType IS RECORD(
				   	SOUS_TACHE VARCHAR2(100),
					LIBELLE	VARCHAR2(500)
                                         );

   TYPE sous_tache_listeCurType IS REF CURSOR RETURN sous_tache_ListeViewType;

   PROCEDURE lister_isac_sstachelb( 	p_ident 	IN VARCHAR2,
					p_pid   	IN isac_etape.pid%TYPE,
                              		p_userid  	IN VARCHAR2,
                             		p_curseur 	IN OUT sous_tache_listeCurType
                             	);

   -----------------------------------------------------------------------------------
   -- Cette procedure renvoie un message si une ligne bip n''a aucune de sous tache
   --
   -------------------------------------------------------------------------------------

   PROCEDURE nombre_isac_sstachelb( p_pid   	IN isac_etape.pid%TYPE,
   			 						p_message   IN OUT VARCHAR2
   			 						);


END pack_liste_isac_sstachelb;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_isac_sstachelb AS


PROCEDURE lister_isac_sstachelb( 	p_ident 	IN VARCHAR2,
					p_pid   	IN isac_etape.pid%TYPE,
                              		p_userid  	IN VARCHAR2,
                              		p_curseur 	IN OUT sous_tache_listeCurType
                             	) IS

l_count number;

BEGIN

	select count(*) into l_count
	from isac_sous_tache
	where pid=p_pid;

	if l_count=0 then
		OPEN p_curseur FOR
	 	select' ',RPAD(' ',86,' ') from dual;
	else
		OPEN p_curseur FOR
		select st.etape||'-'||st.tache||'-'||st.sous_tache SOUS_TACHE,
		et.ecet||'-'||RPAD(SUBSTR(et.libetape,1,25),25,' ')||' '||
		RPAD(et.TYPETAPE,2,' ')||' '||ta.acta||'-'||
			RPAD(SUBSTR(ta.libtache,1,25),25,' ')||
		' '||st.acst||'-'||RPAD(SUBSTR(st.asnom,1,25),25,' ')||' '|| RPAD(NVL(st.AIST,' '),6,' ')||' '||
		decode(aff.ident,NULL,'Non','Oui')
		 LIBELLE
		from  isac_affectation aff, isac_sous_tache st, isac_tache ta, isac_etape et
		where aff.sous_tache(+)=st.sous_tache
		and st.tache=ta.tache
		and ta.etape=et.etape
		and et.pid=p_pid
		and aff.ident(+)=to_number(p_ident)
		order by et.ecet,ta.acta,st.acst;

	end if;

END lister_isac_sstachelb;


PROCEDURE nombre_isac_sstachelb( p_pid   	IN isac_etape.pid%TYPE,
   			 						p_message   IN OUT VARCHAR2
   			 					   ) IS
      l_count number;

  BEGIN


	  select count(*) into l_count
	       from isac_sous_tache
	       where pid=p_pid;

	  if l_count=0 then

	      --p_message := 'Veuillez créer une sous-tâche pour cette ligne : '||p_pid;
		  pack_global.recuperer_message(21028, '%s1', p_pid, NULL, p_message);

	  end if;



  END nombre_isac_sstachelb;


END pack_liste_isac_sstachelb;
/
CREATE OR REPLACE PACKAGE pack_liste_isac_tache AS

   TYPE tache_ListeViewType IS RECORD(
				   	TACHE		VARCHAR2(100),
					LISTTACHE 	VARCHAR2(255)

                                         );

   TYPE tache_listeCurType IS REF CURSOR RETURN tache_ListeViewType;

   PROCEDURE lister_isac_tache( p_pid     IN isac_tache.pid%TYPE,
				p_etape   IN VARCHAR2,
                              	p_userid  IN VARCHAR2,
                              	p_curseur IN OUT tache_listeCurType
                             );

END pack_liste_isac_tache;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_isac_tache AS

PROCEDURE lister_isac_tache( 	p_pid   	IN isac_tache.pid%TYPE,
				p_etape 	IN VARCHAR2,
                         	p_userid  	IN VARCHAR2,
                		p_curseur 	IN OUT tache_listeCurType
                             ) IS
l_count number(2);
BEGIN
	select count(*) into l_count
	from isac_tache
	where etape=to_number(p_etape);

	if l_count=0 then
	OPEN p_curseur FOR
	 select' ',RPAD(' ',33,' ') from dual;
	else
	OPEN p_curseur FOR
		select to_char(tache) TACHE,RPAD(ACTA,2,' ')||' '|| RPAD(LIBTACHE,30,' ') LISTACHE
		from isac_tache
		where etape=to_number(p_etape)
		order by acta;
	end if;
END lister_isac_tache;
END pack_liste_isac_tache;
/
CREATE OR REPLACE PACKAGE pack_liste_isac_tachelb AS

   TYPE tache_ListeViewType IS RECORD(
				   	TACHE		VARCHAR2(100),
					LISTTACHE 	VARCHAR2(255)

                                         );

   TYPE tache_listeCurType IS REF CURSOR RETURN tache_ListeViewType;

   PROCEDURE lister_isac_tachelb(p_pid     IN isac_tache.pid%TYPE,
                              	 p_userid  IN VARCHAR2,
                              	 p_curseur IN OUT tache_listeCurType
                             );

END pack_liste_isac_tachelb;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_isac_tachelb AS

PROCEDURE lister_isac_tachelb( 	p_pid     IN isac_tache.pid%TYPE,
                         	p_userid  IN VARCHAR2,
                		p_curseur IN OUT tache_listeCurType
                             ) IS

l_count number;
BEGIN
	select count(*) into l_count
	from isac_tache t, isac_etape e
	where  t.etape=e.etape
	and t.pid=p_pid;

	IF l_count=0 THEN
	OPEN p_curseur FOR
		select' ',RPAD(' ',67,' ') from dual;
	ELSE

	OPEN p_curseur FOR
	select to_char(e.etape)||'-'||to_char(t.tache) TACHE,
RPAD(e.ecet,2,' ') ||'-'||RPAD(e.libetape,30,' ')||' '||RPAD(t.acta,2,' ')||'-'|| RPAD(t.libtache,30,' ') LISTACHE
	from isac_tache t, isac_etape e
	where  t.etape=e.etape
	and t.pid=p_pid
	order by e.ecet,t.acta;

	END IF;
END lister_isac_tachelb;
END pack_liste_isac_tachelb;
/
CREATE OR REPLACE PACKAGE pack_liste_isac_tachelb_copier AS

       TYPE sous_tache_ListeViewType IS RECORD(
                                        SOUS_TACHE VARCHAR2(100),
                                        LIBELLE VARCHAR2(500)
                                         );

       TYPE sous_tache_listeCurType IS REF CURSOR RETURN sous_tache_ListeViewType;

       -- liste des sous-taches à copier
       PROCEDURE lister_isac_sstachelb_copier(
                                    	p_pid_src   	IN VARCHAR2,
                                        p_userid        IN VARCHAR2,
                                        p_curseur       IN OUT sous_tache_listeCurType
                                );

       --liste des taches ou sera collee la sous-tache choisie
       PROCEDURE lister_isac_sstachelb_coller(
                                        p_pid_dest      IN VARCHAR2,
                                        p_userid        IN VARCHAR2,
                                        p_curseur       IN OUT sous_tache_listeCurType
                                );

END pack_liste_isac_tachelb_copier;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_isac_tachelb_copier AS
       PROCEDURE lister_isac_sstachelb_copier(
                                    p_pid_src   IN VARCHAR2,
                                    p_userid    IN VARCHAR2,
                                    p_curseur   IN OUT sous_tache_listeCurType
                                ) IS
       l_count number;

       BEGIN

        select count(*) into l_count
        from isac_sous_tache
        where pid=p_pid_src;

        if l_count=0 then
                OPEN p_curseur FOR
                select' ',RPAD(' ',86,' ') from dual;
        else
                OPEN p_curseur FOR
                select st.etape||'-'||st.tache||'-'||st.sous_tache "SOUS_TACHE",
                et.ecet||'-'||RPAD(SUBSTR(et.libetape,1,25),25,' ')||' '||ta.acta||'-'||
                        RPAD(SUBSTR(ta.libtache,1,25),25,' ')||
                ' '||st.acst||'-'||RPAD(SUBSTR(st.asnom,1,25),25,' ') "LIBELLE"
                from  isac_sous_tache st, isac_tache ta, isac_etape et
                where st.tache=ta.tache
                and ta.etape=et.etape
                and et.pid=p_pid_src
                order by et.ecet,ta.acta,st.acst;
        end if;

      END lister_isac_sstachelb_copier;

      PROCEDURE lister_isac_sstachelb_coller(
                                    p_pid_dest  IN VARCHAR2,
                                    p_userid    IN VARCHAR2,
                                    p_curseur   IN OUT sous_tache_listeCurType
                                ) IS
       l_count number;

       BEGIN

        select count(*) into l_count
        from isac_tache
        where pid=p_pid_dest;

        if l_count=0 then
                OPEN p_curseur FOR
                select' ',RPAD(' ',86,' ') from dual;
        else
                OPEN p_curseur FOR
                select ta.etape||'-'||ta.tache "TACHE",
                et.ecet||'-'||RPAD(SUBSTR(et.libetape,1,25),25,' ')||' '||ta.acta||'-'||
                        RPAD(SUBSTR(ta.libtache,1,25),25,' ') "LIBELLE"
                from  isac_tache ta, isac_etape et
                where ta.etape=et.etape
                and et.pid=p_pid_dest
                order by et.ecet,ta.acta;
        end if;

      END lister_isac_sstachelb_coller;


END pack_liste_isac_tachelb_copier;
/
CREATE OR REPLACE PACKAGE pack_liste_isac_total_mois AS
Function f_get_total_mois ( p_ident IN VARCHAR2,
			    p_mois IN VARCHAR2
			)  return VARCHAR2  ;
PRAGMA restrict_references(f_get_total_mois,wnds,wnps);

Function f_get_nbjour_mois (  p_mois IN VARCHAR2
			)  return Number ;
PRAGMA restrict_references(f_get_nbjour_mois,wnds,wnps);

 TYPE conso_ListeViewType IS RECORD(    TOT_MOIS_1 	VARCHAR2(10),
					TOT_MOIS_2	VARCHAR2(10),
					TOT_MOIS_3 	VARCHAR2(10),
					TOT_MOIS_4 	VARCHAR2(10),
					TOT_MOIS_5 	VARCHAR2(10),
					TOT_MOIS_6 	VARCHAR2(10),
					TOT_MOIS_7	VARCHAR2(10),
					TOT_MOIS_8	VARCHAR2(10),
					TOT_MOIS_9 	VARCHAR2(10),
					TOT_MOIS_10 	VARCHAR2(10),
					TOT_MOIS_11	VARCHAR2(10),
					TOT_MOIS_12	VARCHAR2(10),
					TOTAL		VARCHAR2(10),
					NBJOUR_1 	isac_consomme.cusag%TYPE,
					NBJOUR_2	isac_consomme.cusag%TYPE,
					NBJOUR_3 	isac_consomme.cusag%TYPE,
					NBJOUR_4 	isac_consomme.cusag%TYPE,
					NBJOUR_5 	isac_consomme.cusag%TYPE,
					NBJOUR_6 	isac_consomme.cusag%TYPE,
					NBJOUR_7	isac_consomme.cusag%TYPE,
					NBJOUR_8	isac_consomme.cusag%TYPE,
					NBJOUR_9 	isac_consomme.cusag%TYPE,
					NBJOUR_10 	isac_consomme.cusag%TYPE,
					NBJOUR_11	isac_consomme.cusag%TYPE,
					NBJOUR_12	isac_consomme.cusag%TYPE
                                   );

   TYPE conso_listeCurType IS REF CURSOR RETURN conso_ListeViewType;


   PROCEDURE lister_isac_total_mois( 	p_ident    IN VARCHAR2,
                              		p_userid   IN VARCHAR2,
                              		p_curseur  IN OUT conso_listeCurType
                             	  );


END pack_liste_isac_total_mois;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_isac_total_mois AS

Function f_get_total_mois ( p_ident IN VARCHAR2,
			  p_mois IN VARCHAR2
			)  return VARCHAR2  IS

l_total NUMBER;
BEGIN
	select sum(cusag) into l_total
	from isac_consomme
	where ident=to_number(p_ident)
	and  to_char(cdeb,'MM/YYYY')=p_mois;

	if (l_total<1 and l_total>0) then
		return to_char(l_total,'FM9990D99');
	else
		return to_char(l_total);
	end if;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		Return '0';


END f_get_total_mois;

Function f_get_nbjour_mois (  p_mois IN VARCHAR2
			)  return Number  IS

l_nbjour NUMBER;
BEGIN
	select cjours into l_nbjour from calendrier
	where calanmois= to_date('01'||p_mois);

	Return l_nbjour ;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		Return 0;


END f_get_nbjour_mois;




   PROCEDURE lister_isac_total_mois( 	p_ident    IN VARCHAR2,
                              		p_userid   IN VARCHAR2,
                              		p_curseur  IN OUT conso_listeCurType
                             	) IS
l_anneecourante VARCHAR2(4);
l_annee date;
  BEGIN
	select to_char(datdebex,'YYYY'),datdebex into  l_anneecourante,l_annee
	from datdebex;

  	OPEN p_curseur FOR
	select f_get_total_mois(max(c.ident), '01/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_1,
	f_get_total_mois(max(c.ident), '02/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_2,
	f_get_total_mois(max(c.ident), '03/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_3,
	f_get_total_mois(max(c.ident), '04/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_4,
	f_get_total_mois(max(c.ident), '05/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_5,
	f_get_total_mois(max(c.ident), '06/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_6,
	f_get_total_mois(max(c.ident), '07/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_7,
	f_get_total_mois(max(c.ident), '08/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_8,
	f_get_total_mois(max(c.ident), '09/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_9,
	f_get_total_mois(max(c.ident), '10/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_10,
	f_get_total_mois(max(c.ident), '11/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_11,
	f_get_total_mois(max(c.ident), '12/'||to_char(min(cdeb),'YYYY')) TOT_MOIS_12,
	to_char(sum(cusag)) TOTAL,
	pack_liste_isac_total_mois.f_get_nbjour_mois('01/'||l_anneecourante) NBJOUR_1,
	pack_liste_isac_total_mois.f_get_nbjour_mois('02/'||l_anneecourante) NBJOUR_2,
	pack_liste_isac_total_mois.f_get_nbjour_mois('03/'||l_anneecourante) NBJOUR_3,
	pack_liste_isac_total_mois.f_get_nbjour_mois('04/'||l_anneecourante) NBJOUR_4,
	pack_liste_isac_total_mois.f_get_nbjour_mois('05/'||l_anneecourante) NBJOUR_5,
	pack_liste_isac_total_mois.f_get_nbjour_mois('06/'||l_anneecourante) NBJOUR_6,
	pack_liste_isac_total_mois.f_get_nbjour_mois('07/'||l_anneecourante) NBJOUR_7,
 	pack_liste_isac_total_mois.f_get_nbjour_mois('08/'||l_anneecourante) NBJOUR_8,
	pack_liste_isac_total_mois.f_get_nbjour_mois('09/'||l_anneecourante) NBJOUR_9,
 	pack_liste_isac_total_mois.f_get_nbjour_mois('10/'||l_anneecourante) NBJOUR_10,
	pack_liste_isac_total_mois.f_get_nbjour_mois('11/'||l_anneecourante) NBJOUR_11,
 	pack_liste_isac_total_mois.f_get_nbjour_mois('12/'||l_anneecourante) NBJOUR_12
	from isac_consomme c , isac_affectation a
	where c.ident=to_number(p_ident)
	and trunc(c.cdeb,'YEAR')=trunc(l_annee,'YEAR')
	and c.ident=a.ident(+)
	and c.pid=a.pid(+)
	and c.etape=a.etape(+)
	and c.tache=a.tache(+)
	and c.sous_tache=a.sous_tache(+);

  END lister_isac_total_mois;


END pack_liste_isac_total_mois;
/
CREATE OR REPLACE PACKAGE pack_liste_lignes_fact AS

   TYPE lignes_fact_Type IS RECORD (clelf    VARCHAR2(71),
                                    liste    VARCHAR2(57));

   TYPE lignes_fact_Cur  IS REF CURSOR RETURN lignes_fact_Type;

   PROCEDURE lister_lignes_fact (p_socfact IN ligne_fact.socfact%TYPE,
                                 p_typfact IN ligne_fact.typfact%TYPE,
                              	 p_datfact IN VARCHAR2,
                              	 p_numfact IN ligne_fact.numfact%TYPE,
                              	 p_soccont IN contrat.soccont%TYPE,
                              	 p_cav     IN contrat.cav%TYPE,
                               	 p_numcont IN contrat.numcont%TYPE,
                              	 p_rnom    IN ressource.rnom%TYPE,
                              	 p_userid  IN VARCHAR2,
                              	 p_curseur IN OUT lignes_fact_Cur
                             );

   PROCEDURE xcle_ligne_fact  (c_clelf       IN VARCHAR2,  -- cle lister ligne facture
                               c_flaglib     IN NUMBER,    -- flag retourner valeur avec libellé ou non
                               c_lnum           OUT VARCHAR2,
                               c_ident          OUT VARCHAR2,
                               c_rnom           OUT VARCHAR2,
                               c_rprenom        OUT VARCHAR2,
                               c_lmontht        OUT VARCHAR2,
                               c_lmoisprest     OUT VARCHAR2,
                               c_lcodcompta     OUT VARCHAR2
                              );
        -- La clé à extraire est longue de 70 car maxi et composée de
        -- lf.lnum(2);lf.ident(5);r.rnom(20);r.rprenom(15);lf.lmontht(11);lf.lmoisprest(7);lf.lcodcompta(11)


END pack_liste_lignes_fact;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_lignes_fact IS

-- **************************************************************************************
-- **************************************************************************************
--
--  lister_lignes_fact
-- La clelf est longue de 70 car maxi et la liste 57 car/ligne
--
-- **************************************************************************************
-- **************************************************************************************

   PROCEDURE lister_lignes_fact (p_socfact IN ligne_fact.socfact%TYPE,
                              	 p_typfact IN ligne_fact.typfact%TYPE,
                              	 p_datfact IN VARCHAR2,
                              	 p_numfact IN ligne_fact.numfact%TYPE,
                              	 p_soccont IN contrat.soccont%TYPE,
                              	 p_cav     IN contrat.cav%TYPE,
                              	 p_numcont IN contrat.numcont%TYPE,
                              	 p_rnom    IN ressource.rnom%TYPE,
                              	 p_userid  IN VARCHAR2,
                              	 p_curseur IN OUT lignes_fact_Cur
                             ) IS

    l_filcode filiale_cli.filcode%TYPE;

    BEGIN

        -- On recupere le code filiale et on prepare numcont et rnom en template
        l_filcode := pack_global.lire_globaldata(p_userid).filcode;

--  DBMS_OUTPUT.PUT_LINE('DEBUT ;' || p_socfact || ';' || p_typfact || ';' || p_datfact || ';' || p_numfact );

        -- La cle a retourner est longue de 70 car maxi et composée de
        -- lf.lnum(2);lf.ident(5);r.rnom(20);r.rprenom(15);lf.lmontht(11);lf.lmoisprest(7);lf.lcodcompta(11)

        OPEN p_curseur FOR
        SELECT (TO_CHAR(lf.lnum,'FM99') || ';' || to_char(lf.ident,'FM99999') || ';' || r.rnom || ';'
               || r.rprenom || ';' || TO_CHAR(lf.lmontht,'FM99999990D00') || ';'
               || TO_CHAR(lf.lmoisprest,'MM/YYYY') || ';' || lf.lcodcompta) as Clelf,
               (RPAD(TO_CHAR(lf.ident,'FM99999'),5,' ') ||
               '  ' || NVL(RPAD(r.rnom,20),'                    ') ||
               '  ' || NVL(RPAD(r.rprenom,15),'               ') ||
               ' ' || TO_CHAR(nvl(lf.lmontht,0),'99999990D00') ) as "Liste Lignes de Facture"
        FROM ligne_fact lf, ressource r
        WHERE   lf.ident   = r.ident
            AND lf.socfact = p_socfact
            AND lf.typfact = p_typfact
            AND lf.datfact = to_date(p_datfact,'dd/mm/yyyy')
            AND lf.numfact = RPAD(p_numfact,15);

--        DBMS_OUTPUT.PUT_LINE('APRES SELECT') ;

   END lister_lignes_fact;


-- **************************************************************************************
-- **************************************************************************************
--
--  XCLE_LIGNE_FACT : retourne les infos de lignes facture
--                    contenues dans clelf de lister_lignes_fact
--         lf.lnum(2);lf.ident(5);r.rnom(20);r.rprenom(15)
--         ;lf.lmontht(11);lf.lmoisprest(7);lf.lcodcompta(11)
-- La clelf est longue de 70 car maxi
--
-- **************************************************************************************
-- **************************************************************************************

   PROCEDURE xcle_ligne_fact  (c_clelf       IN VARCHAR2,      -- cle lister ligne facture
                               c_flaglib     IN NUMBER,
                               c_lnum           OUT VARCHAR2,
                               c_ident          OUT VARCHAR2,
                               c_rnom           OUT VARCHAR2,
                               c_rprenom        OUT VARCHAR2,
                               c_lmontht        OUT VARCHAR2,
                               c_lmoisprest     OUT VARCHAR2,
                               c_lcodcompta     OUT VARCHAR2
                              ) IS
   pos1   integer;
   pos2   integer;
   pos3   integer;
   pos4   integer;
   pos5   integer;
   pos6   integer;
   lgth   integer;

   BEGIN
        pos1 := INSTR( c_clelf, ';', 1, 1);
        pos2 := INSTR( c_clelf, ';', 1, 2);
        pos3 := INSTR( c_clelf, ';', 1, 3);
        pos4 := INSTR( c_clelf, ';', 1, 4);
        pos5 := INSTR( c_clelf, ';', 1, 5);
        pos6 := INSTR( c_clelf, ';', 1, 6);
        lgth := LENGTH( c_clelf);
DBMS_OUTPUT.PUT_LINE('longueur:'||lgth);
	IF c_flaglib = 1  THEN
        c_lnum       :=  substr( c_clelf, 1, pos1-1);
        c_ident      :=  substr( c_clelf, pos1+1, pos2-pos1-1);
        c_rnom       :=  substr( c_clelf, pos2+1, pos3-pos2-1);
        c_rprenom    :=  substr( c_clelf, pos3+1, pos4-pos3-1);
        c_lmontht    :=  substr( c_clelf, pos4+1, pos5-pos4-1);
        c_lmoisprest :=  substr( c_clelf, pos5+1, pos6-pos5-1);
DBMS_OUTPUT.PUT_LINE('moisprest:'||c_lmoisprest||',code comp:'|| substr( c_clelf, pos6+1, lgth-pos6));
        c_lcodcompta :=  substr( c_clelf, pos6+1, lgth-pos6);
		ELSE
        c_lnum       := substr( c_clelf, 1, pos1-1);
        c_ident      := substr( c_clelf, pos1+1, pos2-pos1-1);
        c_rnom       := substr( c_clelf, pos2+1, pos3-pos2-1);
        c_rprenom    := substr( c_clelf, pos3+1, pos4-pos3-1);
        c_lmontht    := substr( c_clelf, pos4+1, pos5-pos4-1);
        c_lmoisprest := substr( c_clelf, pos5+1, pos6-pos5-1);
DBMS_OUTPUT.PUT_LINE('moisprest:'||c_lmoisprest );
        c_lcodcompta := substr( c_clelf, pos6+1, lgth-pos6);
		END IF;


   END xcle_ligne_fact;


END pack_liste_lignes_fact;
/
CREATE OR REPLACE PACKAGE pack_liste_metier AS

   TYPE metier_ListeViewType IS RECORD( id      ligne_bip.metier%TYPE,
					libelle metier.libmetier%TYPE
                                        );

   TYPE metier_listeCurType IS REF CURSOR RETURN metier_ListeViewType;

   PROCEDURE lister_metier(p_userid  IN VARCHAR2,
                           p_curseur IN OUT metier_listeCurType
                          );
   PROCEDURE lister_metier_tous(p_userid  IN VARCHAR2,
                           p_curseur IN OUT metier_listeCurType
                          );

END pack_liste_metier;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_metier AS

   PROCEDURE lister_metier (p_userid  IN VARCHAR2,
                            p_curseur IN OUT metier_listeCurType
                           ) IS
   BEGIN

      OPEN p_curseur FOR
      	SELECT '','   '
	FROM dual
	UNION
	SELECT RPAD(metier,3,' ') ,
             libmetier
	FROM metier
	ORDER BY 1 DESC;

   END lister_metier;

   PROCEDURE lister_metier_tous (p_userid  IN VARCHAR2,
                            p_curseur IN OUT metier_listeCurType
                           ) IS
   BEGIN

      OPEN p_curseur FOR
	SELECT 	' TOUS' metier,
  		'Tous' libmetier
  	FROM dual
  	UNION
      	SELECT '','   '
	FROM dual
	UNION
	SELECT RPAD(metier,3,' ') ,
             libmetier
	FROM metier
	ORDER BY 1 DESC;

   END lister_metier_tous;

END pack_liste_metier;
/
CREATE OR REPLACE PACKAGE pack_liste_moproposes AS
-- Majuscule pour javascript qui utilise le nom des colonnes pour l'automates.

   TYPE moproposes_ListeViewType IS RECORD(CLICODE    ligne_bip.clicode%TYPE,
					  PID        ligne_bip.pid%TYPE,
                                          PNOM       ligne_bip.pnom%TYPE,
                                          FLAGLOCK   VARCHAR2(20),
                                          CODSG      VARCHAR2(20),
                                          BPMONTMO    VARCHAR2(20)
                                         );

   TYPE moproposes_listeCurType IS REF CURSOR RETURN moproposes_ListeViewType;

   PROCEDURE lister_moproposes( p_clicode   IN VARCHAR2,
			      p_annee   IN VARCHAR2,
                              p_userid  IN VARCHAR2,
                              p_curseur IN OUT moproposes_listeCurType
                             );

END pack_liste_moproposes;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_moproposes AS
PROCEDURE lister_moproposes(  p_clicode IN VARCHAR2,
			      p_annee   IN VARCHAR2,
                              p_userid  IN VARCHAR2,
                              p_curseur IN OUT moproposes_listeCurType
                             ) IS


   l_pid ligne_bip.pid%TYPE;
  -- l_codsg varchar2(10);

   BEGIN

		OPEN p_curseur FOR
		SELECT RTRIM(LTRIM( bip.clicode)) as CLICODE,
		      		bip.pid as PID,
                      		SUBSTR(bip.pnom,1,20) as PNOM,
                      		TO_CHAR(budg.flaglock) as FLAGLOCK,
                      		TO_CHAR(bip.codsg, 'FM0000000') as CODSG,
                      		TO_CHAR(budg.bpmontmo, 'FM9999999990D00') as BPMONTMO
            	FROM      budget budg, ligne_bip bip,datdebex
             	WHERE    bip.clicode = p_clicode
		AND      budg.annee (+)= TO_NUMBER(p_annee)
             	AND      budg.pid (+)= bip.pid
		AND     ((bip.adatestatut is null) OR (to_number(to_char(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
		ORDER BY   bip.clicode ||bip.pid ;



  END lister_moproposes;

END pack_liste_moproposes;
/
CREATE OR REPLACE PACKAGE pack_liste_niveau AS

   PROCEDURE lister_niveau(p_userid  IN VARCHAR2,
                             p_curseur IN OUT pack_liste_dynamique.liste_dyn
                            );

END pack_liste_niveau;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_niveau AS

----------------------------------- SELECT -----------------------------------
   PROCEDURE lister_niveau (p_userid  IN VARCHAR2,
                              p_curseur IN OUT pack_liste_dynamique.liste_dyn
                             ) IS
   BEGIN

      OPEN p_curseur FOR
      SELECT '',
             ' '
      FROM dual
    UNION
      SELECT
           niveau,
           libniveau
      FROM niveau
      ORDER BY 2;

   EXCEPTION
      WHEN OTHERS THEN
        raise_application_error(-20997, SQLERRM);

   END lister_niveau;

END pack_liste_niveau;
/
CREATE OR REPLACE PACKAGE pack_liste_parametre AS

   TYPE parametre_ListeViewType IS RECORD(	CLE			parametre.CLE%TYPE,
   											LIBELLE		parametre.LIBELLE%TYPE);

   TYPE parametre_listeCurType IS REF CURSOR RETURN parametre_ListeViewType;

   PROCEDURE lister_parametre( p_curseur IN OUT parametre_listeCurType );

END pack_liste_parametre;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_parametre AS

   PROCEDURE lister_parametre (p_curseur IN OUT parametre_listeCurType ) IS
   BEGIN

      OPEN p_curseur FOR
        SELECT
       		cle,
       		libelle
        FROM
        	parametre
        ORDER BY Libelle;

   END lister_parametre;



END pack_liste_parametre;
/
CREATE OR REPLACE PACKAGE pack_liste_pole AS

   PROCEDURE lister_pole( p_userid   IN VARCHAR2,
                          p_curseur  IN OUT pack_liste_dynamique.liste_dyn
                        );

END pack_liste_pole;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_pole AS

----------------------------------- SELECT -----------------------------------

   PROCEDURE lister_pole( p_userid   IN VARCHAR2,
                          p_curseur  IN OUT pack_liste_dynamique.liste_dyn
                        ) IS

   l_pole      VARCHAR2(25);
   l_perime    VARCHAR2(255);
   BEGIN
	l_pole := SUBSTR(LPAD(pack_global.lire_globaldata(p_userid).codpole, 7, '0'), 1, 5);
	l_perime := pack_global.lire_globaldata(p_userid).perime;


	IF l_pole  = '00000' THEN 	-- Tous les départements et pôles
	    OPEN p_curseur FOR
		SELECT *
		FROM
		   (
		   -- ----------------------------------------------------------------------
		   -- Liste de tous les departements/poles (XXXXX)
		   -- ----------------------------------------------------------------------
		   SELECT DISTINCT
			substr(to_char(codsg,'FM0000000'),1,5) AS code,
			substr(to_char(codsg,'FM0000000'),1,5)  || ' - '  ||
			sigdep                                 || '/'    ||
			sigpole
		   FROM
			struct_info
		   WHERE
			codsg > 1 and topfer like 'O'
		   -- -----
		   UNION
		   -- -----
   		   -- ----------------------------------------------------------------------
		   -- Liste de tous les departements (XXX**)
		   -- ----------------------------------------------------------------------
		   SELECT DISTINCT
			substr(to_char(codsg,'FM0000000'),1,3) || '00'  AS code,
			substr(to_char(codsg,'FM0000000'),1,3) || '00'   || ' - '  ||
			rpad(sigdep,6,' ')
		   FROM
			struct_info
		   WHERE
			codsg > 1 and topfer like 'O'
		   -- -----
		   UNION
		   -- -----
   		   -- ----------------------------------------------------------------------
		   -- Code special '00000'
		   -- ----------------------------------------------------------------------
		   SELECT
			'00000' AS code,
			'00000' || ' - ' || rpad('Tous',6,' ')
		   FROM
			dual
		   );

	ELSE	-- liste des dépt et pôles du périmètre ME de l'utilisateur
	   OPEN p_curseur FOR
		SELECT *
		FROM (
		   -- Pôles
		   	SELECT DISTINCT SUBSTR(TO_CHAR(me.codsg, 'FM0000000'), 1, 5) AS code,
		   			SUBSTR(TO_CHAR(me.codsg, 'FM0000000'), 1, 5) || ' - ' ||
		   			  sigdep                                     || '/'   ||
		   			  sigpole
		   	FROM    struct_info s,
		   		vue_dpg_perime me
		   	WHERE	s.codsg = me.codsg
		   	    AND s.topfer LIKE 'O'
		   	    AND INSTR(l_perime, me.codbddpg) > 0
		   	    AND me.codhabili IN ('bip', 'br', 'dir', 'dpt', 'pole')
		   UNION
		   -- Départements
		   	SELECT DISTINCT SUBSTR(TO_CHAR(me.codsg, 'FM0000000'), 1, 3) || '00' AS code,
		   			SUBSTR(TO_CHAR(me.codsg, 'FM0000000'), 1, 3) || '00' || ' - ' ||
		   			  RPAD(sigdep, 6, ' ')
		   	FROM    struct_info s,
		   		vue_dpg_perime me
		   	WHERE	s.codsg = me.codsg
		   	    AND s.topfer LIKE 'O'
		   	    AND INSTR(l_perime, me.codbddpg) > 0
		   	    AND me.codhabili IN ('bip', 'br', 'dir', 'dpt')
		);
	END IF;
   END lister_pole;

END pack_liste_pole;
/
CREATE OR REPLACE PACKAGE pack_liste_profil AS


   TYPE profil_ListeViewType IS RECORD( id      lien_profil_actu.code_profil%TYPE,
   										filler lien_profil_actu.code_profil%TYPE );
   TYPE profil_listeCurType IS REF CURSOR RETURN profil_ListeViewType;


  PROCEDURE lister_profil_actu(	p_userid  IN VARCHAR2,
  								p_code_actu  IN VARCHAR2,
                           		p_curseur IN OUT profil_listeCurType );

END pack_liste_profil;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_profil AS


   PROCEDURE lister_profil_actu (	p_userid  IN VARCHAR2,
   									p_code_actu  IN VARCHAR2,
                            		p_curseur IN OUT profil_listeCurType)
	IS
	BEGIN
		OPEN
			p_curseur
		FOR
      	SELECT
      		code_profil,
            code_profil
	FROM
		lien_profil_actu
    where
    	code_actu = to_number(p_code_actu)
	ORDER BY 2;

   END lister_profil_actu;

END pack_liste_profil;
/
CREATE OR REPLACE PACKAGE     pack_liste_proj_info AS

TYPE lib_ListeViewType IS RECORD(    	ICPI	CHAR(5),
					LIB	VARCHAR2(50)
                                         );

   TYPE lib_listeCurType IS REF CURSOR RETURN lib_ListeViewType;
   -- liste des projets pour un dossier projet donné
   PROCEDURE lister_projet(	p_userid   IN 	  VARCHAR2,
   				p_dpcode   IN 	  VARCHAR2,
             	       		p_curseur  IN OUT lib_listeCurType
            );

   -- Liste des projets pour un dossier projet donné par ordre alphabétique
   PROCEDURE lister_projet_alpha(	p_userid   IN 	  VARCHAR2,
   					p_dpcode   IN 	  VARCHAR2,
             	       			p_curseur  IN OUT lib_listeCurType
            );

   -- Liste des projets pour le menu référentiel
   PROCEDURE lister_projet_ref(	p_userid   IN 	  VARCHAR2,
             	       		p_curseur  IN OUT lib_listeCurType
            );

    -- Liste des projets pour un dossier projet (notification)
   PROCEDURE lister_projet_notif(	p_userid   IN 	  VARCHAR2,
   					p_dpcode   IN 	  VARCHAR2,
             	       			p_curseur  IN OUT lib_listeCurType
            );

END pack_liste_proj_info;
/

CREATE OR REPLACE PACKAGE BODY     pack_liste_proj_info AS

PROCEDURE lister_projet(	p_userid   IN 	  VARCHAR2,
   				p_dpcode   IN 	  VARCHAR2,
             	       		p_curseur  IN OUT lib_listeCurType
            ) IS
BEGIN
  -- Si le code DP est = à 70000 on retourne tous les projets actifs
  IF TO_NUMBER(p_dpcode) = 70000 THEN
  	OPEN p_curseur FOR

  	    -- La première ligne est vide
  	    SELECT 	'' icpi,
  	    		' ' LIB
  	    FROM dual
  	    UNION
	    SELECT DISTINCT  pi.icpi,
	    		     'DP ' || TO_CHAR(pi.icodproj, 'FM00000') ||' - ' || pi.icpi ||' - ' || ltrim(rtrim(pi.ilibel))  LIB
	    FROM proj_info pi, dossier_projet dp
	    WHERE dp.dpcode = pi.icodproj
	      AND (pi.statut IS NULL OR pi.statut='O' OR pi.statut='N')
	      AND dp.actif = 'O'
	      AND dp.dpcode != 0
	    ORDER BY LIB;


  -- Sinon on renvoie la liste des projets actifs pour le dossier projet
  ELSE
	OPEN p_curseur FOR
  	    -- La première ligne est vide
  	    SELECT 	'' icpi,
  	    		' ' LIB
  	    FROM dual
  	    UNION
	    SELECT DISTINCT  icpi,
	    		     icpi ||' - ' || ltrim(rtrim(ilibel))  LIB
	    FROM proj_info
	    WHERE icodproj = TO_NUMBER(p_dpcode)
	      AND (statut IS NULL OR statut='O' OR statut='N')
	    ORDER BY LIB;

  END IF;

EXCEPTION WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);

END lister_projet;


PROCEDURE lister_projet_alpha(	p_userid   IN 	  VARCHAR2,
   				p_dpcode   IN 	  VARCHAR2,
             	       		p_curseur  IN OUT lib_listeCurType
            ) IS
BEGIN

	OPEN p_curseur FOR
  	    -- La première ligne est vide
  	    SELECT 	'' icpi,
  	    		' ' LIB
  	    FROM dual
  	    UNION
	    SELECT DISTINCT  icpi,
	    		     ltrim(rtrim(ilibel)) ||' - ' || icpi LIB
	    FROM proj_info
	    WHERE icodproj = TO_NUMBER(p_dpcode)
	      AND (statut IS NULL OR statut='O' OR statut='N')
	    ORDER BY LIB;

EXCEPTION WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);

END lister_projet_alpha;

-- Liste des projets pour le menu référentiel
PROCEDURE lister_projet_ref(	p_userid   IN 	  VARCHAR2,
             	       		p_curseur  IN OUT lib_listeCurType) IS
l_doss_proj 	VARCHAR2(255);
l_projet	VARCHAR2(255);
BEGIN
   l_doss_proj := pack_global.lire_doss_proj(p_userid);
   l_projet    := pack_global.lire_projet(p_userid);

   IF (l_projet IS NULL) AND (l_doss_proj IS NULL) THEN
   	OPEN p_curseur FOR
        	-- Ligne vide
        	SELECT '' CODE,
        	       '' LIB
        	FROM DUAL;

   ELSIF (INSTR(UPPER(l_doss_proj), 'TOUS') > 0) OR (INSTR(UPPER(l_projet), 'TOUS') > 0) THEN

	OPEN p_curseur FOR
  	    -- La première ligne est "Tous"
  	    SELECT 	' TOUS' icpi,
  	    		'Tous' LIB
  	    FROM dual
  	    -- La seconde liste est la liste des projets actifs
  	    UNION
	    SELECT  	icpi,
	    	     	icpi ||' - ' ||ltrim(rtrim(ilibel)) LIB
	    FROM proj_info, datdebex
	    WHERE (datdem IS NULL OR datdem > datdebex)
	    ORDER BY icpi;
   ELSE
	OPEN p_curseur FOR
  	    -- La première ligne est "Tous"
  	    SELECT 	' TOUS' icpi,
  	    		'Tous' LIB
  	    FROM dual
  	    -- La seconde liste est la liste des projets de l'habilitation
  	    UNION
	    SELECT  	icpi,
	    	     	icpi ||' - ' ||ltrim(rtrim(ilibel)) LIB
	    FROM proj_info, datdebex
	    WHERE (datdem IS NULL OR datdem > datdebex)
	      AND INSTR(l_projet, icpi) > 0
	    -- La troisieme liste est la liste des projets rattachés au dossiers_projets de l'habilitation
	    UNION
	    SELECT  	pi.icpi,
	    	     	pi.icpi ||' - ' ||ltrim(rtrim(pi.ilibel)) LIB
	    FROM proj_info pi, ligne_bip lb, datdebex d
	    WHERE pi.icpi = lb.icpi
	      AND ((pi.datdem IS NULL) OR (pi.datdem >= d.datdebex))
	      AND ((lb.adatestatut IS NULL) OR (lb.adatestatut >= d.datdebex))
	      AND INSTR(l_doss_proj, TO_CHAR(lb.dpcode, 'FM00000')) > 0
	    ORDER BY icpi;
   END IF;
EXCEPTION
	WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);
END lister_projet_ref;

PROCEDURE lister_projet_notif(	p_userid   IN 	  VARCHAR2,
   				p_dpcode   IN 	  VARCHAR2,
             	       		p_curseur  IN OUT lib_listeCurType
            ) IS
BEGIN

IF (p_dpcode IS NULL)  THEN
	OPEN p_curseur FOR
        	-- Ligne vide
        	SELECT '' CODE,
        	       '' LIB
        	FROM DUAL;
ELSE
   	OPEN p_curseur FOR
  	    -- La première ligne est vide
  	    SELECT 	' ' icpi,
  	    		' ' LIB
  	    FROM dual
  	    UNION
  	    -- La première ligne est "Tous"
  	    SELECT 	' TOUS' icpi,
  	    		'Tous' LIB
  	    FROM dual
  	    UNION
	    SELECT DISTINCT  icpi,
	    		     icpi ||' - ' ||  ltrim(rtrim(ilibel)) LIB
	    FROM proj_info
	    WHERE icodproj = TO_NUMBER(p_dpcode)
	      AND (statut IS NULL OR statut='O' OR statut='N')
	    ORDER BY icpi;

END IF;
EXCEPTION WHEN OTHERS THEN raise_application_error(-20997, SQLERRM);


END lister_projet_notif;

END pack_liste_proj_info;
/
CREATE OR REPLACE PACKAGE pack_liste_proj_spe AS

   PROCEDURE lister_proj_spe(p_userid  IN VARCHAR2,
                             p_curseur IN OUT pack_liste_dynamique.liste_dyn
                            );

END pack_liste_proj_spe;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_proj_spe AS


  PROCEDURE lister_proj_spe(p_userid  IN VARCHAR2,
                             p_curseur IN OUT pack_liste_dynamique.liste_dyn
                            ) IS
   BEGIN

      OPEN p_curseur FOR
 		SELECT codpspe,
             rpad( codpspe, 10, ' ') ||
             libpspe
		FROM proj_spe
		UNION
		select ' ','           ' from proj_spe
		order by 1;

   END lister_proj_spe;

END pack_liste_proj_spe;
/
CREATE OR REPLACE PACKAGE pack_liste_proposes AS

   TYPE proposes_ListeViewType IS RECORD(CLICODE    	ligne_bip.clicode%TYPE,
					 PID        	ligne_bip.pid%TYPE,
                                         TYPE       	ligne_bip.typproj%TYPE,
                                         PNOM       	ligne_bip.pnom%TYPE,
                                         CODSG      	VARCHAR2(20),
                                         LIB_CODSG	VARCHAR2(30),
                                         BPMONTME    	VARCHAR2(20),
                                         BPMONTMO    	VARCHAR2(20),
                                         FLAGLOCK	VARCHAR2(20)
                                         );

   TYPE proposes_listeCurType IS REF CURSOR RETURN proposes_ListeViewType;


   TYPE proposes_TotalListeViewType IS RECORD(BPMONTME    VARCHAR2(20),
                                              BPMONTMO    VARCHAR2(20)
                                             );

   TYPE proposes_totallisteCurType IS REF CURSOR RETURN proposes_TotalListeViewType;


   PROCEDURE lister_proposes( p_codsg   IN VARCHAR2,
   							  p_clicode IN VARCHAR2,
   							  p_airt 	IN VARCHAR2,
							  p_annee   IN VARCHAR2,
                              p_userid  IN VARCHAR2,
							  p_ordre_tri IN VARCHAR2,
                              p_curseur IN OUT proposes_listeCurType
                             );



	 PROCEDURE lister_total_proposes(p_codsg   IN VARCHAR2,
					 		 	     p_clicode    IN VARCHAR2,
   							         p_airt       IN VARCHAR2,
									 p_annee   IN VARCHAR2,
                                     p_userid  IN VARCHAR2,
                                     p_curseur IN OUT proposes_totallisteCurType
                                     );

END pack_liste_proposes;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Proposes AS
PROCEDURE lister_proposes( p_codsg   IN VARCHAR2,
						   p_clicode IN VARCHAR2,
						   p_airt 	 IN VARCHAR2,
			     		   p_annee   IN VARCHAR2,
                           p_userid  IN VARCHAR2,
						   p_ordre_tri IN VARCHAR2,
                           p_curseur IN OUT proposes_listeCurType
                          ) IS

   -- codsg et un varchar2 pour les cas XX**** et XXXX**
      l_codsg	VARCHAR2(10);
      l_msg	VARCHAR2(1024);
      l_perime	VARCHAR2(255);
      l_perimo	VARCHAR2(255);


   BEGIN
       -- Récupérer les périmètres de l'utilisateur
      l_perime := Pack_Global.lire_globaldata(p_userid).perime ;
      l_perimo := Pack_Global.lire_globaldata(p_userid).perimo ;

      -- Si c'est un code ME = *******
      IF (p_codsg IS NOT NULL) AND (p_codsg = '*******') THEN
      	BEGIN
             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 		RTRIM(LTRIM(bip.clicode)) 	AS CLICODE,
		      		bip.pid 			AS PID,
		      		RTRIM(LTRIM(bip.typproj))	AS TYPE,
                      		SUBSTR(bip.pnom,1,20) 		AS PNOM,
                      		TO_CHAR(bip.codsg, 'FM0000000') AS CODSG,
                      		si.sigdep || '/' || si.sigpole	AS LIB_CODSG,
                      		TO_CHAR(budg.bpmontme, 'FM9999999990D00') AS BPMONTME,
                      		TO_CHAR(budg.bpmontmo, 'FM9999999990D00') AS BPMONTMO,
                      		TO_CHAR(budg.flaglock) 		AS FLAGLOCK
             FROM   BUDGET budg, LIGNE_BIP bip, vue_dpg_perime vdp, STRUCT_INFO si, APPLICATION ap
             WHERE  bip.codsg = si.codsg
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
               AND  bip.codsg = vdp.codsg
               AND  INSTR(l_perime, vdp.codbddpg) > 0
			   AND (p_airt IS NULL OR p_airt = bip.AIRT)
			   AND (p_clicode IS NULL OR p_clicode = bip.CLICODE)
               AND ap.AIRT=bip.AIRT
			   ORDER BY DECODE(p_ordre_tri,'1',bip.clicode,'2',bip.pid,'3',bip.pnom,'4',ap.ALIBEL),
			   	                        DECODE(p_ordre_tri,'1', bip.pid,'4', bip.typproj),
			                            DECODE(p_ordre_tri,'4', bip.pid);

	     /*  ORDER BY DECODE(p_ordre_tri,'1',bip.clicode,'2',bip.pid,'3',bip.pnom,'4',ap.ALIBCOURT),
			   	    DECODE(p_ordre_tri,'1', ap.ALIBCOURT,'4', bip.typproj),
			            DECODE(p_ordre_tri,'1', bip.typproj,'4', bip.pid),
				    DECODE(p_ordre_tri,'1', bip.pid);*/


      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;


     -- Si c'est un code ME != *******
     ELSIF (p_codsg IS NOT NULL) THEN
      	BEGIN
      	     -- On formatte l_codsg
	     IF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,3)||'%';
	     ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,5)||'%';
	     ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) != '**' THEN
			l_codsg :=LPAD(p_codsg, 7, '0');
	     END IF;

             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 		RTRIM(LTRIM(bip.clicode)) 	AS CLICODE,
		      		bip.pid 			AS PID,
		      		RTRIM(LTRIM(bip.typproj))	AS TYPE,
                      		SUBSTR(bip.pnom,1,20) 		AS PNOM,
                      		TO_CHAR(bip.codsg, 'FM0000000') AS CODSG,
                      		si.sigdep || '/' || si.sigpole	AS LIB_CODSG,
                      		TO_CHAR(budg.bpmontme, 'FM9999999990D00') AS BPMONTME,
                      		TO_CHAR(budg.bpmontmo, 'FM9999999990D00') AS BPMONTMO,
                      		TO_CHAR(budg.flaglock) 		AS FLAGLOCK
             FROM   BUDGET budg, LIGNE_BIP bip, STRUCT_INFO si, APPLICATION ap
             WHERE  bip.codsg = si.codsg
               AND  TO_CHAR(bip.codsg, 'FM0000000') LIKE l_codsg
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
			   AND (p_airt IS NULL OR p_airt = bip.AIRT)
			   AND (p_clicode IS NULL OR p_clicode = bip.CLICODE)
             AND ap.AIRT=bip.AIRT
            ORDER BY DECODE(p_ordre_tri,'1',bip.clicode,'2',bip.pid,'3',bip.pnom,'4',ap.ALIBEL),
			   	                     DECODE(p_ordre_tri,'1', bip.pid,'4', bip.typproj),
			                         DECODE(p_ordre_tri,'4', bip.pid);

	     /*  ORDER BY DECODE(p_ordre_tri,'1',bip.clicode,'2',bip.pid,'3',bip.pnom,'4',ap.ALIBCOURT),
			   	    DECODE(p_ordre_tri,'1', ap.ALIBCOURT,'4', bip.typproj),
			            DECODE(p_ordre_tri,'1', bip.typproj,'4', bip.pid),
				    DECODE(p_ordre_tri,'1', bip.pid);*/

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;
     END IF;


      -- Si c'est un code MO = *****
	  -- JMAS 13/06/2005 : ajout de la condition "AND (p_codsg IS NULL)" pour différencier "Mes Lignes" de "Lignes Clients"
      IF (p_clicode IS NOT NULL) AND (p_clicode = '*****') AND (p_codsg IS NULL) THEN
      	BEGIN
             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 		RTRIM(LTRIM(bip.clicode)) 	AS CLICODE,
		      		bip.pid 			AS PID,
		      		RTRIM(LTRIM(bip.typproj))	AS TYPE,
                      		SUBSTR(bip.pnom,1,20) 		AS PNOM,
                      		TO_CHAR(bip.codsg, 'FM0000000') AS CODSG,
                      		si.sigdep || '/' || si.sigpole	AS LIB_CODSG,
                      		TO_CHAR(budg.bpmontme, 'FM9999999990D00') AS BPMONTME,
                      		TO_CHAR(budg.bpmontmo, 'FM9999999990D00') AS BPMONTMO,
                      		TO_CHAR(budg.flaglock) 		AS FLAGLOCK
             FROM   BUDGET budg, LIGNE_BIP bip, vue_clicode_perimo vcp, STRUCT_INFO si, APPLICATION ap
             WHERE  bip.codsg = si.codsg
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
               AND  bip.clicode = vcp.clicode
               AND  INSTR(l_perimo, vcp.bdclicode) > 0
			   AND (p_airt IS NULL OR p_airt = bip.AIRT)
 	     AND ap.AIRT=bip.AIRT
            ORDER BY DECODE(p_ordre_tri,'1',bip.clicode,'2',bip.pid,'3',bip.pnom,'4',ap.ALIBEL),
			   	                     DECODE(p_ordre_tri,'1', bip.pid,'4', bip.typproj),
			                         DECODE(p_ordre_tri,'4', bip.pid);

	     /*  ORDER BY DECODE(p_ordre_tri,'1',bip.clicode,'2',bip.pid,'3',bip.pnom,'4',ap.ALIBCOURT),
			   	    DECODE(p_ordre_tri,'1', ap.ALIBCOURT,'4', bip.typproj),
			            DECODE(p_ordre_tri,'1', bip.typproj,'4', bip.pid),
				    DECODE(p_ordre_tri,'1', bip.pid);*/

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;


     -- Si c'est un code MO != *****
	 -- JMAS 13/06/2005 : ajout de la condition "AND (p_codsg IS NULL)" pour différencier "Mes Lignes" de "Lignes Clients"
     ELSIF (p_clicode IS NOT NULL) AND (p_codsg IS NULL) THEN
      	BEGIN
             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 		RTRIM(LTRIM(bip.clicode)) 	AS CLICODE,
		      		bip.pid 			AS PID,
		      		RTRIM(LTRIM(bip.typproj))	AS TYPE,
                      		SUBSTR(bip.pnom,1,20) 		AS PNOM,
                      		TO_CHAR(bip.codsg, 'FM0000000') AS CODSG,
                      		si.sigdep || '/' || si.sigpole	AS LIB_CODSG,
                      		TO_CHAR(budg.bpmontme, 'FM9999999990D00') AS BPMONTME,
                      		TO_CHAR(budg.bpmontmo, 'FM9999999990D00') AS BPMONTMO,
                      		TO_CHAR(budg.flaglock) 		AS FLAGLOCK
             FROM   BUDGET budg, LIGNE_BIP bip, STRUCT_INFO si, APPLICATION ap
             WHERE  bip.codsg = si.codsg
               AND  bip.clicode  = p_clicode
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
			   AND (p_airt IS NULL OR p_airt = bip.AIRT)
	    AND ap.AIRT=bip.AIRT
         ORDER BY DECODE(p_ordre_tri,'1',bip.clicode,'2',bip.pid,'3',bip.pnom,'4',ap.ALIBEL),
			   	                     DECODE(p_ordre_tri,'1', bip.pid,'4', bip.typproj),
			                         DECODE(p_ordre_tri,'4', bip.pid);

	     /*  ORDER BY DECODE(p_ordre_tri,'1',bip.clicode,'2',bip.pid,'3',bip.pnom,'4',ap.ALIBCOURT),
			   	    DECODE(p_ordre_tri,'1', ap.ALIBCOURT,'4', bip.typproj),
			            DECODE(p_ordre_tri,'1', bip.typproj,'4', bip.pid),
				    DECODE(p_ordre_tri,'1', bip.pid);*/

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;
     END IF;
  END lister_proposes;




  PROCEDURE lister_total_proposes( p_codsg   IN VARCHAR2,
						   p_clicode IN VARCHAR2,
						   p_airt 	 IN VARCHAR2,
			     		   p_annee   IN VARCHAR2,
                           p_userid  IN VARCHAR2,
                           p_curseur IN OUT proposes_totallisteCurType
                          ) IS

   -- codsg et un varchar2 pour les cas XX**** et XXXX**
      l_codsg	VARCHAR2(10);
      l_msg	VARCHAR2(1024);
      l_perime	VARCHAR2(255);
      l_perimo	VARCHAR2(255);


   BEGIN
       -- Récupérer les périmètres de l'utilisateur
      l_perime := Pack_Global.lire_globaldata(p_userid).perime ;
      l_perimo := Pack_Global.lire_globaldata(p_userid).perimo ;

      -- Si c'est un code ME = *******
      IF (p_codsg IS NOT NULL) AND (p_codsg = '*******') THEN
      	BEGIN
             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 	TO_CHAR(SUM(budg.bpmontme),'FM9999999990D00') AS BPMONTME,
                    TO_CHAR(SUM(budg.bpmontmo),'FM9999999990D00') AS BPMONTMO
             FROM   BUDGET budg, LIGNE_BIP bip, vue_dpg_perime vdp, STRUCT_INFO si
             WHERE  bip.codsg = si.codsg
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
               AND  bip.codsg = vdp.codsg
               AND  INSTR(l_perime, vdp.codbddpg) > 0
			   AND (p_airt IS NULL OR p_airt = bip.AIRT)
			   AND (p_clicode IS NULL OR p_clicode = bip.CLICODE)
             ORDER BY   bip.clicode ||bip.pid ;

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;


     -- Si c'est un code ME != *******
     ELSIF (p_codsg IS NOT NULL) THEN
      	BEGIN
      	     -- On formatte l_codsg
	     IF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,3)||'%';
	     ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,5)||'%';
	     ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) != '**' THEN
			l_codsg :=LPAD(p_codsg, 7, '0');
	     END IF;

             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 	TO_CHAR(SUM(budg.bpmontme), 'FM9999999990D00') AS BPMONTME,
                    TO_CHAR(SUM(budg.bpmontmo), 'FM9999999990D00') AS BPMONTMO
             FROM   BUDGET budg, LIGNE_BIP bip, STRUCT_INFO si
             WHERE  bip.codsg = si.codsg
               AND  TO_CHAR(bip.codsg, 'FM0000000') LIKE l_codsg
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
			   AND (p_airt IS NULL OR p_airt = bip.AIRT)
			   AND (p_clicode IS NULL OR p_clicode = bip.CLICODE)
             ORDER BY   bip.clicode ||bip.pid ;

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;
     END IF;


      -- Si c'est un code MO = *****
	  -- JMAS 13/06/2005 : ajout de la condition "AND (p_codsg IS NULL)" pour différencier "Mes Lignes" de "Lignes Clients"
      IF (p_clicode IS NOT NULL) AND (p_clicode = '*****') AND (p_codsg IS NULL) THEN
      	BEGIN
             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 	TO_CHAR(SUM(budg.bpmontme), 'FM9999999990D00') AS BPMONTME,
                    TO_CHAR(SUM(budg.bpmontmo), 'FM9999999990D00') AS BPMONTMO
             FROM   BUDGET budg, LIGNE_BIP bip, vue_clicode_perimo vcp, STRUCT_INFO si
             WHERE  bip.codsg = si.codsg
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
               AND  bip.clicode = vcp.clicode
               AND  INSTR(l_perimo, vcp.bdclicode) > 0
			   AND (p_airt IS NULL OR p_airt = bip.AIRT)
             ORDER BY   bip.clicode ||bip.pid ;

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;


     -- Si c'est un code MO != *****
	 -- JMAS 13/06/2005 : ajout de la condition "AND (p_codsg IS NULL)" pour différencier "Mes Lignes" de "Lignes Clients"
     ELSIF (p_clicode IS NOT NULL) AND (p_codsg IS NULL) THEN
      	BEGIN
             -- On récupère les lignes correspondante
	     OPEN p_curseur FOR
	     SELECT 	TO_CHAR(SUM(budg.bpmontme), 'FM9999999990D00') AS BPMONTME,
                    TO_CHAR(SUM(budg.bpmontmo), 'FM9999999990D00') AS BPMONTMO
             FROM   BUDGET budg, LIGNE_BIP bip, STRUCT_INFO si
             WHERE  bip.codsg = si.codsg
               AND  bip.clicode  = p_clicode
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
			   AND (p_airt IS NULL OR p_airt = bip.AIRT)
             ORDER BY   bip.clicode ||bip.pid ;

      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;
     END IF;
  END lister_total_proposes;



END Pack_Liste_Proposes;
/
CREATE OR REPLACE PACKAGE pack_liste_reestimes AS

   TYPE reestimes_ListeViewType IS RECORD(CLICODE    ligne_bip.clicode%TYPE,
					  PID        ligne_bip.pid%TYPE,
					  TYPE       ligne_bip.typproj%TYPE,
                                          PNOM       ligne_bip.pnom%TYPE,
                                          FLAGLOCK   VARCHAR2(20),
                                          CODSG      VARCHAR2(20),
                                          XCUSAG0    VARCHAR2(20),
                                          XBNMONT    VARCHAR2(20),
                                          PREESANCOU VARCHAR2(20)
                                         );

   TYPE reestimes_listeCurType IS REF CURSOR RETURN reestimes_ListeViewType;


   TYPE reestimes_TotalListeViewType IS RECORD(XCUSAG0    VARCHAR2(20),
                                               XBNMONT    VARCHAR2(20),
                                               PREESANCOU VARCHAR2(20)
                                               );

   TYPE reestimes_totallisteCurType IS REF CURSOR RETURN reestimes_TotalListeViewType;


   PROCEDURE lister_reestimes(p_codsg   IN VARCHAR2,
					 		  p_clicode    IN VARCHAR2,
   							  p_airt       IN VARCHAR2,
                              p_userid  IN VARCHAR2,
							  p_ordre_tri IN VARCHAR2,
                              p_curseur IN OUT reestimes_listeCurType
                             );



   PROCEDURE lister_total_reestimes(p_codsg   IN VARCHAR2,
					 		 	    p_clicode    IN VARCHAR2,
   							        p_airt       IN VARCHAR2,
                                    p_userid  IN VARCHAR2,
									p_ordre_tri IN VARCHAR2,
                                    p_curseur IN OUT reestimes_totallisteCurType
                                   );

END pack_liste_reestimes;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Reestimes AS

PROCEDURE lister_reestimes(p_codsg   IN VARCHAR2,
					 		  p_clicode    IN VARCHAR2,
   							  p_airt       IN VARCHAR2,
                              p_userid  IN VARCHAR2,
							  p_ordre_tri IN VARCHAR2,
                              p_curseur IN OUT reestimes_listeCurType
                             ) IS

      -- codsg et un varchar2 pour les cas XXX**** et XXXXX**
      l_codsg	VARCHAR2(10);
      l_perime	VARCHAR2(255);
      l_annee	NUMBER(4);

BEGIN
   	-- Récupérer le périmètre de l'utilisateur
   	l_perime := Pack_Global.lire_globaldata(p_userid).perime ;

	SELECT TO_NUMBER(TO_CHAR (DATDEBEX, 'YYYY'))
	INTO l_annee
	FROM DATDEBEX
	WHERE ROWNUM < 2;

    IF (p_codsg = '*******') THEN
        OPEN p_curseur FOR
        	SELECT RTRIM(LTRIM(lb.clicode)) 	AS CLICODE,
		      	   lb.pid	 		AS PID,
		      	   RTRIM(LTRIM(lb.typproj))	AS TYPE,
                   SUBSTR(lb.pnom,1,16) 	AS PNOM,
                   TO_CHAR(budg.flaglock) 		AS FLAGLOCK,
                   TO_CHAR(lb.codsg, 'FM0000000') 	AS CODSG,
                   TO_CHAR(conso.cusag, 'FM9999999990D00') 	AS XCUSAG0,
                   TO_CHAR(budg.anmont, 'FM9999999990D00') 	AS XBNMONT,
                   TO_CHAR(NVL(budg.reestime, 0),'FM9999999990D00') 	AS PREESANCOU
              FROM LIGNE_BIP lb, CONSOMME conso, BUDGET budg, vue_dpg_perime vdp, APPLICATION ap
             WHERE conso.pid(+) = lb.pid
	     	   AND budg.pid(+) = lb.pid
	     	   AND conso.annee(+) = l_annee
	     	   AND budg.annee(+) = l_annee
	     	   AND ((lb.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(lb.adatestatut,'YYYY')) >= l_annee))
               AND lb.codsg = vdp.codsg
               AND INSTR(l_perime, vdp.codbddpg) > 0
			   AND (p_airt IS NULL OR p_airt = lb.AIRT)
			   AND (p_clicode IS NULL OR p_clicode = lb.CLICODE)
	       AND ap.AIRT=lb.AIRT
	      ORDER BY DECODE(p_ordre_tri,'1',lb.clicode,'2',lb.pid,'3',lb.pnom,'4',ap.ALIBEL),
			   	                     DECODE(p_ordre_tri,'1', lb.pid,'4', lb.typproj),
			                         DECODE(p_ordre_tri,'4', lb.pid);


	     /*   ORDER BY DECODE(p_ordre_tri,'1',lb.clicode,'2',lb.pid,'3',lb.pnom,'4',ap.ALIBCOURT),
			   	    DECODE(p_ordre_tri,'1', ap.ALIBCOURT,'4', lb.typproj),
			            DECODE(p_ordre_tri,'1', lb.typproj,'4', lb.pid),
				    DECODE(p_ordre_tri,'1', lb.pid);*/



    ELSE
      	     -- On formatte l_codsg
	    IF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,3)||'%';
	    ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,5)||'%';
	    ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) != '**' THEN
			l_codsg :=LPAD(p_codsg, 7, '0');
	    END IF;

        OPEN p_curseur FOR
            SELECT RTRIM(LTRIM(lb.clicode))	AS CLICODE,
		      	   lb.pid 			AS PID,
		      	   RTRIM(LTRIM(lb.typproj))	AS TYPE,
                   SUBSTR(lb.pnom,1,16) 	AS PNOM,
                   TO_CHAR(budg.flaglock) 		AS FLAGLOCK,
                   TO_CHAR(lb.codsg, 'FM0000000') 	AS CODSG,
                   TO_CHAR(conso.cusag, 'FM9999999990D00') 	AS XCUSAG0,
                   TO_CHAR(budg.anmont, 'FM9999999990D00') 	AS XBNMONT,
                   TO_CHAR(NVL(budg.reestime, 0),'FM9999999990D00') 	AS PREESANCOU
              FROM LIGNE_BIP lb,CONSOMME conso,BUDGET budg, APPLICATION ap
             WHERE conso.pid(+) = lb.pid
               AND budg.pid(+) = lb.pid
	     	   AND conso.annee(+) = l_annee
	     	   AND budg.annee(+) = l_annee
	     	   AND TO_CHAR(lb.codsg, 'FM0000000') LIKE l_codsg
	     	   AND ((lb.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(lb.adatestatut,'YYYY')) >= l_annee))
			   AND (p_airt IS NULL OR p_airt = lb.AIRT)
			   AND (p_clicode IS NULL OR p_clicode = lb.CLICODE)
		AND ap.AIRT=lb.AIRT
	     ORDER BY DECODE(p_ordre_tri,'1',lb.clicode,'2',lb.pid,'3',lb.pnom,'4',ap.ALIBEL),
			   	                     DECODE(p_ordre_tri,'1', lb.pid,'4', lb.typproj),
			                         DECODE(p_ordre_tri,'4', lb.pid);


	     /*   ORDER BY DECODE(p_ordre_tri,'1',lb.clicode,'2',lb.pid,'3',lb.pnom,'4',ap.ALIBCOURT),
			   	    DECODE(p_ordre_tri,'1', ap.ALIBCOURT,'4', lb.typproj),
			            DECODE(p_ordre_tri,'1', lb.typproj,'4', lb.pid),
				    DECODE(p_ordre_tri,'1', lb.pid);*/


    END IF;

END lister_reestimes;



PROCEDURE lister_total_reestimes(p_codsg   IN VARCHAR2,
					 		     p_clicode    IN VARCHAR2,
   							     p_airt       IN VARCHAR2,
                                 p_userid  IN VARCHAR2,
								 p_ordre_tri IN VARCHAR2,
                                 p_curseur IN OUT reestimes_totallisteCurType
                                 ) IS

      -- codsg et un varchar2 pour les cas XXX**** et XXXXX**
      l_codsg	VARCHAR2(10);
      l_perime	VARCHAR2(255);
      l_annee	NUMBER(4);

BEGIN
   	-- Récupérer le périmètre de l'utilisateur
   	l_perime := Pack_Global.lire_globaldata(p_userid).perime ;

	SELECT TO_NUMBER(TO_CHAR (DATDEBEX, 'YYYY'))
	INTO l_annee
	FROM DATDEBEX
	WHERE ROWNUM < 2;

    IF (p_codsg = '*******') THEN
        OPEN p_curseur FOR
        	SELECT TO_CHAR(SUM(conso.cusag),'FM9999999990D00') 	AS XCUSAG0,
			       TO_CHAR(SUM(budg.anmont),'FM9999999990D00') 	AS XBNMONT,
			       TO_CHAR(SUM(NVL(budg.reestime, 0)),'FM9999999990D00') 	AS PREESANCOU
              FROM LIGNE_BIP lb, CONSOMME conso, BUDGET budg, vue_dpg_perime vdp
             WHERE conso.pid(+) = lb.pid
	     	   AND budg.pid(+) = lb.pid
	     	   AND conso.annee(+) = l_annee
	     	   AND budg.annee(+) = l_annee
	     	   AND ((lb.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(lb.adatestatut,'YYYY')) >= l_annee))
               AND lb.codsg = vdp.codsg
               AND INSTR(l_perime, vdp.codbddpg) > 0
			   AND (p_airt IS NULL OR p_airt = lb.AIRT)
			   AND (p_clicode IS NULL OR p_clicode = lb.CLICODE)
	        ORDER BY DECODE(p_ordre_tri,'1',lb.clicode,'2',lb.pid,'3',lb.pnom),
			   	                     DECODE(p_ordre_tri,'1', lb.pid,'4', lb.typproj),
			                         DECODE(p_ordre_tri,'4', lb.pid);

    ELSE
      	     -- On formatte l_codsg
	    IF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,3)||'%';
	    ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,5)||'%';
	    ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) != '**' THEN
			l_codsg :=LPAD(p_codsg, 7, '0');
	    END IF;

        OPEN p_curseur FOR
             SELECT TO_CHAR(SUM(conso.cusag),'FM9999999990D00') 	AS XCUSAG0,
			        TO_CHAR(SUM(budg.anmont),'FM9999999990D00') 	AS XBNMONT,
			        TO_CHAR(SUM(NVL(budg.reestime, 0)),'FM9999999990D00') 	AS PREESANCOU
		     FROM LIGNE_BIP lb,CONSOMME conso,BUDGET budg
             WHERE conso.pid(+) = lb.pid
               AND budg.pid(+) = lb.pid
	     	   AND conso.annee(+) = l_annee
	     	   AND budg.annee(+) = l_annee
	     	   AND TO_CHAR(lb.codsg, 'FM0000000') LIKE l_codsg
	     	   AND ((lb.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(lb.adatestatut,'YYYY')) >= l_annee))
			   AND (p_airt IS NULL OR p_airt = lb.AIRT)
			   AND (p_clicode IS NULL OR p_clicode = lb.CLICODE)
			   ORDER BY DECODE(p_ordre_tri,'1',lb.clicode,'2',lb.pid,'3',lb.pnom),
			   	                     DECODE(p_ordre_tri,'1', lb.pid,'4', lb.typproj),
			                         DECODE(p_ordre_tri,'4', lb.pid);
	        -- ORDER BY DECODE(p_ordre_tri,'1',lb.clicode,'2',lb.pid,'3',lb.pnom) , lb.airt, lb.typproj, lb.pid;


    END IF;

END lister_total_reestimes;




END Pack_Liste_Reestimes;
/
CREATE OR REPLACE PACKAGE pack_liste_resscont AS

   TYPE contress_RecType IS RECORD (clelc    VARCHAR2(6),
                                    liste    VARCHAR2(57));

   TYPE contress_CurType IS REF CURSOR RETURN contress_RecType;

   PROCEDURE lister_resscont (p_socfact IN facture.socfact%TYPE,
                              p_typfact IN facture.typfact%TYPE,
                              p_datfact IN VARCHAR2,
                              p_numfact IN facture.numfact%TYPE,
                              p_soccont IN contrat.soccont%TYPE,
                              p_cav     IN contrat.cav%TYPE,
                              p_numcont IN contrat.numcont%TYPE,
                              p_rnom    IN ressource.rnom%TYPE,
                              p_userid  IN VARCHAR2,
                              p_curseur IN OUT contress_CurType
                             );
END pack_liste_resscont;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_resscont AS

    PROCEDURE lister_resscont (p_socfact IN facture.socfact%TYPE,
                              p_typfact IN facture.typfact%TYPE,
                              p_datfact IN VARCHAR2,
                              p_numfact IN facture.numfact%TYPE,
                              p_soccont IN contrat.soccont%TYPE,
                              p_cav     IN contrat.cav%TYPE,
                              p_numcont IN contrat.numcont%TYPE,
                              p_rnom    IN ressource.rnom%TYPE,
                              p_userid  IN VARCHAR2,
                              p_curseur IN OUT contress_CurType
                             ) IS
    l_like_numcont  varchar2(16);
    l_like_rnom     varchar2(31);
    l_filcode       contrat.filcode%TYPE;

    BEGIN

      -- La largeur de la liste_resscont est limité à 28 caractères
      -- La clé cachée est l'identifiant
if p_numcont !='' or p_numcont is not null then
      OPEN p_curseur FOR
 	SELECT  TO_CHAR(r.ident,'FM99999') as CleR,
                TO_CHAR(r.ident,'99999') ||
                ' '  || RPAD(r.rnom,10) ||
                ' '  || LPAD(TO_CHAR(TRUNC(lc.lccouact),'FM99999D00'),8)   as Liste_RessCont
      FROM  ligne_cont lc, ressource r
      WHERE		  r.ident   =  lc.ident
            AND lc.soccont =  p_soccont
            AND lc.cav     =  p_cav
            AND lc.numcont =  p_numcont
      UNION ALL
      SELECT  TO_CHAR(r.ident,'FM99999') as CleR,
                TO_CHAR(r.ident,'99999') ||
                ' '  || RPAD(r.rnom,10) ||
                ' '  || LPAD(TO_CHAR(TRUNC(hlc.lccouact),'FM99999D00'),8)   as Liste_RessCont
      FROM  histo_ligne_cont hlc, ressource r
      WHERE		  r.ident   =  hlc.ident
            AND hlc.soccont =  p_soccont
            AND hlc.cav     =  p_cav
            AND hlc.numcont =  p_numcont ;

else	 /* FACTURES SANS CONTRAT*/
	OPEN p_curseur FOR
	SELECT distinct  TO_CHAR(r.ident,'FM99999') as CleR,
                TO_CHAR(r.ident,'99999') ||
                ' '  || RPAD(r.rnom,10) as Liste_RessCont
	FROM situ_ress s, ressource r
	WHERE  s.ident=r.ident
	  AND  s.soccode=p_socfact ;

 end if;

   END lister_resscont;

-- Pour Tester sous SQLPlus
-- > set serveroutput on
-- > var vcur refcursor
-- > exec pack_liste_contrats.lister_resscont('SOPR','F','10101999','TOTO','','','','LE','S935708;;;;01;',:vcur)
-- > exec pack_liste_resscont.lister_resscont('SOPR','F','10121999','LE123456H','SOPR','00' ,'1239','','S935708;;;;01;',:vcur)
-- > print vcur

END pack_liste_resscont;
/
CREATE OR REPLACE PACKAGE     PACK_LISTE_RJH AS

   TYPE lib_ListeViewType IS RECORD( CODREP RJH_TABREPART.CODREP%TYPE,
   						  	 		 LIB	RJH_TABREPART.LIBREP%TYPE
                                   );

   TYPE lib_listeCurType IS REF CURSOR RETURN lib_ListeViewType;


   -- liste des tables de répartition suivant le perimètre de l'utilisateur
   PROCEDURE lister_table_repart( p_userid   IN 	  VARCHAR2,
             	       			  p_curseur  IN OUT lib_listeCurType
                                );

END PACK_LISTE_RJH;
/

CREATE OR REPLACE PACKAGE BODY     PACK_LISTE_RJH AS

PROCEDURE lister_table_repart( p_userid  IN VARCHAR2,
							   p_curseur IN OUT lib_listeCurType
            ) IS
    l_perime VARCHAR2(255);
    l_dir    VARCHAR2(255);
	l_pos	 NUMBER;
BEGIN
   	-- Récupérer le périmètre de l'utilisateur
   	l_perime := pack_global.lire_globaldata(p_userid).perime ;
	l_dir := '';

	-- On fait une boucle pour récupérer les codes directions qu'on met dans la variable
	-- l_dir qui sera ensuite testée
	while (length(l_perime)>0)
	loop
		if (length(l_dir) > 0) then
		    l_dir := l_dir||','||substr(l_perime,3,2);
		else
			l_dir := substr(l_perime,3,2);
		end if;
	    l_perime := substr(l_perime,13);
	end loop;

	OPEN p_curseur FOR
	    SELECT codrep, codrep ||' - ' || ltrim(rtrim(librep))  LIB
	      FROM RJH_TABREPART
	     WHERE FLAGACTIF = 'O'
	       AND ( (INSTR(l_dir, coddir)>0) or (INSTR(l_dir,'00')>0) )
	     ORDER BY LIB;


EXCEPTION
    WHEN OTHERS THEN
		raise_application_error(-20997, SQLERRM);

END lister_table_repart;

END PACK_LISTE_RJH;
/
CREATE OR REPLACE PACKAGE Pack_Liste_Rubrique AS

   TYPE lib_ListeCompteViewType IS RECORD( CODCOMPTE      COMPTE.CODCOMPTE%TYPE,
   						  	 		                                                             LIBCOMPTE           VARCHAR2(70)
                                                                                                 );

   TYPE lib_listeCompteCurType IS REF CURSOR RETURN lib_ListeCompteViewType;



   -- liste des compte selon le type
      PROCEDURE lister_compte_type( p_userid   IN 	  VARCHAR2,
    		 					  			 		  		   						   p_type                         IN VARCHAR2,
             	       		                                                           p_curseur  IN OUT lib_listeCompteCurType
                                                                                       );



      PROCEDURE lister_type_rubrique( p_userid   IN 	  VARCHAR2,
    		 					  			 		  		   				 p_curseur  IN OUT Pack_Liste_Dynamique.liste_dyn
                                                                            );

	 PROCEDURE lister_rubrique_metier( p_userid   IN 	  VARCHAR2,
	 		   						   			  		  		   			    p_codsg IN 	  VARCHAR2,
    		 					  			 		  		   				    p_curseur  IN OUT Pack_Liste_Dynamique.liste_dyn
                                                                              );



END Pack_Liste_Rubrique;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Rubrique AS


 PROCEDURE lister_compte_type( p_userid   IN 	  VARCHAR2,
    		 					  			 		  		   						   p_type                         IN VARCHAR2,
             	       		                                                           p_curseur  IN OUT lib_listeCompteCurType
                                                                                       ) IS

   BEGIN


      OPEN p_curseur FOR


	--Ligne vide en haut
       SELECT '',
		                    ' ' libelle
		 FROM 		COMPTE
		 UNION
        SELECT
                 DISTINCT TO_CHAR(CODCOMPTE),
                 RPAD(TO_CHAR(codcompte),10,' ') || ' - '|| libcompte libelle
       FROM COMPTE
       WHERE TYPE=p_type
        ORDER BY libelle;



   END lister_compte_type;




   PROCEDURE lister_type_rubrique( p_userid   IN 	  VARCHAR2,
    		 					  			 		  		   				 p_curseur  IN OUT Pack_Liste_Dynamique.liste_dyn
                                                                            ) IS

	BEGIN


      OPEN p_curseur FOR


	--Ligne vide en haut


      SELECT
                 TO_CHAR(codep,'FM00000') || '-' || codfei,
				 codep || ' - ' || codfei || ' - ' || librubst
       FROM TYPE_RUBRIQUE
       ORDER BY codfei, codep;



    END lister_type_rubrique;



	 PROCEDURE lister_rubrique_metier( p_userid   IN 	  VARCHAR2,
	 		   						   			  		  		   			    p_codsg IN 	  VARCHAR2,
    		 					  			 		  		   				    p_curseur  IN OUT Pack_Liste_Dynamique.liste_dyn
       	                                                                          )  IS
     v_cafi NUMBER;

	BEGIN

   IF (UPPER(p_codsg)!='NULL')  THEN


	  SELECT s.cafi INTO v_cafi
	      FROM STRUCT_INFO s
		  WHERE s.codsg=TO_NUMBER(p_codsg);


	IF( (v_cafi = 88888) OR (v_cafi = 99999) ) THEN


	    OPEN p_curseur FOR

				  SELECT '',
 	   	  		  ' ' Libelle
				  FROM RUBRIQUE_METIER
	    UNION
                  SELECT DISTINCT RPAD(rm.METIER,3,' ') , rm.METIER Libelle
                  FROM RUBRIQUE_METIER rm
	              ORDER BY Libelle;


	ELSE

     OPEN p_curseur FOR

				  SELECT '',
 	   	  		  ' ' Libelle
				  FROM RUBRIQUE_METIER
	UNION
    SELECT DISTINCT RPAD(rm.METIER,3,' ') , rm.METIER Libelle
    FROM RUBRIQUE_METIER rm
    WHERE (rm.CODEP, rm.CODFEI) IN (SELECT r.CODEP, r.CODFEI
	  		  		  	 		 			   				                   FROM RUBRIQUE r
															                    WHERE r.CAFI IN (SELECT s.cafi
																		  			   	  		  		 		      FROM STRUCT_INFO s
																												      WHERE s.codsg=TO_NUMBER(p_codsg))
																		     )
     ORDER BY Libelle;

	 END IF;

ELSE

	 OPEN p_curseur FOR

       SELECT '' METIER,
 	   	  		  ' ' Libelle
				  FROM DUAL;

END IF;


EXCEPTION
    WHEN OTHERS THEN
	   OPEN p_curseur FOR

       SELECT '' METIER,
 	   	  		  ' ' Libelle
				  FROM DUAL;

    END lister_rubrique_metier;



END Pack_Liste_Rubrique;
/
CREATE OR REPLACE PACKAGE pack_liste_scenarios AS

   TYPE scenarios_ListeViewType IS RECORD(  CODE_ACTIVITE   VARCHAR2(12),
  								   			LIB_ACTIVITE     VARCHAR2(75)
					  					  );

   TYPE scenarios_listeCurType IS REF CURSOR RETURN scenarios_ListeViewType;


   PROCEDURE lister_scenarios_dpg( 	p_codsg 	IN VARCHAR2,
   			 						p_userid 	IN VARCHAR2,
   			 						p_curseur 	IN OUT scenarios_listeCurType
                             	  );


END pack_liste_scenarios;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_scenarios AS
   PROCEDURE lister_scenarios_dpg( 	p_codsg IN VARCHAR2,
   			 						p_userid 	IN VARCHAR2,
   									p_curseur IN OUT scenarios_listeCurType
                                 ) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_userid)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

	BEGIN
        	OPEN   p_curseur FOR
              	SELECT CODE_SCENARIO CODE_SCENARIO,CODE_SCENARIO||' - '||LIB_SCENARIO LIB_SCENARIO
				FROM REE_SCENARIOS
				WHERE CODSG=TO_NUMBER(p_codsg)
				ORDER BY OFFICIEL desc;



      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
       END;
        END IF;
     END IF;


  END lister_scenarios_dpg;



END pack_liste_scenarios;
/
CREATE OR REPLACE PACKAGE pack_liste_situation_forfait AS

   TYPE situation_f_RecType IS RECORD (datsitu    VARCHAR2(20),
                                       lib        VARCHAR2(150));

   TYPE situation_f_CurType IS REF CURSOR RETURN situation_f_RecType;

   PROCEDURE lister_situation_forfait(p_ident   IN CHAR,
                                      p_userid  IN VARCHAR2,
                                      p_curseur IN OUT situation_f_CurType
                                     );
END pack_liste_situation_forfait;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_situation_forfait AS

   PROCEDURE lister_situation_forfait (p_ident   IN CHAR,
                                       p_userid  IN VARCHAR2,
                                       p_curseur IN OUT situation_f_CurType
                                      ) IS

   BEGIN
      OPEN p_curseur FOR SELECT
             TO_CHAR(datsitu,'dd/mm/yyyy'),
		 NVL(TO_CHAR(datsitu,'dd/mm/yyyy'), '          ')||' '||
             NVL(TO_CHAR(datdep,'dd/mm/yyyy'), '          ')||''||
             TO_CHAR(codsg, '0000000')||' '||
             RPAD(prestation, 3, ' ')||'    '||      -- 3
             RPAD(soccode, 4, ' ')||' '||         -- 4
             TO_CHAR(nvl(cout,0), '9999999990D00')||' '||
             TO_CHAR(nvl(montant_mensuel,0), '9999999990D00')
     FROM situ_ress
     WHERE ident = TO_NUMBER(p_ident)
     ORDER BY datsitu DESC;

   END lister_situation_forfait;

END pack_liste_situation_forfait;
/
CREATE OR REPLACE PACKAGE pack_liste_situation_logiciel AS

  TYPE situation_l_RecType IS RECORD (datsitu    VARCHAR2(20),
                                      lib        VARCHAR2(150));


   TYPE situation_l_CurType IS REF CURSOR RETURN situation_l_RecType;

   PROCEDURE lister_situation_logiciel(p_ident   IN CHAR,
                                       p_userid  IN VARCHAR2,
                                       p_curseur IN OUT situation_l_CurType
                                      );

END pack_liste_situation_logiciel;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_situation_logiciel AS

----------------------------------- SELECT -----------------------------------

   PROCEDURE lister_situation_logiciel (p_ident   IN CHAR,
                                        p_userid  IN VARCHAR2,
                                        p_curseur IN OUT situation_l_CurType
                                       ) IS
   BEGIN
      OPEN p_curseur FOR SELECT
             TO_CHAR(datsitu,'dd/mm/yyyy'),
	     NVL(TO_CHAR(datsitu,'dd/mm/yyyy'), '          ')||' '||
             NVL(TO_CHAR(datdep,'dd/mm/yyyy'),'          ')||''||
             TO_CHAR(codsg, '0000000')||' '||
             RPAD(prestation, 3, ' ')||'    '||      -- 3
             RPAD(soccode, 4, ' ')||' '||         -- 4
             TO_CHAR(nvl(cout,0), '999990D00')
     FROM situ_ress
     WHERE ident = TO_NUMBER(p_ident)
     ORDER BY datsitu DESC;

   END lister_situation_logiciel;

END pack_liste_situation_logiciel;
/
CREATE OR REPLACE PACKAGE pack_liste_situation_personne AS

		TYPE situation_p_RecType IS RECORD (datsitu    VARCHAR2(20),
		                                    lib        VARCHAR2(150));

		TYPE situation_p_CurType IS REF CURSOR RETURN situation_p_RecType;

		PROCEDURE lister_situation_personne(p_ident   IN CHAR,
		                                       p_userid  IN VARCHAR2,
		                                       p_curseur IN OUT situation_p_CurType
		                                      );

END pack_liste_situation_personne;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_situation_personne AS

		   PROCEDURE lister_situation_personne (p_ident   IN CHAR,
		                                        p_userid  IN VARCHAR2,
		                                        p_curseur IN OUT situation_p_CurType
		                                       ) IS

		   l_soccode situ_ress.soccode%TYPE;
		   l_menu          VARCHAR2(255);

		   BEGIN

		   	  l_menu := pack_global.lire_globaldata(p_userid).menutil;

		   --Récupérer la société de la ressource pour la situation la plus récente
		   	  SELECT distinct RTRIM(soccode) INTO l_soccode FROM situ_ress
            	   WHERE   datsitu = (select max(datsitu) from situ_ress s
				   		   		   	  where s.ident= situ_ress.ident)
				   and ident = TO_NUMBER(p_ident);

		      IF(l_soccode <> 'SG..') THEN

			      OPEN p_curseur FOR SELECT
			             TO_CHAR(datsitu,'dd/mm/yyyy'),
			             NVL(TO_CHAR(datsitu,'dd/mm/yyyy'), '          ')||' '||
			             NVL(TO_CHAR(datdep,'dd/mm/yyyy'), '          ')||' '||
			             TO_CHAR(codsg, 'FM0000000')||' '||
			             RPAD(prestation, 3, ' ')||'    '||      -- 3
			             soccode||' '||         -- 4
			             TO_CHAR(nvl(cout,0), '9999999990D00')
			     FROM situ_ress
			     WHERE ident = TO_NUMBER(p_ident)
			     ORDER BY datsitu DESC;

			 ELSE
			 	 -- TEST si c'est le menu administration
				 -- si oui afficher le niveau pour les SG
				 -- sinon rien
				 IF l_menu = 'DIR' THEN

				 	 OPEN p_curseur FOR SELECT
				             TO_CHAR(datsitu,'dd/mm/yyyy'),
				             NVL(TO_CHAR(datsitu,'dd/mm/yyyy'), '          ')||' '||
				             NVL(TO_CHAR(datdep,'dd/mm/yyyy'), '          ')||' '||
				             TO_CHAR(codsg, 'FM0000000')||' '||
				             RPAD(prestation, 3, ' ')||'    '||      -- 3
				             soccode||' '||         -- 4
				             nvl(niveau,'')
				     FROM situ_ress
				     WHERE ident = TO_NUMBER(p_ident)
				     ORDER BY datsitu DESC;

				ELSE

					 OPEN p_curseur FOR SELECT
				             TO_CHAR(datsitu,'dd/mm/yyyy'),
				             NVL(TO_CHAR(datsitu,'dd/mm/yyyy'), '          ')||' '||
				             NVL(TO_CHAR(datdep,'dd/mm/yyyy'), '          ')||' '||
				             TO_CHAR(codsg, 'FM0000000')||' '||
				             RPAD(prestation, 3, ' ')||'    '||      -- 3
				             soccode||' '        -- 4
				     FROM situ_ress
				     WHERE ident = TO_NUMBER(p_ident)
				     ORDER BY datsitu DESC;

				END IF;

			 END IF;

		   END lister_situation_personne;

END pack_liste_situation_personne;
/
CREATE OR REPLACE PACKAGE pack_liste_sous_type AS
   TYPE Projet_ListeViewType IS RECORD( id      sous_typologie.sous_type%TYPE,
					libelle VARCHAR2(33)
                                        );
   TYPE projet_listeCurType IS REF CURSOR RETURN Projet_ListeViewType;

   PROCEDURE lister_sous_typo (p_userid  IN VARCHAR2,
   				   p_sous_typo IN VARCHAR2,
                                   p_curseur IN OUT projet_listeCurType);


END pack_liste_sous_type;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_sous_type AS

    PROCEDURE lister_sous_typo (p_userid  IN VARCHAR2,
   				   p_sous_typo IN VARCHAR2,
                                   p_curseur IN OUT projet_listeCurType
                                  ) IS

l_menutil 	VARCHAR2(100);
   BEGIN
      l_menutil := pack_global.lire_globaldata(p_userid).menutil;

      OPEN p_curseur FOR

      --Ligne vide en haut
        SELECT '',
               ' ' libelle
        FROM dual
       UNION
        SELECT sous_type,
             rpad( sous_type, 3, ' ') ||' '|| libsoustype libelle
	FROM sous_typologie
	ORDER BY libelle;

   END lister_sous_typo;

END pack_liste_sous_type;
/
CREATE OR REPLACE PACKAGE pack_liste_top_amort AS

   PROCEDURE lister_top_amort(	p_userid  IN VARCHAR2,
             			p_curseur IN OUT pack_liste_dynamique.liste_dyn
            );

END pack_liste_top_amort;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_top_amort AS

----------------------------------- SELECT -----------------------------------

   PROCEDURE lister_top_amort ( p_userid IN VARCHAR2,
               			p_curseur IN OUT pack_liste_dynamique.liste_dyn
              ) IS

   BEGIN

      OPEN p_curseur FOR SELECT
           ctopact,
           libamort
      FROM type_amort
       ORDER BY ctopact;

   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_top_amort;

END pack_liste_top_amort;
/
CREATE OR REPLACE PACKAGE Pack_Liste_Type AS

   TYPE lib_ListeDomaineViewType IS RECORD( CODE_DOMAINE      TYPE_DOMAINE.CODE_DOMAINE%TYPE,
   						  	 		                                                               LIB_DOMAINE	           TYPE_DOMAINE.LIB_DOMAINE%TYPE
                                                                                                 );

   TYPE lib_listeDomaineCurType IS REF CURSOR RETURN lib_ListeDomaineViewType;


    -- liste des types de domaine
      PROCEDURE lister_type_domaine( p_userid   IN 	  VARCHAR2,
    		 					  			 		  		   				 p_curseur  IN OUT lib_listeDomaineCurType
                                                                             );


   -- liste des types de domaine selon le type
      PROCEDURE lister_type_domaine_type( p_userid   IN 	  VARCHAR2,
    		 					  			 		  		   				p_rtype                         IN VARCHAR2,
             	       		                                               p_curseur  IN OUT lib_listeDomaineCurType
                                                                           );


   TYPE lib_ListePrestationViewType IS RECORD( CODE_PRESTATION      PRESTATION.PRESTATION%TYPE,
   						  	 		                                                                LIBPREST                             PRESTATION.LIBPREST%TYPE
                                                                                                 );

   TYPE lib_listePrestationCurType IS REF CURSOR RETURN lib_ListePrestationViewType;


   -- liste des types de Prestation
   PROCEDURE lister_type_Prestation( p_userid                       IN  VARCHAR2,
   			 						 				  		   				  p_rtype                         IN VARCHAR2,
																			  p_code_domaine     IN VARCHAR2,
             	       		                                                 p_curseur                      IN OUT lib_listePrestationCurType
                                                                           );



	TYPE lib_ListeRtypeViewType IS RECORD( RTYPE      TYPE_RESS.RTYPE%TYPE,
   						  	 		                                                          RLIB            TYPE_RESS.RLIB %TYPE
                                                                                             );

   TYPE lib_listeRtypeCurType IS REF CURSOR RETURN lib_ListeRtypeViewType;


   -- liste des types de Ressource
   PROCEDURE lister_type_rtype( p_userid   IN 	  VARCHAR2,
             	       		                                         p_curseur  IN OUT lib_listeRtypeCurType
                                                                              );


END Pack_Liste_Type;
/

CREATE OR REPLACE PACKAGE BODY Pack_Liste_Type AS

   -- liste des types de domaine
   PROCEDURE lister_type_domaine( p_userid   IN 	  VARCHAR2,
   			 					  			 		  		   			  p_curseur  IN OUT lib_listeDomaineCurType
                                                                           ) IS

   BEGIN


      OPEN p_curseur FOR


	--Ligne vide en haut
        SELECT '',
               ' ' libelle
        FROM dual
       UNION
        SELECT
                 CODE_DOMAINE,
                 RPAD(code_domaine,2,' ') || ' - '|| lib_domaine libelle
       FROM TYPE_DOMAINE
       ORDER BY libelle;



   END lister_type_domaine;



    -- liste des types de domaine selon le rtype
   PROCEDURE lister_type_domaine_type( p_userid   IN 	  VARCHAR2,
   			 					  			 		  		   			   p_rtype                         IN VARCHAR2,
             	       		                                               p_curseur  IN OUT lib_listeDomaineCurType
                                                                           ) IS

   BEGIN


      OPEN p_curseur FOR


	--Ligne vide en haut
        SELECT '',
               ' ' libelle
        FROM dual
       UNION
        SELECT
                 DISTINCT p.CODE_DOMAINE,
                 RPAD(p.code_domaine,2,' ') || ' - '|| d.lib_domaine libelle
       FROM PRESTATION p, TYPE_DOMAINE d
       WHERE p.RTYPE=p_rtype
       AND p.top_actif='O'
       AND d.CODE_DOMAINE=p.CODE_DOMAINE
	   ORDER BY libelle;



   END lister_type_domaine_type;


    -- liste des types de prestation
   PROCEDURE lister_type_prestation(  p_userid                       IN  VARCHAR2,
   			 						 				  		   				  p_rtype                         IN VARCHAR2,
																			  p_code_domaine     IN VARCHAR2,
             	       		                                                  p_curseur                      IN OUT lib_listePrestationCurType
                                                                            ) IS

   BEGIN


      OPEN p_curseur FOR

       --Ligne vide en haut
        SELECT '',
               ' ' libelle
        FROM dual
       UNION
        SELECT PRESTATION,
                        RPAD(PRESTATION,3,' ') ||  ' - ' || LIBPREST libelle
	FROM PRESTATION
	WHERE RTYPE=p_rtype
	AND CODE_DOMAINE=p_code_domaine
	AND top_actif='O'
	ORDER BY libelle;

   END lister_type_prestation;



       -- liste des types de Ressource
   PROCEDURE lister_type_rtype( p_userid   IN 	  VARCHAR2,
             	       		                                        p_curseur  IN OUT lib_listeRtypeCurType
                                                                   ) IS

   BEGIN


      OPEN p_curseur FOR

      --Ligne vide en haut
        SELECT '',
               ' ' libelle
        FROM dual
       UNION
        SELECT RTYPE,
                          RTYPE ||' - '|| RLIB libelle
	FROM TYPE_RESS
	WHERE UPPER(RTYPE)<>'C'
	ORDER BY libelle;

   END lister_type_rtype;


END Pack_Liste_Type;
/
CREATE OR REPLACE PACKAGE pack_liste_type_activite AS

   TYPE Activite_ListeViewType IS RECORD( id      type_activite.arctype%TYPE,
					  libelle VARCHAR2(33)
                                        );

   TYPE activite_listeCurType IS REF CURSOR RETURN Activite_ListeViewType;

   PROCEDURE lister_type_activite(p_userid  IN VARCHAR2,
   				  p_typproj IN VARCHAR2,
                                  p_curseur IN OUT activite_listeCurType
                                 );

   PROCEDURE lister_type2(p_userid  IN VARCHAR2,
                                  p_curseur IN OUT activite_listeCurType
                                 );

END pack_liste_type_activite;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_type_activite AS

   PROCEDURE lister_type_activite (p_userid  IN VARCHAR2,
   				   p_typproj IN VARCHAR2,
                                   p_curseur IN OUT activite_listeCurType
                                  ) IS

l_menutil 	VARCHAR2(100);
   BEGIN

      l_menutil := pack_global.lire_globaldata(p_userid).menutil;

      OPEN p_curseur FOR
        -- Ligne vide en haut
        SELECT '',
               ' ' libelle
        FROM DUAL
        UNION
        SELECT arctype,
             rpad( arctype, 3, ' ') || libarc libelle
	FROM type_activite, lien_types_proj_act
	WHERE type_act = arctype
	  AND type_proj=RPAD(p_typproj, 2, ' ')
	  -- Type d'activit¿ actif
	  AND actif='O'
	  -- Il n'est pas possible de saisir un grand T1
	  AND (type_act <> 'T1' OR l_menutil = 'DIR')
	ORDER BY libelle;

   END lister_type_activite;

   PROCEDURE lister_type2	 (p_userid  IN VARCHAR2,
                                  p_curseur IN OUT activite_listeCurType
                                  ) IS

   BEGIN

      OPEN p_curseur FOR
        -- Ligne vide en haut
        SELECT arctype,
             rpad( arctype, 3, ' ') || ' - ' || libarc || DECODE(actif, 'O', ' - ACTIF', '') libelle
	FROM type_activite
	ORDER BY libelle;

   END lister_type2;

END pack_liste_type_activite;
/
CREATE OR REPLACE PACKAGE pack_liste_type_doss_proj AS

TYPE lib_ListeViewType IS RECORD(    	TYPDP	type_dossier_projet.typdp%TYPE,
					LIBTYPDP type_dossier_projet.libtypdp%TYPE
                                         );

   TYPE lib_listeCurType IS REF CURSOR RETURN lib_ListeViewType;


   -- Liste des type de dossier projet
   PROCEDURE lister_type_doss_proj(	p_userid   IN 	  VARCHAR2,
             	       			p_curseur  IN OUT lib_listeCurType
            );

END pack_liste_type_doss_proj;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_type_doss_proj AS

   PROCEDURE lister_type_doss_proj( p_userid   IN 	  VARCHAR2,
             	       			p_curseur  IN OUT lib_listeCurType
            ) IS

   BEGIN

      OPEN p_curseur FOR
      SELECT
           typdp,
           libtypdp
      FROM type_dossier_projet
       ORDER BY typdp;

   EXCEPTION
       WHEN OTHERS THEN
          raise_application_error(-20997, SQLERRM);

   END lister_type_doss_proj;

END pack_liste_type_doss_proj;
/
CREATE OR REPLACE PACKAGE pack_liste_type_projet AS
   TYPE Projet_ListeViewType IS RECORD( id      type_projet.typproj%TYPE,
					libelle VARCHAR2(33)
                                        );
   TYPE projet_listeCurType IS REF CURSOR RETURN Projet_ListeViewType;

   PROCEDURE lister_type_projet  (p_userid  IN VARCHAR2,
                                  p_curseur IN OUT projet_listeCurType
                                 );
END pack_liste_type_projet;
/

CREATE OR REPLACE PACKAGE BODY pack_liste_type_projet AS

   PROCEDURE lister_type_projet (p_userid  IN VARCHAR2,
                                 p_curseur IN OUT projet_listeCurType
                                ) IS
   BEGIN

      OPEN p_curseur FOR
        -- Ligne vide en haut
        SELECT '',
               ' ' libelle
        FROM dual
        UNION
        SELECT typproj,
               rpad( typproj, 3, ' ') || libtyp libelle
	FROM type_projet
	ORDER BY libelle;

   END lister_type_projet;

END pack_liste_type_projet;
/
CREATE OR REPLACE PACKAGE pack_MajDatSuivCont AS

   TYPE ContRecType IS RECORD (soccont      contrat.soccont%TYPE,
                               soclib       societe.soclib%TYPE,
                               numcont      contrat.numcont%TYPE,
                               cav          contrat.cav%TYPE,
                               cobjet1      contrat.cobjet1%TYPE,
                               cobjet2      contrat.cobjet2%TYPE,
                               codsg        VARCHAR2(20),
                               libdsg       struct_info.libdsg%TYPE,
                               cdatsai      VARCHAR2(10),
                               cdatdeb      VARCHAR2(10),
                               cdatfin      VARCHAR2(10),
                               cdatrpol     VARCHAR2(10),  -- date de d'envoie au pole
                               cdatdir      VARCHAR2(10),  -- date de retour au pole
                               flaglock     VARCHAR2(20)
                              );

   TYPE ContCurType IS REF CURSOR RETURN ContRecType;

   PROCEDURE update_contrat (
                             p_soccont   IN  contrat.soccont%TYPE,
                             p_soclib    IN  societe.soclib%TYPE,
                             p_numcont   IN  contrat.numcont%TYPE,
                             p_cav       IN  contrat.cav%TYPE,
                             p_cobjet1   IN  contrat.cobjet1%TYPE,
                             p_cobjet2   IN  contrat.cobjet2%TYPE,
                             p_codsg     IN  VARCHAR2,
                             p_libdsg    IN  struct_info.libdsg%TYPE,
                             p_cdatsai   IN  VARCHAR2,
                             p_cdatdeb   IN  VARCHAR2,
                             p_cdatfin   IN  VARCHAR2,
                             p_cdatrpol  IN  VARCHAR2,     -- date de d'envoie au pole
                             p_cdatdir   IN  VARCHAR2,     -- date de retour au pole
                             p_flaglock  IN  NUMBER,
                             p_userid    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            );

   PROCEDURE select_contrat (
                             p_soccont   IN contrat.soccont%TYPE,
                             p_numcont   IN contrat.numcont%TYPE,
                             p_cav       IN contrat.cav%TYPE,
                             p_userid    IN VARCHAR2,
                             p_curcont   IN OUT ContCurType,
                             p_nbcurseur    OUT INTEGER,
                             p_message      OUT VARCHAR2
                            );

END pack_MajDatSuivCont;
/

CREATE OR REPLACE PACKAGE BODY pack_MajDatSuivCont AS

   PROCEDURE update_contrat (
                             p_soccont   IN  contrat.soccont%TYPE,
                             p_soclib    IN  societe.soclib%TYPE,
                             p_numcont   IN  contrat.numcont%TYPE,
                             p_cav       IN  contrat.cav%TYPE,
                             p_cobjet1   IN  contrat.cobjet1%TYPE,
                             p_cobjet2   IN  contrat.cobjet2%TYPE,
                             p_codsg     IN  VARCHAR2,
                             p_libdsg    IN  struct_info.libdsg%TYPE,
                             p_cdatsai   IN  VARCHAR2,
                             p_cdatdeb   IN  VARCHAR2,
                             p_cdatfin   IN  VARCHAR2,
                             p_cdatrpol  IN  VARCHAR2,     -- date de d'envoie au pole
                             p_cdatdir   IN  VARCHAR2,     -- date de retour au pole
                             p_flaglock  IN  NUMBER,
                             p_userid    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);
      l_filcode filiale_cli.filcode%TYPE;

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      -- On recupere le code filiale de l'utilisateur

      l_filcode := pack_global.lire_globaldata(p_userid).filcode;
      -- dbms_output.put_line(l_filcode);

      -- ---------------------------
      -- Controles Regles de gestion
      IF (p_cdatdir IS NULL) OR (p_cdatrpol IS NULL) THEN
         -- Saisie obligatoire
         pack_global.recuperer_message(20434, NULL, NULL, NULL, l_msg);
         p_message := l_msg;
         raise_application_error(-20434, l_msg );
	ELSE
         IF TO_DATE(p_cdatdir, 'dd/mm/yyyy') < TO_DATE(p_cdatsai, 'dd/mm/yyyy') THEN
            -- Date de retour du pôle doit être postérieure ou égale à la date de saisie
            pack_global.recuperer_message(20433,NULL, NULL, 'CDATDIR', l_msg);
            raise_application_error(-20433, l_msg );

         ELSIF TO_DATE(p_cdatrpol, 'dd/mm/yyyy') < TO_DATE(p_cdatsai, 'dd/mm/yyyy') THEN
            -- Date d'envoi au pôle doit être postérieure ou égale à la date de saisie
            pack_global.recuperer_message(20432,NULL, NULL, 'CDATRPOL', l_msg);
            raise_application_error(-20432, l_msg );

         ELSIF TO_DATE(p_cdatrpol, 'dd/mm/yyyy') > TO_DATE(p_cdatdir, 'dd/mm/yyyy') THEN
            -- Date d'envoi au pôle doit être inférieur ou égale à la date de retour du pôle
            pack_global.recuperer_message(20439,NULL, NULL, 'CDATRPOL', l_msg);
            raise_application_error(-20439, l_msg );

         END IF;

      END IF;

      -- UPDATE du contrat
      BEGIN
         UPDATE contrat
         SET cdatrpol  = to_date(p_cdatrpol,'DD/MM/YYYY'),
             cdatdir   = to_date(p_cdatdir,'DD/MM/YYYY'),
             cdatmaj   = trunc(sysdate),
             flaglock  = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE soccont = p_soccont
         AND   filcode = l_filcode
         AND   numcont = RPAD(p_numcont,15)
         AND   cav     = p_cav
         AND   flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN
            -- habiller le msg erreur
            pack_global.recuperation_integrite(-2291);

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN   -- si la mise a jour n'est pas effectuee
         -- Accès concurrent sur les mêmes données,\nveuillez recharger vos données
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         -- Contrat %s1 modifié
         pack_global.recuperer_message(2089,'%s1',p_numcont, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END update_contrat;


-- *****************************************************************************
-- SELECT FACTURE
-- *****************************************************************************
   PROCEDURE select_contrat (
                             p_soccont   IN contrat.soccont%TYPE,
                             p_numcont   IN contrat.numcont%TYPE,
                             p_cav       IN contrat.cav%TYPE,
                             p_userid    IN VARCHAR2,
                             p_curcont   IN OUT ContCurType,
                             p_nbcurseur    OUT INTEGER,
                             p_message      OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);
      l_soclib  societe.soclib%TYPE;
      l_soccont contrat.soccont%TYPE;
      l_filcode filiale_cli.filcode%TYPE;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_ccentrefrais centre_frais.codcfrais%TYPE;



   BEGIN
      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- ----------------------------------------------------
      -- TEST existence du code societe dans la table societe
      BEGIN
         SELECT DISTINCT soccode
         INTO   l_soccont
         FROM   societe
         WHERE  soccode = p_soccont
           AND  rownum < 2;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
             -- Erreur message "Code Societe inconnu"
             pack_global.recuperer_message(20306, '%s1', p_soccont, 'SOCCONT', l_msg);
             raise_application_error(-20306,l_msg);

         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      --------------------------------------------------------------------------
      -- Test de l'existence du no de contrat et no avenant dans la table contrat
      BEGIN
         SELECT distinct soccont
         INTO   l_soccont
         FROM   contrat
         WHERE  numcont = RPAD(p_numcont,15)
           AND  cav = p_cav
           AND  rownum < 2;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
             -- Erreur message "Contrat inexistant"
             pack_global.recuperer_message(20280, NULL, NULL, 'NUMCONT', l_msg);
             raise_application_error(-20280,l_msg);
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      ----------------------------------------------
      -- On recupere le code filiale de l'utilisateur
      l_filcode := pack_global.lire_globaldata(p_userid).filcode;

      -- Test de l'existance du contrat dans la table contrat pour une autre filiale
      BEGIN
         SELECT distinct soccont
         INTO   l_soccont
         FROM   contrat
         WHERE  soccont = p_soccont
         AND    numcont = RPAD(p_numcont,15)
         AND    cav     = p_cav
         AND    filcode <> l_filcode;

         IF SQL%FOUND THEN
             -- Erreur message "Le contrat existe deja pour une autre filiale"
             pack_global.recuperer_message(20286, NULL, NULL, 'NUMCONT', l_msg);
             raise_application_error(-20286,l_msg);
         END IF;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
             NULL;
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      -- 20/12/2000 :Contrôler que le contrat appartient au centre de frais de l'utilisateur
      -- On récupère le code centre de frais de l'utilisateur
      l_centre_frais:=pack_global.lire_globaldata(p_userid).codcfrais;

     IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
        BEGIN
		select ccentrefrais into l_ccentrefrais
		from contrat
        	where  	numcont = p_numcont
	 	and	soccont = p_soccont
         	and    cav     = p_cav
		and    filcode = l_filcode;
	EXCEPTION

		WHEN OTHERS THEN
               		raise_application_error(-20997,SQLERRM);

	END;
	IF l_ccentrefrais is null  then
		-- Ce contrat n'est rattaché à aucun centre de frais
			 pack_global.recuperer_message(20336, '%s1',to_char(l_centre_frais),NULL, l_msg);
         		 raise_application_error(-20336, l_msg);

	END IF;
  	IF l_ccentrefrais!=l_centre_frais then
		--Le contrat n'existe pas dans le centre de frais mais dans le centre %s2
		 pack_global.recuperer_message(20335, '%s1',to_char(l_centre_frais),'%s2',to_char(l_ccentrefrais),NULL, l_msg);
         	raise_application_error(-20335, l_msg);
	END IF;
     END IF;

      ----------------------
      -- select

      BEGIN
            OPEN p_curcont FOR
               SELECT c.soccont                           ,
                      s.soclib                            ,
                      c.numcont                           ,
                      c.cav                               ,
                      c.cobjet1                           ,
                      c.cobjet2                           ,
                      to_char(c.codsg, 'FM0000000')       ,
                      si.libdsg                           ,
                      to_char(c.cdatsai,'dd/mm/yyyy')     ,
                      to_char(c.cdatdeb,'dd/mm/yyyy')     ,
                      to_char(c.cdatfin,'dd/mm/yyyy')     ,
                      to_char(c.cdatrpol,'dd/mm/yyyy')    ,
                      to_char(c.cdatdir,'dd/mm/yyyy')     ,
                      to_char(c.flaglock)
              FROM    contrat c, societe s, struct_info si
              WHERE   c.soccont = p_soccont
              AND     s.soccode = p_soccont
              AND     si.codsg  = c.codsg
              AND     c.filcode = l_filcode
              AND     c.numcont = RPAD(p_numcont,15)
              AND     c.cav     = p_cav;

      EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- Erreur message "Contrat inexistant"
                pack_global.recuperer_message(20280, NULL, NULL, NULL, l_msg);
                raise_application_error(-20280,l_msg);

            WHEN OTHERS THEN
               raise_application_error(-20997,SQLERRM);
      END;

   END select_contrat;

END pack_MajDatSuivCont;
/
CREATE OR REPLACE PACKAGE pack_multi_ca AS

FUNCTION str_multi_ca 		(p_string     IN  VARCHAR2,
                           	 p_occurence  IN  NUMBER
                          	 ) return VARCHAR2;

PROCEDURE select_multi_ca  	 (	p_pid		IN  ligne_bip.pid%TYPE,
                               		p_userid       	IN  VARCHAR2,
                               		p_pnom		OUT ligne_bip.pnom%TYPE,
                               		p_anneeEx	OUT VARCHAR2,
                               		p_nbpages	OUT VARCHAR2,
                               		p_numpage 	OUT VARCHAR2,
                               		p_nbcurseur	OUT INTEGER,
                               		p_message	OUT VARCHAR2
                             		 );

PROCEDURE update_multi_ca(  	p_string    IN  VARCHAR2,
				p_pid	    IN  VARCHAR2,
                              	p_userid    IN  VARCHAR2,
                              	p_message   OUT VARCHAR2
                             );

PROCEDURE verif_multi_ca(     p_codcamo   IN  VARCHAR2,
			      p_datdeb	  IN  VARCHAR2,
			      p_clicode	  IN  VARCHAR2,
                              p_userid    IN  VARCHAR2,
                              p_libca	  OUT centre_activite.clibrca%TYPE,
                              p_clilib    OUT client_mo.clilib%TYPE,
                              p_message   OUT VARCHAR2
                             );

PROCEDURE verif_edition_multi_ca  (	p_pid		IN  ligne_bip.pid%TYPE,
					p_codsg		IN  VARCHAR2,
                               		p_userid       	IN  VARCHAR2,
                               		p_message	OUT VARCHAR2
                             		 );


END pack_multi_ca;
/

CREATE OR REPLACE PACKAGE BODY pack_multi_ca AS

   FUNCTION str_multi_ca (p_string     IN  VARCHAR2,
                          p_occurence  IN  NUMBER
                          ) return VARCHAR2 IS
   pos1 NUMBER(6);
   pos2 NUMBER(6);
   str  VARCHAR2(111);

   BEGIN

      pos1 := INSTR(p_string,';',1,p_occurence);
      pos2 := INSTR(p_string,';',1,p_occurence+1);

      IF pos2 != 1 THEN
         str := SUBSTR( p_string, pos1+1, pos2-pos1-1);
         return str;
      ELSE
         return '1';
      END IF;

   END str_multi_ca;

PROCEDURE select_multi_ca  (	p_pid		IN  ligne_bip.pid%TYPE,
                               	p_userid       	IN  VARCHAR2,
                               	p_pnom		OUT ligne_bip.pnom%TYPE,
                               	p_anneeEx	OUT VARCHAR2,
                               	p_nbpages	OUT VARCHAR2,
                               	p_numpage 	OUT VARCHAR2,
                               	p_nbcurseur	OUT INTEGER,
                               	p_message	OUT VARCHAR2
                              	) IS

    -- Nombre de lignes maxi par pages
    NB_LIGNES_PAGES	NUMBER(2)	:= 10;
    -- clé CodCAMO pour indiquer la facturation multi-ca
    CODCAMO_MULTI	VARCHAR2(6)	:= '77777';
    l_msg		VARCHAR2(1024);
    l_nbpages		NUMBER(5);
    l_codcamo		VARCHAR2(6);
    l_codsg 		ligne_bip.codsg%TYPE;
    l_habilitation 	VARCHAR2(10);

    BEGIN
      p_numpage := 'NumPage#1';

      -- Année d'exercice
      SELECT TO_CHAR(datdebex, 'YYYY') INTO p_anneeEx
      FROM datdebex WHERE ROWNUM < 2;

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur := 1;
      p_message := '';

      -- On vérifie que le PID demandé existe
      -- Et on vérifie que le CODCAMO de la ligne BIP est bien renseigné à CODCAMO_MULTI
      BEGIN
      	SELECT TO_CHAR(codcamo), pnom INTO l_codcamo, p_pnom
      	FROM ligne_bip WHERE pid=p_pid;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
        	pack_global.recuperer_message(20504, '%s1', p_pid, 'pid', l_msg);
	        raise_application_error(-20504, l_msg);
	WHEN OTHERS THEN
		-- Message d'alerte Problème inconnu
	      	raise_application_error(-20997, SQLERRM);
      END;
      IF l_codcamo<>CODCAMO_MULTI THEN
      	pack_global.recuperer_message(20142, '%s1', p_pid, 'pid', l_msg);
	raise_application_error(-20142, l_msg);
      END IF;

      --
      -- On vérifie que l'utilisateur est habilité au PID demandé
      SELECT codsg INTO l_codsg
      FROM   ligne_bip
      WHERE  pid = p_pid;
      l_habilitation := pack_habilitation.fhabili_me(l_codsg, p_userid);
      IF l_habilitation='faux' THEN
        -- Vous n'etes pas autorise a modifier cette ligne BIP, son DPG est
	pack_global.recuperer_message(20365, '%s1',  'modifier cette ligne BIP, son DPG est '||l_codsg, 'PID', l_msg);
        raise_application_error(-20365, l_msg);
      END IF;

      -- On compte le nombre de lignes
      SELECT count(*) INTO l_nbpages
      FROM repartition_ligne WHERE pid=p_pid;

      l_nbpages := CEIL(l_nbpages/NB_LIGNES_PAGES);
      p_nbpages := 'NbPages#'|| l_nbpages;


    END select_multi_ca;


PROCEDURE update_multi_ca(	p_string    IN  VARCHAR2,
				p_pid	    IN  VARCHAR2,
                              	p_userid    IN  VARCHAR2,
                              	p_message   OUT VARCHAR2
                             ) IS

   l_msg    VARCHAR2(10000);
   l_cpt    NUMBER(7);

   l_datdeb  	  VARCHAR2(7);
   l_datdeb_faux  VARCHAR2(7);
   l_taux_faux	repartition_ligne.tauxrep%TYPE;
   l_codcamo 	repartition_ligne.codcamo%TYPE;
   l_clicode 	repartition_ligne.clicode%TYPE;
   l_tauxrep 	repartition_ligne.tauxrep%TYPE;


   BEGIN
      -- Initialiser le message retour
      p_message   := '';
      l_cpt       := 1;
      l_datdeb_faux := '';

      WHILE l_cpt != 0 LOOP
         l_datdeb  	:= pack_multi_ca.str_multi_ca(p_string,l_cpt);
       	 l_codcamo 	:= TO_NUMBER(pack_multi_ca.str_multi_ca(p_string,l_cpt+1));
       	 l_clicode	:= pack_multi_ca.str_multi_ca(p_string,l_cpt+2);
       	 l_tauxrep 	:= TO_NUMBER(pack_multi_ca.str_multi_ca(p_string,l_cpt+3));


	 -- Si une ligne est retournée
         IF l_datdeb != '0' THEN

            -- Si le taux est égal à 0, on supprime la ligne de la table
            IF l_tauxrep=0 THEN
            	DELETE repartition_ligne
            	WHERE PID=p_pid
            	  AND datdeb = TO_DATE(l_datdeb, 'MM/YYYY')
            	  AND codcamo = l_codcamo;
            ELSE
         	UPDATE repartition_ligne
         	SET clicode = l_clicode,
         	    tauxrep = l_tauxrep
	    	WHERE pid = p_pid
	    	AND datdeb = TO_DATE(l_datdeb, 'MM/YYYY')
	    	AND codcamo = l_codcamo;

	    	IF (SQL%NOTFOUND) AND (l_tauxrep > 0) THEN
	    		INSERT INTO repartition_ligne (pid, codcamo, clicode, tauxrep, datdeb)
	    		VALUES (p_pid, l_codcamo, l_clicode, l_tauxrep, TO_DATE(l_datdeb, 'MM/YYYY'));
	    	END IF;
	    END IF;
            l_cpt := l_cpt + 4;

         ELSE
            l_cpt :=0;
         END IF;
      END LOOP;

      -- Vérif qu'il reste au moins une ligne de données afin d'éviter la disparition de consommés
      BEGIN
      	SELECT 		TO_CHAR(rl.datdeb, 'MM/YYYY') INTO l_datdeb
      	FROM 		repartition_ligne rl
      	WHERE 		pid = p_pid
      	  AND		ROWNUM < 2;
      EXCEPTION
      	WHEN NO_DATA_FOUND THEN
		-- Les lignes ont voulues être supprimées : Interdit
		pack_global.recuperer_message(20264, '%s1', 'd''exercice', NULL, p_message);
		raise_application_error(-20264, p_message);
	WHEN OTHERS THEN
		-- Message d'erreur inconnu
		raise_application_error(-20997, SQLERRM);
      END;


      -- Mise à jour de datfin : c'est la date datdeb minimale qui est supérieure à datdeb de la ligne
      UPDATE repartition_ligne l
      SET l.datfin = (SELECT MIN(rl.datdeb) FROM repartition_ligne rl WHERE rl.datdeb > l.datdeb AND rl.pid = p_pid)
      WHERE pid = p_pid;

      -- Vérification que tous les taux sont à 100%
      BEGIN
      	SELECT 		TO_CHAR(rl.datdeb, 'MM/YYYY'), st.somme_taux INTO l_datdeb_faux, l_taux_faux
      	FROM 		repartition_ligne rl,
      			(SELECT   rl1.pid, rl1.datdeb, SUM(rl1.tauxrep) AS somme_taux
      			 FROM     repartition_ligne rl1
      			 WHERE    rl1.pid=p_pid
      			 GROUP BY rl1.pid, rl1.datdeb
      			) st
      	WHERE 		rl.pid = st.pid
      	  AND 		rl.datdeb = st.datdeb
      	  AND 		st.somme_taux <> 100
      	  AND		ROWNUM < 2;
      EXCEPTION
      	WHEN NO_DATA_FOUND THEN
		-- C'est normal, tout va bien, on valide
		pack_global.recuperer_message(20977, '%s1', 'Nouveaux taux de répartition', NULL, p_message);
	WHEN OTHERS THEN
		-- Message d'erreur inconnu
		raise_application_error(-20997, SQLERRM);
      END;

      -- Si il y a un taux <> 100%, on envoie un message
      IF (l_datdeb_faux IS NOT NULL) THEN
        pack_global.recuperer_message(20264, '%s1', l_datdeb_faux, '%s2', l_taux_faux, NULL, p_message);
	raise_application_error(-20264, p_message);
      END IF;

   END update_multi_ca;

PROCEDURE verif_multi_ca     (p_codcamo   IN  VARCHAR2,
			      p_datdeb	  IN  VARCHAR2,
                              p_clicode	  IN  VARCHAR2,
                              p_userid    IN  VARCHAR2,
                              p_libca	  OUT centre_activite.clibrca%TYPE,
                              p_clilib    OUT client_mo.clilib%TYPE,
                              p_message   OUT VARCHAR2
                             ) IS

   l_datdebex	datdebex.datdebex%TYPE;
   l_test 	CHAR(1) ;

   BEGIN
     BEGIN
     	-- Vérif CA existe
   	SELECT clibrca INTO p_libca
   	FROM centre_activite
   	WHERE codcamo = TO_NUMBER(p_codcamo);
     EXCEPTION
     	WHEN NO_DATA_FOUND THEN
   	  -- CODCAMO inconnu!
     	  pack_global.recuperer_message(20754, NULL, NULL, 'CODCAMO', p_message);
     	WHEN OTHERS THEN
	  -- Message d'alerte Problème inconnu
	  raise_application_error(-20997, SQLERRM);
     END;


     -- Vérif sur la date saisie
     SELECT datdebex INTO l_datdebex
     FROM datdebex;
     IF TO_DATE(p_datdeb, 'MM/YYYY') < ADD_MONTHS(l_datdebex, -1) THEN
     	  -- Interdit de faire des saisies sur l'exercice antérieur
     	  pack_global.recuperer_message(20313, NULL, NULL, 'DATDEB', p_message);
     END IF;

     -- Retourne le code client
     IF (p_clicode IS NOT NULL) THEN
	     BEGIN
	     	-- Vérif clicode existe
	   	SELECT clilib INTO p_clilib
	   	FROM client_mo
	   	WHERE clicode = p_clicode;
	     EXCEPTION
	     	WHEN NO_DATA_FOUND THEN
	   	  -- Client inconnu
	   	  pack_global.recuperer_message(4, '%s1', p_clicode, 'CLICODE', p_message);
	     	WHEN OTHERS THEN
		  -- Message d'alerte Problème inconnu
		  raise_application_error(-20997, SQLERRM);
	     END;
     END IF;

     -- centre_activite fermé ou non facturable
	BEGIN
		SELECT 	'1' INTO l_test
		FROM 	CENTRE_ACTIVITE c , DATDEBEX d
		WHERE	c.codcamo=TO_NUMBER(p_codcamo)
		AND NVL(c.cdfain,0) <> 3
		AND (c.cdateferm  IS NULL OR c.cdateferm >= d.moismens);
		EXCEPTION
		WHEN NO_DATA_FOUND THEN
			Pack_Global.recuperer_message( 20984, NULL, NULL, NULL, p_message);

           	WHEN OTHERS THEN
               		RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;

   END verif_multi_ca;

PROCEDURE verif_edition_multi_ca  (p_pid		IN  ligne_bip.pid%TYPE,
				p_codsg		IN  VARCHAR2,
                               	p_userid       	IN  VARCHAR2,
                               	p_message	OUT VARCHAR2
                              	) IS

    l_habilitation 	VARCHAR2(10);
    l_msg		VARCHAR2(1024);

    -- Variables créées pour pouvoir utiliser la fonction select_multi_ca
    --    elles n'ont pas d'autre utilité
    l_numpage 		VARCHAR2(10);
    l_nbpages 		VARCHAR2(10);
    l_pnom 		ligne_bip.pnom%TYPE;
    l_anneeEx 		VARCHAR2(10);
    l_nbcurseur 	INTEGER ;


    BEGIN

	if ( p_pid is null or p_pid ='' ) THEN

	-- Edition Multi-CA par DPG

		-- Vérifie si l'utilisateur est habilité au DPG
	      	pack_habilitation.verif_habili_me(p_codsg, p_userid,l_msg);


	else

	-- Edition Multi-CA par Ligne BIP

	-- Appel de la fonction de controle Edition Multi-CA par ligne BIP
	select_multi_ca  (	p_pid		,
                               	p_userid       	,
                               	l_pnom		,
                               	l_anneeEx	,
                               	l_nbpages	,
                               	l_numpage 	,
                               	l_nbcurseur	,
                               	p_message	);


	end if ;


    END verif_edition_multi_ca;



END pack_multi_ca;
/
CREATE OR REPLACE PACKAGE     pack_nature AS

   TYPE nature_ViewType IS RECORD ( cod_nature    VARCHAR2(4),
                                   lib_nature    nature.lib_nature%TYPE,
					 	           flaglock   	nature.flaglock%TYPE
						          );

   TYPE natureCurType IS REF CURSOR RETURN nature_ViewType;


   PROCEDURE insert_nature (
                         p_nature     in VARCHAR2,
                         p_lib_nature in nature.lib_nature%TYPE,
 	                     p_flaglock  in nature.flaglock%TYPE,
                         p_message   out VARCHAR2
                                 );

   PROCEDURE update_nature (p_nature     in VARCHAR2,
                           p_lib_nature in nature.lib_nature%TYPE,
 	                       p_flaglock  in nature.flaglock%TYPE,
                           p_message   out VARCHAR2
                              );

   PROCEDURE delete_nature (p_nature     in VARCHAR2,
                           p_lib_nature in nature.lib_nature%TYPE,
 	                       p_flaglock  in nature.flaglock%TYPE,
                           p_message   out VARCHAR2
                                   );

   PROCEDURE select_nature_c ( p_nature  in VARCHAR2,
                              p_curseur IN OUT natureCurType,
                              p_message  out VARCHAR2
                                );

   PROCEDURE select_nature_m ( p_nature  in VARCHAR2,
                              p_curseur IN OUT natureCurType,
                              p_message  out VARCHAR2
                             );


END pack_nature;
/

CREATE OR REPLACE PACKAGE BODY     pack_nature AS

       PROCEDURE insert_nature (p_nature     in VARCHAR2,
                        p_lib_nature in nature.lib_nature%TYPE,
 	                    p_flaglock  in nature.flaglock%TYPE,
                        p_message   out VARCHAR2

                                 ) IS
       l_msg VARCHAR2(1024);
       l_nature nature.lib_nature%TYPE;

       BEGIN
          p_message := '';

          begin
            select codnature into l_nature
            from nature where codnature=to_number(p_nature);

            -- test si le nature n'existe pas déjà.

            if(l_nature is not null OR l_nature != null) then
                pack_global.recuperer_message( 20968, '%s1', p_nature, NULL, l_msg);
                p_message := l_msg;
                raise_application_error( -20968, l_msg );
            end if;

            EXCEPTION
            WHEN NO_DATA_FOUND THEN
               begin
                -- création du nature
                insert into nature(codnature, lib_nature, flaglock)
                values
                (
                 p_nature,
                 p_lib_nature,
                 0
                );
                pack_global.recuperer_message(20971, '%s1', 'Code nature ' || p_nature, NULL, l_msg);
                p_message := l_msg;
              end;

            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
          end;

       END insert_nature;

       /******************** PROCEDURE update_nature ******************/

       PROCEDURE update_nature (p_nature     in VARCHAR2,
                               p_lib_nature in nature.lib_nature%TYPE,
 	                           p_flaglock  in nature.flaglock%TYPE,
                               p_message   out VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       l_nature nature.codnature%TYPE;

       BEGIN
       p_message := '';

          -- test si le nature existe .

          begin
            select codnature into l_nature
            from nature where codnature=to_number(p_nature);

            update nature set
            lib_nature = p_lib_nature,
            codnature = to_number(p_nature),
            flaglock 	= DECODE( p_flaglock, 1000000, 0, p_flaglock + 1 )
            where codnature = TO_NUMBER(p_nature)
            and   flaglock 	= p_flaglock;

            -- 'nature modifié
            pack_global.recuperer_message(20972, '%s1', 'Code nature ' || p_nature, NULL, l_msg);
            p_message := l_msg;

            EXCEPTION
            WHEN NO_DATA_FOUND THEN
                pack_global.recuperer_message( 20969, '%s1', p_nature, NULL, l_msg);
                p_message := l_msg;
                raise_application_error( -20969, l_msg );
            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

          end;

       END update_nature;

       /******************** PROCEDURE delete_nature ******************/

       PROCEDURE delete_nature (p_nature     in VARCHAR2,
                               p_lib_nature in nature.lib_nature%TYPE,
 	                       p_flaglock  in nature.flaglock%TYPE,
                               p_message   out VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       referential_integrity EXCEPTION;
       PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

       BEGIN
          -- Initialiser le message retour
          p_message := '';

          begin
        	DELETE FROM nature
        	WHERE codnature = TO_NUMBER(p_nature)
        	AND flaglock = p_flaglock;
               EXCEPTION
               WHEN referential_integrity THEN
               -- habiller le msg erreur
               --pack_global.recuperation_integrite(-2292);
               pack_global.recuperer_message( 20970, '%s1', p_nature,'%s2','nature', NULL, l_msg);
               p_message := l_msg;
               raise_application_error( -20970, l_msg );
        	   WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
          end;

          IF SQL%NOTFOUND THEN
    	   -- 'Accès concurrent'
    	    pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
            raise_application_error( -20999, l_msg );
          ELSE
    	   -- 'Le code nature p_nature a été supprimé'
    	   pack_global.recuperer_message( 20973, '%s1', 'Code nature ' || p_nature, NULL, l_msg);
          END IF;

          p_message := l_msg;

       END delete_nature;

       /******************** PROCEDURE select_nature ******************/

       PROCEDURE select_nature_c ( p_nature  in VARCHAR2,
                                  p_curseur IN OUT natureCurType,
                                  p_message  out VARCHAR2
                                )IS
       l_msg VARCHAR2(1024);

       BEGIN

              OPEN p_curseur FOR SELECT
                   TO_CHAR(codnature) as codnature,
                   lib_nature,
                   flaglock
              FROM  nature
              WHERE codnature = TO_NUMBER(p_nature);

              pack_global.recuperer_message( 20968, '%s1', p_nature, NULL, l_msg);
              p_message := l_msg;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

       END select_nature_c;

       PROCEDURE select_nature_m (p_nature  in VARCHAR2,
                                 p_curseur IN OUT natureCurType,
                                 p_message  out VARCHAR2
                                )IS
       l_msg VARCHAR2(1024);

       BEGIN

              OPEN p_curseur FOR SELECT
                   TO_CHAR(codnature) as codnature,
                   lib_nature,
                   flaglock
              FROM  nature
              WHERE codnature = TO_NUMBER(p_nature);

              pack_global.recuperer_message( 20969, '%s1', p_nature, NULL, l_msg);
              p_message := l_msg;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

       END select_nature_m;


END pack_nature;
/
CREATE OR REPLACE PACKAGE pack_newcod AS
  -- ------------------------------------------------------------------------
  -- Nom        :  update_cod
  -- Auteur     :  Noï
  -- Description :  met à jour les champs code comptable et code fournisseur
  --                dans les tables contrat, fature, ligne_fact, histo_contrat,
  --		    histo_facture, histo_ligne_fact, code_compt, agence
  --
  -- ------------------------------------------------------------------------
PROCEDURE update_cod(	p_logdir in varchar2,
			p_chemin_fichier in varchar2);
END pack_newcod;
/

CREATE OR REPLACE PACKAGE BODY pack_newcod AS
-- -------------------
-- Gestions exceptions
-- -------------------
	CALLEE_FAILED exception;
	pragma exception_init( CALLEE_FAILED, -20000 );
	CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
	TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
	ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
	CONSTRAINT_VIOLATION exception;          -- pour clause when
	pragma exception_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
  -- ------------------------------------------------------------------------
  -- Nom        :  update_cod
  -- Auteur     :  N.C
  -- Description :   met à jour les champs code comptable et code fournisseur
  --                dans les tables contrat, fature, ligne_fact, histo_contrat,
  --		    histo_facture, histo_ligne_fact, code_compt, agence
  --
  -- ------------------------------------------------------------------------
PROCEDURE update_cod(	p_logdir in varchar2,
			p_chemin_fichier in varchar2) AS
L_HFILE utl_file.file_type;
L_RETCOD number;
L_PROCNAME varchar2(50) := 'CONVERSION CC-CF';
L_STATEMENT varchar2(64);
l_filecompt 	utl_file.file_type;
l_filefour  	utl_file.file_type;
l_ligne_fichier varchar2(500);
l_pos1 		integer;
l_pos2 		integer;
l_pos3 		integer;
l_pos4 		integer;
l_oldcod 	varchar2(11);
l_newcod 	varchar2(11);
l_libelle 	varchar2(25);
l_type 		char(1);
l_exist 	integer;
l_soc 		varchar2(4);
l_sitefour  varchar2(3);
l_cod 	varchar2(15);
l_codcompt 	number:=0;
l_codfour 	number:=0;
BEGIN
 -- ----------------
 -- Init de la trace
 -- ----------------
	L_RETCOD := TRCLOG.INITTRCLOG( p_logdir, L_PROCNAME, L_HFILE );
	  if ( L_RETCOD <> 0 ) then
	      raise_application_error( TRCLOG_FAILED_ID,
				       'Erreur : Gestion du fichier LOG impossible',
				       false );
	  end if;
 -- -----------
 -- Trace Start
 -- -----------
	TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );
   -- ************************************************ --
       L_STATEMENT := 'MAJ CODE COMPTABLE';
   -- ************************************************ --
   BEGIN
	-- Ouverture du fichier des codes comptables
	l_filecompt := UTL_FILE.FOPEN(p_chemin_fichier,'code_compta','r');
	LOOP
		-- Lecture de chaque ligne du fichier
		UTL_FILE.GET_LINE(l_filecompt, l_ligne_fichier);
		l_pos1 := INSTR(l_ligne_fichier,';',1,1);
		l_pos2 := INSTR(l_ligne_fichier,';',1,2);
		l_pos3 := INSTR(l_ligne_fichier,';',1,3);
	--TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || ' : ' ||l_pos1||', '||l_pos2||', '||l_pos3);
		l_oldcod  := RTRIM(SUBSTR(l_ligne_fichier,1, l_pos1-1 ));
		l_newcod  := RTRIM(SUBSTR(l_ligne_fichier, l_pos1+1 , l_pos2-l_pos1-1  ));
		l_libelle := RTRIM(SUBSTR(l_ligne_fichier, l_pos2+1 , l_pos3-l_pos2-1  ));
		l_type    := RTRIM(SUBSTR(l_ligne_fichier, l_pos3+1 ,1));
	TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || ' : ' ||l_oldcod|| ', '||l_newcod);
	------------------------------
	-- MAJ DE LA TABLE CODE_COMPT
	------------------------------
		-- Vérifier que le nouveau code comptable n'existe pas déjà dans la table
	     BEGIN
		SELECT 1 into l_exist
		FROM CODE_COMPT
		--WHERE comcode=l_oldcod;
		WHERE comcode=l_newcod;
		EXCEPTION
		WHEN NO_DATA_FOUND THEN
			-- Ajouter les nouveaux codes
			INSERT INTO CODE_COMPT VALUES (l_newcod,l_libelle,l_type,0);
			--TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || ' : ' ||l_oldcod);
			l_codcompt:=l_codcompt + 1;
	     END ;
		-- supprimer les anciens codes
		DELETE CODE_COMPT WHERE comcode=l_oldcod;
	------------------------------
	-- MAJ DE LA TABLE CONTRAT
	------------------------------
		UPDATE CONTRAT
		SET COMCODE=l_newcod
		WHERE COMCODE=l_oldcod;
		commit;
	------------------------------
	-- MAJ DE LA TABLE FACTURE
	------------------------------
		UPDATE FACTURE
		SET FCODCOMPTA=l_newcod
		WHERE FCODCOMPTA=l_oldcod;
		commit;
	------------------------------
	-- MAJ DE LA TABLE LIGNE_FACT
	------------------------------
		UPDATE LIGNE_FACT
		SET LCODCOMPTA=l_newcod
		WHERE LCODCOMPTA=l_oldcod;
		commit;
	---------------------------------
	-- MAJ DE LA TABLE HISTO_CONTRAT
	---------------------------------
		UPDATE HISTO_CONTRAT
		SET COMCODE=l_newcod
		WHERE COMCODE=l_oldcod;
		commit;
	---------------------------------
	-- MAJ DE LA TABLE HISTO_FACTURE
	---------------------------------
		UPDATE HISTO_FACTURE
		SET FCODCOMPTA=l_newcod
		WHERE FCODCOMPTA=l_oldcod;
		commit;
	------------------------------------
	-- MAJ DE LA TABLE HISTO_LIGNE_FACT
	------------------------------------
		UPDATE HISTO_LIGNE_FACT
		SET LCODCOMPTA=l_newcod
		WHERE LCODCOMPTA=l_oldcod;
		commit;
	END LOOP;
   EXCEPTION
   WHEN NO_DATA_FOUND THEN
	commit;
	-- Fermeture du fichier
	UTL_FILE.FCLOSE(l_filecompt);
   END;
	TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || ' : ' ||l_codcompt|| ' nouveaux codes comptables .');
   -- ************************************************* --
      L_STATEMENT := 'MAJ CODE FOURNISSEUR';
   -- ************************************************* --
   BEGIN
	-- Ouverture du fichier des codes fournisseurs
	l_filefour := UTL_FILE.FOPEN(p_chemin_fichier,'sitefour','r');
	LOOP
		-- Lecture de chaque ligne du fichier
		UTL_FILE.GET_LINE(l_filefour,l_ligne_fichier);
		l_pos1 := INSTR(l_ligne_fichier,';',1,1);
		l_pos2 := INSTR(l_ligne_fichier,';',1,2);
		l_pos3 := INSTR(l_ligne_fichier,';',1,3);
		l_pos4 := INSTR(l_ligne_fichier,';',1,4);
		l_oldcod := RTRIM(SUBSTR(l_ligne_fichier,1,l_pos1-1));
		l_newcod := RTRIM(SUBSTR(l_ligne_fichier,l_pos1+1,l_pos2-l_pos1-1));
		l_soc    := RTRIM(SUBSTR(l_ligne_fichier,l_pos2+1,l_pos3-l_pos2-1));
		l_libelle:= RTRIM(SUBSTR(l_ligne_fichier,l_pos3+1,25));
		l_sitefour:= RTRIM(SUBSTR(l_ligne_fichier,l_pos4+1,3));
	--	TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || ' : ' ||l_oldcod|| ', '||l_newcod||', '||l_soc||', '||l_libelle);
	--Le nouveau code doit être la concaténation du code fournisseur et du site fournisseur
	--Le code fournisseur est sur 6 caractères avec des 0 devant pour faire le compte
		l_cod := LPAD(l_newcod,6,0)||l_sitefour;
	TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || ' : ' ||l_cod);
	-- MAJ DE LA TABLE AGENCE
		-- cas où plusieurs anciens codes fournisseur-société correspondent au même nouveau code fourniseur-société
	    BEGIN
		SELECT 1 into l_exist
		FROM AGENCE
		WHERE rtrim(SOCFOUR)=l_cod
		AND rtrim(SOCCODE)= l_soc;
	    EXCEPTION
		WHEN NO_DATA_FOUND THEN
			INSERT INTO AGENCE VALUES (l_cod,l_libelle,0,l_soc);
			l_codfour:=l_codfour + 1;
	    END;
		DELETE AGENCE
		WHERE ltrim(rtrim(ltrim(ltrim(socfour),'000')))=l_oldcod
		AND rtrim(soccode)=l_soc;
		commit;
	-- MAJ DE LA TABLE FACTURE
		UPDATE FACTURE
		SET FSOCFOUR= l_cod
		WHERE ltrim(rtrim(ltrim(ltrim(FSOCFOUR),'000')))= l_oldcod
		AND   rtrim(SOCFACT)= l_soc;
		commit;
	-- MAJ DE LA TABLE HISTO_FACTURE
		UPDATE HISTO_FACTURE
		SET FSOCFOUR= l_cod
		WHERE ltrim(rtrim(ltrim(ltrim(FSOCFOUR),'000')))= l_oldcod
		AND   rtrim(SOCFACT)= l_soc;
		commit;
	END LOOP;
   EXCEPTION
   WHEN NO_DATA_FOUND THEN
	commit;
	-- Fermeture du fichier
	UTL_FILE.FCLOSE(l_filefour);
   END;
	TRCLOG.TRCLOG(L_HFILE, L_STATEMENT || ' : ' ||l_codfour|| ' nouveaux codes fournisseurs .');
 -- ----------
 -- Trace Stop
 -- ----------
	TRCLOG.TRCLOG( L_HFILE, 'Fin normale de ' || L_PROCNAME );
	TRCLOG.CLOSETRCLOG( L_HFILE );
EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		If  sqlcode <> CALLEE_FAILED_ID and
	         	sqlcode <> TRCLOG_FAILED_ID then
		   	TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' : '|| SQLERRM );
	     	end if;
	     	if sqlcode <> TRCLOG_FAILED_ID then
		  	TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		  	TRCLOG.CLOSETRCLOG( L_HFILE );
		  	raise_application_error( CALLEE_FAILED_ID,
					 'Erreur : consulter le fichier LOG',false );
	     	else
		  	raise;
	     	end if;
END update_cod;
END pack_newcod;
/
CREATE OR REPLACE PACKAGE pack_oscar_lignebip AS

   PROCEDURE alim_oscar;

   PROCEDURE select_oscar_lignebip (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2
		);

   PROCEDURE lance_oscar_lignebip (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2
		);

   PROCEDURE oscar_ressource (
			p_chemin_fichier	IN VARCHAR2,
			p_nom_fichier		IN VARCHAR2
		);


   PROCEDURE select_bip_pma (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2
		);

	PROCEDURE select_bip_metrique (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2
       );

END pack_oscar_lignebip;
/

CREATE OR REPLACE PACKAGE BODY pack_oscar_lignebip AS

   PROCEDURE alim_oscar IS
	-- algorythme  :
	-- on crée une table temporaire de même structure que le fichier oscar en sortie
	-- à chaque appel de la procédure d'alimentation de la table temporaire on delete ce qu'il y a dedans
	-- puis on alimente toutes les colonnes qui contiennent des données différentes des budgets ou consommé
	-- on met les colonnes budgétaires ou de consommé à NULL
	-- puis on update la table à partir des tables budget consomme et proplus
	-- une fois la table ok on fait le select sur toute la table


	-- delete de la table temporaire tmp_oscar
	BEGIN
		DELETE FROM tmp_oscar;
		COMMIT;
	-- alimentation de la table temporaire tmp_oscar
	-- dans un premier temp on insère les données pour les colonnes différentes du budget ou du consommé
	  BEGIN


		INSERT INTO tmp_oscar ( pid,
					datdebex,
					pnom,
					typproj,
					dpcode,
					dplib,
					sigdeppole,
					clisigle,
					codcamo,
					codpspe ,
					icpi,
					ilibel,
					factint,
					airt ,
					alibel,
					arctype,
					rnom ,
					pnmouvra,
					bpmontme ,
					bpmontme1,
					bpmontme2,
					bpmontme3,
					bnmont,
					reserve,
					anmont,
					xcusmois,
					cusag,
					xcusag,
					reestime,
					metier,
					topfer,
					cle_bip,
                                        astatut,
                                        adatestatut,
					bpmontmo,
					bpmontmo1
				      )
				      ( SELECT  lb.pid,
						d.datdebex,
						lb.pnom,
						lb.typproj,
						lb.dpcode,
						rpad(nvl(DP.dplib,' '),35,' '),
						sti.sigdep||'/'||nvl(sti.sigpole,' '),
						cmo.clisigle,
						lb.codcamo,
						lb.codpspe,
						lb.icpi,
						rpad(nvl(PI.ilibel,' '),50,' '),
						conskf.factint,
						lb.airt,
						rpad(nvl(AP.alibel,' '),50,' '),
						lb.arctype,
						ress.rnom,
						lb.pnmouvra,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						NULL,
						lb.metier,
						lb.topfer,
						lb.pcle,
						lb.astatut,
						lb.adatestatut,
						NULL,
						NULL
					FROM  	ligne_bip lb,
						datdebex		d,
        					ressource ress,
        					proj_info PI,
        					dossier_projet DP,
        					application AP,
        					struct_info   sti,
						(SELECT ROUND((SUM(consoft+consoenvimmo+nconsoenvimmo)/1000),1)	factint,
						ligne_bip.pid
						FROM 	ligne_bip
							, stock_fi
						WHERE stock_fi.pid(+) = ligne_bip.pid
						AND ligne_bip.typproj NOT IN ('7')
						AND ligne_bip.codsg > 1
						GROUP BY ligne_bip.pid
          					) CONSKF,
        					client_mo cmo
					WHERE	lb.pcpi = ress.ident
					AND lb.codsg = sti.codsg
					AND lb.clicode = cmo.clicode
					AND     lb.pid = CONSKF.pid(+)
					AND lb.icpi    = PI.icpi
  					AND lb.airt    = AP.airt
 					AND lb.dpcode  = DP.dpcode
        				AND sti.coddep != '50'
        				AND     lb.typproj != '7' );

		COMMIT;



	  END;
	-- deuxième temps on update le table tmp_oscar pour les colonnes budgétaires

	  BEGIN

		UPDATE tmp_oscar SET 	bpmontme = (select bpmontme from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY'))
							and budget.pid = tmp_oscar.pid),
					bpmontme1 = (select bpmontme from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY')) +1
							and budget.pid = tmp_oscar.pid) ,
					bpmontme2 = (select bpmontme from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY')) +2
							and budget.pid = tmp_oscar.pid),
					bpmontme3 = (select bpmontme from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY')) +3
							and budget.pid = tmp_oscar.pid),
					bnmont = (select bnmont from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY'))
							and budget.pid = tmp_oscar.pid) ,
					reserve = (select reserve from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY'))
							and budget.pid = tmp_oscar.pid),
					anmont = (select anmont from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY'))
							and budget.pid = tmp_oscar.pid),
					reestime = (select reestime from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY'))
							and budget.pid = tmp_oscar.pid),
					bpmontmo = (select bpmontmo from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY'))
							and budget.pid = tmp_oscar.pid),
					bpmontmo1 = (select bpmontmo from budget,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY')) +1
							and budget.pid = tmp_oscar.pid);


		COMMIT;

	  END;

	-- troisième temps on update la table tmp_oscar pour les colonnes de consomme

	  BEGIN

		UPDATE tmp_oscar SET 	cusag = (select cusag from consomme,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY'))
							and consomme.pid = tmp_oscar.pid),
					xcusag = (select xcusag from consomme,datdebex
							where annee = TO_NUMBER(TO_CHAR(datdebex.datdebex,'YYYY'))
							and consomme.pid = tmp_oscar.pid),
					xcusmois = (select conso_mois.xcusmois from
							(SELECT factpid pid,SUM(cusag) xcusmois
							FROM proplus, datdebex,ligne_bip lb
							WHERE proplus.factpid=lb.pid
							AND (qualif not in ('MO','GRA','STA','INT','IFO') OR qualif is null)
							AND trunc(proplus.cdeb,'MONTH')=trunc(datdebex.moismens,'MONTH')
	 						GROUP BY factpid
	 						)conso_mois
							WHERE conso_mois.pid = tmp_oscar.pid);


		COMMIT;
	  END;

	-- quatrième temps on update la table tmp_oscar pour les lignes de type T1 le top fermeture
	BEGIN

		Update tmp_oscar set topfer = 'N'
			where astatut is null
			and   adatestatut is null;

		Update tmp_oscar set topfer = 'O'
			where astatut in ('D','A','C')
			and   adatestatut <= sysdate;


		Update tmp_oscar set topfer = 'N'
			where astatut in ('D','A','C')
			and   adatestatut > sysdate;

		commit;

	END;

   END alim_oscar;

   PROCEDURE select_oscar_lignebip (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2) IS


       l_hfile utl_file.file_type;
       l_datdebex number(4);
       l_msg  varchar2(1024);

-- déclaration du curseur pour oscar
	CURSOR curs_oscar IS
	SELECT rpad(nvl(pid,' '),4,' ') pid,
        lpad(to_char(datdebex,'YYYY'),4,' ') datdebex,
        rpad(nvl(replace(pnom,'"',' '),' '),30,' ') pnom,
        rpad(nvl(typproj,' '),1,' ') typproj,
        rpad(to_char(nvl(dpcode,0)),5,' ') dpcode,
        lpad(to_char(nvl(bpmontme,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme,
        lpad(to_char(nvl(bpmontme1,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme1,
        lpad(to_char(nvl(bpmontme2,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme2,
        lpad(to_char(nvl(bpmontme3,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme3,
	lpad(to_char(nvl(bnmont,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bnmont,
	lpad(to_char(nvl(reserve,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') reserve,
	lpad(to_char(nvl(anmont,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') anmont,
	lpad(to_char(nvl(xcusmois,'0'), 'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') xcusmois,
	lpad(to_char(nvl(cusag,'0'), 'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') cusag,
	lpad(to_char(nvl(xcusag,'0'), 'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') xcusag,
	lpad(to_char(nvl(reestime,'0'),'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') reestime,
	rpad(sigdeppole,7,' ') sigdeppole,
	rpad(nvl(clisigle,' '),8,' ') clisigle,
	rpad(to_char(nvl(codcamo,0)),5,' ') codcamo,
	rpad(nvl(codpspe,' '),1,' ') codpspe,
	rpad(nvl(icpi,' '),5,' ') icpi,
	lpad(to_char(nvl(factint,'0'),'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') factint,
	rpad(nvl(airt,' '),5,' ') airt,
	rpad(nvl(arctype,' '),3,' ') arctype,
	rpad(nvl(replace(rnom,'"',' '),' '),30,' ') rnom,
	rpad(nvl(replace(pnmouvra,'"',' '),' '),15,' ') pnmouvra,
	rpad(nvl(metier,' '),3,' ') metier,
	rpad(nvl(topfer,' '),1,' ') topfer,
	rpad(nvl(cle_bip,' '),3,' ') cle_bip,
	lpad(to_char(nvl(bpmontmo,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontmo,
	lpad(to_char(nvl(bpmontmo1,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontmo1,
	rpad(nvl(dplib,' '),35,' ') libdp,
	rpad(nvl(ilibel,' '),50,' ') libproj,
	rpad(nvl(alibel,' '),50,' ') libappli
FROM    tmp_oscar
ORDER BY rpad(nvl(pid,' '),4,' ');


   BEGIN


      select to_number(to_char(datdebex,'YYYY')) into l_datdebex from datdebex;


      PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);


    FOR cur_enr IN curs_oscar
      LOOP
        PACK_GLOBAL.WRITE_STRING( l_hfile,
                                   '"' ||cur_enr.pid 				|| '";' ||
                                   cur_enr.datdebex				|| ';"' ||
                                   cur_enr.pnom 				|| '";"' ||
                                   cur_enr.typproj			 	|| '";"' ||
                                   cur_enr.dpcode 				|| '";' ||
                                   cur_enr.bpmontme 				|| ';' ||
                                   cur_enr.bpmontme1 				|| ';' ||
                                   cur_enr.bpmontme2				|| ';' ||
                                   cur_enr.bpmontme3 				|| ';' ||
				   cur_enr.bnmont 				|| ';' ||
                                   LPAD(TO_CHAR(0,'FM0D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') 	|| ';' ||
				   cur_enr.anmont 				|| ';' ||
                                   cur_enr.xcusmois 				|| ';' ||
				   cur_enr.cusag 				|| ';' ||
                                   cur_enr.xcusag 				|| ';' ||
                                   cur_enr.reestime 				|| ';"' ||
                                   cur_enr.sigdeppole 				|| '";"' ||
                                   cur_enr.clisigle 				|| '";"' ||
                                   cur_enr.codcamo 				|| '";"' ||
				   cur_enr.codpspe 				|| '";"' ||
				   cur_enr.icpi 				|| '";' ||
				   cur_enr.factint				|| ';"' ||
                                   cur_enr.airt 				|| '";"' ||
                                   cur_enr.arctype	 			|| '";"' ||
                                   cur_enr.rnom 				|| '";"' ||
                                   cur_enr.pnmouvra 				|| '";"' ||
				   cur_enr.metier				|| '";"' ||
				   cur_enr.topfer				|| '";"' ||
				   cur_enr.cle_bip				|| '";' ||
				   cur_enr.bpmontmo                             || ';' ||
				   cur_enr.bpmontmo1				|| ';' ||
				   cur_enr.libdp 				|| ';' ||
				   cur_enr.libproj 				|| ';' ||
				   cur_enr.libappli 				);
       END LOOP;


       PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);


	EXCEPTION
   		WHEN OTHERS THEN


   		pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
   		raise_application_error(-20401, l_msg);

    END select_oscar_lignebip;

    PROCEDURE lance_oscar_lignebip (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2) IS

	l_msg  varchar2(1024);
	BEGIN

		pack_oscar_lignebip.alim_oscar;
		pack_oscar_lignebip.select_oscar_lignebip(p_chemin_fichier,p_nom_fichier);

	EXCEPTION
   		WHEN OTHERS THEN

   		pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
   		raise_application_error(-20401, l_msg);

	END lance_oscar_lignebip;


	PROCEDURE oscar_ressource(
			p_chemin_fichier	IN VARCHAR2,
			p_nom_fichier		IN VARCHAR2
	) IS
		CURSOR csr_ressource IS
			SELECT TO_CHAR(ressource.ident)			ident
				, ressource.matricule			matricule
				, ressource.rnom			rnom
				, ressource.rprenom			rprenom
				, TO_CHAR(struct_info.centractiv)	centractiv
				, ressource.rtype			rtype
			FROM struct_info
				, situ_ress_full
				, ressource
			WHERE situ_ress_full.ident=ressource.ident
			AND situ_ress_full.codsg=struct_info.codsg
			AND (situ_ress_full.datsitu<=SYSDATE OR situ_ress_full.datsitu IS NULL)
			AND (situ_ress_full.datdep>=SYSDATE OR situ_ress_full.datdep IS NULL)
			AND ressource.rtype='P';

		l_msg  varchar2(1024);
		l_hfile utl_file.file_type;
	BEGIN
		PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);

		FOR rec_ressource IN csr_ressource LOOP
			PACK_GLOBAL.WRITE_STRING( l_hfile,
				rec_ressource.ident || ';' ||
				rec_ressource.matricule || ';' ||
				rec_ressource.rnom || ';' ||
				rec_ressource.rprenom || ';' ||
				rec_ressource.centractiv || ';' ||
				rec_ressource.rtype);
		END LOOP;
		PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);
	EXCEPTION
   		WHEN OTHERS THEN
			pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
			raise_application_error(-20401, l_msg);
	END oscar_ressource;

-- extraction pour l'appli PMA
PROCEDURE select_bip_pma (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2) IS


       l_hfile utl_file.file_type;
       l_datdebex number(4);
       l_msg  varchar2(1024);

-- déclaration du curseur
	CURSOR curs_pma IS
	SELECT rpad(nvl(o.pid,' '),4,' ') pid,
        lpad(to_char(o.datdebex,'YYYY'),4,' ') datdebex,
        rpad(nvl(replace(o.pnom,'"',' '),' '),30,' ') pnom,
        rpad(nvl(o.typproj,' '),1,' ') typproj,
        rpad(to_char(nvl(o.dpcode,0)),5,' ') dpcode,
        lpad(to_char(nvl(o.bpmontme,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme,
        lpad(to_char(nvl(o.bpmontme1,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme1,
        lpad(to_char(nvl(o.bpmontme2,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme2,
        lpad(to_char(nvl(o.bpmontme3,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme3,
	lpad(to_char(nvl(o.bnmont,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bnmont,
	lpad(to_char(nvl(o.reserve,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') reserve,
	lpad(to_char(nvl(o.anmont,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') anmont,
	lpad(to_char(nvl(o.xcusmois,'0'), 'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') xcusmois,
	lpad(to_char(nvl(o.cusag,'0'), 'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') cusag,
	lpad(to_char(nvl(o.xcusag,'0'), 'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') xcusag,
	lpad(to_char(nvl(o.reestime,'0'),'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') reestime,
	rpad(o.sigdeppole,7,' ') sigdeppole,
	rpad(nvl(o.clisigle,' '),8,' ') clisigle,
	rpad(to_char(nvl(o.codcamo,0)),5,' ') codcamo,
	rpad(nvl(o.codpspe,' '),1,' ') codpspe,
	rpad(nvl(o.icpi,' '),5,' ') icpi,
	lpad(to_char(nvl(o.factint,'0'),'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') factint,
	rpad(nvl(o.airt,' '),5,' ') airt,
	rpad(nvl(o.arctype,' '),2,' ') arctype,
	rpad(nvl(replace(o.rnom,'"',' '),' '),30,' ') rnom,
	rpad(nvl(replace(o.pnmouvra,'"',' '),' '),15,' ') pnmouvra,
	rpad(nvl(o.metier,' '),3,' ') metier,
	rpad(nvl(o.topfer,' '),1,' ') topfer,
	rpad(nvl(o.cle_bip,' '),3,' ') cle_bip,
	lpad(to_char(nvl(o.bpmontmo,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontmo,
	lpad(to_char(nvl(o.bpmontmo1,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontmo1,
	rpad(nvl(o.dplib,' '),35,' ') libdp,
	rpad(nvl(o.ilibel,' '),50,' ') libproj,
	rpad(nvl(o.alibel,' '),50,' ') libappli,
	rpad(nvl(to_char(l.codsg),' '),7,' ') codsg,
	rpad(nvl(s.libdsg,' '),30,' ') libdsg
FROM    tmp_oscar o, struct_info s, ligne_bip l
WHERE   o.pid = l.pid
AND     l.codsg = s.codsg
ORDER BY rpad(nvl(o.pid,' '),4,' ');


   BEGIN


      select to_number(to_char(datdebex,'YYYY')) into l_datdebex from datdebex;


      PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);


    FOR cur_enr IN curs_pma
      LOOP
        PACK_GLOBAL.WRITE_STRING( l_hfile,
                                   '"' ||cur_enr.pid 				|| '";' ||
                                   cur_enr.datdebex				|| ';"' ||
                                   cur_enr.pnom 				|| '";"' ||
                                   cur_enr.typproj			 	|| '";"' ||
                                   cur_enr.dpcode 				|| '";' ||
                                   cur_enr.bpmontme 				|| ';' ||
                                   cur_enr.bpmontme1 				|| ';' ||
                                   cur_enr.bpmontme2				|| ';' ||
                                   cur_enr.bpmontme3 				|| ';' ||
				   cur_enr.bnmont 				|| ';' ||
                                   LPAD(TO_CHAR(0,'FM0D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') 	|| ';' ||
				   cur_enr.anmont 				|| ';' ||
                                   cur_enr.xcusmois 				|| ';' ||
				   cur_enr.cusag 				|| ';' ||
                                   cur_enr.xcusag 				|| ';' ||
                                   cur_enr.reestime 				|| ';"' ||
                                   cur_enr.sigdeppole 				|| '";"' ||
                                   cur_enr.clisigle 				|| '";"' ||
                                   cur_enr.codcamo 				|| '";"' ||
				   cur_enr.codpspe 				|| '";"' ||
				   cur_enr.icpi 				|| '";' ||
				   cur_enr.factint				|| ';"' ||
                                   cur_enr.airt 				|| '";"' ||
                                   cur_enr.arctype	 			|| '";"' ||
                                   cur_enr.rnom 				|| '";"' ||
                                   cur_enr.pnmouvra 				|| '";"' ||
				   cur_enr.metier				|| '";"' ||
				   cur_enr.topfer				|| '";"' ||
				   cur_enr.cle_bip				|| '";' ||
				   cur_enr.bpmontmo                             || ';' ||
				   cur_enr.bpmontmo1				|| ';' ||
				   cur_enr.libdp 				|| ';' ||
				   cur_enr.libproj 				|| ';' ||
				   cur_enr.libappli 				|| ';' ||
				   cur_enr.codsg 				|| ';' ||
				   cur_enr.libdsg 				);
       END LOOP;


       PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);


	EXCEPTION
   		WHEN OTHERS THEN


   		pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
   		raise_application_error(-20401, l_msg);

END select_bip_pma;

--
-- extraction pour l'appli METRIQUE
--
PROCEDURE select_bip_metrique (
                       p_chemin_fichier IN VARCHAR2,
                       p_nom_fichier    IN VARCHAR2) IS

       l_hfile utl_file.file_type;
       l_datdebex number(4);
       l_msg  varchar2(1024);

-- déclaration du curseur
CURSOR curs_metrique IS
SELECT
	rpad(nvl(o.pid,' '),4,' ') pid,
	lpad(to_char(o.datdebex,'YYYY'),4,' ') datdebex,
	rpad(nvl(replace(o.pnom,'"',' '),' '),30,' ') pnom,
	rpad(nvl(o.typproj,' '),1,' ') typproj,
	rpad(to_char(nvl(o.dpcode,0)),5,' ') dpcode,
	lpad(to_char(nvl(o.bpmontme,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme,
	lpad(to_char(nvl(o.bpmontme1,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme1,
	lpad(to_char(nvl(o.bpmontme2,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme2,
	lpad(to_char(nvl(o.bpmontme3,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontme3,
	lpad(to_char(nvl(o.bnmont,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bnmont,
	lpad(to_char(nvl(o.reserve,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') reserve,
	lpad(to_char(nvl(o.anmont,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') anmont,
	lpad(to_char(nvl(o.xcusmois,'0'), 'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') xcusmois,
	lpad(to_char(nvl(o.cusag,'0'), 'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') cusag,
	lpad(to_char(nvl(o.xcusag,'0'), 'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') xcusag,
	lpad(to_char(nvl(o.reestime,'0'),'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') reestime,
	rpad(o.sigdeppole,7,' ') sigdeppole,
	rpad(nvl(o.clisigle,' '),8,' ') clisigle,
	rpad(to_char(nvl(o.codcamo,0)),5,' ') codcamo,
	rpad(nvl(o.codpspe,' '),1,' ') codpspe,
	rpad(nvl(o.icpi,' '),5,' ') icpi,
	lpad(to_char(nvl(o.factint,'0'),'FM999990D00','NLS_NUMERIC_CHARACTERS='',.'),8,' ') factint,
	rpad(nvl(o.airt,' '),5,' ') airt,
	rpad(nvl(o.arctype,' '),2,' ') arctype,
	rpad(nvl(replace(o.rnom,'"',' '),' '),30,' ') rnom,
	rpad(nvl(replace(o.pnmouvra,'"',' '),' '),15,' ') pnmouvra,
	rpad(nvl(o.metier,' '),3,' ') metier,
	rpad(nvl(o.topfer,' '),1,' ') topfer,
	rpad(nvl(o.cle_bip,' '),3,' ') cle_bip,
	lpad(to_char(nvl(o.bpmontmo,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontmo,
	lpad(to_char(nvl(o.bpmontmo1,'0'),'FM99990D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') bpmontmo1,
	rpad(nvl(o.dplib,' '),35,' ') libdp,
	rpad(nvl(o.ilibel,' '),50,' ') libproj,
	rpad(nvl(o.alibel,' '),50,' ') libappli,
	rpad(nvl(to_char(l.codsg),' '),7,' ') codsg,
	rpad(nvl(s.libdsg,' '),30,' ') libdsg
	,rpad(nvl(l.sous_type,' '),3,' ') soustype
	,lpad(TO_CHAR(ADD_MONTHS(sysdate,-1),'YYYYMM'),6,' ') datearrete
	,lpad(to_char(l.adatestatut,'DD/MM/YYYY'),10,' ') adatestatut
FROM    tmp_oscar o, struct_info s, ligne_bip l
WHERE   o.pid = l.pid AND l.codsg = s.codsg
ORDER BY rpad(nvl(o.pid,' '),4,' ');

BEGIN

	-- Regenere la table TMP_OSCAR
	pack_oscar_lignebip.alim_oscar;

	select to_number(to_char(datdebex,'YYYY')) into l_datdebex from datdebex;
	PACK_GLOBAL.INIT_WRITE_FILE( p_chemin_fichier, p_nom_fichier, l_hfile);

    FOR cur_enr IN curs_metrique
      LOOP
        PACK_GLOBAL.WRITE_STRING( l_hfile,
	'"' ||cur_enr.pid 			|| '";' ||
	cur_enr.datdebex			|| ';"' ||
	cur_enr.pnom 				|| '";"' ||
	cur_enr.typproj			 	|| '";"' ||
	cur_enr.dpcode 				|| '";' ||
	cur_enr.bpmontme 			|| ';' ||
	cur_enr.bpmontme1 			|| ';' ||
	cur_enr.bpmontme2			|| ';' ||
	cur_enr.bpmontme3 			|| ';' ||
	cur_enr.bnmont 				|| ';' ||
	LPAD(TO_CHAR(0,'FM0D00','NLS_NUMERIC_CHARACTERS='',.,'),8,' ') 	|| ';' ||
	cur_enr.anmont 				|| ';' ||
	cur_enr.xcusmois 			|| ';' ||
	cur_enr.cusag 				|| ';' ||
	cur_enr.xcusag 				|| ';' ||
	cur_enr.reestime 			|| ';"' ||
	cur_enr.sigdeppole 			|| '";"' ||
	cur_enr.clisigle 			|| '";"' ||
	cur_enr.codcamo 			|| '";"' ||
	cur_enr.codpspe 			|| '";"' ||
	cur_enr.icpi 				|| '";' ||
	cur_enr.factint				|| ';"' ||
	cur_enr.airt 				|| '";"' ||
	cur_enr.arctype	 			|| '";"' ||
	cur_enr.rnom 				|| '";"' ||
	cur_enr.pnmouvra 			|| '";"' ||
	cur_enr.metier				|| '";"' ||
	cur_enr.topfer				|| '";"' ||
	cur_enr.cle_bip				|| '";' ||
	cur_enr.bpmontmo                        || ';' ||
	cur_enr.bpmontmo1			|| ';' ||
	cur_enr.libdp 				|| ';' ||
	cur_enr.libproj 			|| ';' ||
	cur_enr.libappli 			|| ';' ||
	cur_enr.codsg 				|| ';' ||
	cur_enr.libdsg 				|| ';' ||
	cur_enr.soustype			|| ';' ||
	cur_enr.datearrete			|| ';' ||
	cur_enr.adatestatut			);
      END LOOP;

	PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);

	EXCEPTION
   		WHEN OTHERS THEN
   		pack_global.recuperer_message(20401, NULL, NULL, NULL, l_msg);
   		raise_application_error(-20401, l_msg);

END select_bip_metrique;
END pack_oscar_lignebip;
/
CREATE OR REPLACE PACKAGE PACK_PARAMETRE AS
	PROCEDURE select_parametre ( p_cle    	IN  parametre.cle%TYPE,
	                            	p_valeur 	OUT  parametre.valeur%TYPE,
	                            	p_listeValeurs OUT  parametre.liste_valeurs%TYPE,
	                            	p_libelle OUT  parametre.libelle%TYPE,
	                            	p_message   	OUT VARCHAR2
	                                );

	PROCEDURE select_lib_parametre ( p_cle    	IN  parametre.cle%TYPE,
                            	p_valeur 	OUT  parametre.valeur%TYPE,
                            	p_message   	OUT VARCHAR2
                                );
	PROCEDURE select_listeval_parametre ( p_cle    	IN  parametre.cle%TYPE,
                            	p_valeur 	OUT  parametre.valeur%TYPE,
                            	p_message   	OUT VARCHAR2
                                );

	PROCEDURE update_parametre ( p_cle    	IN  parametre.cle%TYPE,
                            	p_valeur 	IN  parametre.valeur%TYPE,
                            	p_message   	OUT VARCHAR2
                              );
END PACK_PARAMETRE;
/

CREATE OR REPLACE PACKAGE BODY PACK_PARAMETRE AS

	-- Récupération de la valeur d'un paramètre de la table
	PROCEDURE select_parametre ( p_cle    	IN  parametre.cle%TYPE,
	                            	p_valeur 	OUT  parametre.valeur%TYPE,
	                            	p_listeValeurs OUT  parametre.liste_valeurs%TYPE,
	                            	p_libelle OUT  parametre.libelle%TYPE,
	                            	p_message   	OUT VARCHAR2
	                                ) IS
	BEGIN
		select VALEUR,LISTE_VALEURS,LIBELLE into p_valeur, p_listeValeurs, p_Libelle
		from PARAMETRE
		where CLE = p_CLE;
	END select_parametre;

	-- Récupération du libelle d'un paramètre de la table
	PROCEDURE select_lib_parametre ( p_cle    	IN  parametre.cle%TYPE,
	                            	p_valeur 	OUT  parametre.valeur%TYPE,
	                            	p_message   	OUT VARCHAR2
	                                ) IS
	BEGIN
		select LIBELLE into p_valeur
		from PARAMETRE
		where CLE = p_CLE;
	END select_lib_parametre;

	-- Récupération de la liste des valeurs autorisées d'un paramètre de la table
	PROCEDURE select_listeval_parametre ( p_cle    	IN  parametre.cle%TYPE,
	                            	p_valeur 	OUT  parametre.valeur%TYPE,
	                            	p_message   	OUT VARCHAR2
	                                ) IS
	BEGIN
		select LISTE_VALEURS into p_valeur
		from PARAMETRE
		where CLE = p_CLE;
	END select_listeval_parametre;


	-- Mise à jour de la valeur d'un paramètre de la table
	PROCEDURE update_parametre (	p_cle    	IN  parametre.cle%TYPE,
	                            	p_valeur 	IN  parametre.valeur%TYPE,
	                            	p_message   	OUT VARCHAR2
	                              )
	IS

	BEGIN
		update PARAMETRE set VALEUR = p_valeur where CLE = p_cle;
		--delete PARAMETRE where CLE = p_cle;

		--insert into PARAMETRE(CLE, VALEUR) values (p_cle, p_valeur);
	END update_parametre;

END PACK_PARAMETRE;
/
CREATE OR REPLACE PACKAGE pack_pca4 AS
-- **************************************************************************************
-- Nom 		: f_lib_sst
-- Auteur 	: MMC
-- Description 	:
-- Param¿tres 	: p_pid (IN) code de la ligne bip imput¿e
--		  p_propid (IN)
-- Retour	: libelle de la sous tache
--
-- **************************************************************************************
FUNCTION  f_lib_sst (p_propid   IN proplus.pid%TYPE,p_aist IN proplus.aist%TYPE) RETURN VARCHAR2 ;
PRAGMA restrict_references(f_lib_sst,wnds,wnps);


-- **************************************************************************************
-- Nom 		: f_conso_sst
-- Auteur 	: MMC
-- Description 	: calcule le consomme en sous traitance
-- Param¿tres 	: p_pid (IN) code de la ligne bip imput¿e
--		  p_propid (IN)
-- Retour	: cusag
--
-- **************************************************************************************
FUNCTION  f_conso_sst (p_pid   IN ligne_bip.pid%TYPE,p_propid IN proplus.pid%TYPE,p_pcpi IN proplus.pcpi%TYPE) RETURN VARCHAR2 ;
PRAGMA restrict_references(f_conso_sst,wnds,wnps);

-- **************************************************************************************
-- Nom 		: f_date
-- Auteur 	: MMC
-- Description 	: recupere la DATE (il faut avoir la DATE sous forme de variable afin de faire une 2eme
--			jointure ouverte sur la TABLE proplus
-- Param¿tres 	: p_datdebex (IN) code de la ligne bip imput¿e
--		  p_propid (IN)
-- Retour	: annee courante
--
-- **************************************************************************************
FUNCTION  f_date  RETURN VARCHAR2 ;
PRAGMA restrict_references(f_date,wnds,wnps);

END pack_pca4;
/

CREATE OR REPLACE PACKAGE BODY pack_pca4 IS

FUNCTION  f_lib_sst (p_propid   IN proplus.pid%TYPE,p_aist IN proplus.aist%TYPE) RETURN VARCHAR2 IS
l_lib tache.asnom%TYPE;

BEGIN
	SELECT MAX(asnom) INTO l_lib
	FROM tache
	WHERE pid=p_propid
	AND aist=p_aist;
RETURN l_lib;
END f_lib_sst;


/******************************************************************************/
FUNCTION  f_conso_sst (p_pid   IN ligne_bip.pid%TYPE,p_propid IN proplus.pid%TYPE,p_pcpi IN proplus.pcpi%TYPE) RETURN VARCHAR2 IS
l_conso proplus.cusag%TYPE;
l_date VARCHAR2(4);

BEGIN
	SELECT to_char(DATDEBEX,'yyyy') INTO l_date
	FROM datdebex;

	SELECT SUM(cusag) INTO l_conso
	FROM proplus
	WHERE factpid=p_pid
	AND pid=p_propid
	AND pid <> factpid
	AND pcpi= p_pcpi
	AND TO_CHAR(cdeb,'yyyy') = l_date ;
RETURN l_conso;
END f_conso_sst;

/******************************************************************************/
FUNCTION  f_date  RETURN VARCHAR2 IS
l_annee VARCHAR2(4);
BEGIN
	SELECT to_char(DATDEBEX,'yyyy') INTO l_annee
	FROM datdebex;
RETURN l_annee;
END f_date;

END pack_pca4;
/
CREATE OR REPLACE PACKAGE pack_pcmratt_proj AS

   TYPE applicationCurType IS REF CURSOR RETURN application%ROWTYPE;
   TYPE proj_infoCurType IS REF CURSOR RETURN proj_info%ROWTYPE;

  PROCEDURE update_un_projet (p_cod      IN VARCHAR2,
                              p_pid      IN ligne_bip.pid%TYPE,
                              p_flaglock IN VARCHAR2,
                              p_table    IN VARCHAR2,
			      p_userid   IN VARCHAR2,
	                      p_compteur IN OUT INTEGER,
                              p_message  IN OUT VARCHAR2
                             );

   PROCEDURE update_pcmratt_proj (p_table      IN  VARCHAR2,
                                  p_cod        IN  VARCHAR2,
                                  p_lib        IN  VARCHAR2,
                                  p_pid_1      IN  ligne_bip.pid%TYPE,
				  p_nom_1      IN  VARCHAR2,
                                  p_flaglock_1 IN  VARCHAR2,
                                  p_pid_2      IN  ligne_bip.pid%TYPE,
				  p_nom_2      IN  VARCHAR2,
                                  p_flaglock_2 IN  VARCHAR2,
                                  p_pid_3      IN  ligne_bip.pid%TYPE,
				  p_nom_3      IN  VARCHAR2,
                                  p_flaglock_3 IN  VARCHAR2,
                                  p_pid_4      IN  ligne_bip.pid%TYPE,
				  p_nom_4      IN  VARCHAR2,
                                  p_flaglock_4 IN  VARCHAR2,
                                  p_pid_5      IN  ligne_bip.pid%TYPE,
				  p_nom_5      IN  VARCHAR2,
                                  p_flaglock_5 IN  VARCHAR2,
                                  p_pid_6      IN  ligne_bip.pid%TYPE,
				  p_nom_6      IN  VARCHAR2,
                                  p_flaglock_6 IN  VARCHAR2,
                                  p_userid     IN  VARCHAR2,
                                  p_nbcurseur  OUT INTEGER,
                                  p_message    OUT VARCHAR2
                                 );

   PROCEDURE select_a_pcmratt_proj (p_airt           IN application.airt%TYPE,
                                    p_userid         IN VARCHAR2,
                                    p_curapplication IN OUT applicationCurType,
                                    p_nbcurseur         OUT INTEGER,
                                    p_message           OUT VARCHAR2
                                  );

   PROCEDURE select_p_pcmratt_proj (p_icpi         IN proj_info.icpi%TYPE,
                                    p_userid       IN VARCHAR2,
                                    p_curproj_info IN OUT proj_infoCurType,
                                    p_nbcurseur       OUT INTEGER,
                                    p_message         OUT VARCHAR2
                                   );
END pack_pcmratt_proj;
/

CREATE OR REPLACE PACKAGE BODY pack_pcmratt_proj AS

  PROCEDURE update_un_projet (p_cod      IN VARCHAR2,
                              p_pid      IN ligne_bip.pid%TYPE,
                              p_flaglock IN VARCHAR2,
                              p_table    IN VARCHAR2,
			      p_userid   IN VARCHAR2,
                              p_compteur IN OUT INTEGER,
                              p_message  IN OUT VARCHAR2
                             ) IS
   l_pid ligne_bip.pid%TYPE;
   l_codsg ligne_bip.codsg%TYPE;
   l_habilitation varchar2(10);
   BEGIN

	--Tester si le codsg de la ligne BIP fait partie du périmètre ME de l'utilisateur
	BEGIN
		select codsg into l_codsg
		from ligne_bip
		where pid = p_pid;

	EXCEPTION

	    WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);

        END;
	l_habilitation := pack_habilitation.fhabili_me(to_char(l_codsg),p_userid);
	if l_habilitation='faux' then
		pack_global.recuperer_message(20360,'%s1', 'à la ligne bip '||p_pid, NULL, p_message);
	  	raise_application_error( -20360, p_message );
	end if;

      IF p_table = 'PRJ' THEN

         BEGIN
            UPDATE ligne_bip
            SET icpi     = p_cod,
                flaglock = decode( TO_NUMBER(p_flaglock), 1000000, 0, p_flaglock + 1)
            WHERE pid    = p_pid
            AND flaglock = p_flaglock;

         EXCEPTION

            WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);
         END;

      ELSIF p_table = 'APP' THEN
         BEGIN
            UPDATE ligne_bip
            SET airt     = p_cod,
                flaglock = decode( TO_NUMBER(p_flaglock), 1000000, 0, p_flaglock + 1)
            WHERE pid    = p_pid
            AND flaglock = p_flaglock;

         EXCEPTION

            WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);
         END;

      ELSIF p_table = 'DP' THEN
         BEGIN
            UPDATE ligne_bip
            SET dpcode   = p_cod,
                flaglock = decode( TO_NUMBER(p_flaglock), 1000000, 0, p_flaglock + 1)
            WHERE pid    = p_pid
            AND flaglock = p_flaglock;

         EXCEPTION

            WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);
         END;

      END IF;

      IF SQL%NOTFOUND THEN

         -- Rollback car on ne connait pas quel update ne marche pas

         ROLLBACK;

      ELSE

         COMMIT;
         p_compteur := p_compteur + 1;
         p_message := REPLACE( p_message, '%s1', p_pid||'   %s1' );

      END IF;

   END update_un_projet;


   PROCEDURE update_pcmratt_proj (p_table      IN  VARCHAR2,
                                  p_cod        IN  VARCHAR2,
                                  p_lib        IN  VARCHAR2,
                                  p_pid_1      IN  ligne_bip.pid%TYPE,
				  p_nom_1      IN  VARCHAR2,
                                  p_flaglock_1 IN  VARCHAR2,
                                  p_pid_2      IN  ligne_bip.pid%TYPE,
				  p_nom_2      IN  VARCHAR2,
                                  p_flaglock_2 IN  VARCHAR2,
                                  p_pid_3      IN  ligne_bip.pid%TYPE,
				  p_nom_3      IN  VARCHAR2,
                                  p_flaglock_3 IN  VARCHAR2,
                                  p_pid_4      IN  ligne_bip.pid%TYPE,
				  p_nom_4      IN  VARCHAR2,
                                  p_flaglock_4 IN  VARCHAR2,
                                  p_pid_5      IN  ligne_bip.pid%TYPE,
				  p_nom_5      IN  VARCHAR2,
                                  p_flaglock_5 IN  VARCHAR2,
                                  p_pid_6      IN  ligne_bip.pid%TYPE,
				  p_nom_6      IN  VARCHAR2,
                                  p_flaglock_6 IN  VARCHAR2,
                                  p_userid     IN  VARCHAR2,
                                  p_nbcurseur  OUT INTEGER,
                                  p_message    OUT VARCHAR2
                                 ) IS

      l_msg VARCHAR2(1024);
      l_total INTEGER := 0;
   BEGIN

     -- Positionner le nb de curseurs ==> 0
     -- Initialiser le message retour

     p_nbcurseur := 0;
     p_message := '';
     -- Recuperer le message parametre

     IF p_table = 'DP' THEN
         pack_global.recuperer_message( 2060, '%s2', p_cod, NULL, l_msg);
     ELSIF p_table = 'APP' THEN
         pack_global.recuperer_message( 2083, '%s2', p_cod, NULL, l_msg);
     ELSIF p_table = 'PRJ' THEN
         pack_global.recuperer_message( 2084, '%s2', p_cod, NULL, l_msg);
     END IF;

     -- 1er traitement
     if (p_pid_1!='' or p_pid_1 is not null) then
     	update_un_projet( p_cod, p_pid_1, p_flaglock_1, p_table, p_userid, l_total, l_msg);
     end if;
     -- 2e traitement
     if (p_pid_2!='' or p_pid_2 is not null) then
    	update_un_projet( p_cod, p_pid_2, p_flaglock_2, p_table, p_userid, l_total, l_msg);
     end if;
     -- 3e traitement
     if (p_pid_3!='' or p_pid_3 is not null) then
     	update_un_projet( p_cod, p_pid_3, p_flaglock_3, p_table, p_userid, l_total, l_msg);
     end if;
     -- 4e traitement
     if (p_pid_4!='' or p_pid_4 is not null) then
     	update_un_projet( p_cod, p_pid_4, p_flaglock_4, p_table, p_userid, l_total, l_msg);
     end if;
     -- 5e traitement
     if (p_pid_5!='' or p_pid_5 is not null) then
     	update_un_projet( p_cod, p_pid_5, p_flaglock_5, p_table, p_userid, l_total,l_msg);
     end if;
     -- 6er traitement
     if (p_pid_6!='' or p_pid_6 is not null) then
     	update_un_projet( p_cod, p_pid_6, p_flaglock_6, p_table, p_userid, l_total, l_msg);
     end if;

     IF l_total > 0 THEN

        p_message := REPLACE( l_msg, '%s1', NULL );

     ELSE

        pack_global.recuperer_message( 2061, '%s1', p_cod, NULL, l_msg);

     END IF;

  END update_pcmratt_proj;

   PROCEDURE select_a_pcmratt_proj (p_airt        IN application.airt%TYPE,
                                 p_userid         IN VARCHAR2,
                                 p_curapplication IN OUT applicationCurType,
                                 p_nbcurseur         OUT INTEGER,
                                 p_message           OUT VARCHAR2
                                ) IS


      l_msg VARCHAR2(1024);
      l_airt application.airt%TYPE;
      l_habilitation varchar2(10);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

	-- Test pour savoir si le premier caractere de airt est un 'A'

	l_airt := SUBSTR(p_airt, 0, 1);
	IF (l_airt != 'A') THEN
        pack_global.recuperer_message(20206, NULL, NULL, NULL, l_msg);
	  raise_application_error( -20206, l_msg );
	END IF;

      -- TEST pour savoir si p_airt = A0000

      IF p_airt = 'A0000' THEN
        pack_global.recuperer_message(20249, NULL, NULL, NULL, l_msg);
	  raise_application_error( -20249, l_msg );
      END IF;


      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curapplication FOR
              SELECT *
              FROM APPLICATION
              WHERE airt = p_airt;

      EXCEPTION
         WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);

      END;

      -- en cas absence
      -- 'Le centre d'activité n'existe pas';

      pack_global.recuperer_message(2027, '%s1', p_airt, NULL, l_msg);
      p_message := l_msg;

   END select_a_pcmratt_proj;


   PROCEDURE select_p_pcmratt_proj (p_icpi         IN proj_info.icpi%TYPE,
                                    p_userid       IN VARCHAR2,
                                    p_curproj_info IN OUT proj_infoCurType,
                                    p_nbcurseur       OUT INTEGER,
                                    p_message         OUT VARCHAR2
                                   ) IS

       l_msg VARCHAR2(1024);
       l_icpi proj_info.icpi%TYPE;
       l_habilitation varchar2(10);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

	-- Test pour savoir si le premier caractere de icpi est un 'P'

	l_icpi := SUBSTR(p_icpi, 0, 1);
	IF (l_icpi != 'P') THEN
         pack_global.recuperer_message(20208, NULL, NULL, NULL, l_msg);
         raise_application_error( -20208, l_msg );
	END IF;

      -- TEST pour savoir si p_airt = P0000

      IF p_icpi = 'P0000' THEN
        	pack_global.recuperer_message(20250, NULL, NULL, NULL, l_msg);
	  	raise_application_error( -20250, l_msg );
      END IF;


      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curproj_info FOR
              SELECT *
              FROM PROJ_INFO
              WHERE icpi = p_icpi;

     EXCEPTION
        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
     END;

      -- en cas absence
      -- 'Le projet n'existe pas';

      pack_global.recuperer_message(2035, '%s1', p_icpi, NULL, l_msg);

      p_message := l_msg;

   END select_p_pcmratt_proj;

END pack_pcmratt_proj;
/
CREATE OR REPLACE PACKAGE pack_pmw_to_isac IS
	PROCEDURE transfert(p_pid IN isac_etape.pid%TYPE);

	PROCEDURE purge(p_pid IN isac_etape.pid%TYPE);
	PROCEDURE purge_cp(p_cpident IN NUMBER);

	PROCEDURE pmw_to_isac(p_chemin_fichier  IN VARCHAR2, p_cpident IN NUMBER);
	PROCEDURE pmw_to_isac(p_cpident IN NUMBER);

	PROCEDURE f_verif_cp(	p_cp IN VARCHAR2,
					p_message   OUT VARCHAR2);

	PROCEDURE pec_isac(	p_cp1 IN VARCHAR2,
				p_cp2 IN VARCHAR2,
				p_cp3 IN VARCHAR2,
				p_cp4 IN VARCHAR2,
				p_cp5 IN VARCHAR2,
 				p_global    IN VARCHAR2,
                       		p_nbcurseur OUT INTEGER,
                       		p_message   OUT VARCHAR2
				);
END pack_pmw_to_isac;
/

CREATE OR REPLACE PACKAGE BODY pack_pmw_to_isac IS
-- Déclaration du curseur : liste des pid du chef de projet
CURSOR CUR_PID(p_cpident IN NUMBER)  IS
 		select pid
		from ligne_bip
		where pcpi=p_cpident;

-- ***************************************************************
-- PROCEDURE transfert
-- permet d'alimenter les tables ISAC
-- ***************************************************************
	PROCEDURE transfert(p_pid IN isac_etape.pid%TYPE) IS
		l_nb	INTEGER;
	BEGIN
		INSERT INTO isac_etape(pid, etape, ecet, libetape, typetape, flaglock)
			SELECT pid
				, seq_etape.nextval
				, ecet
				, pid || ' / ' || ecet
				, typetap
				, 0
			FROM etape
			WHERE typetap IS NOT NULL
				AND pid=p_pid;

	commit;

		INSERT INTO isac_tache(pid, etape, tache, acta, libtache, flaglock)
			SELECT
				les_taches.pid
				, les_taches.etape
				, seq_tache.nextval
				, les_taches.acta
				, les_taches.libetape
				, 0
			FROM
				(SELECT DISTINCT
					tache.pid
					, isac_etape.etape
					, tache.acta
					, isac_etape.libetape || '/' || tache.acta libetape
				FROM isac_etape, tache
				WHERE isac_etape.pid=tache.pid
					AND isac_etape.ecet=tache.ecet
				) les_taches
			WHERE les_taches.pid=p_pid;

	commit;

		INSERT INTO isac_sous_tache(pid, etape, tache, sous_tache, acst, asnom
									, aist, asta, adeb, afin, ande, anfi, adur, flaglock)
			SELECT tache.pid
				, isac_tache.etape
				, isac_tache.tache
				, seq_sous_tache.nextval
				, tache.acst
				, NVL(tache.asnom, 'nom vide')
				, tache.aist
				, asta
				, tache.adeb
				, tache.afin
				, tache.ande
				, tache.anfi
				, tache.adur
				, 0
			FROM isac_etape, isac_tache, tache
			WHERE tache.pid=isac_etape.pid
				AND tache.ecet=isac_etape.ecet
				AND tache.acta=isac_tache.acta
				AND isac_etape.etape=isac_tache.etape
				AND isac_etape.pid=p_pid;
	commit;

--Test s'il y a du consommé pour la ligne
BEGIN
	l_nb := 0 ;

	 select count(1) into l_nb
	 from cons_sstache_res_mois
	 where  pid= p_pid;

	 IF l_nb = 0 THEN
	 	--
	 	-- Si on n'a pas trouvé de consommé, on va chercher dans la table
	 	-- cons_sstache_res_mois_back afin de ramener des ressources qui ont
	 	-- consommé l'année précédente
	 	-- Cas d'un rattachement à ISAC qui intervient au cours du mois de
	 	-- Janvier alors que la table cons_sstache_res_mois est vide
	 	--
	 	INSERT INTO isac_affectation(pid, etape, tache, sous_tache, ident)
			SELECT DISTINCT isac_etape.pid
				, isac_etape.etape
				, isac_tache.tache
				, isac_sous_tache.sous_tache
				, cons_sstache_res_mois_back.ident
			FROM 	isac_etape
				, isac_tache
				, isac_sous_tache
				, cons_sstache_res_mois_back
			WHERE isac_etape.etape=isac_tache.etape
				AND isac_tache.tache=isac_sous_tache.tache
				AND cons_sstache_res_mois_back.pid=isac_etape.pid
				AND cons_sstache_res_mois_back.ecet=isac_etape.ecet
				AND cons_sstache_res_mois_back.acta=isac_tache.acta
				AND cons_sstache_res_mois_back.acst=isac_sous_tache.acst
				AND isac_etape.PID=p_pid;

		commit;
	 ELSE

		INSERT INTO isac_affectation(pid, etape, tache, sous_tache, ident)
			SELECT DISTINCT isac_etape.pid
				, isac_etape.etape
				, isac_tache.tache
				, isac_sous_tache.sous_tache
				, cons_sstache_res_mois.ident
			FROM 	datdebex
				, isac_etape
				, isac_tache
				, isac_sous_tache
				, cons_sstache_res_mois
			WHERE isac_etape.etape=isac_tache.etape
				AND isac_tache.tache=isac_sous_tache.tache
				AND cons_sstache_res_mois.pid=isac_etape.pid
				AND cons_sstache_res_mois.ecet=isac_etape.ecet
				AND cons_sstache_res_mois.acta=isac_tache.acta
				AND cons_sstache_res_mois.acst=isac_sous_tache.acst
				--AND cdeb>=TO_DATE('01/01/2002', 'dd/mm/yyyy')
				AND cdeb>=datdebex.datdebex
				AND isac_etape.PID=p_pid;

		commit;


		INSERT INTO isac_consomme(ident, pid, etape, tache, sous_tache, cdeb, cusag)
			SELECT cons_sstache_res_mois.ident
				, isac_etape.pid
				, isac_etape.etape
				, isac_tache.tache
				, isac_sous_tache.sous_tache
				, cons_sstache_res_mois.cdeb
				, cons_sstache_res_mois.cusag
			FROM datdebex
				, isac_etape
				, isac_tache
				, isac_sous_tache
				, cons_sstache_res_mois
			WHERE isac_etape.etape=isac_tache.etape
				AND isac_tache.tache=isac_sous_tache.tache
				AND cons_sstache_res_mois.pid=isac_etape.pid
				AND cons_sstache_res_mois.ecet=isac_etape.ecet
				AND cons_sstache_res_mois.acta=isac_tache.acta
				AND cons_sstache_res_mois.acst=isac_sous_tache.acst
				AND cdeb>=datdebex.datdebex
				AND isac_etape.PID=p_pid;

		COMMIT;
		END IF;
END;
	END transfert;

-- ***************************************************************
-- PROCEDURE purge
-- permet de supprimer les lignes reliées à un PID
-- ***************************************************************
PROCEDURE purge(p_pid IN isac_etape.pid%TYPE) IS
	BEGIN
		DELETE isac_consomme WHERE pid=p_pid;
		DELETE isac_affectation WHERE pid=p_pid;
		DELETE isac_sous_tache WHERE pid=p_pid;
		DELETE isac_tache WHERE pid=p_pid;
		DELETE isac_etape WHERE pid=p_pid;
		COMMIT;
	END purge;

-- ***************************************************************
-- PROCEDURE purge_cp
-- permet de supprimer les lignes reliées à un chef de projet
-- ***************************************************************
PROCEDURE purge_cp(p_cpident IN NUMBER) IS
	BEGIN
		FOR curseur IN CUR_PID(p_cpident) LOOP
			purge(curseur.pid);
		END LOOP;

	END purge_cp;

-- ***************************************************************
-- PROCEDURE pmw_to_isac
-- permet de lancer le traitement d'alimentation des tables ISAC
-- ***************************************************************
PROCEDURE pmw_to_isac(p_chemin_fichier  IN VARCHAR2, p_cpident IN NUMBER) IS
	l_nb	INTEGER;
	l_hfile     utl_file.file_type;


	BEGIN
		 PACK_GLOBAL.INIT_WRITE_FILE(p_chemin_fichier, 'PMWtoISAC.'||TO_CHAR(p_cpident), l_hfile);

	-- Rechercher toutes les lignes BIP du chef de projet
		FOR curseur IN CUR_PID(p_cpident) LOOP
		--dbms_output.put_line(curseur.pid);
			SELECT COUNT(1)
			INTO l_nb
			FROM isac_tache
			WHERE pid=curseur.pid;

			IF (l_nb=0) THEN
				 transfert(curseur.pid);
				 PACK_GLOBAL.WRITE_STRING( l_hfile,curseur.pid);
			 ELSE
				 PACK_GLOBAL.WRITE_STRING( l_hfile,curseur.pid||' : existe deja dans ISAC');
			END IF;

	END LOOP;
	PACK_GLOBAL.CLOSE_WRITE_FILE(l_hfile);
	END pmw_to_isac;

PROCEDURE pmw_to_isac( p_cpident IN NUMBER) IS
	l_nb	INTEGER;

      	CURSOR CUR_PID IS
 		select pid
		from ligne_bip
		where pcpi=p_cpident ;

	BEGIN


	-- Rechercher toutes les lignes BIP du chef de projet
		FOR curseur IN CUR_PID LOOP
		--dbms_output.put_line(curseur.pid);
			SELECT COUNT(1)
			INTO l_nb
			FROM isac_tache
			WHERE pid=curseur.pid;

			IF (l_nb=0) THEN
				 transfert(curseur.pid);
			END IF;


	END LOOP;

	END pmw_to_isac;


	PROCEDURE f_verif_cp(	p_cp IN VARCHAR2,
					p_message   OUT VARCHAR2)
			 IS
	l_exist number(1);
	BEGIN
		select 1 into l_exist
		from ressource
		where ident=to_number(p_cp);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN --Message : Identifiant chef de projet %s1 inexistant
		 	pack_global.recuperer_message(20226,'%s1',p_cp,NULL,p_message);
            	raise_application_error( -20226, p_message );


	END f_verif_cp;

-- ***************************************************************
-- PROCEDURE pec_isac
-- utiliser dans la page pecisac.htm pour mettre à jour les données d'ISAC
-- ***************************************************************
	PROCEDURE pec_isac(	p_cp1 IN VARCHAR2,
				p_cp2 IN VARCHAR2,
				p_cp3 IN VARCHAR2,
				p_cp4 IN VARCHAR2,
				p_cp5 IN VARCHAR2,
 				p_global    IN VARCHAR2,
                       		p_nbcurseur OUT INTEGER,
                       		p_message   OUT VARCHAR2
				) IS
	l_cp VARCHAR2(256);
	BEGIN
		-- Vérifier que les CP existent dans la BIP
		if (p_cp1!='' or p_cp1 is not null) then
			pack_pmw_to_isac.f_verif_cp(	p_cp1,p_message);
		end if;
		if (p_cp2!='' or p_cp2 is not null) then
			pack_pmw_to_isac.f_verif_cp(	p_cp2,p_message);
		end if;
		if (p_cp3!='' or p_cp3 is not null) then
			pack_pmw_to_isac.f_verif_cp(	p_cp3,p_message);
		end if;
		if (p_cp4!='' or p_cp4 is not null) then
			pack_pmw_to_isac.f_verif_cp(	p_cp4,p_message);
		end if;
		if (p_cp5!='' or p_cp5 is not null) then
			pack_pmw_to_isac.f_verif_cp(	p_cp5,p_message);
		end if;

		if (p_cp1!='' or p_cp1 is not null) then
			pack_pmw_to_isac.pmw_to_isac(to_number(p_cp1));
			l_cp := p_cp1;
		end if;
		if (p_cp2!='' or p_cp2 is not null) then
			pack_pmw_to_isac.pmw_to_isac(to_number(p_cp2));
			l_cp := l_cp||', '||p_cp2;
		end if;
		if (p_cp3!='' or p_cp3 is not null) then
			pack_pmw_to_isac.pmw_to_isac(to_number(p_cp3));
			l_cp := l_cp||', '||p_cp3;
		end if;
		if (p_cp4!='' or p_cp4 is not null) then
			pack_pmw_to_isac.pmw_to_isac(to_number(p_cp4));
			l_cp := l_cp||', '||p_cp4;
		end if;
		if (p_cp5!='' or p_cp5 is not null) then
			pack_pmw_to_isac.pmw_to_isac(to_number(p_cp5));
			l_cp := l_cp||', '||p_cp5;
		end if;

	p_message:='Prise en charge des CP '||l_cp||' terminée';
	END pec_isac;
-- exec pack_pmw_to_isac.pmw_to_isac('/bip/bip3/extraction',3697);
END pack_pmw_to_isac;
/
CREATE OR REPLACE PACKAGE     pack_poste AS

   TYPE poste_ViewType IS RECORD ( cod_poste    VARCHAR2(4),
                                   lib_poste    poste.lib_poste%TYPE,
					 	           flaglock   	poste.flaglock%TYPE
						          );

   TYPE posteCurType IS REF CURSOR RETURN poste_ViewType;


   PROCEDURE insert_poste (
                         p_poste     in VARCHAR2,
                         p_lib_poste in poste.lib_poste%TYPE,
 	                     p_flaglock  in poste.flaglock%TYPE,
                         p_message   out VARCHAR2
                                 );

   PROCEDURE update_poste (p_poste     in VARCHAR2,
                           p_lib_poste in poste.lib_poste%TYPE,
 	                       p_flaglock  in poste.flaglock%TYPE,
                           p_message   out VARCHAR2
                              );

   PROCEDURE delete_poste (p_poste     in VARCHAR2,
                           p_lib_poste in poste.lib_poste%TYPE,
 	                       p_flaglock  in poste.flaglock%TYPE,
                           p_message   out VARCHAR2
                                   );

   PROCEDURE select_poste_c ( p_poste  in VARCHAR2,
                              p_curseur IN OUT posteCurType,
                              p_message  out VARCHAR2
                                );

   PROCEDURE select_poste_m ( p_poste  in VARCHAR2,
                              p_curseur IN OUT posteCurType,
                              p_message  out VARCHAR2
                             );


END pack_poste;
/

CREATE OR REPLACE PACKAGE BODY     pack_poste AS

       PROCEDURE insert_poste (p_poste     in VARCHAR2,
                        p_lib_poste in poste.lib_poste%TYPE,
 	                    p_flaglock  in poste.flaglock%TYPE,
                        p_message   out VARCHAR2

                                 ) IS
       l_msg VARCHAR2(1024);
       l_poste poste.lib_poste%TYPE;

       BEGIN
          p_message := '';

          begin
            select codposte into l_poste
            from poste where codposte=to_number(p_poste);

            -- test si le poste n'existe pas déjà.

            if(l_poste is not null OR l_poste != null) then
                pack_global.recuperer_message( 20968, '%s1', p_poste, NULL, l_msg);
                p_message := l_msg;
                raise_application_error( -20968, l_msg );
            end if;

            EXCEPTION
            WHEN NO_DATA_FOUND THEN
               begin
                -- création du poste
                insert into poste(codposte, lib_poste, flaglock)
                values
                (
                 p_poste,
                 p_lib_poste,
                 0
                );
                pack_global.recuperer_message(20971, '%s1', 'Code poste ' || p_poste, NULL, l_msg);
                p_message := l_msg;
              end;

            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
          end;

       END insert_poste;

       /******************** PROCEDURE update_poste ******************/

       PROCEDURE update_poste (p_poste     in VARCHAR2,
                               p_lib_poste in poste.lib_poste%TYPE,
 	                           p_flaglock  in poste.flaglock%TYPE,
                               p_message   out VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       l_poste poste.codposte%TYPE;

       BEGIN
       p_message := '';

          -- test si le poste existe .

          begin
            select codposte into l_poste
            from poste where codposte=to_number(p_poste);

            update poste set
            lib_poste = p_lib_poste,
            codposte = to_number(p_poste),
            flaglock 	= DECODE( p_flaglock, 1000000, 0, p_flaglock + 1 )
            where codposte = TO_NUMBER(p_poste)
            and   flaglock 	= p_flaglock;

            -- 'Poste modifié
            pack_global.recuperer_message(20972, '%s1', 'Code poste ' || p_poste, NULL, l_msg);
            p_message := l_msg;

            EXCEPTION
            WHEN NO_DATA_FOUND THEN
                pack_global.recuperer_message( 20969, '%s1', p_poste, NULL, l_msg);
                p_message := l_msg;
                raise_application_error( -20969, l_msg );
            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

          end;

       END update_poste;

       /******************** PROCEDURE delete_poste ******************/

       PROCEDURE delete_poste (p_poste     in VARCHAR2,
                               p_lib_poste in poste.lib_poste%TYPE,
 	                           p_flaglock  in poste.flaglock%TYPE,
                               p_message   out VARCHAR2
                              )IS
       l_msg VARCHAR2(1024);
       referential_integrity EXCEPTION;
       PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

       BEGIN
          -- Initialiser le message retour
          p_message := '';

          begin
        	   DELETE FROM poste
        		      WHERE codposte = TO_NUMBER(p_poste)
        			  AND flaglock = p_flaglock;
               EXCEPTION
               WHEN referential_integrity THEN
               -- habiller le msg erreur
               --pack_global.recuperation_integrite(-2292);
               pack_global.recuperer_message( 20970, '%s1', p_poste,'%s2','poste', NULL, l_msg);
               p_message := l_msg;
               raise_application_error( -20970, l_msg );
        	   WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
          end;

          IF SQL%NOTFOUND THEN
    	   -- 'Accès concurrent'
    	    pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
            raise_application_error( -20999, l_msg );
          ELSE
    	   -- 'Le poste p_poste a été supprimé'
    	   pack_global.recuperer_message( 20973, '%s1', 'Code poste ' || p_poste, NULL, l_msg);
          END IF;

          p_message := l_msg;

       END delete_poste;

       /******************** PROCEDURE select_poste ******************/

       PROCEDURE select_poste_c ( p_poste  in VARCHAR2,
                                  p_curseur IN OUT posteCurType,
                                  p_message  out VARCHAR2
                                )IS
       l_msg VARCHAR2(1024);

       BEGIN

              OPEN p_curseur FOR SELECT
                   TO_CHAR(codposte) as codposte,
                   lib_poste,
                   flaglock
              FROM  poste
              WHERE codposte = TO_NUMBER(p_poste);

              pack_global.recuperer_message( 20968, '%s1', p_poste, NULL, l_msg);
              p_message := l_msg;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

       END select_poste_c;

       PROCEDURE select_poste_m (p_poste  in VARCHAR2,
                                 p_curseur IN OUT posteCurType,
                                 p_message  out VARCHAR2
                                )IS
       l_msg VARCHAR2(1024);

       BEGIN

              OPEN p_curseur FOR SELECT
                   TO_CHAR(codposte) as codposte,
                   lib_poste,
                   flaglock
              FROM  poste
              WHERE codposte = TO_NUMBER(p_poste);

              pack_global.recuperer_message( 20969, '%s1', p_poste, NULL, l_msg);
              p_message := l_msg;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);

       END select_poste_m;



END pack_poste;
/
CREATE OR REPLACE PACKAGE pack_ppcm AS
  -- ------------------------------------------------------------------------
  -- Decription :  vérifie l'existence du code dpg
  -- Paramètres :  p_param6 (IN) situ_ress.codsg%type: code dpg
-- param10 classement du report
  -- param
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------


PROCEDURE  verif_ppcm(       p_codcfrais IN varchar2,
				p_param8 IN varchar2,
				p_param6 IN varchar2,
                                p_param10 IN varchar2,
				p_global  IN VARCHAR2,
			 	p_message OUT VARCHAR2);

END pack_ppcm;
/

CREATE OR REPLACE PACKAGE BODY pack_ppcm AS

  -- ------------------------------------------------------------------------
  --
  -- ------------------------------------------------------------------------


PROCEDURE  verif_ppcm(      p_codcfrais IN varchar2,   	-- centre de frais
				p_param8 IN varchar2,   	-- menu courant
				p_param6 IN varchar2,		-- code dPG
                                 p_param10 IN varchar2,
				p_global  IN VARCHAR2,
			 	p_message OUT VARCHAR2) IS
  l_msg VARCHAR2(1024) :='';
  l_codsg2 struct_info.codsg%type;
  l_centre_frais centre_frais.codcfrais%TYPE;
  l_scentrefrais centre_frais.codcfrais%TYPE;


BEGIN
   BEGIN
      -- P_codsg peut avoir une valeur = '01313**' ou '0131312' ou '01312  ' (avec des blancs)
      -- S'il possed un metacaractere (' ', '*'), on va le supprimer
      -- Puis former la condition Where du Select en fonction du longueur de P_codsg
 	if p_param6!='*******' then
      		SELECT   codsg, scentrefrais   INTO  l_codsg2, l_scentrefrais
      		FROM   struct_info
	   	WHERE  substr(to_char(codsg,'FM0000000'),1, length(rtrim(rtrim(LPAD(p_param6,7,'0'),'*')))) = rtrim(rtrim(LPAD(p_param6,7,'0'),'*'))
	     	 AND ROWNUM <= 1;
  	end if;

   EXCEPTION
	WHEN NO_DATA_FOUND then
		pack_global.recuperer_message(20215, '%s1', p_param6, 'p_param6', l_msg);
     	 	raise_application_error(-20215, l_msg);
   	p_message := l_msg;
   END;

  IF p_param8='ACH' THEN
     -- ===================================================================
     -- 28/12/2000 : Test si le DPG appartient bien au centre de frais
     -- ===================================================================
     -- On récupère le code centre de frais de l'utilisateur
	l_centre_frais := to_number(p_codcfrais);
   	IF p_param6!='*******' then
     		IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
      			IF (l_scentrefrais is null)   then
			--msg : Le DPG n'est rattaché à aucun centre de frais
				pack_global.recuperer_message(20339, NULL,NULL,'CODSG', l_msg);
          			raise_application_error(-20339, l_msg);
			ELSE
				IF (l_scentrefrais!=l_centre_frais) then
				--msg:Ce DPG n'appartient pas à ce centre de frais
				pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'CODSG', l_msg);
          			raise_application_error(-20334, l_msg);
				END IF;
      			END IF;
     		END IF;
   	END IF;

  ELSE
     -- =====================================================================
     -- 07/02/2001 : Test si le DPG appartient au périmètre de l'utilisateur
     -- =====================================================================
     pack_habilitation.verif_habili_me ( p_param6,p_global  , p_message  );

  END IF;
END verif_ppcm;

END pack_ppcm;
/
CREATE OR REPLACE PACKAGE pack_prodec2 IS
-----------------------------------------
-------------------------------------------------------------------------------------------------------
-- Quand    Qui  	Nom                   		Quoi
-- -------- ---  	--------------------  		----------------------------------------
-- 08/06/00 HTM  	ouvrir_conso_cv			(1)Remplacement tests (sir.prestation != 'GRA') par
--								   ( (sir.prestation != 'GRA') OR (sir.prestation IS NULL) )
--								(2) Exclusion de la ressource 0 du calcul du consommé
--								(3) SELECT ... UNION ALL ... SELECT pour prendre en compte
--								    les ressources ayant "une mauvaise situation" :
--								    Ressource sans situation, Ressource ayant consomme
--								    avec une situation fermée, ...
--
--			calc_cons_sstache_res_mois2	Exclusion de la ressource 0 du calcul du consommé
-- 02/03/2001 NBM : gestion des habilitations: filtre par direction ou département
-- 15/03/2001 NBM : TRUNC(sir.datsitu,'MONTH')  <= TRUNC(csr.cdeb,'MONTH') au lieu de
--					sir.datsitu  <= csr.cdeb :une situation commençant le 02/01/2001
--					n'était pas prise en compte pour le mois de janvier
-- 30/11/2004 EGR : F93 modification sur les codes MO, clidom est abandonné au profit de clicode pour la table client_mo

-------------------------------------------------------------------------------------------------------


/**************************************************************************************
 * NOTE : Package "pack_prodec2" est utilisé pour :
 *		PROJPRIN, PRODEC2 (Lot 3A),
 *		PRODEC3, PRODEC4, PRODECL (Lot 3B)
 *
 *
 * PAR AILLEURS : - verif_prodec3 et verif_prodecl utilisent le concept d'HISTORIQUE!!!
 *                Elles se trouvent dans  le package des HISTORIQUES : pack_historique
 * 			- verif_prodec4 est déplacé dans pack_prodec4
 *
 **************************************************************************************/


------------------------------------------------------------------------------
-- Constantes globales
------------------------------------------------------------------------------

CST_CODE_DPG_TOUS CONSTANT CHAR(7) := '*******'; 	-- Code DPG signifiant tous les Codes DPG
CST_PREM_CAR_ID_APPLI CONSTANT CHAR(1) := 'A';		-- 1er caractère identifiant Application (AIRT)
CST_PREM_CAR_ID_PROJ CONSTANT CHAR(1) := 'P';		-- 1er caractère identifiant Projet (ICPI)

CST_BUD_XXXX CONSTANT CHAR(4) := 'XXXX';			-- Chaîne 'XXXX' affichée dans les états PRODEC


------------------------------------------------------------------------------
-- Types et Curseurs
------------------------------------------------------------------------------

TYPE ConsoCurRecTyp IS RECORD (
						cdeb  cons_sstache_res_mois.cdeb%TYPE,
	  					pid   cons_sstache_res_mois.pid%TYPE,
	  					acta  cons_sstache_res_mois.acta%TYPE,
	  					acst  cons_sstache_res_mois.acst%TYPE,
	  					ecet  cons_sstache_res_mois.ecet%TYPE,
						cusag cons_sstache_res_mois.cusag%TYPE
 				       );

 TYPE BudgetCurRecTyp IS RECORD ( pid ligne_bip.pid%TYPE );

-- Type de curseur générique
-- TYPE GenericCurType IS REF CURSOR;

-- Types de curseur utilisés pour la construction des tables tmp_conso_sstache, tmp_budget_sstache
-- (Etats PRODEC2, PRODEC3, PRODEC4, PRODECL)
TYPE ConsoCurTyp  IS REF CURSOR RETURN ConsoCurRecTyp;
TYPE BudgetCurTyp IS REF CURSOR RETURN BudgetCurRecTyp;

------------------------------------------------------------------------------
-- Les Fonctions
------------------------------------------------------------------------------

----------------------------------
-- Copié à partir de pack_utile
----------------------------------
   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_pnom_lbip
   -- Auteur     :  Equipe SOPRA
   -- Decription :  recupere le libelle d'une ligne bip
   -- Paramètres :  p_pid (IN) identifiant du code projet
   --
   -- Retour     :  le libelle du projet
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_pnom_lbip(p_pid IN ligne_bip.pid%TYPE) RETURN VARCHAR2;
	   PRAGMA restrict_references(f_get_pnom_lbip,wnds,wnps);

   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_codsg_lbip
   -- Auteur     :  Equipe SOPRA
   -- Decription :  recupere le codsg d'une ligne bip
   -- Paramètres :  p_pid (IN) identifiant du code projet
   --
   -- Retour     :  le code DEP/POL/GR de la ligne bip
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_codsg_lbip(p_pid IN ligne_bip.pid%TYPE) RETURN VARCHAR2;
	   PRAGMA restrict_references(f_get_codsg_lbip,wnds,wnps);


   -- ------------------------------------------------------------------------
   -- Nom        :  f_formater_budget
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Formatage des Montants  de la table tmp_budget_sstache
   -- Paramètres :  p_val	  (IN)      Montant à formater
   --
   -- Retour     :  p_val au format 'FM9G999G999G999G999D0' si possible, sinon p_val tel quel!!!
   --
   -- ------------------------------------------------------------------------

FUNCTION f_formater_budget(p_val IN VARCHAR2) RETURN VARCHAR2;
	PRAGMA restrict_references(f_formater_budget, wnds, wnps);



   -- ------------------------------------------------------------------------
   -- Nom        :  f_conso_mois_a_afficher
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Retourne le montant qui sera affiché dans le Report pour les états PRODEC2,3,4,L ou NULL
   -- Paramètres :  p_cusag	  (IN)      Montant du consommé
   --			  p_cdeb (IN)  		Date du consommé (Date)
   --			  p_mois  (IN) 		Mois traité ( format 'MM')
   --			  p_mois_maxi (IN) 	Mois maxi à traiter ( format 'MM')
   --							(Si p_mois > p_mois_maxi, on retourne NULL!!!)
   --
   -- Retour     :  Le montant du consommé (p_cusag) si Mois de p_cdeb = p_mois et p_mois <= p_mois_maxi
   -- 		  NULL dans le cas contraire
   -- ------------------------------------------------------------------------
   FUNCTION f_conso_mois_a_afficher(		p_cusag 	IN cons_sstache_res_mois.cusag%TYPE,
						p_cdeb  	IN cons_sstache_res_mois.cdeb%TYPE,
						p_mois  	IN VARCHAR2,
						p_mois_maxi 	IN VARCHAR2
						) RETURN NUMBER;
	   PRAGMA restrict_references(f_conso_mois_a_afficher, wnds, wnps);



   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_lib_statut
   -- Auteur     :  Equipe SOPRA
   -- Decription :  recupere le libelle d'un code statut
   -- Paramètres :  p_astatut (IN) Code statut
   --
   -- Retour     :  le libelle du statut
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_lib_statut(p_astatut IN code_statut.astatut%TYPE) RETURN VARCHAR2;
	   PRAGMA restrict_references(f_get_lib_statut, wnds, wnps);

   -- ------------------------------------------------------------------------
   -- Nom        : calc_prop_budget2 (Construit à partir de calc_prop_budget!!!)
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget propose pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_prop_budget2 (p_pid  		IN budget.pid%TYPE,
			       p_annee 		IN budget.annee%TYPE,
			       p_date_cour 	IN DATE
			         ) RETURN VARCHAR2;

   PRAGMA restrict_references(calc_prop_budget2, wnds, wnps);

   -- ------------------------------------------------------------------------
   -- Nom        : calc_budg_notif2
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget notifier pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_budg_notif2 (p_pid   	  IN budget.pid%TYPE,
			      p_annee 	  IN budget.annee%TYPE,
			      p_date_cour IN DATE
			    ) RETURN VARCHAR2;

   PRAGMA restrict_references(calc_budg_notif2, wnds, wnps);

   -- ------------------------------------------------------------------------
   -- Nom        : calc_budg_arb_notif2
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget arbitrer notifier pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_budg_arb_notif2 (p_pid       IN budget.pid%TYPE,
				  p_annee     IN budget.annee%TYPE,
				  p_date_cour IN DATE
				) RETURN VARCHAR2;

      PRAGMA restrict_references(calc_budg_arb_notif2, wnds, wnps);

   -- ------------------------------------------------------------------------
   -- Nom        : calc_cons_sstache_res_mois2
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget consomme pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_cons_sstache_res_mois2 (p_pid       IN cons_sstache_res_mois.pid%TYPE,
					 p_annee     IN cons_sstache_res_mois.cdeb%TYPE,
					 p_date_cour IN DATE
				       ) RETURN VARCHAR2;
      PRAGMA restrict_references(calc_cons_sstache_res_mois2, wnds, wnps);

   -- ------------------------------------------------------------------------
   -- Nom        : calc_cons_annee_prec
   -- Auteur     : MMC
   -- Decription : calcul le budget consomme pour l'anne precedente et l'historique
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_cons_annee_prec (p_pid	IN consomme.pid%TYPE,
				  p_annee IN consomme.annee%TYPE,
				  p_indic_annee IN VARCHAR2
				  ) RETURN VARCHAR2;
      PRAGMA restrict_references(calc_cons_annee_prec, wnds, wnps);

   -- ------------------------------------------------------------------------
   -- Nom        : decode_amortissement
   -- Auteur     : Equipe SOPRA
   -- Decription : test pour renvoyer l'amortissement dans les editions prodec2
   --              et edition ligne BIP
   --
   -- Paramètres : p_type    (IN) code type de projet
   --              p_astatut (IN) statut de l'amortissement
   -- Retour     : un  varchar2 avec 'OUI' ou 'NON'
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION decode_amortissement (p_type    ligne_bip.typproj%TYPE,
				  p_astatut ligne_bip.astatut%TYPE
				 ) RETURN VARCHAR2;
   PRAGMA restrict_references(decode_amortissement,wnds,wnps);

   -- ------------------------------------------------------------------------
   -- Nom        : tmp_sstache_budget2
   -- Auteur     : Equipe SOPRA
   -- Decription : met a jour de la table tmp_budget_sstache a partir des tables
   --              cons_sstache_res_mois, prop_budget, budg_notif, budg_arb_notif
   --              budg_arb_notif
   -- Paramètres :
   --               p_nom_etat (IN)     	Nom de l'état traité (PRODEC2, 3, 4, ou L)
   -- 		  p_clicode   (IN) 	Code direction
   --			  p_codsg    (IN)       Code DPG (Pouvant contenir des * à la fin!!!)
   --               p_pid      (IN)       Code ligne BIP
   --               p_id_proj_ou_appli     (IN)       Code référentiel (Identifiant Projet ou Application)
   --			  p_date_traite (IN)    Date à prendre en compte
   --			 (L'année de cette date correspond à l'année N !!! dans l'état!!!)
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   --
   -- ------------------------------------------------------------------------
   FUNCTION tmp_sstache_budget2 (
					p_nom_etat 		IN VARCHAR2,
					p_clicode   		IN client_mo.clicode%TYPE,
					p_codsg    		IN VARCHAR2,
					p_pid      		IN ligne_bip.pid%TYPE,
					p_id_proj_ou_appli     	IN VARCHAR2,
					p_date_traite 		IN DATE
					) RETURN NUMBER;


   -- ------------------------------------------------------------------------
   -- Nom        : tmp_sstache2
   -- Auteur     : Equipe SOPRA  (HTM 23/02/2000)
   -- Decription : met a jour de la table tmp_conso_sstache a partir des tables
   --              cons_sstache_res_mois, proplus, tache et etape
   -- Paramètres :
   --               p_nom_etat (IN)     	Nom de l'état traité (PRODEC2, 3, 4, ou L)
   -- 		  p_clicode   (IN) 	Code direction
   --			  p_codsg    (IN)       Code DPG (Pouvant contenir des * à la fin!!!)
   --               p_pid      (IN)       Code ligne BIP
   --               p_id_proj_ou_appli     (IN)       Code référentiel (Identifiant Projet ou Application)
   --			  p_date_traite (IN)    Date à prendre en compte
   --			 (L'année de cette date correspond à l'année N !!! dans l'état!!!)
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- Remarque   : Le filtre sur p_clicode serait trop coûteux : Ce paramètre
   --			 est inutilisé pour l'instant!!!
   -- ------------------------------------------------------------------------
   FUNCTION tmp_sstache2 (
					p_nom_etat 		IN VARCHAR2,
					p_clicode   		IN client_mo.clicode%TYPE,
					p_codsg    		IN VARCHAR2,
					p_pid      		IN ligne_bip.pid%TYPE,
					p_id_proj_ou_appli      IN VARCHAR2,
					p_date_traite 		IN DATE
					) RETURN NUMBER;


------------------------------------------------------------------------------
-- Les Procédures
------------------------------------------------------------------------------

   -- ------------------------------------------------------------------------
   -- Nom        :  ouvrir_conso_cv (Procédure)
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Ouverture variable curseur de type ConsoCurTyp
   -- Paramètres :  p_curv    (IN/OUT) 	Curseur à ouvrir
   --               p_nom_etat (IN)     	Nom de l'état traité (PRODEC2, 3, 4, ou L)
   -- 		  p_clicode   (IN) 	Code direction
   --			  p_codsg    (IN)       Code DPG (Pouvant contenir des * à la fin!!!)
   --               p_pid      (IN)       Code ligne BIP
   --               p_id_proj_ou_appli     (IN)       Code référentiel (Identifiant Projet ou Application)
   --               p_airt     (IN)       Identifiant Application
   --			  p_date_traite (IN)    Date à prendre en compte
   --			 (L'année de cette date correspond à l'année N !!! dans l'état!!!)
   --
   -- Retour     :
   --
   -- ------------------------------------------------------------------------
   PROCEDURE ouvrir_conso_cv(
					p_curv     	IN OUT ConsoCurTyp,
					p_nom_etat 	IN VARCHAR2,
					p_clicode   	IN client_mo.clicode%TYPE,
					p_codsg    	IN VARCHAR2,
					p_pid      	IN ligne_bip.pid%TYPE,
					p_id_proj_ou_appli     IN VARCHAR2,
					p_date_traite 	IN DATE
				    );

   -- ------------------------------------------------------------------------
   -- Nom        :  ouvrir_budget_cv (Procédure)
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Ouverture variable curseur de type BudgetCurTyp
   -- Paramètres :  p_curv     (IN/OUT)  	Curseur à ouvrir
   --               p_nom_etat (IN)     	Nom de l'état traité (PRODEC2, 3, 4, ou L)
   -- 		  p_clicode   (IN) 	Code direction
   --			  p_codsg    (IN)       Code DPG (Pouvant contenir des * à la fin!!!)
   --               p_pid      (IN)       Code ligne BIP
   --               p_id_proj_ou_appli     (IN)       Code référentiel (Identifiant Projet ou Application)
   --			  p_date_traite (IN)    Date à prendre en compte
   --			 (L'année de cette date correspond à l'année N !!! dans l'état!!!)
   --
   -- Retour     :
   --
   -- ------------------------------------------------------------------------
   PROCEDURE ouvrir_budget_cv(
					p_curv     	IN OUT BudgetCurTyp,
					p_nom_etat 	IN VARCHAR2,
					p_clicode   	IN client_mo.clicode%TYPE,
					p_codsg    	IN VARCHAR2,
					p_pid      	IN ligne_bip.pid%TYPE,
					p_id_proj_ou_appli     IN VARCHAR2,
					p_date_traite 	IN DATE
				    );

-- ------------------------------------------------------------------------
   -- Nom        :  ouvrir_budget_tout (Procédure)
   -- Auteur     :  MMC
   -- Decription :  Ouverture variable curseur de type BudgetCurTyp
   -- Paramètres :  p_curv     (IN/OUT)  	Curseur à ouvrir
   --               p_userid    (IN)    identifiant de l'utilisateur
   --
-- ------------------------------------------------------------------------
   PROCEDURE ouvrir_budget_tout(	p_curv     	IN OUT BudgetCurTyp,
					p_userid 	IN VARCHAR2
				    ) ;

-- ------------------------------------------------------------------------
   -- Nom        :  ouvrir_conso_tout (Procédure)
   -- Auteur     :  MMC
   -- Decription :  Ouverture variable curseur de type ConsoCurTyp
   -- Paramètres :  p_curv    (IN/OUT) 	Curseur à ouvrir
   --               p_userid (IN)     	p_global
-- ------------------------------------------------------------------------
 PROCEDURE ouvrir_conso_tout(		p_curv     	IN OUT ConsoCurTyp,
					p_userid 	IN VARCHAR2,
					p_date_traite 	IN DATE
				    ) ;



END pack_prodec2;
/

CREATE OR REPLACE PACKAGE BODY pack_prodec2 IS
----------------------------------------------

--****************************************************************************
-- Les Fonctions
--****************************************************************************

   -- **********************************************************************
   -- Nom        : f_get_pnom_lbip
   -- Auteur     : Equipe SOPRA
   -- Decription : recupere le libelle d'une ligne bip
   -- Paramètres : p_pid (IN) identifiant du code projet
   --
   -- Retour     : le libelle du projet
   --
   -- **********************************************************************
   FUNCTION f_get_pnom_lbip(p_pid IN ligne_bip.pid%TYPE) RETURN VARCHAR2 IS

      l_pnom ligne_bip.pnom%TYPE;

   BEGIN
      SELECT  lib.pnom
	INTO  l_pnom
	FROM  ligne_bip lib
	WHERE lib.pid = p_pid;

      RETURN l_pnom;

   END f_get_pnom_lbip;

   -- **********************************************************************
   -- Nom        : f_get_codsg_lbip
   -- Auteur     : Equipe SOPRA
   -- Decription : recupere le codsg d'une ligne bip
   -- Paramètres : p_pid (IN) identifiant du code projet
   --
   -- Retour     : le code DEP/POL/GR de la ligne bip
   --
   -- **********************************************************************
   FUNCTION f_get_codsg_lbip(p_pid IN ligne_bip.pid%TYPE) RETURN VARCHAR2 IS

      l_codsg ligne_bip.codsg%TYPE;

   BEGIN
      SELECT  lib.codsg
   	INTO  l_codsg
   	FROM  ligne_bip lib
   	WHERE lib.pid = p_pid;

      RETURN TO_CHAR(l_codsg, 'FM0000000');

   END f_get_codsg_lbip;


   -- ------------------------------------------------------------------------
   -- Nom        :  f_formater_budget
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Formatage des Montants  de la table tmp_budget_sstache
   -- Paramètres :  p_val	  (IN)      Montant à formater
   --
   -- Retour     :  p_val au format 'FM9G999G999G999G999D0' si possible, sinon p_val tel quel!!!
   --
   -- ------------------------------------------------------------------------

FUNCTION f_formater_budget(p_val VARCHAR2) RETURN VARCHAR2 is
	l_val VARCHAR2(30);

BEGIN

  l_val := LTRIM(RTRIM(p_val));

  IF ( (l_val IS NULL) OR (l_val  = CST_BUD_XXXX) ) THEN
	RETURN(l_val );
  ELSE
  	RETURN( TO_CHAR(TO_NUMBER(l_val ), 'FM9G999G999G999G999D0') );
  END IF;


EXCEPTION
	WHEN OTHERS THEN RETURN(l_val );

END f_formater_budget;


   -- ------------------------------------------------------------------------
   -- Nom        :  f_conso_mois_a_afficher
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Retourne le montant qui sera affiché dans le Report pour les états PRODEC2,3,4,L ou NULL
   -- Paramètres :  p_cusag	  (IN)      Montant du consommé
   --			  p_cdeb (IN)  		Date du consommé (Date)
   --			  p_mois  (IN) 		Mois traité ( format 'MM')
   --			  p_mois_maxi (IN) 	Mois maxi à traiter ( format 'MM')
   --							(Si p_mois > p_mois_maxi, on retourne NULL!!!)
   --
   -- Retour     :  Le montant du consommé (p_cusag) si Mois de p_cdeb = p_mois et p_mois <= p_mois_maxi
   -- 		  NULL dans le cas contraire
   -- ------------------------------------------------------------------------
   FUNCTION f_conso_mois_a_afficher(p_cusag 	IN cons_sstache_res_mois.cusag%TYPE,
				    p_cdeb  	IN cons_sstache_res_mois.cdeb%TYPE,
				    p_mois  	IN VARCHAR2,
				    p_mois_maxi IN VARCHAR2
				) RETURN NUMBER IS
  BEGIN

	IF ( (p_mois <= p_mois_maxi) AND (TO_CHAR(p_cdeb,'MM') = p_mois) ) THEN
		RETURN (p_cusag);
	ELSE
		RETURN (NULL);
	END IF;

  END f_conso_mois_a_afficher;


   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_lib_statut
   -- Auteur     :  Equipe SOPRA
   -- Decription :  recupere le libelle d'un code statut
   -- Paramètres :  p_astatut (IN) Code statut
   --
   -- Retour     :  le libelle du statut
   --
   -- Quand    Qui  	Quoi
   -- -----    ---  	--------------------------------------------------------
   -- 15/03/00 HTM  	Création

   -- ------------------------------------------------------------------------
   FUNCTION f_get_lib_statut(p_astatut IN code_statut.astatut%TYPE) RETURN VARCHAR2 IS

      l_res code_statut.libstatut%TYPE;

   BEGIN

	IF  ( (p_astatut IS NULL) OR p_astatut = ' ' ) THEN
		l_res := 'En Cours';
	ELSE
      	SELECT  sta.libstatut
		INTO  l_res
		FROM  code_statut sta
		WHERE sta.astatut = p_astatut;
      END IF;

      RETURN l_res;

	EXCEPTION
      	WHEN OTHERS THEN RETURN '';

   END f_get_lib_statut;

   -- ------------------------------------------------------------------------
   -- Nom        : calc_prop_budget2 (Construit à partir de calc_prop_budget!!!)
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget propose pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_prop_budget2 (p_pid   	   IN budget.pid%TYPE,
			       p_annee 	   IN budget.annee%TYPE,
			       p_date_cour IN DATE
			         ) RETURN VARCHAR2 IS

      l_bpmont1 budget.bpmontme%TYPE;

   BEGIN

      	-- Le select fait la somme des montants pour un projet et une annee
      	-- le decode est present dans le cas d'un historique p_annee = N-2
      	-- ou l'on doit faire la somme des budgets sinon on prend l'annee
      	-- p_annee (prb.bpannee <= p_annee ET prb.bpannee >= p_annee équivaut à prb.bpannee = p_annee )
      	-- N annee courante
      	SELECT  sum(b.bpmontme)
	INTO  l_bpmont1
	FROM  budget b
	WHERE b.pid = p_pid
	AND   b.annee <= p_annee
	AND   b.annee >= decode(p_annee,
				    to_number(to_char(p_date_cour, 'YYYY')) - 2 , 0,
				    p_annee);

	RETURN to_char(l_bpmont1, 'FM9999999999D00');

   EXCEPTION
      	WHEN OTHERS THEN RETURN 'NOK';

   END calc_prop_budget2;

   -- ------------------------------------------------------------------------
   -- Nom        : calc_budg_notif2
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget notifier pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_budg_notif2 (p_pid   	  IN budget.pid%TYPE,
			      p_annee 	  IN budget.annee%TYPE,
			      p_date_cour IN DATE
			    ) RETURN VARCHAR2 IS

      l_bnmont budget.bnmont%TYPE;

   BEGIN

      -- Le select fait la somme des montants pour un projet et une annee
      -- le decode est present dans le cas d'un historique p_annee = N-2
      -- ou l'on doit faire la somme des budgets sinon on prend l'annee
      -- p_annee (<= + >= donne =)
      -- N annee courante
      SELECT  sum(b.bnmont)
	INTO  l_bnmont
	FROM  budget b
	WHERE b.pid = p_pid
	AND   b.annee <= p_annee
       AND   b.annee >= decode(p_annee,
				    to_number(to_char(p_date_cour, 'YYYY')) - 2 , 0,
				    p_annee);

	RETURN to_char(l_bnmont, 'FM9999999999D00');

   EXCEPTION
      WHEN OTHERS THEN RETURN 'NOK';

   END calc_budg_notif2;

   -- ------------------------------------------------------------------------
   -- Nom        : calc_budg_arb_notif2
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget arbitrer notifier pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_budg_arb_notif2 (p_pid   	IN budget.pid%TYPE,
				  p_annee 	IN budget.annee%TYPE,
				  p_date_cour 	IN DATE
				) RETURN VARCHAR2 IS

      l_anmont budget.anmont%TYPE;

   BEGIN

      -- Le select fait la somme des montants pour un projet et une annee
      -- le decode est present dans le cas d'un historique p_annee = N-2
      -- pour avoir la condition : 0 >= 0
      -- ou l'on doit faire la somme des budgets sinon on prend l'annee
      -- p_annee (<= + >= donne =)
      -- N annee courante
      SELECT  sum(b.anmont)
	INTO  l_anmont
	FROM  budget b
	WHERE b.pid = p_pid
	AND   b.annee <= p_annee
	AND   b.annee >= decode(p_annee,
				    to_number(to_char(p_date_cour, 'YYYY')) - 2 , 0,
				    p_annee
				    );

	RETURN to_char(l_anmont, 'FM9999999999D00');

   EXCEPTION
      WHEN OTHERS THEN RETURN 'NOK';

   END calc_budg_arb_notif2;

   -- ------------------------------------------------------------------------
   -- Nom        : calc_cons_sstache_res_mois2
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget consomme pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_date_cour (IN) Date courante (En principe, SYSDATE ou datdebex)
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_cons_sstache_res_mois2 (p_pid       IN cons_sstache_res_mois.pid%TYPE,
					 p_annee     IN cons_sstache_res_mois.cdeb%TYPE,
					 p_date_cour IN DATE
				       ) RETURN VARCHAR2 IS

      l_cusag  NUMBER(12,2);
      l_cusag1  NUMBER(12,2);

   BEGIN

      -- Le select fait la somme des montants pour un projet et une annee
      -- Sans prendre les sous-traitances
      -- le decode est present dans le cas d'un historique p_annee = N-2
      -- ou l'on doit faire la somme des budgets sinon on prend l'annee
      -- p_annee (<= + >= donne =)
      -- N annee courante
      SELECT  sum(csr.cusag)
	INTO  l_cusag
	FROM  cons_sstache_res_mois csr,
	tache tac
	WHERE csr.pid = p_pid
	AND   tac.pid = csr.pid
	AND   tac.acta = csr.acta
	AND   tac.acst = csr.acst
	AND   tac.ecet = csr.ecet
	AND   ((tac.aistty != 'FF') OR (tac.aistty IS NULL))
	AND   trunc(csr.cdeb, 'YEAR') <= trunc(p_annee, 'YEAR')
	AND   trunc(csr.cdeb, 'YEAR') >= decode(p_annee,
						add_months(trunc(p_date_cour, 'YEAR'), -24) ,
						to_date('01/01/1900', 'dd/mm/yyyy'),
						p_annee)
	AND csr.ident != 0	-- HTM 08/06/00 : Exclusion de la Ressource 0
	;

      -- Meme chose mais on prend les consommes des sous-traitances
      -- donne par le projet
      SELECT  sum(csr.cusag)
	INTO  l_cusag1
	FROM  cons_sstache_res_mois csr,
	tache tac
	WHERE tac.aistpid = p_pid
	AND   tac.aistty  = 'FF'
	AND   tac.pid = csr.pid
	AND   tac.acta = csr.acta
	AND   tac.acst = csr.acst
	AND   tac.ecet = csr.ecet
	AND   trunc(csr.cdeb, 'YEAR') <= trunc(p_annee, 'YEAR')
	AND   trunc(csr.cdeb, 'YEAR') >= decode(p_annee,
						add_months(trunc(p_date_cour, 'YEAR'), -24),
						to_date('01/01/1900', 'dd/mm/yyyy'),
						p_annee)
	AND csr.ident != 0	-- HTM 08/06/00 : Exclusion de la Ressource 0
	;

      l_cusag := nvl(l_cusag, 0) + nvl(l_cusag1, 0);
      IF l_cusag = 0 THEN
	 RETURN NULL;
      ELSE
	  RETURN to_char(l_cusag, 'FM9999999999D00');
      END IF;

   EXCEPTION
      WHEN OTHERS THEN RETURN 'NOK';

   END calc_cons_sstache_res_mois2;

   -- ------------------------------------------------------------------------
   -- Nom        : calc_cons_annee_prec
   -- Auteur     : MMC
   -- Decription : calcul le budget consomme pour l'annee precedente
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   --              p_indic_annee IN VARCHAR2
   -- Retour     : un  varchar2 avec le montant
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION calc_cons_annee_prec (p_pid	IN consomme.pid%TYPE,
				  p_annee IN consomme.annee%TYPE,
				  p_indic_annee IN VARCHAR2
				  ) RETURN VARCHAR2 IS

   l_montant_res consomme.cusag%TYPE ;

BEGIN
	begin
	if p_indic_annee='p' then
		SELECT cusag
		INTO  l_montant_res
		FROM  consomme
		WHERE pid = p_pid
		AND annee = p_annee;

	else SELECT xcusag
		INTO  l_montant_res
		FROM  consomme
		WHERE pid = p_pid
		AND annee = p_annee;
	end if;

	RETURN(to_char(l_montant_res, 'FM9999999999D00'));

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN NULL;
	 		WHEN OTHERS THEN RETURN 'NOK';
	end;
   END calc_cons_annee_prec;


   -- ------------------------------------------------------------------------
   -- Nom        : decode_amortissement
   -- Auteur     : Equipe SOPRA
   -- Decription : test pour renvoyer l'amortissement dans les editions prodec2
   --              et edition ligne BIP
   --
   -- Paramètres : p_type    (IN) code type de projet
   --              p_astatut (IN) statut de l'amortissement
   -- Retour     : un  varchar2 avec 'OUI' ou 'NON'
   --	           un  varchar2 avec 'NOK' si erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION decode_amortissement (p_type ligne_bip.typproj%TYPE,
				  p_astatut ligne_bip.astatut%TYPE
				 ) RETURN VARCHAR2 IS
   BEGIN

	IF (
		( (p_type = '1 ') AND ((p_astatut != 'N') OR  (p_astatut IS NULL)) )
							OR
	      ( ((p_type != '1 ') OR (p_type IS NULL)) AND (p_astatut = 'O') )
	    ) THEN
		RETURN( 'OUI' );
	ELSE
		RETURN( 'NON' );
	END IF;

   END decode_amortissement;


   -- ------------------------------------------------------------------------
   -- Nom        : tmp_sstache2
   -- Auteur     : Equipe SOPRA  (HTM 23/02/2000)
   -- Decription : met a jour de la table tmp_conso_sstache a partir des tables
   --              cons_sstache_res_mois, proplus, tache et etape
   -- Paramètres :
   --               p_nom_etat (IN)     	Nom de l'état traité (PRODEC2, 3, 4, ou L)
   -- 		  p_clicode   (IN) 	Code direction
   --			  p_codsg    (IN)       Code DPG (Pouvant contenir des * à la fin!!!)
   --               p_pid      (IN)       Code ligne BIP
   --               p_id_proj_ou_appli     (IN)       Code référentiel (Identifiant Projet ou Application)
   --			  p_date_traite (IN)    Date à prendre en compte
   --			 (L'année de cette date correspond à l'année N !!! dans l'état!!!)
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- Remarque   : Le filtre sur p_clicode serait trop coûteux : Ce paramètre
   --			 est inutilisé pour l'instant!!!
   -- ------------------------------------------------------------------------
   FUNCTION tmp_sstache2 (
					p_nom_etat 	IN VARCHAR2,
					p_clicode   	IN client_mo.clicode%TYPE,
					p_codsg    	IN VARCHAR2,
					p_pid      	IN ligne_bip.pid%TYPE,
					p_id_proj_ou_appli     IN VARCHAR2,
					p_date_traite 	IN DATE
					) RETURN NUMBER IS

      l_var_seq NUMBER;       -- Numero de séquence

	-- Déclaration curseurs
	-- Sert à récupérer les identifiants (PID) de cons_sstache_res_mois pour qualif != 'GRA' dans proplus
      	-- ramene les informations de cons_sstache_res_mois
      	-- il faut encore filtrer par rapport a TACHE pour enlever les taches dont aistty != 'FC' et 'DF'

	lc_conso ConsoCurTyp;		-- Variable Curseur pour conso


	-- declaration des variables pour les curseurs.
	 lc_lig_conso ConsoCurRecTyp;

	-- Mois maxi à prendre en compte (Vaut '12' si on prend en compte tous les mois!!!)
	l_mois_maxi_a_traiter VARCHAR2(2);

   BEGIN
      -- Initialisations
	l_mois_maxi_a_traiter := TO_CHAR(p_date_traite, 'MM');
      SELECT sconso.nextval INTO l_var_seq FROM dual;

	-- Ouverture Curseur
	IF NOT lc_conso%ISOPEN THEN
		IF p_pid='Tout' THEN
			-- isac : etat lancé pour toutes le lignes bip de l'utilisateur
			-- p_nom_etat devient l identifiant de l'utilisateur
		 ouvrir_conso_tout(lc_conso, p_nom_etat, p_date_traite);
		ELSE
		 ouvrir_conso_cv(lc_conso, p_nom_etat, p_clicode, p_codsg, p_pid, p_id_proj_ou_appli, p_date_traite);
		END IF;

	END IF;

   	-- Boucle sur le curseur ...
      LOOP
	 -- Fetch du curseur des conso
	 FETCH  lc_conso INTO lc_lig_conso;

	 -- condition de sortie
	 EXIT WHEN lc_conso%NOTFOUND;

	/*******************************************************************************************************
	 DBMS_OUTPUT.PUT_LINE( ' ');
	 DBMS_OUTPUT.PUT_LINE( ' ');
	 DBMS_OUTPUT.PUT_LINE('FETCH : PID:' || lc_lig_conso.pid || ' CUSAG:' || lc_lig_conso.cusag ||' CDEB:'|| lc_lig_conso.cdeb
	                                || ' ACTA:' || lc_lig_conso.acta ||' ACST:'|| lc_lig_conso.acst
                                      || ' ECET:' || lc_lig_conso.ecet);
	********************************************************************************************************/

	 INSERT INTO tmp_conso_sstache (numseq ,
					typetap,
					id     ,		-- AIST : Type de sous-tâche
					aist,
					asnom  ,		-- Libellé sous-tâche
					pid    ,
					codsg  ,
					pnom   ,
					acst   ,		-- N° sous-tâche
					janv   ,
					fevr   ,
					mars   ,
					avril  ,
					mai    ,
					juin   ,
					juil   ,
					aout   ,
					sept   ,
					octo   ,
					nove   ,
					dece
					)
	   (SELECT l_var_seq,
	    eta.typetap,
            tac.aistty || tac.aistpid,                  -- FF et ligne bip sous traitance
            tac.aist,
	    tac.asnom,
	    tac.pid,
	    TO_NUMBER(f_get_codsg_lbip(tac.pid)),   -- codsg de la ligne_bip
	    f_get_pnom_lbip(tac.pid),   -- pnom de la ligne_bip
	    tac.acst,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '01', l_mois_maxi_a_traiter) janv,
            f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '02', l_mois_maxi_a_traiter) fevr,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '03', l_mois_maxi_a_traiter) mars,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '04', l_mois_maxi_a_traiter) avril,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '05', l_mois_maxi_a_traiter) mai,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '06', l_mois_maxi_a_traiter) juin,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '07', l_mois_maxi_a_traiter) juil,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '08', l_mois_maxi_a_traiter) aout,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '09', l_mois_maxi_a_traiter) sept,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '10', l_mois_maxi_a_traiter) octo,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '11', l_mois_maxi_a_traiter) nove,
	    f_conso_mois_a_afficher(lc_lig_conso.cusag, lc_lig_conso.cdeb, '12', l_mois_maxi_a_traiter) dece
	    FROM  tache tac,
	    	    etape eta
	    WHERE tac.pid  = lc_lig_conso.pid
	    AND   tac.acta = lc_lig_conso.acta
	    AND   tac.acst = lc_lig_conso.acst
	    AND   tac.ecet = lc_lig_conso.ecet
	    AND   eta.pid  = tac.pid
	    AND   eta.ecet = tac.ecet			-- N° Etape
	    AND   ( (tac.aistty NOT IN ('FC', 'DF')) OR (tac.aistty IS NULL) )
	    ----------------------------------------------------------------
	    -- HTM 31/03/00
	    -- (tac.aistty IS NULL) permet de prendre en compte les consommés en direct!
	    ----------------------------------------------------------------
	    );

	 COMMIT;

      END LOOP;

	-- Fermeture Curseur
	CLOSE lc_conso;

      RETURN l_var_seq;

   EXCEPTION
      WHEN OTHERS THEN RETURN 0;
	--WHEN OTHERS THEN raise_application_error(-20997, sqlerrm);


   END tmp_sstache2;

   -- ------------------------------------------------------------------------
   -- Nom        : tmp_sstache_budget2
   -- Auteur     : Equipe SOPRA
   -- Decription : met a jour de la table tmp_budget_sstache a partir des tables
   --              cons_sstache_res_mois, prop_budget, budg_notif, budg_arb_notif
   --              budg_arb_notif
   -- Paramètres :
   --             p_nom_etat (IN)     	Nom de l'état traité (PRODEC2, 3, 4, ou L)
   -- 		  p_clidom   (IN) 	Code direction
   --		  p_codsg    (IN)       Code DPG (Pouvant contenir des * à la fin!!!)
   --             p_pid      (IN)       Code ligne BIP
   --             p_id_proj_ou_appli     (IN)       Code référentiel (Identifiant Projet ou Application)
   --		  p_date_traite (IN)    Date à prendre en compte
   --		 (L'année de cette date correspond à l'année N !!! dans l'état!!!)
   -- 		  p_clicode   (IN) 	Code direction
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   --
   -- ------------------------------------------------------------------------
   FUNCTION tmp_sstache_budget2 (
					p_nom_etat 	IN VARCHAR2,
					p_clicode   	IN client_mo.clicode%TYPE,
					p_codsg    	IN VARCHAR2,
					p_pid      	IN ligne_bip.pid%TYPE,
					p_id_proj_ou_appli     IN VARCHAR2,
					p_date_traite 	IN DATE
					) RETURN NUMBER IS

      -- numero de sequence
      l_var_seq NUMBER;

	lc_pid BudgetCurTyp;		-- Variable Curseur

	-- declaration des variables pour les curseurs.
	lc_lig_pid BudgetCurRecTyp;


	l_temp1 VARCHAR2(50);
	l_temp2 VARCHAR2(50);
	l_temp3 VARCHAR2(50);
	l_temp4 VARCHAR2(50);
	l_temp5 VARCHAR2(50);
	l_temp6 VARCHAR2(50);


   BEGIN

      SELECT sbudget.nextval INTO l_var_seq FROM dual;

	-- DBMS_OUTPUT.PUT_LINE(' Avant ouvrir_budget_cv ');
	-- Ouverture Curseur

	IF NOT lc_pid%ISOPEN THEN
		IF p_pid='Tout' THEN
			-- isac : etat lancé pour toutes le lignes bip de l'utilisateur
			-- p_nom_etat devient l identifiant de l'utilisateur
		 ouvrir_budget_tout(lc_pid, p_nom_etat);
		ELSE
		 ouvrir_budget_cv(lc_pid, p_nom_etat, p_clicode, p_codsg, p_pid, p_id_proj_ou_appli, p_date_traite);
		END IF;
	END IF;

	-- DBMS_OUTPUT.PUT_LINE(' Après ouvrir_budget_cv ');

      LOOP

	 FETCH lc_pid INTO lc_lig_pid;
	 EXIT WHEN lc_pid%NOTFOUND;


	 -- DBMS_OUTPUT.PUT_LINE('FETCH :' || lc_lig_pid.pid ||' '|| l_var_seq );

	 -- insert dans la table tmp_budget_sstache de budget propose
	 INSERT INTO tmp_budget_sstache (numseq,
					 typeb,
					 pid,
					 histo,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES ( l_var_seq,
		    'A',
		    lc_lig_pid.pid,
		    calc_prop_budget2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) -2), p_date_traite),
		    calc_prop_budget2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) -1), p_date_traite),
		    calc_prop_budget2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY'))), p_date_traite),
		    calc_prop_budget2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +1), p_date_traite),
		    calc_prop_budget2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +2), p_date_traite),
		    calc_prop_budget2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +3), p_date_traite),
		    CST_BUD_XXXX
		    );

	 -- insert dans la table tmp_budget_sstache de budget notifier
	 l_temp1 := calc_budg_notif2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) -2), p_date_traite);
	 l_temp2 := calc_budg_notif2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) -1), p_date_traite);
	 l_temp3 := calc_budg_notif2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY'))), p_date_traite);

	 INSERT INTO tmp_budget_sstache (numseq,
					 typeb,
					 pid,
					 histo,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'B',
		   lc_lig_pid.pid,
		   l_temp1,
		   l_temp2,
		   l_temp3,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp1), 0) + nvl(to_number(l_temp2), 0) + nvl(to_number(l_temp3), 0),
			      'FM9999999D00' )
		   );

	 -- insert dans la table tmp_budget_sstache de budget arbitré notifié
	 l_temp1 := calc_budg_arb_notif2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) -2), p_date_traite);
	 l_temp2 := calc_budg_arb_notif2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) -1), p_date_traite);
	 l_temp3 := calc_budg_arb_notif2(lc_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY'))), p_date_traite);

	 INSERT INTO tmp_budget_sstache (numseq,
					 typeb,
					 pid,
					 histo,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'C',
		   lc_lig_pid.pid,
		   l_temp1,
		   l_temp2,
		   l_temp3,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp1), 0) + nvl(to_number(l_temp2), 0) + nvl(to_number(l_temp3), 0),
			      'FM9999999D00')
		   );

	 -- insert dans la table tmp_budget_sstache de budget reestime
	 INSERT INTO tmp_budget_sstache (numseq,
					 typeb,
					 pid,
					 histo,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   (SELECT l_var_seq,
	    'D',
	    lc_lig_pid.pid,
	    CST_BUD_XXXX,
	    CST_BUD_XXXX,
	    to_char(budg.reestime, 'FM9999999999999'),
	    CST_BUD_XXXX,
	    CST_BUD_XXXX,
	    CST_BUD_XXXX,
	    CST_BUD_XXXX
	    FROM budget budg,ligne_bip lb
	    WHERE budg.pid (+)= lb.pid
	    AND lb.pid = lc_lig_pid.pid
	    AND budg.annee (+)= TO_NUMBER(TO_CHAR(p_date_traite,'YYYY'))
	    );

	 -- insert dans la table tmp_budget_sstache de budget consomme
	 -- ATTENTION ICI LE SECOND PARAM EST DE TYPE DATE

	 l_temp1 := calc_cons_annee_prec(lc_lig_pid.pid, (to_number(to_char(p_date_traite,'YYYY'))-2), 'h');
	 l_temp2 := calc_cons_annee_prec(lc_lig_pid.pid, (to_number(to_char(p_date_traite,'YYYY'))-1), 'p');
	 l_temp3 := calc_cons_sstache_res_mois2(lc_lig_pid.pid, trunc(p_date_traite, 'YEAR'), p_date_traite);

	 INSERT INTO tmp_budget_sstache (numseq,
					 typeb,
					 pid,
					 histo,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'E',
		   lc_lig_pid.pid,
		   l_temp1,
		   l_temp2,
		   l_temp3,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp1), 0) + nvl(to_number(l_temp2), 0) + nvl(to_number(l_temp3), 0),
			     'FM9999999D00')
		   );

	 commit;

      END LOOP;

      -- Fermeture du curseur
      CLOSE lc_pid;

      RETURN l_var_seq;

   EXCEPTION
      WHEN OTHERS THEN RETURN 0;
	-- WHEN OTHERS THEN raise_application_error(-20997, sqlerrm);
   END tmp_sstache_budget2;


--****************************************************************************
-- Les Procédures
--****************************************************************************

   -- ------------------------------------------------------------------------
   -- Nom        :  ouvrir_conso_cv (Procédure)
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Ouverture variable curseur de type ConsoCurTyp
   -- Paramètres :  p_curv    (IN/OUT) 	Curseur à ouvrir
   --               p_nom_etat (IN)     	Nom de l'état traité (PRODEC2, 3, 4, ou L)
   -- 		  p_clicode   (IN) 	Code direction
   --			  p_codsg    (IN)       Code DPG (Pouvant contenir des * à la fin!!!)
   --               p_pid      (IN)       Code ligne BIP
   --               p_id_proj_ou_appli     (IN)       Code référentiel (Identifiant Projet ou Application)
   --			  p_date_traite (IN)    Date à prendre en compte
   --			 	Le mois de cette date est le mois maxi à traiter
   --			 	L'année de cette date correspond à l'année à traiter
   --
   -- Retour     :
   --
   -- Remarque   : On ne peut avoir p_codsg et p_pid tous les 2 non NULS!!!
   -- ------------------------------------------------------------------------
 PROCEDURE ouvrir_conso_cv(
					p_curv     	IN OUT ConsoCurTyp,
					p_nom_etat 	IN VARCHAR2,
					p_clicode   	IN client_mo.clicode%TYPE,
					p_codsg    	IN VARCHAR2,
					p_pid      	IN ligne_bip.pid%TYPE,
					p_id_proj_ou_appli IN VARCHAR2,
					p_date_traite 	IN DATE
				    ) IS

	l_annee_traite VARCHAR2(4);
	l_mois_maxi_traite VARCHAR2(2);
	l_derjour_mois_maxi_traite VARCHAR2(2);

	l_date_mini DATE;
	l_date_maxi DATE;
	l_dir varchar2(10);

 BEGIN

 /********************************************************************************
  * Seul le paramètre "p_date_traite" est pris en compte :
  * On conserve les autres paramètres pour le  cas où!!!
  ********************************************************************************/

	l_annee_traite := TO_CHAR(p_date_traite, 'YYYY');
	l_mois_maxi_traite  := TO_CHAR(p_date_traite, 'MM');
        l_derjour_mois_maxi_traite := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || l_mois_maxi_traite  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );

	l_date_mini := TO_DATE('01/01/' || l_annee_traite, 'DD/MM/YYYY');
	l_date_maxi := TO_DATE(l_derjour_mois_maxi_traite || '/' || l_mois_maxi_traite || '/' || l_annee_traite, 'DD/MM/YYYY');

--	 -- 02/03/2001 : filtre sur p_clidom (direction ou département)
--	  -- tester si p_clidom est une direction ou un département
--	  BEGIN
--   		select 'dir' into l_dir
--		from client_mo
--		where
--		 clicode=p_clicode;
--          EXCEPTION
--		WHEN NO_DATA_FOUND THEN   --départment
--		l_dir :='dpt';
--          END;

	-----------------------------------------------------------------------------------------
	-- ON PREND CONSOMMES DE L'ANNEE TRAITEE ET DES MOIS <= Mois maxi à traiter (Mois saisi)
  	-- (l_date_mini <= cdeb <= l_date_maxi )
	--				+
	-- Filtres supplémentaires suivant Etat
	-----------------------------------------------------------------------------------------

	IF ( (p_nom_etat = 'PRODECL') AND (p_pid IS NOT NULL) ) THEN
		-- PRODECL Avec Code ligne BIP Obligatoirement Saisi (Code DPG  est non saisi)!!!

OPEN p_curv FOR
SELECT
      csr.cdeb   cdeb,
      csr.pid   pid,
      csr.acta   acta,
      csr.acst  acst,
      csr.ecet  ecet,
      SUM(csr.cusag)    cusag
FROM
(
  ------------------------------------------------------------------------------------
  -- Cas 1 : Ressource avec bonne situation
  -- On teste prestation != 'GRA' !!!
  ------------------------------------------------------------------------------------
  SELECT
      csr1.cdeb   	cdeb,
      csr1.pid   		pid,
      csr1.acta   	acta,
      csr1.acst  		acst,
      csr1.ecet  		ecet,
      SUM(csr1.cusag)   cusag
    FROM  cons_sstache_res_mois csr1,
          situ_ress sir1
    WHERE
	sir1.ident = csr1.ident
      AND    TRUNC(sir1.datsitu,'MONTH')  <= TRUNC(csr1.cdeb,'MONTH')
      AND   ( (csr1.cdeb <= sir1.datdep) OR (sir1.datdep IS NULL) )
      AND   ( (sir1.prestation != 'GRA') OR (sir1.prestation IS NULL) )
     	AND   (csr1.cdeb BETWEEN l_date_mini AND l_date_maxi )
    	AND   csr1.ident != 0
      AND   csr1.cusag != 0
      -------------------------------------------------------------------
      -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
      --------------------------------------------------------------------
      AND  csr1.pid IN ( SELECT pro1.pid FROM proplus pro1
        			WHERE pro1.factpid = p_pid
        			AND ( pro1.cdeb BETWEEN l_date_mini AND l_date_maxi )
                      )
     GROUP BY csr1.pid, csr1.cdeb, csr1.acta, csr1.acst, csr1.ecet
   -----------------------------------------------------------------------
   UNION ALL
   ------------------------------------------------------------------------
   ------------------------------------------------------------------------------------
   -- Cas 2 : Ressource avec mauvaise situation
   -- Correspond à tous les cas autres que Cas 1 :
   ------------------------------------------------------------------------------------
   SELECT
       csr2.cdeb   	cdeb,
       csr2.pid   	pid,
       csr2.acta   	acta,
       csr2.acst  	acst,
       csr2.ecet  	ecet,
       SUM(csr2.cusag)  cusag
    FROM  cons_sstache_res_mois csr2
    WHERE
     	NOT EXISTS 	(
        			SELECT 1 from situ_ress sir2
        			WHERE  sir2.ident = csr2.ident
        			AND   TRUNC(sir2.datsitu,'MONTH')  <= TRUNC(csr2.cdeb,'MONTH')
        			AND   ( (csr2.cdeb <= sir2.datdep) OR (sir2.datdep IS NULL) )
          		)
     	AND ( csr2.cdeb BETWEEN l_date_mini AND l_date_maxi )
     	AND csr2.ident != 0
	AND csr2.cusag != 0
     -------------------------------------------------------------------
     -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
     -------------------------------------------------------------------
     AND csr2.pid IN ( 	SELECT pro2.pid FROM proplus pro2
        			WHERE pro2.factpid = p_pid
        			AND ( pro2.cdeb BETWEEN l_date_mini AND l_date_maxi )
          		   )
    GROUP BY csr2.pid, csr2.cdeb, csr2.acta, csr2.acst, csr2.ecet
) csr
GROUP BY csr.pid, csr.cdeb, csr.acta, csr.acst, csr.ecet
;

  ELSIF ( (p_nom_etat = 'PRODECL') AND (p_codsg IS NOT NULL) AND (p_codsg <> CST_CODE_DPG_TOUS) ) THEN
	-- PRODECL Avec Code DPG différent de '******' saisi (Code ligne BIP n'est pas saisi) !!!

OPEN p_curv FOR
SELECT
      csr.cdeb  cdeb,
      csr.pid   pid,
      csr.acta  acta,
      csr.acst  acst,
      csr.ecet  ecet,
      SUM(csr.cusag)    cusag
FROM
(
  ------------------------------------------------------------------------------------
  -- Cas 1 : Ressource avec bonne situation
  -- On teste prestation != 'GRA' !!!
  ------------------------------------------------------------------------------------
  SELECT
      csr1.cdeb   	cdeb,
      csr1.pid   	pid,
      csr1.acta   	acta,
      csr1.acst  	acst,
      csr1.ecet  	ecet,
      SUM(csr1.cusag)   cusag
    FROM  cons_sstache_res_mois csr1,
          situ_ress sir1
    WHERE
      sir1.ident = csr1.ident
      AND  TRUNC(sir1.datsitu,'MONTH')  <= TRUNC(csr1.cdeb,'MONTH')
      AND   ( (csr1.cdeb <= sir1.datdep) OR (sir1.datdep IS NULL) )
      AND   ( (sir1.prestation != 'GRA') OR (sir1.prestation IS NULL) )
      AND   (csr1.cdeb BETWEEN l_date_mini AND l_date_maxi )
      AND   csr1.ident != 0
      AND   csr1.cusag != 0
      -------------------------------------------------------------------
      -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
      --------------------------------------------------------------------
      AND  csr1.pid IN ( SELECT pro1.pid FROM proplus pro1
					WHERE SUBSTR(TO_CHAR(pro1.factpdsg,'FM0000000'), 1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg, 7, '0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg, 7 ,'0'),'*'))
        			AND ( pro1.cdeb BETWEEN l_date_mini AND l_date_maxi )
                      )
     GROUP BY csr1.pid, csr1.cdeb, csr1.acta, csr1.acst, csr1.ecet
   -----------------------------------------------------------------------
   UNION ALL
   ------------------------------------------------------------------------
   ------------------------------------------------------------------------------------
   -- Cas 2 : Ressource avec mauvaise situation
   -- Correspond à tous les cas autres que Cas 1 :
   ------------------------------------------------------------------------------------
   SELECT
       csr2.cdeb   	cdeb,
       csr2.pid   	pid,
       csr2.acta   	acta,
       csr2.acst  	acst,
       csr2.ecet  	ecet,
       SUM(csr2.cusag)  cusag
    FROM  cons_sstache_res_mois csr2
    WHERE
     	NOT EXISTS 	(
        			SELECT 1 from situ_ress sir2
        			WHERE  sir2.ident = csr2.ident
        			AND   TRUNC(sir2.datsitu,'MONTH')  <= TRUNC(csr2.cdeb,'MONTH')
        			AND   ( (csr2.cdeb <= sir2.datdep) OR (sir2.datdep IS NULL) )
          		)
     	AND ( csr2.cdeb BETWEEN l_date_mini AND l_date_maxi )
     	AND csr2.ident != 0
	AND csr2.cusag != 0
     -------------------------------------------------------------------
     -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
     -------------------------------------------------------------------
     AND csr2.pid IN ( 	SELECT pro2.pid FROM proplus pro2
					WHERE SUBSTR(TO_CHAR(pro2.factpdsg,'FM0000000'), 1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*'))
        			AND ( pro2.cdeb BETWEEN l_date_mini AND l_date_maxi )
          		   )
    GROUP BY csr2.pid, csr2.cdeb, csr2.acta, csr2.acst, csr2.ecet
) csr
GROUP BY csr.pid, csr.cdeb, csr.acta, csr.acst, csr.ecet
;


	ELSIF ( (p_nom_etat = 'PRODEC3') AND (p_codsg IS NOT NULL) AND (p_codsg <> CST_CODE_DPG_TOUS) ) THEN
		-- PRODEC3 avec saisie DPG différent de '*******'

OPEN p_curv FOR
SELECT
      csr.cdeb   cdeb,
      csr.pid   pid,
      csr.acta   acta,
      csr.acst  acst,
      csr.ecet  ecet,
      SUM(csr.cusag)    cusag
FROM
(
  ------------------------------------------------------------------------------------
  -- Cas 1 : Ressource avec bonne situation
  -- On teste prestation != 'GRA' !!!
  ------------------------------------------------------------------------------------
  SELECT
      csr1.cdeb   	cdeb,
      csr1.pid   	pid,
      csr1.acta   	acta,
      csr1.acst  	acst,
      csr1.ecet  	ecet,
      SUM(csr1.cusag)   cusag
    FROM  cons_sstache_res_mois csr1,
          situ_ress sir1
    WHERE
      sir1.ident = csr1.ident
      AND    TRUNC(sir1.datsitu,'MONTH')  <= TRUNC(csr1.cdeb,'MONTH')
      AND   ( (csr1.cdeb <= sir1.datdep) OR (sir1.datdep IS NULL) )
      AND   ( (sir1.prestation != 'GRA') OR (sir1.prestation IS NULL) )
      AND   (csr1.cdeb BETWEEN l_date_mini AND l_date_maxi )
      AND   csr1.ident != 0
      AND   csr1.cusag != 0
      -------------------------------------------------------------------
      -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
      --------------------------------------------------------------------
      AND  csr1.pid IN ( SELECT pro1.pid FROM proplus pro1
					WHERE SUBSTR(TO_CHAR(pro1.factpdsg,'FM0000000'), 1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*'))
        			AND ( pro1.cdeb BETWEEN l_date_mini AND l_date_maxi )
                      )
     GROUP BY csr1.pid, csr1.cdeb, csr1.acta, csr1.acst, csr1.ecet
   -----------------------------------------------------------------------
   UNION ALL
   ------------------------------------------------------------------------
   ------------------------------------------------------------------------------------
   -- Cas 2 : Ressource avec mauvaise situation
   -- Correspond à tous les cas autres que Cas 1 :
   ------------------------------------------------------------------------------------
   SELECT
       csr2.cdeb   	cdeb,
       csr2.pid   	pid,
       csr2.acta   	acta,
       csr2.acst  	acst,
       csr2.ecet  	ecet,
       SUM(csr2.cusag)  cusag
    FROM  cons_sstache_res_mois csr2
    WHERE
     	NOT EXISTS 	(
        			SELECT 1 from situ_ress sir2
        			WHERE  sir2.ident = csr2.ident
        			AND   TRUNC(sir2.datsitu,'MONTH')  <= TRUNC(csr2.cdeb,'MONTH')
        			AND   ( (csr2.cdeb <= sir2.datdep) OR (sir2.datdep IS NULL) )
          		)
     	AND ( csr2.cdeb BETWEEN l_date_mini AND l_date_maxi )
     	AND csr2.ident != 0
	AND csr2.cusag != 0
     -------------------------------------------------------------------
     -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
     -------------------------------------------------------------------
     AND csr2.pid IN ( 	SELECT pro2.pid FROM proplus pro2
					WHERE SUBSTR(TO_CHAR(pro2.factpdsg,'FM0000000'), 1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg, 7, '0'),'*'))
        			AND ( pro2.cdeb BETWEEN l_date_mini AND l_date_maxi )
          		   )
    GROUP BY csr2.pid, csr2.cdeb, csr2.acta, csr2.acst, csr2.ecet
) csr
GROUP BY csr.pid, csr.cdeb, csr.acta, csr.acst, csr.ecet
;

	ELSIF ( (p_nom_etat = 'PRODEC4') AND (SUBSTR(p_id_proj_ou_appli, 1, 1) = CST_PREM_CAR_ID_APPLI) ) THEN
		-- PRODEC4 avec Code Application saisi

OPEN p_curv FOR
SELECT
      csr.cdeb   cdeb,
      csr.pid   pid,
      csr.acta   acta,
      csr.acst  acst,
      csr.ecet  ecet,
      SUM(csr.cusag)    cusag
FROM
(
  ------------------------------------------------------------------------------------
  -- Cas 1 : Ressource avec bonne situation
  -- On teste prestation != 'GRA' !!!
  ------------------------------------------------------------------------------------
  SELECT
      csr1.cdeb   	cdeb,
      csr1.pid   	pid,
      csr1.acta   	acta,
      csr1.acst  	acst,
      csr1.ecet  	ecet,
      SUM(csr1.cusag)   cusag
    FROM  cons_sstache_res_mois csr1,
          situ_ress sir1
    WHERE
      sir1.ident = csr1.ident
      AND   TRUNC(sir1.datsitu,'MONTH')  <= TRUNC(csr1.cdeb,'MONTH')
      AND   ( (csr1.cdeb <= sir1.datdep) OR (sir1.datdep IS NULL) )
      AND   ( (sir1.prestation != 'GRA') OR (sir1.prestation IS NULL) )
      AND   (csr1.cdeb BETWEEN l_date_mini AND l_date_maxi )
      AND   csr1.ident != 0
      AND   csr1.cusag != 0
      -------------------------------------------------------------------
      -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
      --------------------------------------------------------------------
      AND  csr1.pid IN ( SELECT pro1.pid FROM proplus pro1
					WHERE pro1.factpid IN (SELECT lbi.pid  FROM ligne_bip lbi WHERE lbi.airt = p_id_proj_ou_appli)
        			AND ( pro1.cdeb BETWEEN l_date_mini AND l_date_maxi )
                      )
     GROUP BY csr1.pid, csr1.cdeb, csr1.acta, csr1.acst, csr1.ecet
   -----------------------------------------------------------------------
   UNION ALL
   ------------------------------------------------------------------------
   ------------------------------------------------------------------------------------
   -- Cas 2 : Ressource avec mauvaise situation
   -- Correspond à tous les cas autres que Cas 1 :
   ------------------------------------------------------------------------------------
   SELECT
       csr2.cdeb   	cdeb,
       csr2.pid   	pid,
       csr2.acta   	acta,
       csr2.acst  	acst,
       csr2.ecet  	ecet,
       SUM(csr2.cusag)  cusag
    FROM  cons_sstache_res_mois csr2
    WHERE
     	NOT EXISTS 	(
        			SELECT 1 from situ_ress sir2
        			WHERE  sir2.ident = csr2.ident
        			AND   TRUNC(sir2.datsitu,'MONTH')  <= TRUNC(csr2.cdeb,'MONTH')
        			AND   ( (csr2.cdeb <= sir2.datdep) OR (sir2.datdep IS NULL) )
          		)
     	AND ( csr2.cdeb BETWEEN l_date_mini AND l_date_maxi )
     	AND csr2.ident != 0
	AND csr2.cusag != 0
     -------------------------------------------------------------------
     -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
     -------------------------------------------------------------------
     AND csr2.pid IN ( 	SELECT pro2.pid FROM proplus pro2
					WHERE pro2.factpid IN (SELECT lbi.pid  FROM ligne_bip lbi WHERE lbi.airt = p_id_proj_ou_appli)
        			AND ( pro2.cdeb BETWEEN l_date_mini AND l_date_maxi )
          		   )
    GROUP BY csr2.pid, csr2.cdeb, csr2.acta, csr2.acst, csr2.ecet
) csr
GROUP BY csr.pid, csr.cdeb, csr.acta, csr.acst, csr.ecet
;

	ELSIF ( (p_nom_etat = 'PRODEC4') AND (SUBSTR(p_id_proj_ou_appli, 1, 1) = CST_PREM_CAR_ID_PROJ) ) THEN
		-- PRODEC4 avec Code Projet saisi

OPEN p_curv FOR
SELECT
      csr.cdeb  	cdeb,
      csr.pid   	pid,
      csr.acta  	acta,
      csr.acst  	acst,
      csr.ecet  	ecet,
      SUM(csr.cusag)    cusag
FROM
(
  ------------------------------------------------------------------------------------
  -- Cas 1 : Ressource avec bonne situation
  -- On teste prestation != 'GRA' !!!
  ------------------------------------------------------------------------------------
  SELECT
      csr1.cdeb   	cdeb,
      csr1.pid   	pid,
      csr1.acta   	acta,
      csr1.acst  	acst,
      csr1.ecet  	ecet,
      SUM(csr1.cusag)   cusag
    FROM  cons_sstache_res_mois csr1,
          situ_ress 		sir1
    WHERE
	sir1.ident = csr1.ident
      AND   TRUNC(sir1.datsitu,'MONTH')  <= TRUNC(csr1.cdeb,'MONTH')
      AND   ( (csr1.cdeb <= sir1.datdep) OR (sir1.datdep IS NULL) )
      AND   ( (sir1.prestation != 'GRA') OR (sir1.prestation IS NULL) )
     	AND   (csr1.cdeb BETWEEN l_date_mini AND l_date_maxi )
    	AND   csr1.ident != 0
      AND   csr1.cusag != 0
      -------------------------------------------------------------------
      -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
      --------------------------------------------------------------------
      AND  csr1.pid IN ( SELECT pro1.pid FROM proplus pro1
					WHERE pro1.factpid IN (SELECT lbi.pid pid FROM ligne_bip lbi WHERE lbi.icpi = p_id_proj_ou_appli)
        			AND ( pro1.cdeb BETWEEN l_date_mini AND l_date_maxi )
                      )
     GROUP BY csr1.pid, csr1.cdeb, csr1.acta, csr1.acst, csr1.ecet
   -----------------------------------------------------------------------
   UNION ALL
   ------------------------------------------------------------------------
   ------------------------------------------------------------------------------------
   -- Cas 2 : Ressource avec mauvaise situation
   -- Correspond à tous les cas autres que Cas 1 :
   ------------------------------------------------------------------------------------
   SELECT
       csr2.cdeb   	cdeb,
       csr2.pid   	pid,
       csr2.acta   	acta,
       csr2.acst  	acst,
       csr2.ecet  	ecet,
       SUM(csr2.cusag)  cusag
    FROM  cons_sstache_res_mois csr2
    WHERE
     	NOT EXISTS 	(
        			SELECT 1 from situ_ress sir2
        			WHERE  sir2.ident = csr2.ident
        			AND   TRUNC(sir2.datsitu,'MONTH')  <= TRUNC(csr2.cdeb,'MONTH')
        			AND   ( (csr2.cdeb <= sir2.datdep) OR (sir2.datdep IS NULL) )
          		)
     	AND ( csr2.cdeb BETWEEN l_date_mini AND l_date_maxi )
     	AND csr2.ident != 0
	AND csr2.cusag != 0
     -------------------------------------------------------------------
     -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
     -------------------------------------------------------------------
     AND csr2.pid IN ( 	SELECT pro2.pid FROM proplus pro2
					WHERE pro2.factpid IN (SELECT lbi.pid pid FROM ligne_bip lbi WHERE lbi.icpi = p_id_proj_ou_appli)
        			AND ( pro2.cdeb BETWEEN l_date_mini AND l_date_maxi )
          		   )
    GROUP BY csr2.pid, csr2.cdeb, csr2.acta, csr2.acst, csr2.ecet
) csr
GROUP BY csr.pid, csr.cdeb, csr.acta, csr.acst, csr.ecet
;

	ELSIF ( (p_nom_etat = 'PRODEC2') ) THEN
		-- PRODEC2 (FILTRE SUR clicode pour TEST SI GAIN EXECUTION!!!)

OPEN p_curv FOR
SELECT
      csr.cdeb  	cdeb,
      csr.pid   	pid,
      csr.acta  	acta,
      csr.acst  	acst,
      csr.ecet  	ecet,
      SUM(csr.cusag)    cusag
FROM
(
  ------------------------------------------------------------------------------------
  -- Cas 1 : Ressource avec bonne situation
  -- On teste prestation != 'GRA' !!!
  ------------------------------------------------------------------------------------
  SELECT
      csr1.cdeb   	cdeb,
      csr1.pid   	pid,
      csr1.acta   	acta,
      csr1.acst  	acst,
      csr1.ecet  	ecet,
      SUM(csr1.cusag)   cusag
    FROM  cons_sstache_res_mois csr1,
          situ_ress 		sir1
    WHERE
	sir1.ident = csr1.ident
      AND   TRUNC(sir1.datsitu,'MONTH')  <= TRUNC(csr1.cdeb,'MONTH')
      AND   ( (csr1.cdeb <= sir1.datdep) OR (sir1.datdep IS NULL) )
      AND   ( (sir1.prestation != 'GRA') OR (sir1.prestation IS NULL) )
      AND   (csr1.cdeb BETWEEN l_date_mini AND l_date_maxi )
      AND   csr1.ident != 0
      AND   csr1.cusag != 0
      -------------------------------------------------------------------
      -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
      --------------------------------------------------------------------
      AND  csr1.pid IN ( SELECT pro1.pid FROM proplus pro1
				 WHERE pro1.factpid IN (	SELECT lbi.pid pid
									FROM ligne_bip lbi, client_mo  clm
								    	WHERE lbi.clicode = clm.clicode
								    		--AND clm.clicode  = p_clicode
								    		--F93
								    	AND clm.clicode in (
								    			select clicoderatt
								    			from vue_clicode_hierarchie vu
								    			where vu.clicode = p_clicode)
							      )
        			 AND ( pro1.cdeb BETWEEN l_date_mini AND l_date_maxi )
                      )
     GROUP BY csr1.pid, csr1.cdeb, csr1.acta, csr1.acst, csr1.ecet
   -----------------------------------------------------------------------
   UNION ALL
   ------------------------------------------------------------------------
   ------------------------------------------------------------------------------------
   -- Cas 2 : Ressource avec mauvaise situation
   -- Correspond à tous les cas autres que Cas 1 :
   ------------------------------------------------------------------------------------
   SELECT
       csr2.cdeb   	cdeb,
       csr2.pid   	pid,
       csr2.acta   	acta,
       csr2.acst  	acst,
       csr2.ecet  	ecet,
       SUM(csr2.cusag)  cusag
    FROM  cons_sstache_res_mois csr2
    WHERE
     	NOT EXISTS 	(
        			SELECT 1 from situ_ress sir2
        			WHERE  sir2.ident = csr2.ident
        			AND   TRUNC(sir2.datsitu,'MONTH')  <= TRUNC(csr2.cdeb,'MONTH')
        			AND   ( (csr2.cdeb <= sir2.datdep) OR (sir2.datdep IS NULL) )
          		)
     	AND ( csr2.cdeb BETWEEN l_date_mini AND l_date_maxi )
     	AND csr2.ident != 0
	AND csr2.cusag != 0
     -------------------------------------------------------------------
     -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
     -------------------------------------------------------------------
     AND csr2.pid IN ( 	SELECT pro2.pid FROM proplus pro2
				WHERE pro2.factpid IN (	SELECT lbi.pid pid
								FROM ligne_bip lbi, client_mo  clm
								WHERE lbi.clicode = clm.clicode
								--AND clm.clicode = p_clicode
								--F93
								AND clm.clicode in (
								    			select clicoderatt
								    			from vue_clicode_hierarchie vu
								    			where vu.clicode = p_clicode)
							     )
        			AND ( pro2.cdeb BETWEEN l_date_mini AND l_date_maxi )
          		   )
    GROUP BY csr2.pid, csr2.cdeb, csr2.acta, csr2.acst, csr2.ecet
) csr
GROUP BY csr.pid, csr.cdeb, csr.acta, csr.acst, csr.ecet
;

	ELSE

OPEN p_curv FOR
SELECT
      csr.cdeb   cdeb,
      csr.pid   pid,
      csr.acta   acta,
      csr.acst  acst,
      csr.ecet  ecet,
      SUM(csr.cusag)    cusag
FROM
(
  ------------------------------------------------------------------------------------
  -- Cas 1 : Ressource avec bonne situation
  -- On teste prestation != 'GRA' !!!
  ------------------------------------------------------------------------------------
  SELECT
      csr1.cdeb   	cdeb,
      csr1.pid   		pid,
      csr1.acta   	acta,
      csr1.acst  		acst,
      csr1.ecet  		ecet,
      SUM(csr1.cusag)   cusag
    FROM  cons_sstache_res_mois csr1,
          situ_ress sir1
    WHERE
	sir1.ident = csr1.ident
      AND   TRUNC(sir1.datsitu,'MONTH')  <= TRUNC(csr1.cdeb,'MONTH')
      AND   ( (csr1.cdeb <= sir1.datdep) OR (sir1.datdep IS NULL) )
      AND   ( (sir1.prestation != 'GRA') OR (sir1.prestation IS NULL) )
     	AND   (csr1.cdeb BETWEEN l_date_mini AND l_date_maxi )
    	AND   csr1.ident != 0
      AND   csr1.cusag != 0
     GROUP BY csr1.pid, csr1.cdeb, csr1.acta, csr1.acst, csr1.ecet
   -----------------------------------------------------------------------
   UNION ALL
   ------------------------------------------------------------------------
   ------------------------------------------------------------------------------------
   -- Cas 2 : Ressource avec mauvaise situation
   -- Correspond à tous les cas autres que Cas 1 :
   ------------------------------------------------------------------------------------
   SELECT
       csr2.cdeb   	cdeb,
       csr2.pid   	pid,
       csr2.acta   	acta,
       csr2.acst  	acst,
       csr2.ecet  	ecet,
       SUM(csr2.cusag)  cusag
    FROM  cons_sstache_res_mois csr2
    WHERE
     	NOT EXISTS 	(
        			SELECT 1 from situ_ress sir2
        			WHERE  sir2.ident = csr2.ident
        			AND   TRUNC(sir2.datsitu,'MONTH')  <= TRUNC(csr2.cdeb,'MONTH')
        			AND   ( (csr2.cdeb <= sir2.datdep) OR (sir2.datdep IS NULL) )
          		)
     	AND ( csr2.cdeb BETWEEN l_date_mini AND l_date_maxi )
     	AND csr2.ident != 0
	AND csr2.cusag != 0
    GROUP BY csr2.pid, csr2.cdeb, csr2.acta, csr2.acst, csr2.ecet
) csr
GROUP BY csr.pid, csr.cdeb, csr.acta, csr.acst, csr.ecet
;

	END IF;

 END ouvrir_conso_cv;


   -- ------------------------------------------------------------------------
   -- Nom        :  ouvrir_budget_cv (Procédure)
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Ouverture variable curseur de type BudgetCurTyp
   -- Paramètres :  p_curv     (IN/OUT)  	Curseur à ouvrir
   --               p_nom_etat (IN)     	Nom de l'état traité (PRODEC2, 3, 4, ou L)
   -- 		    p_clicode  (IN) 	Code direction
   --		    p_codsg    (IN)       Code DPG (Pouvant contenir des * à la fin!!!)
   --               p_pid      (IN)       Code ligne BIP
   --               p_id_proj_ou_appli     (IN)       Code référentiel (Identifiant Projet ou Application)
   --		    p_date_traite (IN)    Date à prendre en compte
   --		   (L'année de cette date correspond à l'année N !!! dans l'état!!!)
   --
   -- Retour     :
   --
   -- ------------------------------------------------------------------------
   PROCEDURE ouvrir_budget_cv(
					p_curv     	IN OUT BudgetCurTyp,
					p_nom_etat 	IN VARCHAR2,
					p_clicode   	IN client_mo.clicode%TYPE,
					p_codsg    	IN VARCHAR2,
					p_pid      	IN ligne_bip.pid%TYPE,
					p_id_proj_ou_appli     IN VARCHAR2,
					p_date_traite 	IN DATE
				    ) IS

	l_annee_traite VARCHAR2(4);
	l_mois_maxi_traite VARCHAR2(2);
	l_derjour_mois_maxi_traite VARCHAR2(2);

	l_date_mini DATE;
	l_date_maxi DATE;
	l_dir varchar2(10);
  BEGIN

	l_annee_traite := TO_CHAR(p_date_traite, 'YYYY');
	l_mois_maxi_traite  := TO_CHAR(p_date_traite, 'MM');
        l_derjour_mois_maxi_traite := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || l_mois_maxi_traite  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );

	l_date_mini := TO_DATE('01/01/' || l_annee_traite, 'DD/MM/YYYY');
	l_date_maxi := TO_DATE(l_derjour_mois_maxi_traite || '/' || l_mois_maxi_traite || '/' || l_annee_traite, 'DD/MM/YYYY');

--	 -- 02/03/2001 : filtre sur p_clidom (direction ou département)
--	  -- tester si p_clidom est une direction ou un département
--	  BEGIN
--   		select 'dir' into l_dir
--		from client_mo
--		where clidom=p_clidom
--		and clicode=p_clidom;
--          EXCEPTION
--		WHEN NO_DATA_FOUND THEN   --départment
--		l_dir :='dpt';
--          END;

  IF ( (p_nom_etat = 'PRODEC4') AND (SUBSTR(p_id_proj_ou_appli, 1, 1) = CST_PREM_CAR_ID_APPLI) ) THEN
	-- PRODEC4 avec Code Application saisi

	OPEN p_curv FOR
		SELECT DISTINCT lbi.pid pid
		FROM 	ligne_bip lbi,
     	     	    	client_mo  clm
	  	WHERE lbi.airt = p_id_proj_ou_appli
	;

  ELSIF ( (p_nom_etat = 'PRODEC4') AND (SUBSTR(p_id_proj_ou_appli, 1, 1) = CST_PREM_CAR_ID_PROJ) ) THEN
	-- PRODEC4 avec Code Projet saisi

	OPEN p_curv FOR
		SELECT DISTINCT lbi.pid pid
		FROM 	ligne_bip lbi,
     	     	    	client_mo  clm
	  	WHERE lbi.icpi = p_id_proj_ou_appli
	;

  ELSIF ( (p_nom_etat = 'PRODEC3') AND ( (p_codsg IS NULL) OR (p_codsg = CST_CODE_DPG_TOUS) ) ) THEN
	-- PRODEC3 avec : absence saisie DPG ou saisie DPG '*******'
	OPEN p_curv FOR
		SELECT DISTINCT pro.pid pid
		FROM 	proplus pro
		WHERE pro.cdeb BETWEEN l_date_mini AND l_date_maxi

		UNION

		SELECT DISTINCT pro.factpid pid
		FROM 	proplus pro
		WHERE pro.cdeb BETWEEN l_date_mini AND l_date_maxi
	;

  ELSIF ( (p_nom_etat = 'PRODEC3') AND (p_codsg IS NOT NULL) AND (p_codsg <> CST_CODE_DPG_TOUS) ) THEN
	-- PRODEC3 avec saisie DPG différent de '*******'

	OPEN p_curv FOR
		SELECT DISTINCT pro.pid pid
		FROM 	proplus pro
		WHERE pro.cdeb BETWEEN l_date_mini AND l_date_maxi
		AND SUBSTR(TO_CHAR(pro.pdsg,'FM0000000'), 1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*'))

		UNION

		SELECT DISTINCT pro.factpid pid
		FROM 	proplus pro
		WHERE pro.cdeb BETWEEN l_date_mini AND l_date_maxi
		AND SUBSTR(TO_CHAR(pro.factpdsg,'FM0000000'), 1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*'))
	;

  ELSIF (
		( (p_nom_etat = 'PRODECL') AND (p_codsg IS NULL) AND (p_pid IS NULL) )
		-- PRODECL avec absence saisie Code DPG et Code PID !!!
				OR
		( (p_nom_etat = 'PRODECL') AND (p_codsg = CST_CODE_DPG_TOUS) )
		-- PRODECL Avec Code DPG '*******' Saisi !!!
        ) THEN

	OPEN p_curv FOR
		SELECT DISTINCT pro.pid pid
		FROM 	proplus pro
		WHERE pro.cdeb BETWEEN l_date_mini AND l_date_maxi

		UNION

		SELECT DISTINCT pro.factpid pid
		FROM 	proplus pro
		WHERE pro.cdeb BETWEEN l_date_mini AND l_date_maxi
	;

  ELSIF ( (p_nom_etat = 'PRODECL') AND (p_codsg IS NOT NULL) AND (p_codsg <> CST_CODE_DPG_TOUS) ) THEN
	-- PRODECL Avec Code DPG différent de '*******' saisi (Code ligne BIP n'est pas saisi) !!!

	OPEN p_curv FOR
		SELECT DISTINCT pro.pid pid
		FROM 	proplus pro
		WHERE pro.cdeb BETWEEN l_date_mini AND l_date_maxi
		AND SUBSTR(TO_CHAR(pro.pdsg,'FM0000000'), 1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*'))

		UNION

		SELECT DISTINCT pro.factpid pid
		FROM 	proplus pro
		WHERE pro.cdeb BETWEEN l_date_mini AND l_date_maxi
		AND SUBSTR(TO_CHAR(pro.factpdsg,'FM0000000'), 1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*'))
	;

  ELSIF ( (p_nom_etat = 'PRODECL') AND (p_pid IS NOT NULL) ) THEN
	-- PRODECL Avec Code ligne BIP Obligatoirement Saisi (Code DPG  est non saisi)!!!

	OPEN p_curv FOR
		SELECT  lbi.pid pid
		FROM 	ligne_bip lbi
	  	WHERE lbi.pid = p_pid	-- Retournera 1 ligne au maxi (PID est la clé primaire de LIGNE_BIP!)
	;

  ELSE
	-- Dans tous les autres cas (Normalement, devrait correspondre au seul cas PRODEC2 !!!)
	-- FAUT PAS OUBLIER QU'IL Y A DES CONTROLES DE SAISIE FAITS AVANT!!!

	OPEN p_curv FOR
		SELECT DISTINCT pro.pid pid
		FROM 	proplus pro,
     	     	    	client_mo  clm
		WHERE pro.pcmouvra = clm.clicode
		--AND clm.clicode = p_clicode
		--F93
		AND clm.clicode in (
				select clicoderatt
				from vue_clicode_hierarchie vu
				where vu.clicode = p_clicode)
		AND pro.cdeb BETWEEN l_date_mini AND l_date_maxi

		UNION

		SELECT DISTINCT pro.factpid pid
		FROM 	proplus pro,
     			client_mo  clm
		WHERE pro.factpcm = clm.clicode
		--AND clm.clicode = p_clicode
		--F93
		AND clm.clicode in (
				select clicoderatt
				from vue_clicode_hierarchie vu
				where vu.clicode = p_clicode)
		AND pro.cdeb BETWEEN l_date_mini AND l_date_maxi
	;

  END IF;

  END ouvrir_budget_cv;

-- ------------------------------------------------------------------------
   -- Nom        :  ouvrir_budget_tout (Procédure)
   -- Auteur     :  MMC
   -- Decription :  Ouverture variable curseur de type BudgetCurTyp
   -- Paramètres :  p_curv     (IN/OUT)  	Curseur à ouvrir
   --               p_userid    (IN)    identifiant de l'utilisateur
   --
-- ------------------------------------------------------------------------
   PROCEDURE ouvrir_budget_tout(	p_curv     	IN OUT BudgetCurTyp,
					p_userid 	IN VARCHAR2
				    ) IS

	l_lst_chefs_projets VARCHAR2(255);

  BEGIN

	/*l_annee_traite := TO_CHAR(p_date_traite, 'YYYY');
	l_mois_maxi_traite  := TO_CHAR(p_date_traite, 'MM');
        l_derjour_mois_maxi_traite := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || l_mois_maxi_traite  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );
	l_date_mini := TO_DATE('01/01/' || l_annee_traite, 'DD/MM/YYYY');
	l_date_maxi := TO_DATE(l_derjour_mois_maxi_traite || '/' || l_mois_maxi_traite || '/' || l_annee_traite, 'DD/MM/YYYY');*/

	l_lst_chefs_projets := pack_global.lire_globaldata(p_userid).chefprojet;

	 /* -- tester si p_clidom est une direction ou un département
	  BEGIN
   		select 'dir' into l_dir
		from client_mo
		where clidom=p_clidom
		and clicode=p_clidom;
          EXCEPTION
		WHEN NO_DATA_FOUND THEN   --départment
		l_dir :='dpt';
          END;	*/

  	OPEN p_curv FOR
		SELECT DISTINCT l.pid pid
		from ligne_bip l, datdebex d
        	where INSTR(l_lst_chefs_projets ,TO_CHAR(l.pcpi, 'FM00000')) > 0
        	minus
        	select DISTINCT l.pid pid
        	from ligne_bip l, datdebex d
        	where INSTR(l_lst_chefs_projets ,TO_CHAR(l.pcpi, 'FM00000')) > 0
        	and ((topfer='O' and TRUNC(adatestatut,'YEAR')<TRUNC(d.datdebex,'YEAR')  )
        	or
        	(astatut  in ('A','D','C')
         	and TRUNC(adatestatut,'YEAR')<TRUNC(d.datdebex,'YEAR') )
        	)
	;

  END ouvrir_budget_tout;


   -- ------------------------------------------------------------------------
   -- Nom        :  ouvrir_conso_tout (Procédure)
   -- Auteur     :  MMC
   -- Decription :  Ouverture variable curseur de type ConsoCurTyp
   -- Paramètres :  p_curv    (IN/OUT) 	Curseur à ouvrir
   --               p_userid (IN)     	p_global
   -- ------------------------------------------------------------------------
 PROCEDURE ouvrir_conso_tout(		p_curv     	IN OUT ConsoCurTyp,
					p_userid 	IN VARCHAR2,
					p_date_traite 	IN DATE
				    ) IS

	l_annee_traite VARCHAR2(4);
	l_mois_maxi_traite VARCHAR2(2);
	l_derjour_mois_maxi_traite VARCHAR2(2);

	l_date_mini DATE;
	l_date_maxi DATE;

	l_lst_chefs_projets VARCHAR2(255);


 BEGIN

 /********************************************************************************
  * Seul le paramètre "p_date_traite" est pris en compte :
  * On conserve les autres paramètres pour le  cas où!!!
  ********************************************************************************/

	l_annee_traite := TO_CHAR(p_date_traite, 'YYYY');
	l_mois_maxi_traite  := TO_CHAR(p_date_traite, 'MM');
        l_derjour_mois_maxi_traite := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || l_mois_maxi_traite  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );

	l_date_mini := TO_DATE('01/01/' || l_annee_traite, 'DD/MM/YYYY');
	l_date_maxi := TO_DATE(l_derjour_mois_maxi_traite || '/' || l_mois_maxi_traite || '/' || l_annee_traite, 'DD/MM/YYYY');
	l_lst_chefs_projets := pack_global.lire_globaldata(p_userid).chefprojet;

OPEN p_curv FOR
SELECT
      csr.cdeb   cdeb,
      csr.pid   pid,
      csr.acta   acta,
      csr.acst  acst,
      csr.ecet  ecet,
      SUM(csr.cusag)    cusag
FROM
(
  ------------------------------------------------------------------------------------
  -- Cas 1 : Ressource avec bonne situation
  -- On teste prestation != 'GRA' !!!
  ------------------------------------------------------------------------------------
    SELECT
      csr1.cdeb   	cdeb,
      csr1.pid   		pid,
      csr1.acta   	acta,
      csr1.acst  		acst,
      csr1.ecet  		ecet,
      SUM(csr1.cusag)   cusag
    FROM  cons_sstache_res_mois csr1,
          situ_ress sir1
    WHERE
	sir1.ident = csr1.ident
      AND    TRUNC(sir1.datsitu,'MONTH')  <= TRUNC(csr1.cdeb,'MONTH')
      AND   ( (csr1.cdeb <= sir1.datdep) OR (sir1.datdep IS NULL) )
      AND   ( (sir1.prestation != 'GRA') OR (sir1.prestation IS NULL) )
      AND   (csr1.cdeb BETWEEN l_date_mini AND l_date_maxi )
      AND   csr1.ident != 0
      AND   csr1.cusag != 0
      -------------------------------------------------------------------
      -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
      --------------------------------------------------------------------
      AND  csr1.pid IN (SELECT DISTINCT l.pid
		from ligne_bip l, datdebex d
        	where INSTR(l_lst_chefs_projets ,TO_CHAR(l.pcpi, 'FM00000')) > 0
        	and ( (topfer='N' and adatestatut is null)
			or
			(TRUNC(adatestatut,'YEAR')=TRUNC(d.datdebex,'YEAR'))
        	))
     GROUP BY csr1.pid, csr1.cdeb, csr1.acta, csr1.acst, csr1.ecet
   -----------------------------------------------------------------------
   UNION ALL
   ------------------------------------------------------------------------
   ------------------------------------------------------------------------------------
   -- Cas 2 : Ressource avec mauvaise situation
   -- Correspond à tous les cas autres que Cas 1 :
   ------------------------------------------------------------------------------------
   SELECT
       csr2.cdeb   	cdeb,
       csr2.pid   	pid,
       csr2.acta   	acta,
       csr2.acst  	acst,
       csr2.ecet  	ecet,
       SUM(csr2.cusag)  cusag
    FROM  cons_sstache_res_mois csr2
    WHERE
     	NOT EXISTS 	(
        			SELECT 1 from situ_ress sir2
        			WHERE  sir2.ident = csr2.ident
        			AND   TRUNC(sir2.datsitu,'MONTH')  <= TRUNC(csr2.cdeb,'MONTH')
        			AND   ( (csr2.cdeb <= sir2.datdep) OR (sir2.datdep IS NULL) )
          		)
     	AND ( csr2.cdeb BETWEEN l_date_mini AND l_date_maxi )
     	AND csr2.ident != 0
	AND csr2.cusag != 0
     -------------------------------------------------------------------
     -- Ne prendre que les lignes concernant le Code ligne BIP Saisi
     -------------------------------------------------------------------
        AND csr2.pid IN (SELECT DISTINCT l.pid
		from ligne_bip l, datdebex d
        	where INSTR(l_lst_chefs_projets ,TO_CHAR(l.pcpi, 'FM00000')) > 0
        	and ( (topfer='N' and adatestatut is null)
			or
			(TRUNC(adatestatut,'YEAR')=TRUNC(d.datdebex,'YEAR'))
        	))
    GROUP BY csr2.pid, csr2.cdeb, csr2.acta, csr2.acst, csr2.ecet
) csr
GROUP BY csr.pid, csr.cdeb, csr.acta, csr.acst, csr.ecet
;

END ouvrir_conso_tout;

END  pack_prodec2;
/
CREATE OR REPLACE PACKAGE pack_prodec4 IS
-----------------------------------------


------------------------------------------------------------------------------
-- Constantes globales
------------------------------------------------------------------------------

CST_PREM_CAR_ID_APPLI CONSTANT CHAR(1) := 'A';		-- 1er caractère identifiant Application (AIRT)
CST_PREM_CAR_ID_PROJ CONSTANT CHAR(1) := 'P';		-- 1er caractère identifiant Projet (ICPI)

------------------------------------------------------------------------------
-- Les Procédures
------------------------------------------------------------------------------


   -- ------------------------------------------------------------------------
   -- Nom        : verif_prodec4
   -- Auteur     : Equipe SOPRA
   -- Decription : Vérification des champs saisies dans la page WEB pour PRODEC4
   -- Paramètres : p_id_proj_ou_appli (IN)   CHAR(5) Ident appli (Axxxx)  ou Projet (Pxxxx)
   --
   -- Retour     : p_message (OUT) 	  message d'erreur
   --
   -- ------------------------------------------------------------------------
PROCEDURE verif_prodec4(
		     	p_nom_etat   		IN  VARCHAR2,
                 	p_id_proj_ou_appli	IN  VARCHAR2,          -- CHAR(5)
			p_global 		IN  VARCHAR2,
                 	P_message 		OUT VARCHAR2
                 	);


END pack_prodec4;
/

CREATE OR REPLACE PACKAGE BODY pack_prodec4 IS
----------------------------------------------

--****************************************************************************
-- Les Procédures
--****************************************************************************


   -- ------------------------------------------------------------------------
   -- Nom        : verif_prodec4
   -- Auteur     : Equipe SOPRA
   -- Decription : Vérification des champs saisies dans la page WEB pour PRODEC4
   -- Paramètres : p_id_proj_ou_appli (IN)   CHAR(5) Ident appli (Axxxx)  ou Projet (Pxxxx)
   --
   -- Retour     : p_message (OUT) 	  message d'erreur
   --
   -- ------------------------------------------------------------------------
PROCEDURE verif_prodec4(
		     	p_nom_etat   		IN  VARCHAR2,
                 	p_id_proj_ou_appli 	IN  VARCHAR2,          -- CHAR(5)
		 	p_global 		IN  VARCHAR2,
                 	P_message 		OUT VARCHAR2
                 	) IS

      	l_message   			VARCHAR2(1024) := '';
      	l_num_exception 		NUMBER;
	l_nuexc_id_appli_inexistant 	CONSTANT NUMBER := 20733;
	l_nuexc_id_proj_inexistant 	CONSTANT NUMBER := 20735;
	l_clicode 			varchar2(10);
	l_bool 				boolean;
BEGIN


  	IF ( SUBSTR(p_id_proj_ou_appli, 1, 1) = CST_PREM_CAR_ID_APPLI ) THEN

		-- Vérifier que le clicode de l'application appartient au périmètre MO de l'utilisateur
		BEGIN
			select clicode into l_clicode
			from application
			where airt=p_id_proj_ou_appli;

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
			pack_global.recuperer_message(20733, NULL, NULL, ' P_param10 ', l_message);
                       	RAISE_APPLICATION_ERROR(-20733, l_message);

		END;

	ELSE
		-- Vérifier que le clicode du projet appartient au périmètre MO de l'utilisateur
		BEGIN
			select clicode into l_clicode
			from proj_info
			where icpi=p_id_proj_ou_appli;

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				pack_global.recuperer_message(20735, NULL, NULL, ' P_param10 ', l_message);
                        	RAISE_APPLICATION_ERROR(-20735, l_message);

		END;

	END IF;

      p_message := l_message;

END  verif_prodec4;

END  pack_prodec4;
/
CREATE OR REPLACE PACKAGE pack_proj_info AS

   TYPE proj_info_ViewType IS RECORD ( 	ICPI PROJ_INFO.ICPI%TYPE,
   					ILIBEL       PROJ_INFO.ILIBEL%TYPE,
					DESCR        PROJ_INFO.DESCR%TYPE,
					IMOP         PROJ_INFO.IMOP%TYPE,
					CLICODE      PROJ_INFO.CLICODE%TYPE,
					ICME         PROJ_INFO.ICME%TYPE,
					CODSG        PROJ_INFO.CODSG%TYPE,
					ICODPROJ     PROJ_INFO.ICODPROJ%TYPE,
					ICPIR        PROJ_INFO.ICPIR%TYPE,
					STATUT       PROJ_INFO.STATUT%TYPE,
					CADA         PROJ_INFO.CADA%TYPE,
					DATDEM       PROJ_INFO.DATDEM%TYPE,
					DATSTATUT    PROJ_INFO.DATSTATUT%TYPE,
					FLAGLOCK     PROJ_INFO.FLAGLOCK%TYPE,
					COD_DB       PROJ_INFO.COD_DB%TYPE,
					CLILIB       CLIENT_MO.CLILIB%TYPE,
					LIBDSG       STRUCT_INFO.LIBDSG%TYPE,
					DATCRE       PROJ_INFO.DATCRE%TYPE,
					LIBRPB       PROJ_INFO.LIBRPB%TYPE,
					IDRPB        PROJ_INFO.IDRPB%TYPE,
					DATPROD      PROJ_INFO.DATPROD%TYPE,
					DATRPRO      PROJ_INFO.DATRPRO%TYPE,
					CRIREG       PROJ_INFO.CRIREG%TYPE,
					DEANRE       PROJ_INFO.DEANRE%TYPE,
					LIBCADA      CENTRE_ACTIVITE.CLIBCA%TYPE
				     );


   TYPE proj_infoCurType IS REF CURSOR RETURN proj_info_ViewType;

   PROCEDURE insert_proj_info (p_icpi      	IN  proj_info.icpi%TYPE,
                               p_ilibel    	IN  proj_info.ilibel%TYPE,
                               p_descr   	IN  proj_info.descr%TYPE,
                               p_clicode   	IN  proj_info.clicode%TYPE,
                               p_imop      	IN  proj_info.imop%TYPE,
                               p_codsg     	IN  VARCHAR2,
                               p_icme      	IN  proj_info.icme%TYPE,
                               p_icodproj  	IN  VARCHAR2,
		               p_icpir     	IN  proj_info.icpir%TYPE,
		               p_statut	   	IN  proj_info.statut%TYPE,
		               p_datestatut 	IN  VARCHAR2,
		               p_cada		IN  VARCHAR2,
		               p_datedemar	IN  VARCHAR2,
		               p_cod_db		IN  VARCHAR2,
                               p_userid    	IN  VARCHAR2,
		   	       p_librpb    	IN  VARCHAR2,
		   	       p_idrpb     	IN  VARCHAR2,
		   	       p_datprod   	IN  VARCHAR2,
		   	       p_datrpro   	IN  VARCHAR2,
		   	       p_crireg    	IN  VARCHAR2,
		   	       p_deanre    	IN  VARCHAR2,
		   	       p_datcre    	IN  VARCHAR2,
                               p_nbcurseur 	OUT INTEGER,
                               p_message   	OUT VARCHAR2
                              );

   PROCEDURE update_proj_info (p_icpi       IN  proj_info.icpi%TYPE,
                               p_ilibel     IN  proj_info.ilibel%TYPE,
                               p_descr      IN  proj_info.descr%TYPE,
                               p_clicode    IN  proj_info.clicode%TYPE,
                               p_imop       IN  proj_info.imop%TYPE,
                               p_codsg      IN  VARCHAR2,
                               p_icme       IN  proj_info.icme%TYPE,
                               p_icodproj   IN  VARCHAR2,
                               p_icpir      IN  proj_info.icpir%TYPE,
		               p_statut	    IN  proj_info.statut%TYPE,
		               p_datestatut IN  VARCHAR2,
		               p_cada	    IN  VARCHAR2,
		               p_datedemar  IN  VARCHAR2,
		               p_cod_db	    IN  VARCHAR2,
                               p_flaglock   IN  NUMBER,
                               p_userid     IN  VARCHAR2,
		   	       p_librpb     IN VARCHAR2,
		   	       p_idrpb      IN VARCHAR2,
		   	       p_datprod    IN VARCHAR2,
		   	       p_datrpro    IN VARCHAR2,
		   	       p_crireg     IN VARCHAR2,
		   	       p_deanre     IN VARCHAR2,
                               p_nbcurseur  OUT INTEGER,
                               p_message    OUT VARCHAR2
                              );

   PROCEDURE delete_proj_info (p_icpi      IN  proj_info.icpi%TYPE,
                               p_flaglock  IN  NUMBER,
                               p_userid    IN  VARCHAR2,
                               p_nbcurseur OUT INTEGER,
                               p_message   OUT VARCHAR2
                              );

   PROCEDURE select_proj_info (p_icpi         IN proj_info.icpi%TYPE,
                               p_userid       IN VARCHAR2,
                               p_curproj_info IN OUT proj_infoCurType,
                               p_nbcurseur       OUT INTEGER,
                               p_message         OUT VARCHAR2
                              );

  PROCEDURE update_dom_bancaire(p_icodproj      	IN VARCHAR2,
  			      p_cod_db		IN VARCHAR2,
  			      p_userid		IN VARCHAR2,
  			      p_message         OUT VARCHAR2
  			     );

END pack_proj_info;
/

CREATE OR REPLACE PACKAGE BODY pack_proj_info AS

    PROCEDURE insert_proj_info (p_icpi      	IN  proj_info.icpi%TYPE,
                                p_ilibel    	IN  proj_info.ilibel%TYPE,
                                p_descr   	IN  proj_info.descr%TYPE,
                                p_clicode   	IN  proj_info.clicode%TYPE,
                                p_imop      	IN  proj_info.imop%TYPE,
                                p_codsg     	IN  VARCHAR2,
                                p_icme      	IN  proj_info.icme%TYPE,
                                p_icodproj  	IN  VARCHAR2,
                                p_icpir     	IN  proj_info.icpir%TYPE,
		                p_statut	IN  proj_info.statut%TYPE,
		                p_datestatut 	IN  VARCHAR2,
		                p_cada		IN  VARCHAR2,
		                p_datedemar 	IN  VARCHAR2,
		                p_cod_db	IN  VARCHAR2,
                                p_userid    	IN  VARCHAR2,
 				p_librpb       	IN  VARCHAR2,
 				p_idrpb        	IN  VARCHAR2,
 				p_datprod      	IN  VARCHAR2,
 				p_datrpro      	IN  VARCHAR2,
 				p_crireg       	IN  VARCHAR2,
 				p_deanre       	IN  VARCHAR2,
 				p_datcre       	IN  VARCHAR2,
                                p_nbcurseur 	OUT INTEGER,
                                p_message   	OUT VARCHAR2
                               ) IS

      l_msg VARCHAR2(1024);
      l_dpcode dossier_projet.dpcode%TYPE;
      l_cada centre_activite.codcamo%TYPE;
      l_dateStatut VARCHAR2(10);
      l_icpir proj_info.icpir%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


	-- Test de la presence de p_icodproj dans la table DOSSIER_PROJET

      IF (NOT(p_icodproj IS NULL)) THEN
        BEGIN
            SELECT dpcode
            INTO l_dpcode
            FROM dossier_projet
            WHERE dpcode = TO_NUMBER(p_icodproj);

        EXCEPTION

             WHEN NO_DATA_FOUND THEN
                pack_global.recuperer_message(20211, NULL, NULL, 'ICODPROJ', l_msg);
                raise_application_error(-20211, l_msg);

             WHEN OTHERS THEN
                raise_application_error( -20997, SQLERRM);
        END;
      END IF;


      -- Si le centre d'activité est inexistant
      -- On revoi une erreur
      BEGIN
      	SELECT codcamo into l_cada
      	FROM CENTRE_ACTIVITE
      	WHERE codcamo=TO_NUMBER(p_cada);
      EXCEPTION
      	WHEN NO_DATA_FOUND THEN
      		pack_global.recuperer_message( 20511, NULL, NULL, 'cada', l_msg);
   		raise_application_error( -20511, l_msg);
      	WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
      END;

      -- Test pour initialiser la date de prise en compte du statut si celui ci est renseigné
      IF ((p_statut=' '))
	THEN  l_dateStatut := '';
      ELSE  l_dateStatut := to_char(SYSDATE,'DD/MM/YYYY');
      END IF;

      -- Initialisation de ICPIR s'il est non renseigné.
          IF (p_icpir is null)
      	  THEN  l_icpir := p_icpi;
          ELSE  l_icpir := p_icpir;
      END IF;

      -- INSERT
      BEGIN

         INSERT INTO proj_info (icodproj,
                                descr,
                                icpi,
                                ilibel,
                                imop,
                                icme,
                                clicode,
                                codsg,
                                icpir,
                                statut,
                                datstatut,
                                cada,
                                datdem,
                                cod_db
				,librpb
				,idrpb
				,datprod
				,datrpro
				,crireg
				,deanre
				,datcre
                               )
         VALUES (NVL(TO_NUMBER(p_icodproj),0),
                 p_descr,
                 p_icpi,
                 p_ilibel,
                 p_imop,
                 p_icme,
                 p_clicode,
                 TO_NUMBER(p_codsg),
                 l_icpir,
                 p_statut,
                 TO_DATE(l_dateStatut,'DD/MM/YYYY'),
                 TO_NUMBER(p_cada),
                 TO_DATE(p_datedemar, 'FMMM/YYYY'),
                 TO_NUMBER(p_cod_db)
		,p_librpb
		,p_idrpb
		,TO_DATE( p_datprod, 'MM/YYYY')
		,TO_DATE( p_datrpro, 'MM/YYYY')
		,p_crireg
		,TO_DATE( p_deanre, 'YYYY')
	    	,SYSDATE
                );

         -- 'Le proj_info ' || p_ipi || ' a été créé.';
         pack_global.recuperer_message(2032,'%s1',p_icpi, NULL, l_msg);
	 p_message := l_msg;
	      EXCEPTION

            WHEN DUP_VAL_ON_INDEX THEN
               pack_global.recuperer_message(20212, NULL, NULL, NULL, l_msg);
               raise_application_error( -20212, l_msg );

            WHEN referential_integrity THEN

               -- habiller le msg erreur

               pack_global.recuperation_integrite(-2291);



            WHEN OTHERS THEN

                raise_application_error( -20997, SQLERRM);

      END;

   END insert_proj_info;


    PROCEDURE update_proj_info (p_icpi      	IN  proj_info.icpi%TYPE,
                                p_ilibel    	IN  proj_info.ilibel%TYPE,
                                p_descr   	IN  proj_info.descr%TYPE,
                                p_clicode   	IN  proj_info.clicode%TYPE,
                                p_imop      	IN  proj_info.imop%TYPE,
                                p_codsg     	IN  VARCHAR2,
                                p_icme      	IN  proj_info.icme%TYPE,
                                p_icodproj  	IN  VARCHAR2,
				p_icpir     	IN  proj_info.icpir%TYPE,
		               	p_statut	IN  proj_info.statut%TYPE,
		               	p_datestatut 	IN  VARCHAR2,
		               	p_cada		IN  VARCHAR2,
		               	p_datedemar	IN  VARCHAR2,
		               	p_cod_db	IN  VARCHAR2,
                                p_flaglock  	IN  NUMBER,
                                p_userid    	IN  VARCHAR2,
		   		p_librpb    	IN  VARCHAR2,
		   		p_idrpb     	IN  VARCHAR2,
		   		p_datprod   	IN  VARCHAR2,
		   		p_datrpro   	IN  VARCHAR2,
		   		p_crireg    	IN  VARCHAR2,
		   		p_deanre    	IN  VARCHAR2,
                                p_nbcurseur 	OUT INTEGER,
                                p_message   	OUT VARCHAR2
                              ) IS

      l_msg VARCHAR2(1024);
      l_dpcode dossier_projet.dpcode%TYPE;
      l_cada centre_activite.codcamo%TYPE;
      l_idarpege audit_statut.demandeur%TYPE;
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

      l_old_statut proj_info.statut%TYPE;

      l_user		ligne_bip_logs.user_log%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      l_idarpege := SUBSTR(pack_global.lire_globaldata(p_userid).idarpege, 1, 15);

      l_user := SUBSTR(pack_global.lire_globaldata(p_userid).idarpege, 1, 30);

	-- Les test ne respectent pas les regles du chap. 2.4.5 de la doc.
 	-- ref.: id9847ac-605731 Car les verifs devraient etre sur la table proj_info et non
 	-- client_mo, struct_info et dossier_proj.

	-- Test de la presence de p_icodproj dans la table DOSSIER_PROJET

	IF (NOT(p_icodproj IS NULL)) THEN
         BEGIN
            SELECT dpcode
            INTO   l_dpcode
            FROM   dossier_projet
            WHERE  dpcode = p_icodproj;

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
                pack_global.recuperer_message(20211, NULL, NULL, 'ICODPROJ', l_msg);
                raise_application_error( -20211, l_msg);

             WHEN OTHERS THEN
                raise_application_error( -20997, SQLERRM);
         END;
      END IF;

      -- Test sur les changements de statuts
      -- Mises à jour sur les stauts des lignes BIP liées.
      SELECT statut INTO l_old_statut
      FROM proj_info
      WHERE icpi = p_icpi AND flaglock = p_flaglock;

      -- Si le statut ancien est Vide et que le nouveau est A ou D ou R ou Q
      -- On renvoie un message d'erreur
      If (l_old_statut IS NULL) AND ((p_statut='A') OR (p_statut='D') OR (p_statut='R') OR (p_statut='Q')) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_old_statut,''), '%s2', NVL(p_statut,''), 'STATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est D et que le nouveau est A ou R ou Vide
      -- On renvoie un message d'erreur
      If (l_old_statut='D') AND ((p_statut='A') OR (p_statut='R') OR (p_statut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_old_statut,''), '%s2', NVL(p_statut,''), 'STATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est Q (Démarré sans immo) et que le nouveau est R (Abandonné sans immo) ou A ou Vide
      -- On renvoie un message d'erreur
      If (l_old_statut='Q') AND ((p_statut='R') OR (p_statut='A') OR (p_statut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_old_statut,''), '%s2', NVL(p_statut,''), 'STATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est A et que le nouveau est D ou Q ou Vide
      -- On renvoie un message d'erreur
      If (l_old_statut='A') AND ((p_statut='D') OR (p_statut='Q') OR (p_statut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_old_statut,''), '%s2', NVL(p_statut,''), 'STATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est R (Abandonné sans immo) et que le nouveau est Q (Démarré sans immo) ou D ou Vide
      -- On renvoie un message d'erreur
      If (l_old_statut='R') AND ((p_statut='Q') OR (p_statut='D') OR (p_statut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_old_statut,''), '%s2', NVL(p_statut,''), 'STATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est N (Non amortissable) et que le nouveau est D (Démarré) ou A (Abandonné) ou Vide
      -- On renvoie un message d'erreur
      If (l_old_statut='N') AND ((p_statut='D') OR (p_statut='A') OR (p_statut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_old_statut,''), '%s2', NVL(p_statut,''), 'STATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

--curseur qui ramene les lignes bip rattachees au projet ayant un statut = 'O'
      DECLARE
      CURSOR C_PID IS
      	SELECT pid FROM ligne_bip
      	WHERE astatut = 'O'
      	AND icpi=p_icpi;
      BEGIN
      -- Si le statut ancien est O et que le nouveau est D
      -- On passe toute les lignes du projet en statut O au statut D
      If (l_old_statut='O') AND (p_statut='D') THEN

	   -- On loggue le changement de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Statut', astatut, 'D', 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE astatut = 'O' AND icpi=p_icpi
           );

	   -- On loggue la nouvelle date de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Date statut', TO_CHAR(adatestatut, 'MM/YYYY'), p_datedemar, 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE astatut = 'O' AND icpi=p_icpi
           );


      		--on met à jour les donnees d'audit
      		FOR ONE_PID IN C_PID LOOP
          	BEGIN
        		UPDATE audit_statut a
				SET 	a.pid = ONE_PID.pid,
					a.date_demande = sysdate,
					a.demandeur=l_idarpege,
					a.commentaire='Projet ' || p_icpi || ' démarré'
				WHERE a.pid = ONE_PID.pid;

			IF SQL%NOTFOUND THEN
					--la ligne n'existe pas, on l'insère dans la table
					INSERT INTO audit_statut (pid,date_demande,demandeur,commentaire)
					VALUES (ONE_PID.pid,SYSDATE,l_idarpege,'Projet ' || p_icpi || ' démarré');
			END IF;
		END;
		COMMIT;
		END LOOP;

	-- mise à jour des lignes bip rattachees au projet
         	BEGIN
           	UPDATE ligne_bip
           	SET 	astatut = 'D',
           		adatestatut = TO_DATE(p_datedemar, 'FMMM/YYYY')
           	WHERE astatut = 'O'
             	AND icpi = p_icpi;
         	EXCEPTION
           	WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
         	END;

      END IF;



      -- Si le statut ancien est O et que le nouveau est A
      -- On passe toutes les lignes du projet en statut O au statut A
      If (l_old_statut='O') AND (p_statut='A') THEN

      	--on met à jour les donnees d'audit
      		FOR ONE_PID IN C_PID LOOP
          	BEGIN
        		UPDATE audit_statut a
				SET 	a.pid = ONE_PID.pid,
					a.date_demande = sysdate,
					a.demandeur=l_idarpege,
					a.commentaire='Projet ' || p_icpi || ' abandonné'
				WHERE a.pid = ONE_PID.pid;

			IF SQL%NOTFOUND THEN
					--la ligne n'existe pas, on l'insère dans la table
					INSERT INTO audit_statut (pid,date_demande,demandeur,commentaire)
					VALUES (ONE_PID.pid,SYSDATE,l_idarpege,'Projet ' || p_icpi || ' abandonné');
			END IF;
		END;
		COMMIT;
		END LOOP;

      	--mise a jour des lignes bip rattachees au projet
         BEGIN

	   -- On loggue le changement de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Statut', astatut, 'A', 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE astatut = 'O' AND icpi=p_icpi
           );

	   -- On loggue la nouvelle date de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Date statut', TO_CHAR(adatestatut, 'MM/YYYY'), p_datedemar, 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE astatut = 'O' AND icpi=p_icpi
           );

           UPDATE ligne_bip
           SET 	astatut = 'A',
           	adatestatut = TO_DATE(p_datedemar, 'FMMM/YYYY')
           WHERE astatut = 'O'
             AND icpi = p_icpi;
         EXCEPTION
           WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
         END;
      END IF;
      END; -- END CURSOR 'O'





--curseur qui ramene les lignes bip rattachees au projet ayant un statut = 'N'
      DECLARE
      CURSOR C_PID IS
      	SELECT pid FROM ligne_bip
      	WHERE icpi=p_icpi;
      BEGIN
      -- Si le statut ancien est N et que le nouveau est Q (Démarré sans amortissement)
      If (l_old_statut='N') AND (p_statut='Q') THEN

	   -- On loggue le changement de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Statut', astatut, 'Q', 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE icpi=p_icpi
           );

	   -- On loggue la nouvelle date de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Date statut', TO_CHAR(adatestatut, 'MM/YYYY'), p_datedemar, 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE icpi=p_icpi
           );


      		--on met à jour les donnees d'audit
      		FOR ONE_PID IN C_PID LOOP
          	BEGIN
        		UPDATE audit_statut a
				SET 	a.pid = ONE_PID.pid,
					a.date_demande = sysdate,
					a.demandeur=l_idarpege,
					a.commentaire='Projet ' || p_icpi || ' Démarré sans immo'
				WHERE a.pid = ONE_PID.pid;

			IF SQL%NOTFOUND THEN
					--la ligne n'existe pas, on l'insère dans la table
					INSERT INTO audit_statut (pid,date_demande,demandeur,commentaire)
					VALUES (ONE_PID.pid,SYSDATE,l_idarpege,'Projet ' || p_icpi || ' démarré');
			END IF;
		END;
		COMMIT;
		END LOOP;

	-- mise à jour des lignes bip rattachees au projet
         	BEGIN
           	UPDATE ligne_bip
           	SET   adatestatut = TO_DATE(p_datedemar, 'FMMM/YYYY'),
           		topfer = 'O'
           	WHERE icpi = p_icpi;
         	EXCEPTION
           	WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
         	END;

      END IF;



      -- Si le statut ancien est N et que le nouveau est R
      If (l_old_statut='N') AND (p_statut='R') THEN

      	--on met à jour les donnees d'audit
      		FOR ONE_PID IN C_PID LOOP
          	BEGIN
        		UPDATE audit_statut a
				SET 	a.pid = ONE_PID.pid,
					a.date_demande = sysdate,
					a.demandeur=l_idarpege,
					a.commentaire='Projet ' || p_icpi || ' abandonné sans immo'
				WHERE a.pid = ONE_PID.pid;

			IF SQL%NOTFOUND THEN
					--la ligne n'existe pas, on l'insère dans la table
					INSERT INTO audit_statut (pid,date_demande,demandeur,commentaire)
					VALUES (ONE_PID.pid,SYSDATE,l_idarpege,'Projet ' || p_icpi || ' abandonné sans immo');
			END IF;
		END;
		COMMIT;
		END LOOP;

      	--mise a jour des lignes bip rattachees au projet
         BEGIN

	   -- On loggue le changement de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Statut', astatut, 'R', 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE icpi=p_icpi
           );

	   -- On loggue la nouvelle date de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Date statut', TO_CHAR(adatestatut, 'MM/YYYY'), p_datedemar, 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE icpi=p_icpi
           );

           UPDATE ligne_bip
           SET 	adatestatut = TO_DATE(p_datedemar, 'FMMM/YYYY'),
           	topfer = 'O'
           WHERE icpi = p_icpi;

           UPDATE ligne_bip
           SET 	astatut = 'R'
           WHERE icpi = p_icpi
           AND (typproj ='1 ' OR typproj ='2 ');
         EXCEPTION
           WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
         END;
      END IF;


   -- Si le statut ancien est Q et que le nouveau est N
      If (l_old_statut='Q') AND (p_statut='N') THEN

	   -- On loggue le changement de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Statut', astatut, 'N', 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE icpi=p_icpi
           );

	   -- On loggue la nouvelle date de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Date statut', TO_CHAR(adatestatut, 'MM/YYYY'), null, 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE icpi=p_icpi
           );


      		--on met à jour les donnees d'audit
      		FOR ONE_PID IN C_PID LOOP
          	BEGIN
        		UPDATE audit_statut a
				SET 	a.pid = ONE_PID.pid,
					a.date_demande = sysdate,
					a.demandeur=l_idarpege,
					a.commentaire='Projet ' || p_icpi || ' démarré sans immo'
				WHERE a.pid = ONE_PID.pid;

			IF SQL%NOTFOUND THEN
					--la ligne n'existe pas, on l'insère dans la table
					INSERT INTO audit_statut (pid,date_demande,demandeur,commentaire)
					VALUES (ONE_PID.pid,SYSDATE,l_idarpege,'Projet ' || p_icpi || ' démarré');
			END IF;
		END;
		COMMIT;
		END LOOP;

	-- mise à jour des lignes bip rattachees au projet
         	BEGIN
           	UPDATE ligne_bip
           	SET   adatestatut = null
           	WHERE icpi = p_icpi;
         	EXCEPTION
           	WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
         	END;

      END IF;

 -- Si le statut ancien est R et que le nouveau est N
      If (l_old_statut='R') AND (p_statut='N') THEN

      	--on met à jour les donnees d'audit
      		FOR ONE_PID IN C_PID LOOP
          	BEGIN
        		UPDATE audit_statut a
				SET 	a.pid = ONE_PID.pid,
					a.date_demande = sysdate,
					a.demandeur=l_idarpege,
					a.commentaire='Projet ' || p_icpi || ' abandonné sans immo'
				WHERE a.pid = ONE_PID.pid;

			IF SQL%NOTFOUND THEN
					--la ligne n'existe pas, on l'insère dans la table
					INSERT INTO audit_statut (pid,date_demande,demandeur,commentaire)
					VALUES (ONE_PID.pid,SYSDATE,l_idarpege,'Projet ' || p_icpi || ' abandonné sans immo');
			END IF;
		END;
		COMMIT;
		END LOOP;

      	--mise a jour des lignes bip rattachees au projet
         BEGIN

	   -- On loggue le changement de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Statut', astatut, 'N', 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE icpi=p_icpi
           );

	   -- On loggue la nouvelle date de statut
           INSERT INTO ligne_bip_logs (pid, date_log, user_log, colonne, valeur_prec, valeur_nouv, commentaire)
           (SELECT pid, SYSDATE, l_user, 'Date statut', TO_CHAR(adatestatut, 'MM/YYYY'), null, 'MAJ du statut du projet'
            FROM ligne_bip
            WHERE icpi=p_icpi
           );

           UPDATE ligne_bip
           SET 	adatestatut = null
           WHERE icpi = p_icpi;

         EXCEPTION
           WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
         END;
      END IF;




      END; -- END CURSOR 'N'





      -- Si le centre d'activité est inexistant
      -- On revoi une erreur
      BEGIN
      	SELECT codcamo into l_cada
      	FROM CENTRE_ACTIVITE
      	WHERE codcamo=TO_NUMBER(p_cada);
      EXCEPTION
      	WHEN NO_DATA_FOUND THEN
      		pack_global.recuperer_message( 20511, NULL, NULL, 'cada', l_msg);
   		raise_application_error( -20511, l_msg);
      	WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
      END;

      BEGIN
         UPDATE proj_info SET icpi 	 = p_icpi,
                              descr    	 = p_descr,
                              icodproj 	 = NVL(TO_NUMBER(p_icodproj),0),
                              ilibel   	 = p_ilibel,
                              imop 	 = p_imop,
                              icme 	 = p_icme,
                              clicode	 = p_clicode,
                              codsg    	 = TO_NUMBER(p_codsg),
                              icpir    	 = p_icpir,
                 	      statut   	 = p_statut,
                 	      datstatut  = DECODE(statut, p_statut, datstatut, SYSDATE),
                 	      cada  	 = TO_NUMBER(p_cada),
                 	      datdem 	 = TO_DATE(p_datedemar, 'FMMM/YYYY'),
                 	      cod_db 	 = TO_NUMBER(p_cod_db),
                              flaglock 	 = decode( p_flaglock, 1000000, 0, p_flaglock + 1),
			      librpb     = p_librpb,
		 	      idrpb  	 = p_idrpb,
		 	      datprod  	 = TO_DATE( p_datprod, 'MM/YYYY'),
			      datrpro    = TO_DATE( p_datrpro, 'MM/YYYY'),
			      crireg   	 = p_crireg,
			      deanre   	 = TO_DATE( p_deanre, 'YYYY')
         WHERE icpi = p_icpi
           AND flaglock = p_flaglock;

      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2291);



         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);

      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2033, '%s1', p_icpi, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END update_proj_info;


   PROCEDURE delete_proj_info (p_icpi      IN  proj_info.icpi%TYPE,
                               p_flaglock  IN  NUMBER,
                               p_userid    IN  VARCHAR2,
                               p_nbcurseur OUT INTEGER,
                               p_message   OUT VARCHAR2
                              ) IS

      l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      BEGIN
          DELETE FROM proj_info
                 WHERE icpi = p_icpi
               AND flaglock = p_flaglock;

      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2034, '%s1', p_icpi, NULL, l_msg);
          --raise_application_error( -20000, 'le message est ' || l_msg );
         --raise_application_error( -20000, 'le message est ' || p_message );
         p_message := l_msg;
      END IF;
   END delete_proj_info;


   PROCEDURE select_proj_info (p_icpi         IN proj_info.icpi%TYPE,
                               p_userid       IN VARCHAR2,
                               p_curproj_info IN OUT proj_infoCurType,
                               p_nbcurseur       OUT INTEGER,
                               p_message         OUT VARCHAR2
                              ) IS

       l_msg VARCHAR2(1024);
       l_icpi proj_info.icpi%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

	-- Test pour savoir si le premier caractere de icpi est un 'P'
-- Olivier Duprey 15/06/2001 : on ajoute 'I' pour ITEC (fiche 240)

	l_icpi := SUBSTR(p_icpi, 0, 1);
	IF ((l_icpi != 'P') AND (l_icpi != 'I')) THEN
         pack_global.recuperer_message(20208, NULL, NULL, NULL, l_msg);
         raise_application_error( -20208, l_msg );
	END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curproj_info FOR
              SELECT
			  		pi.ICPI,
					pi.ILIBEL,
					pi.DESCR,
					pi.IMOP,
					pi.CLICODE,
					pi.ICME,
					pi.CODSG,
					pi.ICODPROJ,
					pi.ICPIR,
					pi.STATUT,
					pi.CADA,
					pi.DATDEM,
					pi.DATSTATUT,
					pi.FLAGLOCK,
					pi.COD_DB,
					cm.CLILIB,
					si.LIBDSG,
					TO_CHAR( pi.DATCRE ,  'DD/MM/YYYY') AS DATCRE,
					pi.LIBRPB,
					pi.IDRPB,
					TO_CHAR( pi.DATPROD , 'MM/YYYY') AS DATPROD,
					TO_CHAR( pi.DATRPRO , 'MM/YYYY') AS DATRPRO,
					pi.CRIREG,
					TO_CHAR( pi.DEANRE ,  'YYYY') AS DEANRE,
					ca.CLIBCA
              FROM PROJ_INFO       pi,
			  	   CLIENT_MO       cm,
				   STRUCT_INFO     si,
				   CENTRE_ACTIVITE ca
              WHERE icpi = p_icpi
			    AND pi.codsg=si.codsg(+)
				AND pi.clicode=cm.clicode(+)
				AND pi.cada=ca.CODCAMO(+);

     EXCEPTION

        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
     END;

      -- en cas absence
      -- 'Le centre d'activité n'existe pas';

      pack_global.recuperer_message(2035, '%s1', p_icpi, NULL, l_msg);
      p_message := l_msg;

   END select_proj_info;

  PROCEDURE update_dom_bancaire(p_icodproj      	IN VARCHAR2,
  			      p_cod_db		IN VARCHAR2,
  			      p_userid		IN VARCHAR2,
  			      p_message     OUT VARCHAR2
  			     ) IS
  BEGIN

  	UPDATE proj_info SET cod_db = TO_NUMBER(p_cod_db)
  	WHERE  icodproj = TO_NUMBER(p_icodproj);

  	pack_global.recuperer_message(20383, '%s1', 'des projets', NULL, p_message);

  EXCEPTION
        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
  END update_dom_bancaire;

END pack_proj_info;
/
CREATE OR REPLACE PACKAGE pack_proj_spe AS

   TYPE proj_speCurType IS REF CURSOR RETURN proj_spe%ROWTYPE;

   PROCEDURE insert_proj_spe (p_codpspe   IN proj_spe.codpspe%TYPE,
                              p_libpspe   IN proj_spe.libpspe%TYPE,
                              p_global    IN VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );

   PROCEDURE update_proj_spe (p_codpspe   IN  proj_spe.codpspe%TYPE,
                              p_libpspe   IN  proj_spe.libpspe%TYPE,
                              p_flaglock  IN  NUMBER,
                              p_global    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );

   PROCEDURE delete_proj_spe (p_codpspe   IN  proj_spe.codpspe%TYPE,
                              p_libpspe   IN  proj_spe.libpspe%TYPE,
                              p_flaglock  IN  NUMBER,
                              p_global    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
	   		           );

   PROCEDURE select_proj_spe (p_codpspe   IN proj_spe.codpspe%TYPE ,
                              p_global    IN VARCHAR2,
                              p_cursor    IN OUT proj_speCurType,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );

END pack_proj_spe;
/

CREATE OR REPLACE PACKAGE BODY pack_proj_spe AS

   PROCEDURE insert_proj_spe (p_codpspe   IN  proj_spe.codpspe%TYPE ,
                              p_libpspe   IN  proj_spe.libpspe%TYPE ,
                              p_global    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


      BEGIN
         INSERT INTO proj_spe ( codpspe,
                                libpspe)
         VALUES ( p_codpspe,
                  p_libpspe);

         -- 'Projet spécial ' || p_libpspe|| ' créé'

         pack_global.recuperer_message( 6005, '%s1', p_libpspe, NULL, msg);
         p_message := msg;

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN

	      -- 'Projet spécial existe déjà'

            pack_global.recuperer_message( 20609, NULL, NULL, NULL, msg);
            raise_application_error( -20609, msg );

         WHEN OTHERS THEN
            raise_application_error(-20997,SQLERRM);
      END;

   END insert_proj_spe;


   PROCEDURE update_proj_spe (p_codpspe   IN  proj_spe.codpspe%TYPE ,
                              p_libpspe   IN  proj_spe.libpspe%TYPE ,
                              p_flaglock  IN  NUMBER,
                              p_global    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         UPDATE proj_spe
         SET codpspe  = p_codpspe,
             libpspe  = p_libpspe,
             flaglock = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE codpspe  = p_codpspe
         AND   flaglock = p_flaglock;

      EXCEPTION
	WHEN OTHERS THEN
          raise_application_error( -20999,msg);
      END;

      IF SQL%NOTFOUND THEN

         -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, msg);
         raise_application_error( -20999, msg );

      ELSE

         -- 'Projet spécial '|| p_libpspe||' modifié'

         pack_global.recuperer_message( 6006, '%s1', p_libpspe, NULL, msg);
         p_message := msg;
      END IF;

   END update_proj_spe;


   PROCEDURE delete_proj_spe (p_codpspe   IN  proj_spe.codpspe%TYPE ,
                              p_libpspe   IN  proj_spe.libpspe%TYPE ,
                              p_flaglock  IN  NUMBER,
                              p_global    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS
      msg VARCHAR(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM proj_spe
         WHERE codpspe = p_codpspe
         AND  flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error( -20999,msg);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message(20999,NULL,NULL,NULL,msg);
         raise_application_error( -20999, msg );

      ELSE

         -- 'Projet spécial '|| p_libpspe||' supprimé'

         pack_global.recuperer_message( 6007, '%s1', p_libpspe, NULL, msg);
	   p_message := msg;
      END IF;

   END delete_proj_spe;


   PROCEDURE select_proj_spe (p_codpspe   IN proj_spe.codpspe%TYPE ,
                              p_global    IN VARCHAR2,
                              p_cursor    IN OUT proj_speCurType,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      OPEN p_cursor FOR
           SELECT *
           FROM proj_spe
           WHERE codpspe = p_codpspe;

      -- en cas absence
      -- 'Projet spécial inexistant';

      pack_global.recuperer_message( 6008, '%s1', p_codpspe, NULL, msg);
      p_message := msg;

   END select_proj_spe;

END pack_proj_spe;
/
CREATE OR REPLACE PACKAGE pack_proposes AS

   TYPE proposes_RecType IS RECORD (bpannee  	VARCHAR2(20),
                                    bpmontme  	VARCHAR2(20),
                                    bpmontmo  	VARCHAR2(20),
                                    flaglock 	VARCHAR2(20),
                                    pid      	budget.pid%TYPE
                                   );

   TYPE proposesCurType IS REF CURSOR RETURN proposes_RecType;


   PROCEDURE insert_proposes (p_pid    		IN  ligne_bip.pid%TYPE,
                              p_pnom  		IN  ligne_bip.pnom%TYPE,
                              p_bpannee   	IN  VARCHAR2,
                              p_bpmontme   	IN  VARCHAR2,
                              p_bpmontmo   	IN  VARCHAR2,
                              p_userid    	IN  VARCHAR2,
                              p_nbcurseur 	OUT INTEGER,
                              p_message   	OUT VARCHAR2
                             );

   PROCEDURE update_proposes (p_pid       IN  ligne_bip.pid%TYPE,
                              p_pnom      IN  ligne_bip.pnom%TYPE,
                              p_bpannee   IN  VARCHAR2,
                              p_bpmontme  IN  VARCHAR2,
                              p_bpmontmo  IN  VARCHAR2,
                              p_flaglock  IN  NUMBER,
                              p_userid    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );



   PROCEDURE select_proposes (p_pid       IN budget.pid%TYPE,
                              p_bpannee   IN VARCHAR2,
                              p_userid    IN VARCHAR2,
                              p_pnom      OUT VARCHAR2,
                              p_mode      OUT VARCHAR2,
                              p_bpmontme  OUT VARCHAR2,
                              p_bpmontmo  OUT VARCHAR2,
                              p_perime	  OUT VARCHAR2,
                              p_perimo	  OUT VARCHAR2,
                              p_flaglock  OUT VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );
END pack_proposes;
/

CREATE OR REPLACE PACKAGE BODY pack_proposes AS


-- ****************************************************************************
--           INSERT_PROPOSES
-- ****************************************************************************
   PROCEDURE insert_proposes (p_pid       IN  ligne_bip.pid%TYPE,
                              p_pnom      IN  ligne_bip.pnom%TYPE,
                              p_bpannee   IN  VARCHAR2,
                              p_bpmontme  IN  VARCHAR2,
                              p_bpmontmo  IN  VARCHAR2,
                              p_userid    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS

   l_msg    VARCHAR2(1024);
   l_bpdate DATE;



   referential_integrity EXCEPTION;
   PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- Recupere la date courante

      -- SELECT SYSDATE
      -- INTO   l_bpdate
      -- FROM   DUAL;


      BEGIN

         INSERT INTO budget (pid,
                                  bpdate,
                                  annee,
                                  bpmontme,
                                  bpmontmo,
				  flaglock
                                 )
                VALUES (p_pid,
			               sysdate,                   -- l_bpdate, (date courante)
                        TO_NUMBER(p_bpannee),
                        DECODE(p_bpmontme,
                               ',00', TO_NUMBER('0,00'),
                               NULL, TO_NUMBER('0,00'),
                               TO_NUMBER(p_bpmontme,'FM9999999990D00')
                              ),
                        DECODE(p_bpmontmo,
                               ',00', TO_NUMBER('0,00'),
                               NULL, TO_NUMBER('0,00'),
                               TO_NUMBER(p_bpmontmo,'FM9999999990D00')
                              ),
			0
                       );

         -- 'La proposition de budget' || p_pid || 'de l''annee' || p_bpannee || ' a été créé';

         pack_global.recuperer_message(2074, '%s1', p_pid, '%s2', p_bpannee, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION

         WHEN DUP_VAL_ON_INDEX THEN
            pack_global.recuperer_message(20268,NULL, NULL, NULL, l_msg);
            raise_application_error( -20268, l_msg );

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2291);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM );

      END;


   END insert_proposes;


-- ****************************************************************************
--           UPDATE_PROPOSES
-- ****************************************************************************
   PROCEDURE update_proposes (p_pid       IN  ligne_bip.pid%TYPE,
                              p_pnom      IN  ligne_bip.pnom%TYPE,
                              p_bpannee   IN  VARCHAR2,
                              p_bpmontme  IN  VARCHAR2,
                              p_bpmontmo  IN  VARCHAR2,
                              p_flaglock  IN  NUMBER,
                              p_userid    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS

   l_msg    VARCHAR2(1024);
   l_bpdate DATE;

   referential_integrity EXCEPTION;
   PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- Recupere la date courante

      -- SELECT SYSDATE
      -- INTO   l_bpdate
      -- FROM   DUAL;


      BEGIN
         UPDATE budget SET pid     = p_pid,
                                annee = TO_NUMBER(p_bpannee),
                                bpdate  = sysdate,                 -- l_bpdate, (date courante)
                                bpmontme = DECODE(p_bpmontme,
                                          ',00', TO_NUMBER('0,00'),
                                          TO_NUMBER(p_bpmontme,'FM9999999990D00')
                                          ),
                                bpmontmo = DECODE(p_bpmontmo,
                                          ',00', TO_NUMBER('0,00'),
                                          TO_NUMBER(p_bpmontmo,'FM9999999990D00')
                                          ),
                                flaglock = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE pid = p_pid
         AND annee = p_bpannee
         AND flaglock = p_flaglock;

      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2291);

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         pack_global.recuperer_message(2075, '%s1', p_pid, '%s2', p_bpannee, NULL, l_msg);
         p_message := l_msg;
      END IF;


   END update_proposes;


-- ****************************************************************************
--           SELECT_PROPOSES
-- ****************************************************************************
   PROCEDURE select_proposes (p_pid       IN budget.pid%TYPE,
                              p_bpannee   IN VARCHAR2,
                              p_userid    IN VARCHAR2,
                              p_pnom      OUT VARCHAR2,
                              p_mode      OUT VARCHAR2,
                              p_bpmontme  OUT VARCHAR2,
                              p_bpmontmo  OUT VARCHAR2,
                              p_perime	  OUT VARCHAR2,
                              p_perimo	  OUT VARCHAR2,
                              p_flaglock  OUT VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS

      l_msg      VARCHAR2(1024);
      l_codsg    ligne_bip.codsg%TYPE;
      l_clicode  ligne_bip.clicode%TYPE;
      l_pid      ligne_bip.pid%TYPE;
      l_habilitation varchar2(10);
      l_perimo	 VARCHAR2(255);
      l_statut   VARCHAR2(56);
      l_date_statut VARCHAR2(10);
      l_topfer   CHAR(1);
      l_datdebex varchar2(10);
      l_date_statut_number NUMBER(10);
      l_menu     VARCHAR2(255);


   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

	l_menu := pack_global.lire_globaldata(p_userid).menutil;



      -- TEST : Existence de pid dans ligne_bip

      BEGIN
         SELECT pid
         INTO   l_pid
         FROM   ligne_bip
         WHERE  pid = p_pid;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20504, '%s1', p_pid, 'PID', l_msg);
            raise_application_error(-20504, l_msg);

        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
      END;

      -- Gestion du niveau d'acces de l'utilisateur.

	-- On récupère le DPG de la ligne
      	BEGIN
         SELECT codsg
         INTO   l_codsg
         FROM   ligne_bip
         WHERE  pid = p_pid;

      	EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20223, NULL, NULL, 'PID', l_msg);
            raise_application_error(-20223, l_msg);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      	END;

	-- On récupère le CLICODE de la ligne
      	BEGIN
         SELECT clicode
         INTO   l_clicode
         FROM   ligne_bip
         WHERE  pid = p_pid;

      	EXCEPTION

         WHEN NO_DATA_FOUND THEN
            pack_global.recuperer_message(20373, NULL, NULL, 'PID', l_msg);
            raise_application_error(-20373, l_msg);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      	END;


      -- ====================================================================
      -- Test appartenance du DPG au périmètre ME de l'utilisateur
      -- ====================================================================
        p_perime := 'N';
     	l_habilitation := pack_habilitation.fhabili_me(l_codsg, p_userid);
	IF l_habilitation='vrai' THEN
		p_perime := 'O';
	END IF;

      -- ====================================================================
      -- Test appartenance du Code MO au périmètre MO de l'utilisateur
      -- ====================================================================
        p_perimo := 'N';
        l_perimo := pack_global.lire_globaldata( p_userid).perimo;
	IF pack_habilitation.fverif_habili_mo(l_perimo, l_clicode) THEN
		p_perimo:='O';
	END IF;

      -- ====================================================================
      -- Si Ni perimètre ME ni périmètre MO alors message d'erreur Ligne hors périmètre
      -- ====================================================================
 	IF p_perime = 'N' AND p_perimo = 'N' THEN
            pack_global.recuperer_message(20201, '%s1', p_pid, 'PID', l_msg);
            raise_application_error(-20201, l_msg);
 	END IF;

	-- test de la date statut
	IF (l_menu <> 'DIR') THEN
		SELECT TO_CHAR(adatestatut,'DD/MM/YYYY'),nvl(astatut,'Pas de statut'),topfer INTO l_date_statut,l_statut,l_topfer
		FROM ligne_bip WHERE pid = p_pid;

		SELECT TO_NUMBER(TO_CHAR(adatestatut,'YYYY')) INTO l_date_statut_number
		FROM ligne_bip WHERE pid = p_pid;

		IF ((l_date_statut IS NOT NULL) AND (l_date_statut_number < to_number(p_bpannee))) THEN
		raise_application_error (-20000,'Vous ne pouvez pas modifier la ligne bip ' || p_pid ||
					' car son statut est ' || l_statut ||
					', son top fermeture est ' || l_topfer ||
					' et sa date de statut ou de top fermeture est ' || l_date_statut);
		END IF;
	END IF;


	-- Pas le droit de saisir sur des années antérieures
	SELECT TO_NUMBER(TO_CHAR(datdebex,'YYYY')) into l_datdebex from datdebex;
	IF l_datdebex > to_number(p_bpannee) THEN
	    pack_global.recuperer_message(20313, '%s1', NULL, NULL, l_msg);
            raise_application_error(-20313, l_msg);
	END IF;

      -- Renvoie pnom de ligne_bip

      BEGIN
         SELECT pnom
         INTO   p_pnom
         FROM   ligne_bip
         WHERE  pid = p_pid;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      -- Renvoie les valeurs pour l'affichage de proposes dc*

      -- Modification

     -- p_preproc := 'PreProc#' || 'UPDATE';
      p_mode  := 'update';

      BEGIN
         SELECT ligne_bip.pid,
                TO_CHAR(bpmontme, 'FM9999999990D00'),
                TO_CHAR(bpmontmo, 'FM9999999990D00'),
                TO_CHAR(budget.flaglock)
         INTO   l_pid, p_bpmontme, p_bpmontmo, p_flaglock
         FROM   budget, ligne_bip
         WHERE  budget.pid = p_pid
         AND    ligne_bip.pid = p_pid
         AND    budget.annee = TO_NUMBER(p_bpannee);

      EXCEPTION

        WHEN NO_DATA_FOUND THEN

           -- Creation
           p_mode   :=  'insert';
           p_bpmontme  :=  '0,00';
           p_bpmontmo  :=  '0,00';
           p_flaglock :=  '';
           l_pid := NULL;
           NULL;

        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
      END;

   END select_proposes;

END pack_proposes;
/
CREATE OR REPLACE PACKAGE pack_proposes_mass AS

FUNCTION str_propo_mass 	(	p_string     IN  VARCHAR2,
                           		p_occurence  IN  NUMBER
                          	  ) return VARCHAR2;

PROCEDURE select_propo_mass  	 (	p_codsg		IN  VARCHAR2,
   								 	p_clicode      	IN  VARCHAR2,
   									p_airt       IN VARCHAR2,
			       					p_annee        	IN  VARCHAR2,
                               		p_userid       	IN  VARCHAR2,
                               		p_libcodsg	OUT struct_info.libdsg%TYPE,
                               		p_libclicode	OUT client_mo.clisigle%TYPE,
                               		p_libairt	 OUT application.alibel%TYPE,
                               		p_nbpages	OUT VARCHAR2,
                               		p_numpage 	OUT VARCHAR2,
                               		p_nbcurseur	OUT INTEGER,
                               		p_message	OUT VARCHAR2
                             		 );

PROCEDURE update_propo_mass(		p_string    IN  VARCHAR2,
                              		p_userid    IN  VARCHAR2,
                              		p_nbcurseur OUT INTEGER,
                              		p_message   OUT VARCHAR2
                             );



TYPE clientdpg_liste_ViewType IS RECORD ( CLICODE VARCHAR2(5),
                                    	  CLIENT  VARCHAR2(100)
                                        );
TYPE clientdpg_listeCurType IS REF CURSOR RETURN clientdpg_liste_ViewType;
PROCEDURE lister_client_dpg( p_codsg 	IN VARCHAR2,
   							 p_userid 	IN VARCHAR2,
   							 p_curseur 	IN OUT clientdpg_listeCurType
                            );
PROCEDURE lister_appli_dpg( p_codsg 	IN VARCHAR2,
   							 p_userid 	IN VARCHAR2,
   							 p_curseur 	IN OUT clientdpg_listeCurType
                            );

END pack_proposes_mass;
/

CREATE OR REPLACE PACKAGE BODY pack_proposes_mass AS

   FUNCTION str_propo_mass (	p_string     IN  VARCHAR2,
                           	p_occurence  IN  NUMBER
                          	) return VARCHAR2 IS
   pos1 NUMBER(6);
   pos2 NUMBER(6);
   str  VARCHAR2(111);

   BEGIN

      pos1 := INSTR(p_string,';',1,p_occurence);
      pos2 := INSTR(p_string,';',1,p_occurence+1);

      IF pos2 != 1 THEN
         str := SUBSTR( p_string, pos1+1, pos2-pos1-1);
         return str;
      ELSE
         return '1';
      END IF;

   END str_propo_mass;




PROCEDURE select_propo_mass  (	p_codsg		 IN VARCHAR2,
   							 	p_clicode    IN VARCHAR2,
   								p_airt       IN VARCHAR2,
			       				p_annee      IN VARCHAR2,
                               	p_userid     IN VARCHAR2,
                               	p_libcodsg	 OUT struct_info.libdsg%TYPE,
                               	p_libclicode OUT client_mo.clisigle%TYPE,
                               	p_libairt	 OUT application.alibel%TYPE,
                               	p_nbpages	 OUT VARCHAR2,
                               	p_numpage 	 OUT VARCHAR2,
                               	p_nbcurseur	 OUT INTEGER,
                               	p_message	 OUT VARCHAR2
                              ) IS

      NB_LIGNES_MAXI 	NUMBER(5);
      NB_LIGNES_PAGES   NUMBER(2);
      l_msg	VARCHAR2(1024);
      l_nbpages	NUMBER(5);
      l_habilitation	varchar2(10);
      l_codsg	VARCHAR2(10);
      l_perime	VARCHAR2(255);
     -- l_perimo	VARCHAR2(255);
      l_annee	VARCHAR2(4);



BEGIN
      -- Nombres de lignes BIP retournées Maxis :
      NB_LIGNES_MAXI := 500;
      -- Nombre de lignes BIP maxi par pages
      NB_LIGNES_PAGES := 10;

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur := 1;
      p_message := '';

      -- Récupérer les périmètres de l'utilisateur
      l_perime := pack_global.lire_globaldata(p_userid).perime ;
     -- l_perimo := pack_global.lire_globaldata(p_userid).perimo ;

      p_numpage := 'NumPage#1';


      	-- ====================================================================
      	--  Pas de proposé sur une année passée
      	-- ====================================================================
	SELECT TO_CHAR (datdebex, 'YYYY')
	INTO l_annee
	FROM datdebex
	WHERE rownum < 2;

	IF TO_NUMBER(p_annee) < TO_NUMBER(l_annee) THEN
		--('vous n etes pas autorisé à faire des proposés sur une année passée')
       		pack_global.recuperer_message(20365, '%s1',  'faire des proposés sur une année passée','ANNEE', l_msg);
	   	raise_application_error(-20365,  l_msg);
	END IF;

      -- ===================================================================
      -- Test existence et appartenance du DPG au périmètre de l'utilisateur
      -- ===================================================================
      	IF (p_codsg IS NOT NULL) AND (p_codsg != '*******') THEN
   		pack_habilitation.verif_habili_me(p_codsg, p_userid ,l_msg);
		IF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,3)||'%';
		ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,5)||'%';
		ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) != '**' THEN
			l_codsg :=LPAD(p_codsg, 7, '0');
		END IF;
	END IF;



      -- =======================================================================
      -- Test existence et appartenance du CLICODE au périmètre de l'utilisateur
      -- =======================================================================
      --	IF (p_clicode IS NOT NULL) AND (p_clicode != '*****') THEN
      --		IF NOT pack_habilitation.fverif_habili_mo(l_perimo, p_clicode) THEN
      			-- Message d'alerte 'Vous n'êtes pas habilité à ce code client
      -- 			pack_global.recuperer_message(20737, '%s1', p_clicode, 'clicode', l_msg);
      --         		raise_application_error(-20737,l_msg);
      --		ENd IF;
      --	END IF;



      -- =======================================
      -- On récupère le lib du DPG ou du clicode
      -- =======================================
      IF p_codsg IS NOT NULL THEN
      	IF p_codsg = '*******' THEN
      		p_libcodsg := 'Tout le Périmètre';
      	ELSE
      		-- On récupère le lib du DPG
      		BEGIN
      			IF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
				    SELECT sigdep INTO p_libcodsg FROM struct_info
				     WHERE TO_CHAR(codsg, 'FM0000000') LIKE l_codsg AND topfer='O' AND rownum < 2;
				ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
				    SELECT sigdep || '/' || sigpole INTO p_libcodsg FROM struct_info
					 WHERE TO_CHAR(codsg, 'FM0000000') LIKE l_codsg AND topfer='O' AND rownum < 2;
			    ELSE
					SELECT libdsg INTO p_libcodsg FROM struct_info
					 WHERE TO_CHAR(codsg, 'FM0000000') = p_codsg AND topfer='O' AND rownum < 2;
			    END IF;
		    EXCEPTION
				WHEN NO_DATA_FOUND THEN
					pack_global.recuperer_message(20925, '%s1', p_codsg, 'codsg', l_msg);
		               		raise_application_error(-20925,l_msg);

				WHEN OTHERS THEN
		      			-- Message d'alerte Problème avec le libellé du DPG
		      			pack_global.recuperer_message(20738, '%s1', p_codsg, 'codsg', l_msg);
		               		raise_application_error(-20738,l_msg);
      		END;
      	END IF;
      END IF;

      IF p_clicode IS NOT NULL THEN
      	IF p_clicode = '*****' THEN
      		p_libclicode := 'Tout le Périmètre';
      	ELSE
      		-- On récupère le lib du clicode
      		p_libclicode := pack_utile3b.f_get_clisigle_climo(p_clicode);
      	END IF;
      END IF;


      IF (p_airt IS NULL) or (p_airt='') THEN
   		  p_libairt := 'Tout le Périmètre';
      ELSE
      	  -- On récupère le lib de l'application
		  IF (pack_utile3b.f_verif_airt_application(p_airt)) THEN
			  BEGIN
			      SELECT alibel INTO p_libairt
				    FROM application
				   WHERE airt = p_airt;
		      EXCEPTION
				  WHEN OTHERS THEN
				  	   p_libairt := '';
			  END;
		  ELSE
		  	  p_libairt := 'Code application inconnu';
          END IF;
      END IF;

      -- =======================================
      -- On récupère le nombre de lignes
      -- =======================================

      -- Si c'est un code ME = *****
      IF (p_codsg IS NOT NULL) AND (p_codsg = '*******') THEN
      	BEGIN
            -- Compte le nombre de lignes et test si on a des pid
             SELECT count(*)
             INTO   l_nbpages
             FROM   budget budg, ligne_bip bip, vue_dpg_perime vdp
             WHERE  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut is null) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
               AND  bip.codsg = vdp.codsg
               AND  INSTR(l_perime, vdp.codbddpg) > 0
			   AND  (p_airt is null or p_airt = bip.AIRT)
			   AND  (p_clicode is null or p_clicode = bip.CLICODE);
	     -- inutile de tester SQL%NOTFOUND car fonction de groupe renvoie toujours soit NULL, soit une valeur

	     IF (l_nbpages = 0) THEN
               pack_global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               raise_application_error(-20373 , l_msg);
             ELSIF (l_nbpages > NB_LIGNES_MAXI) THEN
               pack_global.recuperer_message( 20381 , '%s1', p_codsg, 'codsg', l_msg);
               raise_application_error(-20381 , l_msg);
             END IF;

             l_nbpages := CEIL(l_nbpages/NB_LIGNES_PAGES);
             p_nbpages := 'NbPages#'|| l_nbpages;
      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               pack_global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               raise_application_error(-20373 , l_msg);

           WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);
      	END;


     -- Si c'est un code ME != *******
     ELSIF (p_codsg IS NOT NULL) THEN
      	BEGIN
            -- Compte le nombre de lignes et test si on a des pid
             SELECT count(*)
             INTO   l_nbpages
             FROM   budget budg, ligne_bip bip
             WHERE  TO_CHAR(bip.codsg, 'FM0000000') LIKE l_codsg
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut is null) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
			   AND  (p_airt is null or p_airt = bip.AIRT)
			   AND  (p_clicode is null or p_clicode = bip.CLICODE);
	     -- inutile de tester SQL%NOTFOUND car fonction de groupe renvoie toujours soit NULL, soit une valeur

	     IF (l_nbpages = 0) THEN
               pack_global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               raise_application_error(-20373 , l_msg);
             ELSIF (l_nbpages > NB_LIGNES_MAXI) THEN
               pack_global.recuperer_message( 20381 , '%s1', p_codsg, 'codsg', l_msg);
               raise_application_error(-20381 , l_msg);
             END IF;

             l_nbpages := CEIL(l_nbpages/NB_LIGNES_PAGES);
             p_nbpages := 'NbPages#'|| l_nbpages;
      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               pack_global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               raise_application_error(-20373 , l_msg);

           WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);
      	END;
     END IF;


      -- Si c'est un code MO = *****
	  -- JMAS 13/06/2005 : ajout de la condition "AND (p_codsg IS NULL)" pour différencier "Mes Lignes" de "Lignes Clients"
      IF (p_clicode IS NOT NULL) AND (p_clicode = '*****') AND (p_codsg IS NULL) THEN
      	BEGIN
            -- Compte le nombre de lignes et test si on a des pid
             SELECT count(*)
             INTO   l_nbpages
             FROM   budget budg, ligne_bip bip, vue_clicode_perimo vcp
             WHERE  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut is null) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
               AND  bip.clicode = vcp.clicode
               --AND  INSTR(l_perimo, vcp.bdclicode) > 0
			   AND  (p_airt is null or p_airt = bip.AIRT);
	     -- inutile de tester SQL%NOTFOUND car fonction de groupe renvoie toujours soit NULL, soit une valeur

	     IF (l_nbpages = 0) THEN
               pack_global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
               raise_application_error(-20373 , l_msg);
             ELSIF (l_nbpages > NB_LIGNES_MAXI) THEN
               pack_global.recuperer_message( 20381 , '%s1', p_clicode, 'clicode', l_msg);
               raise_application_error(-20381 , l_msg);
             END IF;

             l_nbpages := CEIL(l_nbpages/NB_LIGNES_PAGES);
             p_nbpages := 'NbPages#'|| l_nbpages;
      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               pack_global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
               raise_application_error(-20373 , l_msg);

           WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);
      	END;


     -- Si c'est un code MO != *****
	 -- JMAS 13/06/2005 : ajout de la condition "AND (p_codsg IS NULL)" pour différencier "Mes Lignes" de "Lignes Clients"
     ELSIF (p_clicode IS NOT NULL) AND (p_codsg IS NULL) THEN
      	BEGIN
            -- Compte le nombre de lignes et test si on a des pid
             SELECT count(*)
             INTO   l_nbpages
             FROM   budget budg, ligne_bip bip
             WHERE  bip.clicode  = p_clicode
               AND  budg.annee(+) = TO_NUMBER(p_annee)
               AND  budg.pid (+)= bip.pid
               AND  ((bip.adatestatut is null) OR (TO_NUMBER(TO_CHAR(bip.adatestatut,'YYYY') ) >= TO_NUMBER(p_annee)))
			   AND  (p_airt is null or p_airt = bip.AIRT);
	     -- inutile de tester SQL%NOTFOUND car fonction de groupe renvoie toujours soit NULL, soit une valeur

	     IF (l_nbpages = 0) THEN
               pack_global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
               raise_application_error(-20373 , l_msg);
             -- Si > 500, pas de saisie en masse possible car il n'y a pas de plus petit périmètre que le clicode
             ELSIF (l_nbpages > NB_LIGNES_MAXI) THEN
               pack_global.recuperer_message( 20382 , '%s1', p_clicode, 'clicode', l_msg);
               raise_application_error(-20382 , l_msg);
             END IF;

             l_nbpages := CEIL(l_nbpages/NB_LIGNES_PAGES);
             p_nbpages := 'NbPages#'|| l_nbpages;
      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               pack_global.recuperer_message( 20373 , '%s1', p_clicode, 'clicode', l_msg);
               raise_application_error(-20373 , l_msg);

           WHEN OTHERS THEN
             raise_application_error( -20997, SQLERRM);
      	END;
     END IF;

      p_message := l_msg;


  END select_propo_mass;



  PROCEDURE update_propo_mass(		p_string    IN  VARCHAR2,
                              		p_userid    IN  VARCHAR2,
                              		p_nbcurseur OUT INTEGER,
                              		p_message   OUT VARCHAR2
                             	) IS

   l_msg    	VARCHAR2(10000);
   l_cpt    	NUMBER(7);
   l_bpannee  	budget.annee%TYPE;
   l_pid    	ligne_bip.pid%TYPE;
   l_bpmontme 	varchar2(20);
   l_bpmontmo 	varchar2(20);
   l_flaglock   budget.flaglock%TYPE;
   l_exist 	NUMBER;

   BEGIN


      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message   := '';
      l_cpt       := 1;
      l_bpannee := TO_NUMBER(pack_proposes_mass.str_propo_mass(p_string,l_cpt));


      WHILE l_cpt != 0 LOOP
	if l_cpt!=1 then
		l_pid := pack_proposes_mass.str_propo_mass(p_string,l_cpt);
         	l_flaglock   := TO_NUMBER(pack_proposes_mass.str_propo_mass(p_string,l_cpt+1));
		l_bpmontme := pack_proposes_mass.str_propo_mass(p_string,l_cpt+2);
		l_bpmontmo := pack_proposes_mass.str_propo_mass(p_string,l_cpt+3);
	else
        	l_pid := pack_proposes_mass.str_propo_mass(p_string,l_cpt+1);
         	l_flaglock   := TO_NUMBER(pack_proposes_mass.str_propo_mass(p_string,l_cpt+2));
		l_bpmontme := pack_proposes_mass.str_propo_mass(p_string,l_cpt+3);
		l_bpmontmo := pack_proposes_mass.str_propo_mass(p_string,l_cpt+4);
	end if;


        IF l_pid != '0' THEN
	   IF ((l_bpmontme is not null) or (l_bpmontmo is not null) or (l_bpmontme!='') or(l_bpmontmo!='')) THEN

	  -- Existence de la ligne bip dans prop_budget
             BEGIN
		select 1 into l_exist
		from budget
		where pid=l_pid
		and   annee = l_bpannee;
             EXCEPTION
		WHEN NO_DATA_FOUND THEN
		--Création de la ligne dans la table BUDGET
		INSERT INTO budget (annee, bpdate, bpmontme, bpmontmo, flaglock, pid)
		VALUES (l_bpannee,
			 sysdate,
			TO_NUMBER(l_bpmontme,'FM9999999990D00'),
			TO_NUMBER(l_bpmontmo,'FM9999999990D00'),
			0,
			l_pid);

	     END;

	    IF l_exist=1 THEN
		 --Mise à jour de la table PROP_BUDGET
             	UPDATE budget SET
                        	bpdate  = sysdate,
                                bpmontme = DECODE(l_bpmontme,
				 	 ',00', TO_NUMBER('0,00'),
                                          TO_NUMBER(l_bpmontme,'FM9999999990D00')
                                          ),
                                bpmontmo = DECODE(l_bpmontmo,
                                          ',00', TO_NUMBER('0,00'),
                                          TO_NUMBER(l_bpmontmo,'FM9999999990D00')
                                          ),
                                flaglock = decode( l_flaglock, 1000000, 0, l_flaglock + 1)
             	WHERE pid = l_pid
         	AND annee = l_bpannee;
         	--AND flaglock = l_flaglock;

	     END IF;
	 END IF;

	    if l_cpt=1 then       --pris en compte de l'année au début de la chaîne {;annee;pid;flaglock;bpmontme;bpmontmo;pid;flaglock;bpmontme;bpmontmo;..;}
		l_cpt := l_cpt + 5;
		dbms_output.put_line('l_cpt1:'||l_cpt);
	    else
            	l_cpt := l_cpt + 4;
	    end if;

         ELSE
            l_cpt :=0;
         END IF;
	 dbms_output.put_line('l_cpt:'||l_cpt);
      END LOOP;

   pack_global.recuperer_message( 20972 , '%s1', 'Proposé de l''année', '', p_message);

   END update_propo_mass;



--*************************************************************************************************
-- Procédure lister_client_dpg
--
-- Sélectionne la liste des clients disponible pour un DPG donné
--
-- ************************************************************************************************
PROCEDURE lister_client_dpg( p_codsg 	IN VARCHAR2,
   							 p_userid 	IN VARCHAR2,
   							 p_curseur 	IN OUT clientdpg_listeCurType
                             ) IS
	l_msg VARCHAR2(1024);
	l_codsg VARCHAR2(10);
	l_perimo	VARCHAR2(255);

BEGIN


	l_perimo := pack_global.lire_globaldata(p_userid).perimo ;



    IF (p_codsg IS NOT NULL) AND (p_codsg != '*******') THEN
   		pack_habilitation.verif_habili_me(p_codsg, p_userid ,l_msg);
	END IF;

	IF (p_codsg = '*******') THEN
		l_codsg := '%';
	ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
		l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,3)||'%';
	ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
		l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,5)||'%';
	ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) != '**' THEN
		l_codsg :=LPAD(p_codsg, 7, '0');
	END IF;

	BEGIN
	   	OPEN p_curseur FOR
          SELECT DISTINCT l.CLICODE, c.CLISIGLE||DECODE(c.CLISIGLE,c.CLILIB,'',' - '||c.CLILIB) CLIENT
            FROM LIGNE_BIP l, CLIENT_MO c
			WHERE  l.clicode = c.clicode
				  AND TO_CHAR(l.codsg, 'FM0000000') LIKE l_codsg
				  AND l.ADATESTATUT is null
		    UNION
            SELECT null, '' FROM dual
            ORDER by 2,1;

    EXCEPTION
		WHEN OTHERS THEN
   		    raise_application_error( -20997, SQLERRM);
	END;

END lister_client_dpg;


--*************************************************************************************************
-- Procédure lister_appli_dpg
--
-- Sélectionne la liste des applications disponible pour un DPG donné
--
-- ************************************************************************************************
PROCEDURE lister_appli_dpg( p_codsg 	IN VARCHAR2,
   							 p_userid 	IN VARCHAR2,
   							 p_curseur 	IN OUT clientdpg_listeCurType
                             ) IS
	l_msg VARCHAR2(1024);
	l_codsg VARCHAR2(10);

BEGIN

    IF (p_codsg IS NOT NULL) AND (p_codsg != '*******') THEN
   		pack_habilitation.verif_habili_me(p_codsg, p_userid ,l_msg);
	END IF;

	IF (p_codsg = '*******') THEN
		l_codsg := '%';
	ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
		l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,3)||'%';
	ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
		l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,5)||'%';
	ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) != '**' THEN
		l_codsg :=LPAD(p_codsg, 7, '0');
	END IF;

	BEGIN
	   	OPEN p_curseur FOR
           	SELECT l.AIRT, a.alibel APPLI
           	  FROM LIGNE_BIP l, APPLICATION a
           	 WHERE l.AIRT = a.AIRT
			   AND TO_CHAR(l.codsg, 'FM0000000') LIKE l_codsg
			   AND l.ADATESTATUT is null
			 GROUP by l.AIRT, a.alibel
			UNION
			select null, '' from dual
           	 ORDER by 2, 1;
    EXCEPTION
		WHEN OTHERS THEN
   		    raise_application_error( -20997, SQLERRM);
	END;

END lister_appli_dpg;


END pack_proposes_mass;
/
CREATE OR REPLACE PACKAGE pack_rapsynt AS

   -- ------------------------------------------------------------------------
   -- Nom        :  prologue
   -- Auteur     :  Equipe SOPRA
   -- Decription :  remplit la table tmprapsynt pour l'edition rapsynt
   -- Paramètres :  p_datdeb (IN) DATE: date debut de rapprochement
   --               p_datfin (IN) DATE: date fin de rapprochement
   --               p_datfin_fact (IN) DATE: date fin saisie facture
   --
   -- Retour     :  renvoie un numero de sequence pour le reports.
   --
   -- ------------------------------------------------------------------------

   FUNCTION prologue(	p_datdeb IN DATE,
           		p_datfin IN DATE,
           		p_datdeb_fact IN DATE,
           		p_datfin_fact IN DATE) RETURN number;

   -- ------------------------------------------------------------------------
   -- Nom        :  epilogue
   -- Auteur     :  Equipe SOPRA
   -- Decription :  supprime les elements lies a une edition de rapsynt
   -- Paramètres :  p_numseq (IN) NUMBER: numero de sequence
   --
   -- Retour     :  TRUE : suppression OK
   --               FALSE : suppression NOK
   --
   -- ------------------------------------------------------------------------

   FUNCTION epilogue(p_numseq IN NUMBER ) RETURN BOOLEAN;

   -- ------------------------------------------------------------------------
   -- Nom        :  verif_rapsynt
   -- Auteur     :  Equipe SOPRA
   -- Decription :  Test des parametres d'entrees de l'edition rapsynt
   -- Paramètres :  p_numseq (IN) NUMBER: numero de sequence
   --
   -- Retour     :  TRUE : suppression OK
   --               FALSE : suppression NOK
   --
   -- ------------------------------------------------------------------------
   PROCEDURE verif_rapsynt(	p_param6  IN  VARCHAR2,
            			p_param7  IN  VARCHAR2,
            			p_param8  IN  VARCHAR2,
            			p_param9  IN  VARCHAR2,
            			p_message OUT VARCHAR2
                );

   -- ------------------------------------------------------------------------
   --  Curseur global : Selection des lignes de factures
   CURSOR l_c_ligne_fact (v_datdeb DATE, v_datfin DATE, v_datdeb_fact DATE, v_datfin_fact DATE) IS
     SELECT  lig.ident,
             to_char(lig.lmoisprest,'YYYYMM') 	mois	  ,
             lig.ldeppole 			codsg	  ,
             lig.lcodcompta 			lcodcompta,
             lig.socfact 			socfact	  ,
             sum(decode(fac.typfact,
                         'A',(-1 * lig.lmontht * ((lig.tva/100) + 1)),
                            (lig.lmontht  * ((lig.tva/100) + 1 ))
                       )
               ) 				mntfact
     FROM   facture 	fac,
            ligne_fact 	lig
     WHERE  lig.lmoisprest BETWEEN v_datdeb AND v_datfin
        AND lig.socfact <> 'SG..'
        AND fac.socfact = lig.socfact
        AND fac.numfact = lig.numfact
        AND fac.typfact = lig.typfact
        AND fac.datfact = lig.datfact
        AND fac.fdatsai <= v_datfin_fact
        AND fac.fdatsai >= v_datdeb_fact
        AND (lig.lcodcompta IN ('6395001','6396201','6396103','6396102','6396102','6322004','6391501','6391507','6391507',
                           '6391507','6391502','6391503','6391504','6391507','4379','6396206','6092001','4386','6391506')
             OR (lig.lcodcompta = '6396204' AND lig.lcodfinali <> 0)
            )
     GROUP BY  lig.ident,
               to_char(lig.lmoisprest,'YYYYMM'),
               lig.ldeppole,
               lig.lcodcompta,
               lig.socfact
     ORDER BY  codsg, ident, mois;

   -- ------------------------------------------------------------------------
   --  Curseur global : Selection de proplus
   CURSOR l_c_pro_plus(v_datdeb DATE, v_datfin DATE, v_tva NUMBER) IS
     SELECT pro.tires 				ident,
             to_char(pro.cdeb,'YYYYMM') 	mois,
             pro.divsecgrou 			codsg,
             sum(pro.cusag * pro.cout * v_tva ) mntpro,
             sum(pro.cusag) 			cusag
     FROM    proplus pro
     WHERE   pro.cdeb BETWEEN v_datdeb AND v_datfin AND
             pro.societe != 'SG..' AND
             pro.qualif NOT IN ('GRA','MO ') AND
             pro.aist NOT IN ('FORMAT','ABSDIV','CONGES','MOBILI','PARTIE','RTT')
     GROUP BY  pro.tires,
               to_char(pro.cdeb,'YYYYMM'),
               pro.divsecgrou
     ORDER BY  codsg, ident, mois;

-- -----------------------------------------------
-- Curseur pour la MAJ de fact_aa1 dans tmprapsynt
-- -----------------------------------------------
	CURSOR C0 is
		select
			distinct
			numseq,
			codsg,
			codcompta
		from
			tmprapsynt
		where
			fact_aa1 is null;
END pack_rapsynt;
/

CREATE OR REPLACE PACKAGE BODY pack_rapsynt AS
  -- ************************************************************************
  -- Nom        :  prologue
  -- Auteur     :  Equipe SOPRA
  -- Decription :  remplit la table tmprapsynt pour l'edition rapsynt
  -- Paramètres :  p_datdeb (IN) DATE: date debut de rapprochement
  --               p_datfin (IN) DATE: date fin de rapprochement
  --               p_datfin_fact (IN) DATE: date fin saisie facture
  --
  -- Retour     :  renvoie un numero de sequence pour le reports.
  --
  -- ************************************************************************
FUNCTION prologue ( p_datdeb      IN DATE,
                    p_datfin      IN DATE,
                    p_datdeb_fact IN DATE,
                    p_datfin_fact IN DATE) RETURN number IS
   -- Booleens de test
   l_pro_plus_fetch_ok  BOOLEAN := true;
   l_lig_fact_fetch_ok  BOOLEAN := true;
   l_pro_plus_finished  BOOLEAN := false;
   l_lig_fact_finished  BOOLEAN := false;

   -- lignes de curseur
   l_lig_fact     l_c_ligne_fact%ROWTYPE;
   l_lig_pro_plus l_c_pro_plus%ROWTYPE;

   -- ligne de la table temporaire
   l_lig_tot      tmprapsynt%ROWTYPE;
   tmp_l_lig_tot  tmprapsynt.fact_aa1%type;
   ligne0 C0%rowtype;

   -- Valeurs de cles
   l_codcompta     varchar2(11);
   l_codcompta_old varchar2(11);
   l_codsg         NUMBER := 0;
   l_codsg_old     NUMBER := 0;

   -- Identifiants servant à calculer la jointure des deux curseurs
   l_id_proplus    NUMBER;
   l_id_lignefact  NUMBER;

   -- autre
   l_numseq        NUMBER;           -- Sequence dans la table temporaire
   first           BOOLEAN := true;  -- Boolean pour la 1er iteration du loop
   l_tva           NUMBER(9,3);      -- taux tva + 1  Modif QHL 16/3/2000
BEGIN
   -- Initialisations
   SELECT srapsynt.nextval INTO l_numseq FROM dual;
   l_tva := ((pack_utile.f_get_tva(sysdate) / 100) + 1);
   open l_c_pro_plus (p_datdeb, p_datfin, l_tva);
   open l_c_ligne_fact (p_datdeb, p_datfin,p_datdeb_fact, p_datfin_fact);
   l_lig_tot.codsg        := 0; l_lig_tot.codcompta    := '0'; l_lig_tot.numseq       := l_numseq;
   l_lig_tot.jh_fac_eq0   := 0; l_lig_tot.mc_fac_eq0   := 0; l_lig_tot.jh_fac_eqcon := 0;
   l_lig_tot.mf_fac_eqcon := 0; l_lig_tot.mc_fac_eqcon := 0; l_lig_tot.jh_fac_necon := 0;
   l_lig_tot.mf_fac_necon := 0; l_lig_tot.mc_fac_necon := 0; l_lig_tot.mf_con_eq0   := 0;
   l_lig_tot.fact_aa1     := 0; tmp_l_lig_tot := 0;
   -- ===================================
   -- Parcours des curseurs
   -- ===================================
   LOOP
      -- ===============================================================
      -- Fetch conditionnels des curseurs, calculs des cles de jointures
      -- ===============================================================
      IF (l_pro_plus_fetch_ok = true) THEN
          fetch l_c_pro_plus INTO l_lig_pro_plus;
          l_id_proplus := rtrim(ltrim(nvl(to_char(l_lig_pro_plus.codsg,'FM0000000'),'0000000'))) ||
                          rtrim(ltrim(nvl(to_char(l_lig_pro_plus.ident,'FM00000'),'00000')))   ||
                          l_lig_pro_plus.mois;
      END IF;
      IF (l_lig_fact_fetch_ok = true) THEN
          fetch l_c_ligne_fact INTO l_lig_fact;
          l_id_lignefact := rtrim(ltrim(nvl(to_char(l_lig_fact.codsg,'FM0000000'),'0000000'))) ||
                            rtrim(ltrim(nvl(to_char(l_lig_fact.ident,'FM00000'),'00000')))   ||
                            l_lig_fact.mois;
      END IF;
      -- ===============================================================
      -- Positionnement des flags de sortie des curseurs sortie de la boucle quand les deux curseurs sont finis
      -- ===============================================================
      IF l_c_pro_plus%NOTFOUND THEN
          l_pro_plus_finished   := true;
          l_id_proplus   := '999999999999999999';    -- Cette cle sera toujours la plus grande
      END IF;
      IF l_c_ligne_fact%NOTFOUND THEN
          l_lig_fact_finished   := true;
          l_id_lignefact := '999999999999999999';    -- Cette cle sera toujours la plus grande
      END IF;
      IF (l_lig_fact_finished = true ) AND (l_pro_plus_finished = true) THEN
          EXIT;
      END IF;
      -- Maj du code comptable et codsg
      IF (l_id_proplus = l_id_lignefact) THEN
            -- Dans ce cas, on prend le code comptable/sg de facture ...
            l_codcompta := l_lig_fact.lcodcompta;
            l_codsg     := l_lig_fact.codsg;
         ELSIF (l_id_proplus < l_id_lignefact) THEN
            -- on prend 0 comme code comptable, et le code SG dans proplus
            l_codcompta := '0';
            l_codsg     := l_lig_pro_plus.codsg;
         ELSE  -- Cas restant, l_id_proplus > l_id_lignefact
            -- On prend le code comptable de ligne_fact
            l_codcompta := l_lig_fact.lcodcompta;
            l_codsg     := l_lig_fact.codsg;
      END IF;
      -- ================================
      -- Cas de la 1er boucle
      -- ================================
      IF (first = true) THEN
          l_codcompta_old := l_codcompta;
          l_codsg_old     := l_codsg;
          first := false;
      END IF;
      -- -----------------------------------------------------------------------------
      -- Ecriture de la ligne dans la table temporaire si on change de code comptable
      -- -----------------------------------------------------------------------------
      IF (l_codcompta != l_codcompta_old ) OR (l_codsg != l_codsg_old)
         THEN
          l_lig_tot.codsg     := l_codsg_old;
          l_lig_tot.codcompta := l_codcompta_old;
          l_codcompta_old     := l_codcompta;
          l_codsg_old         := l_codsg;
          INSERT INTO  tmprapsynt
            VALUES (l_lig_tot.numseq      , l_lig_tot.codsg       , l_lig_tot.codcompta   ,
                    l_lig_tot.jh_fac_eq0  , l_lig_tot.mc_fac_eq0  , l_lig_tot.jh_fac_eqcon,
                    l_lig_tot.mf_fac_eqcon, l_lig_tot.mc_fac_eqcon, l_lig_tot.jh_fac_necon,
                    l_lig_tot.mf_fac_necon, l_lig_tot.mc_fac_necon, l_lig_tot.mf_con_eq0  ,
                    l_lig_tot.fact_aa1
                   );
          -- Mise à 0 des compteurs, pour nouvelle affectation;
          l_lig_tot.codsg        := 0;
          l_lig_tot.codcompta    := '0'; l_lig_tot.jh_fac_eq0   := 0; l_lig_tot.mc_fac_eq0   := 0;
          l_lig_tot.jh_fac_eqcon := 0; l_lig_tot.mf_fac_eqcon := 0; l_lig_tot.mc_fac_eqcon := 0;
          l_lig_tot.jh_fac_necon := 0; l_lig_tot.mf_fac_necon := 0; l_lig_tot.mc_fac_necon := 0;
          l_lig_tot.mf_con_eq0   := 0; l_lig_tot.fact_aa1     := 0; tmp_l_lig_tot := 0;
      END IF ;
      -- ---------------------------------------
      -- 'Jointure' entre les deux curseurs
      -- ---------------------------------------
      IF (l_id_proplus = l_id_lignefact)
         THEN
             l_pro_plus_fetch_ok := true;
             l_lig_fact_fetch_ok := true;
             -- Et on effecture les sommes (uniquement les différence et les égalités, les absences ne sont pas
             -- puisqu'on a la jointure entre les deux curseurs
             IF ((l_lig_fact.mntfact != 0 ) AND  (l_lig_pro_plus.mntpro != 0))
               THEN
                  IF (l_lig_fact.mntfact = l_lig_pro_plus.mntpro) OR (l_lig_fact.mntfact - l_lig_pro_plus.mntpro < 0.01)
                     THEN
                      l_lig_tot.jh_fac_eqcon :=  l_lig_tot.jh_fac_eqcon + l_lig_pro_plus.cusag;
                      l_lig_tot.mf_fac_eqcon :=  l_lig_tot.mf_fac_eqcon + l_lig_fact.mntfact;
                      l_lig_tot.mc_fac_eqcon :=  l_lig_tot.mc_fac_eqcon + l_lig_pro_plus.mntpro;
                     ELSE  -- Cas de la difference  :>   l_lig_fact.mntfact - l_lig_pro_plus.mntpro >= 0.01
                      l_lig_tot.jh_fac_necon :=  l_lig_tot.jh_fac_necon + l_lig_pro_plus.cusag;
                      l_lig_tot.mf_fac_necon :=  l_lig_tot.mf_fac_necon + l_lig_fact.mntfact;
                      l_lig_tot.mc_fac_necon :=  l_lig_tot.mc_fac_necon + l_lig_pro_plus.mntpro;
                  END IF;
             END IF;
	     l_lig_tot.fact_aa1 := null; -- La MAJ de cette donnée est faite à la fin du traitement avec le curseur C0
         ELSIF (l_id_proplus < l_id_lignefact) THEN
             -- on avance sur proplus, pas sur ligne fact, c'est la ligne de proplus que l'on va traiter
             l_pro_plus_fetch_ok := true;
             l_lig_fact_fetch_ok := false;
             -- on ne fait que les calculs correspondant à la partie proplus
             l_lig_tot.jh_fac_eq0 := l_lig_tot.jh_fac_eq0 + l_lig_pro_plus.cusag;  -- ajout du cusag
             l_lig_tot.mc_fac_eq0 := l_lig_tot.mc_fac_eq0 + l_lig_pro_plus.mntpro;
         ELSE  -- Cas restant, l_id_proplus > l_id_lignefact
             -- on avance sur lignefact, pas sur proplus, c'est la ligne de ligne_fact que l'on va traiter
             l_pro_plus_fetch_ok := false;
             l_lig_fact_fetch_ok := true;
             -- On ne fait que les calculs correspondant à la partie de ligne_fact
             l_lig_tot.mf_con_eq0 := l_lig_tot.mf_con_eq0 + l_lig_fact.mntfact ; -- Ajout de la facture
             -- Cas particulier du montant FACT_AA1
		l_lig_tot.fact_aa1 := null;
         END IF ;
   END LOOP;
   CLOSE l_c_pro_plus;
   CLOSE l_c_ligne_fact;

	OPEN C0;
	LOOP
	fetch C0 into ligne0;
	exit when C0%notfound;
	-- Recherche du fact_aa1 = consomme des années antérieures
	BEGIN
	SELECT
			nvl(
				sum(decode(
						fac.typfact,
                  	     		'A',(-1 * lig.lmontht * ((lig.tva/100) + 1)),
                            		(lig.lmontht  * ((lig.tva/100) + 1 ))
                 		))
			,0)
			INTO
				tmp_l_lig_tot
     			FROM
				facture fac,
	            		ligne_fact lig
	     		WHERE
			  	lig.lmoisprest <= to_date('12' || to_char(add_months(p_datdeb,-12),'yyyy'),'MMYYYY')
				AND lig.socfact <> 'SG..'
		        	AND fac.socfact = lig.socfact
		        	AND fac.numfact = lig.numfact
		        	AND fac.typfact = lig.typfact
		        	AND fac.datfact = lig.datfact
		        	AND fac.fdatsai <= p_datfin_fact
				AND fac.fdatsai >= to_date('0101' || to_char(p_datdeb_fact,'yyyy'),'DDMMYYYY')
		        	AND (lig.lcodcompta IN ('6395001', '6396201', '6396103', '6396102', '6396102', '6322004',
 								'6391501', '6391507', '6391507', '6391507', '6391502', '6391503',
 								'6391504', '6391507', '4379', '6396206', '6092001', '4386', '6391506')
		             	OR (lig.lcodcompta = '6396204' AND lig.lcodfinali <> 0)
		            	)
				AND substr(TO_CHAR(lig.ldeppole, 'FM0000000'),1,5) = substr(TO_CHAR(ligne0.codsg, 'FM0000000'),1,5)
				AND lig.lcodcompta = ligne0.codcompta;
	Exception
		when no_data_found then tmp_l_lig_tot := 0;
	END;

	-- MAJ de tmprapsynt pour fact_aa1
	update tmprapsynt t
	set fact_aa1 = tmp_l_lig_tot
	where numseq = l_numseq
		and substr(TO_CHAR(t.codsg, 'FM0000000'),1,5) = substr(TO_CHAR(ligne0.codsg, 'FM0000000'),1,5)
		and t.codcompta = ligne0.codcompta;

END LOOP;
CLOSE C0;

RETURN  l_numseq;
EXCEPTION
   WHEN OTHERS THEN
     RETURN 0; -- code d'erreur
END prologue;

-- ************************************************************************
-- Nom        :  epilogue
-- Auteur     :  Equipe SOPRA
-- Decription :  supprime les elements lies a une edition de rapsynt
-- Paramètres :  p_numseq (IN) NUMBER: numero de sequence
--
-- Retour     :  TRUE : suppression OK
--               FALSE : suppression NOK
--
-- ************************************************************************
   FUNCTION epilogue (p_numseq IN NUMBER ) RETURN BOOLEAN IS
   BEGIN
      DELETE FROM tmprapsynt WHERE numseq = p_numseq;
      RETURN true;
   EXCEPTION
         WHEN OTHERS THEN
           IF l_c_pro_plus%ISOPEN = true THEN
              close l_c_pro_plus;
           END IF;
           IF l_c_ligne_fact%ISOPEN = true THEN
         close l_c_ligne_fact;
           END IF;
           RETURN false;
   END epilogue;

-- ************************************************************************
-- Nom        :  verif_rapsynt
-- Auteur     :  Equipe SOPRA
-- Decription :  Test des parametres d'entrees de l'edition rapsynt
-- Paramètres :  p_numseq (IN) NUMBER: numero de sequence
--
-- Retour     :  TRUE : suppression OK
--               FALSE : suppression NOK
--
-- exec pack_rapsynt.verif_rapsynt('01/1999', '02/1999', '01/01/1999', '26/10/1999', :msg);
-- ************************************************************************
   PROCEDURE verif_rapsynt(p_param6  IN  VARCHAR2,
            p_param7  IN  VARCHAR2,
            p_param8  IN  VARCHAR2,
            p_param9  IN  VARCHAR2,
            p_message OUT VARCHAR2
                ) IS
      l_msg VARCHAR2(1024);
   BEGIN
      IF to_date('01/'||p_param6, 'dd/mm/yyyy') > to_date('01/'||p_param7, 'dd/mm/yyyy') THEN
         pack_global.recuperer_message(20284, NULL, NULL, 'P_param6', l_msg);
         raise_application_error(-20284, l_msg);
      END IF;
      IF to_date(p_param8, 'dd/mm/yyyy') > to_date(p_param9, 'dd/mm/yyyy') THEN
         pack_global.recuperer_message(20284, NULL, NULL, 'P_param8', l_msg);
         raise_application_error(-20284, l_msg);
      END IF;
   END verif_rapsynt;
END  pack_rapsynt;
/
CREATE OR REPLACE PACKAGE pack_ratt_bip AS

  TYPE Struct_info_ViewType IS RECORD (codsg      char(7),
                                       sigdep     struct_info.sigdep%TYPE,
                                       sigpole    struct_info.sigpole%TYPE,
                                       libdsg     struct_info.libdsg%TYPE,
                                       centractiv char(7),
                                       topfer     struct_info.topfer%TYPE,
                                       flaglock   struct_info.flaglock%TYPE
                                      );

   TYPE client_moCurType IS REF CURSOR RETURN client_mo%ROWTYPE;
   TYPE struct_infoCurType_Char IS REF CURSOR RETURN Struct_info_ViewType;
   TYPE ligne_bipCurType IS REF CURSOR RETURN ligne_bip%ROWTYPE;

   	PROCEDURE select_c_ratt_proj (	p_codsg          IN VARCHAR2,
                                 	p_userid         IN VARCHAR2,
                                 	p_curStruct_info IN OUT struct_infoCurType_Char,
                                 	p_nbcurseur         OUT INTEGER,
                                 	p_message           OUT VARCHAR2
                                	);

   	PROCEDURE select_m_ratt_proj (	p_clicode      IN client_mo.clicode%TYPE,
                                 	p_userid       IN VARCHAR2,
                                 	p_curClient_mo IN OUT client_moCurType,
                                 	p_nbcurseur       OUT INTEGER,
                                 	p_message         OUT VARCHAR2
                                	);

	PROCEDURE update_un_projet (p_cod      IN VARCHAR2,
                              p_pid     IN ligne_bip.pid%TYPE,
                              p_flaglock IN VARCHAR2,
                              p_table    IN VARCHAR2,
                              p_userid	 IN VARCHAR2,
                              p_compteur IN OUT INTEGER,
                              p_message  IN OUT VARCHAR2
                             );

	PROCEDURE update_ratt_bip (p_table      IN  VARCHAR2,
                               p_cod        IN  VARCHAR2,
                               p_lib        IN  VARCHAR2,
                               p_pid_1      IN  ligne_bip.pid%TYPE,
                               p_flaglock_1 IN  VARCHAR2,
                               p_pid_2      IN  ligne_bip.pid%TYPE,
                               p_flaglock_2 IN  VARCHAR2,
                               p_pid_3      IN  ligne_bip.pid%TYPE,
                               p_flaglock_3 IN  VARCHAR2,
                               p_pid_4      IN  ligne_bip.pid%TYPE,
                               p_flaglock_4 IN  VARCHAR2,
                               p_pid_5      IN  ligne_bip.pid%TYPE,
                               p_flaglock_5 IN  VARCHAR2,
                               p_pid_6      IN  ligne_bip.pid%TYPE,
                               p_flaglock_6 IN  VARCHAR2,
                               p_userid     IN  VARCHAR2,
                               p_nbcurseur  OUT INTEGER,
                               p_message    OUT VARCHAR2
                              );

	PROCEDURE select_ratt_pid (p_dpcode	IN  VARCHAR2,
                               p_dplib	IN  VARCHAR2,
                               p_flaglock	IN VARCHAR2,
                               p_pid_1      IN  ligne_bip.pid%TYPE,
                               p_pid_2      IN  ligne_bip.pid%TYPE,
                               p_pid_3      IN  ligne_bip.pid%TYPE,
                               p_pid_4      IN  ligne_bip.pid%TYPE,
                               p_pid_5      IN  ligne_bip.pid%TYPE,
                               p_pid_6      IN  ligne_bip.pid%TYPE,
                               p_userid     IN  VARCHAR2,
                               p_curpid IN OUT ligne_bipCurType,
                               p_nbcurseur  OUT INTEGER,
                               p_message    OUT VARCHAR2
                              );

END pack_ratt_bip;
/

CREATE OR REPLACE PACKAGE BODY pack_ratt_bip AS

  PROCEDURE select_c_ratt_proj (p_codsg           IN VARCHAR2,
                                p_userid          IN VARCHAR2,
                                p_curStruct_info  IN OUT struct_infoCurType_Char,
                                p_nbcurseur          OUT INTEGER,
                                p_message            OUT VARCHAR2
                              ) IS

	l_msg    VARCHAR2(1024);
      l_topfer struct_info.topfer%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- TEST codsg actif

      BEGIN
         SELECT topfer
         INTO   l_topfer
         FROM   struct_info
         WHERE  codsg = TO_NUMBER(p_codsg);

      EXCEPTION

        WHEN NO_DATA_FOUND THEN
            NULL;

        WHEN OTHERS THEN
           raise_application_error(-20997, SQLERRM);
      END;

      IF l_topfer != 'O' THEN
         pack_global.recuperer_message( 20252, '%s1', p_codsg, NULL, l_msg);
         raise_application_error( -20252, l_msg);
      END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN   p_curStruct_info FOR
              SELECT codsg,
                     sigdep,
                     sigpole,
                     libdsg,
                     TO_CHAR(centractiv),
                     topfer,
                     flaglock
              FROM   struct_info
              WHERE  codsg = TO_NUMBER(p_codsg)
              AND    topfer = 'O';

      EXCEPTION

         WHEN OTHERS THEN
            raise_application_error( -20997,SQLERRM);
      END;

      -- en cas absence
	-- 'Code Département/Pôle/Groupe p_codsg inexistant'

	pack_global.recuperer_message( 2064, '%s1', p_codsg, NULL, l_msg);
	p_message := l_msg;

   END select_c_ratt_proj;


   PROCEDURE select_m_ratt_proj(p_clicode       IN client_mo.clicode%TYPE,
                                p_userid   	IN VARCHAR2,
                                p_curClient_mo  IN OUT client_moCurType,
                                p_nbcurseur       OUT INTEGER,
                                p_message         OUT VARCHAR2
                               ) IS
	l_msg     VARCHAR2(1024);
      	l_clitopf client_mo.clitopf%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- TEST clicode actif

      BEGIN

         SELECT clitopf
         INTO   l_clitopf
         FROM   client_mo
         WHERE  LTRIM(RTRIM(clicode)) = p_clicode;

      EXCEPTION

        WHEN NO_DATA_FOUND THEN
          NULL;

        WHEN OTHERS THEN
           raise_application_error(-20997, SQLERRM);
      END;

      IF (l_clitopf != 'O') AND (l_clitopf IS NOT NULL) THEN
         pack_global.recuperer_message( 20253, '%s1', p_clicode, NULL, l_msg);
         raise_application_error( -20253, l_msg);
      END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *


      BEGIN

         OPEN p_curClient_mo FOR
              SELECT *
              FROM client_mo
              WHERE LTRIM(RTRIM(clicode)) = LTRIM(RTRIM(p_clicode));

      EXCEPTION

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);

      END;

        -- en cas absence
	-- p_message := 'Code Client absent';
	pack_global.recuperer_message( 4, '%s1', p_clicode, NULL, l_msg);
	p_message := l_msg;

   END select_m_ratt_proj;



  PROCEDURE update_un_projet (p_cod      IN VARCHAR2,
                              p_pid      IN ligne_bip.pid%TYPE,
                              p_flaglock IN VARCHAR2,
                              p_table    IN VARCHAR2,
                              p_userid	 IN VARCHAR2,
                              p_compteur IN OUT INTEGER,
                              p_message  IN OUT VARCHAR2
                             ) IS
   CODCAMO_MULTI	VARCHAR2(6) := '77777';
   l_user		ligne_bip_logs.user_log%TYPE;
   -- Valeurs précédentes pour les logs
   l_codcamo		ligne_bip.codcamo%TYPE;
   -- Date de début d'exercice
   l_datdeb		repartition_ligne.datdeb%TYPE;
   l_test 		CHAR(1) ; -- utilisée dans un test d'existance
   BEGIN

      l_user := SUBSTR(pack_global.lire_globaldata(p_userid).idarpege, 1, 30);

      IF p_table = 'DPG' THEN
         BEGIN
            UPDATE ligne_bip
            SET codsg    = TO_NUMBER(p_cod),
                flaglock = decode( TO_NUMBER(p_flaglock), 1000000, 0, p_flaglock + 1)
            WHERE pid    = p_pid
            AND flaglock = p_flaglock;

         EXCEPTION

            WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);
         END;

      ELSIF p_table = 'CAMO' THEN
         BEGIN
            -- On récupère les valeurs précédentes pour les logs
            SELECT codcamo
            INTO l_codcamo
            FROM ligne_bip
            WHERE pid = p_pid
            AND flaglock = p_flaglock;

            UPDATE ligne_bip
            SET codcamo = TO_NUMBER(p_cod),
                flaglock = decode( TO_NUMBER(p_flaglock), 1000000, 0, p_flaglock + 1)
            WHERE pid   = p_pid
            AND flaglock = p_flaglock;

	    -- Si le CA saisit correspond avec le code de multi_facturation,
	    -- On saisit l'ancien CA dans la table repartition_ligne avec un taux de 100%
	    IF ((p_cod=CODCAMO_MULTI) AND (l_codcamo != CODCAMO_MULTI)) THEN
	  	SELECT ADD_MONTHS(datdebex, -1) INTO l_datdeb FROM datdebex WHERE ROWNUM<2;
	         --
	         -- Vérifie qu'il n'existe pas déjà des lignes dans répartition ligne
	         --
	         BEGIN
	            SELECT distinct '1' into l_test
	            FROM REPARTITION_LIGNE
	            WHERE PID = p_pid;

	         EXCEPTION
	            WHEN NO_DATA_FOUND THEN
	      	  	-- Insère une première répartition
		  	INSERT INTO repartition_ligne
		  	       (pid, codcamo, tauxrep, datdeb)
		  	VALUES (p_pid, l_codcamo, 100, l_datdeb);

	            WHEN OTHERS THEN
	               raise_application_error( -20997, SQLERRM);
	          END;
	    END IF;

	    pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'CA payeur', TO_CHAR(l_codcamo), p_cod, 'Modification du CA Payeur via Lien CA MO');
         EXCEPTION
	    WHEN NO_DATA_FOUND THEN
	    	-- Pas de problème on ne fait rien : C'est une ligne inexistante
	    	l_codcamo := 0;
            WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);
         END;

      ELSIF p_table = 'DP' THEN
         BEGIN
            UPDATE ligne_bip
            SET dpcode  = TO_NUMBER(p_cod),
                flaglock = decode( TO_NUMBER(p_flaglock), 1000000, 0, p_flaglock + 1)
            WHERE pid   = p_pid
            AND flaglock = p_flaglock;

         EXCEPTION

            WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);
         END;

      ELSIF p_table = 'MO' THEN
         BEGIN
            UPDATE ligne_bip
            SET clicode  = p_cod,
                flaglock = decode( TO_NUMBER(p_flaglock), 1000000, 0, p_flaglock + 1)
            WHERE pid    = p_pid
            AND flaglock = p_flaglock;

         EXCEPTION

            WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);
         END;


	  ELSIF p_table = 'CP' THEN
         BEGIN
            UPDATE ligne_bip
            SET pcpi  = TO_NUMBER(p_cod),
                flaglock = decode( TO_NUMBER(p_flaglock), 1000000, 0, p_flaglock + 1)
            WHERE pid   = p_pid
            AND flaglock = p_flaglock;

         EXCEPTION

            WHEN OTHERS THEN
                raise_application_error(-20997, SQLERRM);
         END;

      END IF;

      IF SQL%NOTFOUND THEN

         -- Rollback car on ne connait pas quel update ne marche pas

         ROLLBACK;

      ELSE

         COMMIT;
         p_compteur := p_compteur + 1;
         p_message := REPLACE( p_message, '%s1', p_pid||'   %s1' );

      END IF;

   END update_un_projet;


    PROCEDURE update_ratt_bip (p_table      IN  VARCHAR2,
                               p_cod        IN  VARCHAR2,
                               p_lib        IN  VARCHAR2,
                               p_pid_1      IN  ligne_bip.pid%TYPE,
                               p_flaglock_1 IN  VARCHAR2,
                               p_pid_2      IN  ligne_bip.pid%TYPE,
                               p_flaglock_2 IN  VARCHAR2,
                               p_pid_3      IN  ligne_bip.pid%TYPE,
                               p_flaglock_3 IN  VARCHAR2,
                               p_pid_4      IN  ligne_bip.pid%TYPE,
                               p_flaglock_4 IN  VARCHAR2,
                               p_pid_5      IN  ligne_bip.pid%TYPE,
                               p_flaglock_5 IN  VARCHAR2,
                               p_pid_6      IN  ligne_bip.pid%TYPE,
                               p_flaglock_6 IN  VARCHAR2,
                               p_userid     IN  VARCHAR2,
                               p_nbcurseur  OUT INTEGER,
                               p_message    OUT VARCHAR2
                              ) IS

      l_msg VARCHAR2(1024);
      l_total INTEGER := 0;

   BEGIN

     -- Positionner le nb de curseurs ==> 0
     -- Initialiser le message retour

     p_nbcurseur := 0;
     p_message := '';

     -- Recuperer le message parametre

     IF p_table = 'DPG' THEN
         pack_global.recuperer_message( 2057, '%s2', p_cod, NULL, l_msg);
     ELSIF p_table = 'MO' THEN
         pack_global.recuperer_message( 2058, '%s2', p_cod, NULL, l_msg);
     ELSIF p_table = 'CAMO' THEN
         pack_global.recuperer_message( 2059, '%s2', p_cod, NULL, l_msg);
     ELSIF p_table = 'DP' THEN
         pack_global.recuperer_message( 2060, '%s2', p_cod, NULL, l_msg);
	 ELSIF p_table = 'CP' THEN
         pack_global.recuperer_message( 21016, '%s2', p_cod, NULL, l_msg);
     END IF;

     -- 1er traitement

     update_un_projet( p_cod, p_pid_1, p_flaglock_1, p_table, p_userid, l_total, l_msg);

     -- 2e traitement

     update_un_projet( p_cod, p_pid_2, p_flaglock_2, p_table, p_userid, l_total, l_msg);

     -- 3e traitement

     update_un_projet( p_cod, p_pid_3, p_flaglock_3, p_table, p_userid, l_total, l_msg);

     -- 4e traitement

     update_un_projet( p_cod, p_pid_4, p_flaglock_4, p_table, p_userid, l_total, l_msg);

     -- 5e traitement

     update_un_projet( p_cod, p_pid_5, p_flaglock_5, p_table, p_userid, l_total, l_msg);

     -- 6er traitement

     update_un_projet( p_cod, p_pid_6, p_flaglock_6, p_table, p_userid, l_total, l_msg);

     IF l_total > 0 THEN

        p_message := REPLACE( l_msg, '%s1', NULL );

     ELSE

        pack_global.recuperer_message( 2061, '%s1', p_cod, NULL, l_msg);
        p_message := l_msg;

     END IF;

  END update_ratt_bip;


PROCEDURE select_ratt_pid (    p_dpcode     IN  VARCHAR2,
                               p_dplib      IN  VARCHAR2,
                               p_flaglock   IN  VARCHAR2,
                               p_pid_1      IN  ligne_bip.pid%TYPE,
                               p_pid_2      IN  ligne_bip.pid%TYPE,
                               p_pid_3      IN  ligne_bip.pid%TYPE,
                               p_pid_4      IN  ligne_bip.pid%TYPE,
                               p_pid_5      IN  ligne_bip.pid%TYPE,
                               p_pid_6      IN  ligne_bip.pid%TYPE,
                               p_userid     IN  VARCHAR2,
                               p_curpid IN OUT ligne_bipCurType,
                               p_nbcurseur  OUT INTEGER,
                               p_message    OUT VARCHAR2
                              ) IS


      l_msg VARCHAR2(1024);

   BEGIN
      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur := 1;
      p_message := '';
      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
       --pid,pnom,flaglock
      BEGIN
         OPEN p_curpid FOR
              SELECT * --pid,pnom,flaglock
              FROM LIGNE_BIP
              WHERE pid = p_pid_1
              UNION
              SELECT * -- pid,pnom,flaglock
              FROM LIGNE_BIP
              WHERE pid = p_pid_2
              UNION
              SELECT * --pid,pnom,flaglock
              FROM LIGNE_BIP
              WHERE pid = p_pid_3
              UNION
              SELECT * --pid,pnom,flaglock
              FROM LIGNE_BIP
              WHERE pid = p_pid_4
              UNION
              SELECT * --pid,pnom,flaglock
              FROM LIGNE_BIP
              WHERE pid = p_pid_5
              UNION
              SELECT * --pid,pnom,flaglock
              FROM LIGNE_BIP
              WHERE pid = p_pid_6

              ;

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;
      -- en cas absence
      -- p_message := '';
      pack_global.recuperer_message( 20504, '%s1', p_pid_1, NULL, l_msg);
      p_message := l_msg;
/*
var nbcurs number
var mess varchar2(1024)
var c refcursor
 exec PACK_RATT_BIP.SELECT_RATT_PID('50011','MARKETING ETUDES','0','BP5','MMC','GAY','A24','JFY
','NBK','A173818;dirmenu;15456;0270000;01 ;03140270000,03140250000;15456,14532;16;00677;1',:c,:nbcur
s,:mess);
*/
END select_ratt_pid;


END pack_ratt_bip;
/
CREATE OR REPLACE PACKAGE Pack_Recup_Id AS


temp VARCHAR2(36);
temp1 VARCHAR2(36);

TYPE cdp_liste_ViewType IS RECORD ( IDENT NUMBER(5),
				    RNOM VARCHAR2(30),
				    RPRENOM VARCHAR2(15) );

TYPE cdp_listeCurType IS REF CURSOR RETURN cdp_liste_ViewType;



TYPE cdp_societe_ViewType IS RECORD ( SOCCODE VARCHAR2(4),
				    SOCLIB VARCHAR2(25),
				    SOCAD1 VARCHAR2(25),
				    SOCAD2 VARCHAR2(25),
				    SOCFER VARCHAR2(10));


TYPE societe_listeCurType IS REF CURSOR RETURN cdp_societe_ViewType;

TYPE projet_liste_ViewType IS RECORD ( ICPI CHAR(5),
				       ILIBEL VARCHAR2(50) );

TYPE projet_listeCurType IS REF CURSOR RETURN projet_liste_ViewType;

PROCEDURE lister_projet( d_nomRecherche 	IN VARCHAR2,
   			     d_curseur 	IN OUT projet_listeCurType
                            );


PROCEDURE lister_cdp( p_nomRecherche 	IN VARCHAR2,
   			     p_curseur 	IN OUT cdp_listeCurType
                            );


PROCEDURE lister_cdp_type( p_nomRecherche 	IN VARCHAR2,
                                                              p_rtype	IN VARCHAR2,
   			                                                  p_curseur 	IN OUT cdp_listeCurType
                                                              );




PROCEDURE lister_societe( p_nomRechercheSociete 	IN VARCHAR2,
   			     s_curseur 	IN OUT societe_listeCurType
                            );


TYPE ca_ViewType IS RECORD ( CODCAMO NUMBER(6),
				    CLIBRCA CHAR(16),
				    CLIBCA VARCHAR2(30) );

TYPE ca_listeCurType IS REF CURSOR RETURN ca_ViewType;



PROCEDURE lister_ca( p_nomRechercheCa 	IN VARCHAR2,
		  			 					         p_cafidpg 	IN VARCHAR2,
   			     								 p_curseur 	IN OUT ca_listeCurType
                                                 );


TYPE rubrique_ViewType IS RECORD ( CODRUB  NUMBER(5),
				       	  		   		   			 		   	   				 LIBELLE    VARCHAR2(70),
				    															 CAFI           NUMBER(6),
																				 LIBCAFI     VARCHAR2(20)
																				 );

TYPE rubrique_listeCurType IS REF CURSOR RETURN rubrique_ViewType;



PROCEDURE lister_rubrique( p_nomRechercheRubrique 	IN VARCHAR2,
		  			 					           			p_curseur 	IN OUT rubrique_listeCurType
                                                 			);



TYPE dpg_liste_ViewType IS RECORD ( CODSG NUMBER(7),
				    LIBDSG VARCHAR2(30) );


TYPE dpg_listeCurType IS REF CURSOR RETURN dpg_liste_ViewType;



PROCEDURE lister_dpg( d_nomRecherche 	IN VARCHAR2,
   			     d_curseur 	IN OUT dpg_listeCurType
                            );


TYPE mo_ViewType IS RECORD ( CLICODE   CLIENT_MO.CLICODE%TYPE,
				             CLISIGLE  CLIENT_MO.CLISIGLE%TYPE,
				             CLILIB    CLIENT_MO.CLILIB%TYPE
					       );

TYPE mo_listeCurType IS REF CURSOR RETURN mo_ViewType;



PROCEDURE lister_mo( p_nomRechercheMo 	IN VARCHAR2,
   			         p_curseur 			IN OUT mo_listeCurType
                   );



TYPE codeCompta_liste_ViewType IS RECORD (  COMCODE CODE_COMPT.COMCODE%TYPE,
											COMLIB  CODE_COMPT.COMLIB%TYPE );


TYPE codeCompta_listeCurType IS REF CURSOR RETURN codeCompta_liste_ViewType;



PROCEDURE lister_codeCompta( d_nomRecherche IN VARCHAR2,
							 d_curseur		IN OUT codeCompta_listeCurType
                            );

TYPE codePresta_liste_ViewType IS RECORD (  CODEPRESTA PRESTATION.PRESTATION%TYPE,
											LIBPREST   PRESTATION.LIBPREST%TYPE );


TYPE codePresta_listeCurType IS REF CURSOR RETURN codePresta_liste_ViewType;



PROCEDURE lister_codePresta( d_nomRecherche IN VARCHAR2,
							 d_curseur		IN OUT codePresta_listeCurType
                            );



TYPE pid_ViewType IS RECORD ( CLICODE   LIGNE_BIP.PID%TYPE,
				              CLISIGLE  LIGNE_BIP.PNOM%TYPE
				            );

TYPE pid_listeCurType IS REF CURSOR RETURN pid_ViewType;



PROCEDURE lister_pid( p_nomRechercheMo 	IN VARCHAR2,
                      p_typeLigne    	IN VARCHAR2,
   			          p_curseur 	    IN OUT pid_listeCurType
                   );


-- -------------------------------------------------
--          Recherche Table de répartition
-- -------------------------------------------------
TYPE codrep_ViewType IS RECORD ( CODREP   RJH_TABREPART.CODREP%TYPE,
			              	     LIBREP   RJH_TABREPART.LIBREP%TYPE
				               );

TYPE codrep_listeCurType IS REF CURSOR RETURN codrep_ViewType;



PROCEDURE lister_codeTableRep( p_nomRechercheMo IN VARCHAR2,
                      		   p_userid    	    IN VARCHAR2,
   			          		   p_curseur 	    IN OUT codrep_listeCurType
                             );


-- -------------------------------------------------
--          Recherche Application
-- -------------------------------------------------
TYPE airt_ViewType IS RECORD ( AIRT   APPLICATION.AIRT%TYPE,
			              	   ALIBEL APPLICATION.ALIBEL%TYPE
				             );

TYPE airt_listeCurType IS REF CURSOR RETURN airt_ViewType;



PROCEDURE lister_appli( p_nomRecherche IN VARCHAR2,
			          	p_curseur 	   IN OUT airt_listeCurType
                      );



-- -------------------------------------------------
--          Recherche Contrat
-- -------------------------------------------------

TYPE RefCurTyp IS REF CURSOR;



PROCEDURE lister_contrat( p_typeContrat 	IN VARCHAR2,
		  				  					             p_soccont 	IN VARCHAR2,
														 p_nomRecherche IN VARCHAR2,
														 p_nomRessource IN VARCHAR2,
                      					                 p_contratEncours   IN VARCHAR2,
														 p_userid  IN VARCHAR2,
   			                                             p_curseur 	    IN OUT RefCurTyp
                                                        );


PROCEDURE lister_facture( p_typefacture	IN VARCHAR2,
		  				  					             p_socfact 	IN VARCHAR2,
														 p_nomRessource IN VARCHAR2,
														 p_contrat IN VARCHAR2,
                      					                 p_FactureEncours   IN VARCHAR2,
														 p_userid  IN VARCHAR2,
   			                                             p_curseur 	    IN OUT RefCurTyp
                                                        );



END Pack_Recup_Id;
/

CREATE OR REPLACE PACKAGE BODY Pack_Recup_Id AS


--*************************************************************************************************
-- Procédure lister_cdp
--
-- Sélectionne la liste des chefs de projets
--
-- ************************************************************************************************
PROCEDURE lister_cdp( p_nomRecherche 	IN VARCHAR2,
   			     p_curseur 	IN OUT cdp_listeCurType
                            ) IS

l_var      RESSOURCE.ident%TYPE;
l_msg           VARCHAR2(1024);

BEGIN
  BEGIN


temp := UPPER(p_nomRecherche) || '%';


	SELECT IDENT INTO l_var
           	 FROM RESSOURCE
           	 WHERE UPPER(RNOM) LIKE temp
			 AND ROWNUM < 2;

	OPEN p_curseur  FOR
           	 SELECT IDENT,RNOM, RPRENOM
           	 FROM RESSOURCE
           	 WHERE UPPER(RNOM) LIKE temp
			 AND ROWNUM < 100
			 ORDER BY RNOM ;


   	EXCEPTION

	  WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_cdp;




--*************************************************************************************************
-- Procédure lister_cdp
--
-- Sélectionne la liste des chefs de projets
--
-- ************************************************************************************************
PROCEDURE lister_societe( p_nomRechercheSociete 	IN VARCHAR2,
   			     s_curseur 	IN OUT societe_listeCurType
                            ) IS

l_var      SOCIETE.SOCCODE%TYPE;
l_msg           VARCHAR2(1024);

BEGIN
   	BEGIN


temp := UPPER(p_nomRechercheSociete) || '%';
temp1 := '% ' || UPPER(p_nomRechercheSociete) || '%';

     SELECT SOCCODE INTO  l_var
           	 FROM SOCIETE
			 WHERE
			 (	UPPER(SOCLIB) LIKE temp
			     OR UPPER(SOCLIB) LIKE temp1)
			    AND ROWNUM < 2;


	OPEN s_curseur  FOR
           	 SELECT SOCCODE, SOCLIB, SOCAD1, SOCAD2, DECODE(SOCFER,TO_DATE('','yyyy'),'OUVERTE','FERMEE')
           	 FROM SOCIETE
			 WHERE
			 (	UPPER(SOCLIB) LIKE temp
			     OR UPPER(SOCLIB) LIKE temp1)
			    AND ROWNUM < 100
			 ORDER BY SOCLIB ;


   	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_societe;





--*************************************************************************************************
-- Procédure lister_cdp_type
--
-- Sélectionne la liste des ressources selon leurs type
--
-- ************************************************************************************************
PROCEDURE lister_cdp_type( p_nomRecherche 	IN VARCHAR2,
                                                               p_rtype 	IN VARCHAR2,
   			                                                   p_curseur 	IN OUT cdp_listeCurType
                                                            ) IS
nbr  RESSOURCE.ident%TYPE;
l_msg           VARCHAR2(1024);

BEGIN
  BEGIN


temp := UPPER(p_nomRecherche) || '%';

    IF(p_rtype='A')THEN

	    SELECT r.ident INTO nbr
	  	       FROM RESSOURCE r
           	   WHERE UPPER(r.RNOM) LIKE temp
			  AND EXISTS (SELECT 1 FROM SITU_RESS_FULL s WHERE s.ident=r.ident AND s.soccode='SG..' AND (DATDEP IS NULL OR datdep>=SYSDATE) GROUP BY s.ident )
               AND R.RTYPE='P'
	           AND ROWNUM < 2;


		     OPEN p_curseur  FOR
           	        SELECT r.IDENT,r.RNOM, r.RPRENOM
           	     	FROM RESSOURCE r
           	   		WHERE UPPER(r.RNOM) LIKE temp
			   		AND EXISTS (SELECT 1 FROM SITU_RESS_FULL s WHERE s.ident=r.ident AND s.soccode='SG..' AND (DATDEP IS NULL OR datdep>=SYSDATE) GROUP BY s.ident )
               		AND R.RTYPE='P'
	           		AND ROWNUM < 100
			   		ORDER BY r.RNOM ;


	    ELSIF(p_rtype='F') OR (p_rtype='E')THEN


	       SELECT ident INTO nbr
		      FROM RESSOURCE
           	   WHERE UPPER(RNOM) LIKE temp
			   AND (RTYPE='F' OR RTYPE='E' )
			   AND ROWNUM < 2;


	          OPEN p_curseur  FOR
           	        SELECT IDENT,RNOM, RPRENOM
           	   		FROM RESSOURCE
           	   		WHERE UPPER(RNOM) LIKE temp
			   		AND (RTYPE='F' OR RTYPE='E' )
			   		AND ROWNUM < 100
			   		ORDER BY RNOM ;



	 ELSIF(p_rtype='P') THEN



			   SELECT r.ident INTO nbr
                FROM RESSOURCE r
                WHERE UPPER(r.RNOM) LIKE temp
                AND NOT EXISTS (SELECT 1 FROM SITU_RESS_FULL s WHERE s.ident=r.ident AND s.soccode='SG..' AND (DATDEP IS NULL OR datdep>=SYSDATE) GROUP BY s.ident )
                AND R.RTYPE='P'
                 AND ROWNUM < 2;


	          OPEN p_curseur  FOR
           	       SELECT r.IDENT,r.RNOM, r.RPRENOM
           	  	    FROM RESSOURCE r
           	   		WHERE UPPER(r.RNOM) LIKE temp
			   		AND r.RTYPE='P'
			    	AND NOT EXISTS (SELECT 1 FROM SITU_RESS_FULL s WHERE s.ident=r.ident AND s.soccode='SG..' AND (DATDEP IS NULL OR datdep>=SYSDATE) GROUP BY s.ident )
                    AND ROWNUM < 100
			   		ORDER BY RNOM ;


	  ELSIF p_rtype='L' THEN


	       SELECT ident INTO nbr
		      FROM RESSOURCE
           	   WHERE UPPER(RNOM) LIKE temp
			   AND RTYPE='L'
			   AND ROWNUM < 2;


	          OPEN p_curseur  FOR
           	         SELECT IDENT,RNOM, RPRENOM
		             FROM RESSOURCE
           	         WHERE UPPER(RNOM) LIKE temp
			        AND RTYPE='L'
			        AND ROWNUM < 100
			   		ORDER BY RNOM ;

		--agents SG et prestations
	ELSIF(p_rtype='R') THEN

			   SELECT r.ident INTO nbr
                FROM RESSOURCE r
                WHERE UPPER(r.RNOM) LIKE temp
				AND  EXISTS (SELECT 1 FROM SITU_RESS_FULL s WHERE s.ident=r.ident  AND (DATDEP IS NULL OR datdep>=SYSDATE) GROUP BY s.ident )
                 AND R.RTYPE='P'
                 AND ROWNUM < 2;


	          OPEN p_curseur  FOR
           	       SELECT r.IDENT,r.RNOM, r.RPRENOM
           	  	    FROM RESSOURCE r
           	   		WHERE UPPER(r.RNOM) LIKE temp
					AND EXISTS (SELECT 1 FROM SITU_RESS_FULL s WHERE s.ident=r.ident AND (DATDEP IS NULL OR datdep>=SYSDATE) GROUP BY s.ident )
			   		AND r.RTYPE='P'
					AND ROWNUM < 100
			     ORDER BY RNOM ;

	END IF;



   	EXCEPTION

	WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_cdp_type;







--*************************************************************************************************
-- Procédure lister_ca
--
-- Recherche les CA d'aprés le début d'un nom saisi
--
-- ************************************************************************************************
PROCEDURE lister_ca( p_nomRechercheCa 	IN VARCHAR2,
   		  			 					   		 p_cafidpg 	IN VARCHAR2,
   			     								 p_curseur 	IN OUT ca_listeCurType
                            					 ) IS

l_var      CENTRE_ACTIVITE.CODCAMO%TYPE;
l_msg           VARCHAR2(1024);

BEGIN
   	BEGIN

	temp := UPPER(p_nomRechercheCa) || '%';


	IF(p_cafidpg  = 'OUI' )THEN

	 			  SELECT a.CODCAMO INTO  l_var
          		   		  FROM CENTRE_ACTIVITE a
			 			  WHERE UPPER(a.CLIBRCA) LIKE temp
							  AND EXISTS (SELECT 1 FROM  STRUCT_INFO WHERE  CAFI=a.CODCAMO )
			 			  AND ROWNUM < 2;

				 OPEN  p_curseur   FOR
				          SELECT a.CODCAMO, a.CLIBRCA, a.CLIBCA
           	 			  FROM CENTRE_ACTIVITE a
			 			  WHERE UPPER(a.CLIBRCA) LIKE temp
						  AND EXISTS (SELECT 1 FROM  STRUCT_INFO WHERE  CAFI=a.CODCAMO )
			 			 AND ROWNUM <100
			 			  ORDER BY CLIBCA ;




	ELSE

       SELECT CODCAMO INTO l_var
           	 FROM CENTRE_ACTIVITE
			 WHERE UPPER(CLIBRCA) LIKE temp
			 AND ROWNUM < 2;

	OPEN  p_curseur   FOR
           	 SELECT CODCAMO, CLIBRCA, CLIBCA
           	 FROM CENTRE_ACTIVITE
			 WHERE UPPER(CLIBRCA) LIKE temp
			 AND ROWNUM < 100
			 ORDER BY CLIBCA ;

	 END IF;

   	EXCEPTION

	     WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_ca;


--*************************************************************************************************
-- Procédure lister_rubrique
--
-- Recherche les RUBRIQUES d'aprés le début d'un nom saisi
--
-- ************************************************************************************************
PROCEDURE lister_rubrique( p_nomRechercheRubrique 	IN VARCHAR2,
		  			 					           			p_curseur 	IN OUT rubrique_listeCurType
                                                 			) IS

l_var      CENTRE_ACTIVITE.CODCAMO%TYPE;
l_msg           VARCHAR2(1024);

BEGIN
   	BEGIN

	temp := UPPER( p_nomRechercheRubrique) || '%';



    SELECT r.codrub  INTO l_var
			 FROM RUBRIQUE r, CENTRE_ACTIVITE ca, TYPE_RUBRIQUE tr
			 WHERE ca.codcamo=r.CAFI
			 AND r.CODEP=tr.CODEP(+)
			 AND r.CODFEI=tr.CODFEI
			 AND UPPER(ca.clibrca) LIKE temp
			 AND ROWNUM < 2;

	OPEN  p_curseur   FOR
            SELECT r.codrub, r.codep || ' - ' || r.codfei || ' - ' || tr.librubst libelle, r.CAFI, ca.clibrca
			 FROM RUBRIQUE r, CENTRE_ACTIVITE ca, TYPE_RUBRIQUE tr
			 WHERE ca.codcamo=r.CAFI
			 AND r.CODEP=tr.CODEP(+)
			 AND r.CODFEI=tr.CODFEI
			 AND UPPER(ca.clibrca) LIKE temp
			AND ROWNUM < 100
			ORDER BY ca.CLIBCA ,  r.codfei;



   	EXCEPTION

	     WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_rubrique;



--*************************************************************************************************
-- Procédure lister_dpg
--
-- Sélectionne la liste des codes DPG
--
-- ************************************************************************************************
PROCEDURE lister_dpg( d_nomRecherche 	IN VARCHAR2,
   			     d_curseur 	IN OUT dpg_listeCurType
                            ) IS

l_var      STRUCT_INFO.CODSG%TYPE;
l_msg           VARCHAR2(1024);

BEGIN
  BEGIN


temp := UPPER(d_nomRecherche) || '%';


     SELECT CODSG INTO l_var
           	 FROM STRUCT_INFO
           	 WHERE UPPER(LIBDSG) LIKE temp
			 AND ROWNUM < 2;

	OPEN d_curseur  FOR
           	 SELECT CODSG,LIBDSG
           	 FROM STRUCT_INFO
           	 WHERE UPPER(LIBDSG) LIKE temp
			 AND ROWNUM < 100
			 ORDER BY LIBDSG ;


   	EXCEPTION
	     WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_dpg;

--*************************************************************************************************
-- Procédure lister_projet
--
-- Sélectionne la liste des codes Projet
--
-- ************************************************************************************************
PROCEDURE lister_projet( d_nomRecherche 	IN VARCHAR2,
   			     d_curseur 	IN OUT projet_listeCurType
                            ) IS

l_var      PROJ_INFO.ICPI%TYPE;
l_msg           VARCHAR2(1024);

BEGIN
  BEGIN


temp := UPPER(d_nomRecherche) || '%';


    SELECT ICPI INTO l_var
           	 FROM PROJ_INFO
           	 WHERE UPPER(ILIBEL) LIKE temp AND
			 ROWNUM < 2;

	OPEN d_curseur  FOR
           	 SELECT ICPI,ILIBEL
           	 FROM PROJ_INFO
           	 WHERE UPPER(ILIBEL) LIKE temp
			 AND ROWNUM < 100
			 ORDER BY ILIBEL ;


   	EXCEPTION

	  WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_projet;


--*************************************************************************************************

--*************************************************************************************************
-- Procédure lister_mo
--
-- Recherche les client d'après le libellé entré
--
-- ************************************************************************************************
PROCEDURE lister_mo( p_nomRechercheMo 	IN VARCHAR2,
   			         p_curseur       	IN OUT mo_listeCurType
                            ) IS

l_var      CLIENT_MO.CLICODE%TYPE;
l_msg           VARCHAR2(1024);

BEGIN
   	BEGIN


    temp := UPPER(p_nomRechercheMo) || '%';


	 SELECT CLICODE INTO l_var
           	 FROM CLIENT_MO
			 WHERE ( UPPER(CLILIB) LIKE temp
			         OR UPPER(CLISIGLE) LIKE temp)
			 AND CLITOPF ='O'
			 AND ROWNUM < 2;

	OPEN  p_curseur   FOR
           	 SELECT CLICODE, CLISIGLE, CLILIB
           	 FROM CLIENT_MO
			 WHERE ( UPPER(CLILIB) LIKE temp
			         OR UPPER(CLISIGLE) LIKE temp)
			 AND CLITOPF ='O'
			 AND ROWNUM < 100
			 ORDER BY CLISIGLE ;




   	EXCEPTION

	     WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_mo;



--*************************************************************************************************
-- Procédure lister_codeCompta
--
-- Sélectionne la liste des codes comptable
--
-- ************************************************************************************************
PROCEDURE lister_codeCompta( d_nomRecherche IN VARCHAR2,
							 d_curseur		IN OUT codeCompta_listeCurType
                            ) IS

l_var      RESSOURCE.ident%TYPE;
l_msg           VARCHAR2(1024);

BEGIN

	temp := UPPER(d_nomRecherche) || '%';

	SELECT COMCODE INTO l_var
          FROM CODE_COMPT
         WHERE UPPER(COMLIB) LIKE temp AND ROWNUM < 2;


	OPEN d_curseur  FOR
    	SELECT COMCODE, COMLIB
          FROM CODE_COMPT
         WHERE UPPER(COMLIB) LIKE temp AND ROWNUM < 100
	  ORDER BY COMCODE ;


EXCEPTION

     WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

	WHEN OTHERS THEN
   		RAISE_APPLICATION_ERROR( -20997, SQLERRM);


END lister_codeCompta;


--*************************************************************************************************
-- Procédure lister_codePresta
--
-- Sélectionne la liste des codes comptable
--
-- ************************************************************************************************
PROCEDURE lister_codePresta( d_nomRecherche IN VARCHAR2,
							 d_curseur		IN OUT codePresta_listeCurType
                            ) IS

l_var          PRESTATION.PRESTATION%TYPE;
l_msg        VARCHAR2(1024);

BEGIN

	temp := UPPER(d_nomRecherche) || '%';


	  SELECT PRESTATION INTO l_var
          FROM PRESTATION
         WHERE UPPER(LIBPREST) LIKE temp AND ROWNUM < 2
           AND TOP_ACTIF = 'O' ;

	OPEN d_curseur  FOR
    	SELECT PRESTATION, LIBPREST
          FROM PRESTATION
         WHERE UPPER(LIBPREST) LIKE temp AND ROWNUM < 100
           AND TOP_ACTIF = 'O'
		   AND ROWNUM<100
	  ORDER BY LIBPREST ;


EXCEPTION
	WHEN OTHERS THEN
   		RAISE_APPLICATION_ERROR( -20997, SQLERRM);


END lister_codePresta;



--*************************************************************************************************
-- Procédure lister_pid
--
-- Recherche les ligne bip d'après le libellé entré et le type de la ligne bip
--
-- ************************************************************************************************
PROCEDURE lister_pid(  p_nomRechercheMo 	IN VARCHAR2,
                      p_typeLigne    	IN VARCHAR2,
   			          p_curseur 	    IN OUT pid_listeCurType
                     ) IS

l_var         LIGNE_BIP.pid%TYPE;
l_msg        VARCHAR2(1024);

BEGIN
   	BEGIN


    temp := '%' ||UPPER( p_nomRechercheMo) || '%';


	IF(p_typeLigne = 'OUVERTES')THEN

   	    	 SELECT PID INTO l_var
			 FROM LIGNE_BIP
			 WHERE UPPER(PNOM) LIKE temp
			 AND TOPFER = 'N'
			 AND ADATESTATUT IS NULL
			 AND ROWNUM < 2;


		OPEN  p_curseur   FOR
	  		 SELECT PID, PNOM
			 FROM LIGNE_BIP
			 WHERE UPPER(PNOM) LIKE temp
			 AND TOPFER = 'N'
			 AND ADATESTATUT IS NULL
			  AND ROWNUM<100
			 ORDER BY PNOM;

    ELSE

	     SELECT PID INTO l_var
			 FROM LIGNE_BIP
			 WHERE UPPER(PNOM) LIKE temp
			 AND ROWNUM < 2;

		OPEN  p_curseur   FOR
			 SELECT PID, PNOM
			 FROM LIGNE_BIP
			 WHERE UPPER(PNOM) LIKE temp
			  AND ROWNUM<100
			 ORDER BY PNOM;

    END IF;

   	EXCEPTION

	    WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_pid;



--****************************************************************************************************************
-- Procédure lister_codeTableRep
--
-- Recherche les codes Table de répartition d'après le libellé entré et suivant le périmètre de l'utilisateur
--
--****************************************************************************************************************
PROCEDURE lister_codeTableRep( p_nomRechercheMo IN VARCHAR2,
                      		   p_userid    	    IN VARCHAR2,
   			          		   p_curseur 	    IN OUT codrep_listeCurType
                             ) IS
    l_perime VARCHAR2(255);
    l_dir    VARCHAR2(255);
	l_pos	 NUMBER;
	temp     VARCHAR2(20);
	l_var      RJH_TABREPART.CODREP%TYPE;
    l_msg           VARCHAR2(1024);

BEGIN
   	-- Récupérer le périmètre de l'utilisateur
   	l_perime := Pack_Global.lire_globaldata(p_userid).perime ;
	l_dir := '';

	-- On fait une boucle pour récupérer les codes directions qu'on met dans la variable
	-- l_dir qui sera ensuite testée
	WHILE (LENGTH(l_perime)>0)
	LOOP
		IF (LENGTH(l_dir) > 0) THEN
		    l_dir := l_dir||','||SUBSTR(l_perime,3,2);
		ELSE
			l_dir := SUBSTR(l_perime,3,2);
		END IF;
	    l_perime := SUBSTR(l_perime,13);
	END LOOP;


   	BEGIN
	    temp := '%' || UPPER(p_nomRechercheMo) || '%';


		 SELECT CODREP INTO l_var
			  FROM RJH_TABREPART
			 WHERE UPPER(LIBREP) LIKE temp
			   AND ( (INSTR(l_dir, coddir)>0) OR (INSTR(l_dir,'00')>0) )
			 AND ROWNUM < 2;

   	    OPEN  p_curseur   FOR
  		    SELECT CODREP, LIBREP
			  FROM RJH_TABREPART
			 WHERE UPPER(LIBREP) LIKE temp
			   AND ( (INSTR(l_dir, coddir)>0) OR (INSTR(l_dir,'00')>0) )
			   AND ROWNUM<100
			 ORDER BY LIBREP;

   	EXCEPTION

	    WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);
		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_codeTableRep;



-- -------------------------------------------------
--          Recherche Application
-- -------------------------------------------------
PROCEDURE lister_appli( p_nomRecherche IN VARCHAR2,
			          	p_curseur 	   IN OUT airt_listeCurType
                      ) IS
    l_perime VARCHAR2(255);
    l_dir    VARCHAR2(255);
	l_pos	 NUMBER;
	temp     VARCHAR2(20);
	l_var      APPLICATION.AIRT%TYPE;
    l_msg           VARCHAR2(1024);

BEGIN

   	BEGIN
	    temp := '%' || UPPER(p_nomRecherche) || '%';


		 SELECT AIRT INTO l_var
			  FROM APPLICATION
			 WHERE UPPER(ALIBEL) LIKE temp
			 AND ROWNUM < 2;

   	    OPEN  p_curseur   FOR
  		    SELECT AIRT, ALIBEL
			  FROM APPLICATION
			 WHERE UPPER(ALIBEL) LIKE temp
			 AND ROWNUM<100
			 ORDER BY ALIBEL;

   	EXCEPTION
	      WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		     RAISE_APPLICATION_ERROR( -20849,  l_msg);

		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;

END lister_appli;



--*************************************************************************************************
-- Procédure lister_contrat
--
--
-- ************************************************************************************************
PROCEDURE lister_facture( p_typefacture	IN VARCHAR2,
		  				  					             p_socfact 	IN VARCHAR2,
														 p_nomRessource IN VARCHAR2,
														 p_contrat IN VARCHAR2,
                      					                 p_FactureEncours   IN VARCHAR2,
														 p_userid  IN VARCHAR2,
   			                                             p_curseur 	    IN OUT RefCurTyp
                                                        ) IS

l_var         LIGNE_BIP.pid%TYPE;
l_msg        VARCHAR2(1024);
req  VARCHAR2(2000);
str               VARCHAR2(2000);
str1               VARCHAR2(2000);
tmp_req               VARCHAR2(800);
l_lst_codcfrais VARCHAR2(255);
cur	   RefCurTyp;
v_contrat VARCHAR2(15);
l_annee NUMBER;

BEGIN
 BEGIN


	l_lst_codcfrais := Pack_Global.lire_globaldata(p_userid).codcfrais;

     tmp_req := ' ';



IF(p_typeFacture IS NOT NULL )THEN
 			tmp_req := tmp_req || '  AND  f.typfact = '''|| p_typeFacture ||''' ';
 END IF;

 IF(LENGTH(l_lst_codcfrais ) <> 0) AND (l_lst_codcfrais IS NOT NULL ) AND (l_lst_codcfrais <> 0 )THEN
 			tmp_req := tmp_req || '  AND f.fcentrefrais = ''' || l_lst_codcfrais || ''' ';
  END IF;


 IF(LENGTH(p_socfact ) <> 0) AND (p_socfact IS NOT NULL )  THEN
 			tmp_req := tmp_req || '  AND upper(f.socfact) like ''' || UPPER(p_socfact) || ''' ';
 END IF;


  IF(p_factureEncours = 'OUI')  THEN
              SELECT EXTRACT(YEAR FROM SYSDATE) INTO l_annee FROM DUAL;
 			tmp_req := tmp_req ||  '  AND EXTRACT(YEAR FROM f.datfact) >= '|| l_annee ||'   ';
 END IF;


 IF(p_nomRessource IS NOT NULL)  AND (LENGTH(p_nomRessource) <> 0)THEN
           	tmp_req := tmp_req ||  '  AND upper(r.rnom) like ''' || UPPER(p_nomRessource) || '%'' ';
  END IF;

 IF(p_contrat IS NOT NULL)  AND (LENGTH(p_contrat) <> 0)THEN
           	tmp_req := tmp_req ||  '  AND upper(f.NUMCONT) like ''' || UPPER(p_contrat) || '%'' ';
  END IF;

  	   req   :=  req || '  FROM FACTURE f, LIGNE_FACT lf, RESSOURCE r ';
	   req   :=  req || '  WHERE lf.numfact =f.numfact ';
	   req   :=  req || '  AND lf.socfact=f.socfact ';
	   req   :=  req || '  AND lf.datfact=f.datfact ';
	   req   :=  req || '  AND lf.ident=r.ident ';
	   req   :=  req || '  AND rownum<100 ';
	   req   :=  req || tmp_req ;
	  -- req   :=  req || ' GROUP BY c.numcont, c.cav,r.rnom, c.cobjet1, TO_CHAR(c.cdatdeb,''dd/mm/yyyy''), TO_CHAR(c.cdatfin,''dd/mm/yyyy'') ';
	   req   :=  req || ' ORDER BY r.rnom, f.datfact desc,  f.numfact' ;



	  str := ' SELECT RTRIM(f.numfact), DECODE(f.typfact,''A'',''Avoir'',''F'',''FACTURE''), TO_CHAR(f.datfact,''dd/mm/yyyy''), r.rnom, r.rprenom, RTRIM(f.numcont) || '' - '' || f.cav '  || req;
	  str1 := ' SELECT f.numfact ' || req;

		OPEN cur FOR   str1;

		LOOP

		        FETCH cur INTO v_contrat;
				EXIT WHEN (cur%NOTFOUND) OR (cur%ROWCOUNT > 0);

		END LOOP;

		IF(cur%ROWCOUNT = 0)THEN
		       Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		       RAISE_APPLICATION_ERROR( -20849,  l_msg);
		END IF;



        OPEN p_curseur FOR   str;



   	EXCEPTION

	    WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		       RAISE_APPLICATION_ERROR( -20849,  l_msg);
		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_facture;





--*************************************************************************************************
-- Procédure lister_contrat
--
--
-- ************************************************************************************************
PROCEDURE lister_contrat( p_typeContrat 	IN VARCHAR2,
		  				  					             p_soccont 	IN VARCHAR2,
														 p_nomRecherche IN VARCHAR2,
														 p_nomRessource IN VARCHAR2,
                      					                 p_contratEncours   IN VARCHAR2,
														 p_userid  IN VARCHAR2,
   			                                             p_curseur 	    IN OUT RefCurTyp
                                                        )	IS

l_var         LIGNE_BIP.pid%TYPE;
l_msg        VARCHAR2(1024);
req  VARCHAR2(2000);
str               VARCHAR2(2000);
str1               VARCHAR2(2000);
tmp_req               VARCHAR2(800);
l_lst_codcfrais VARCHAR2(255);
cur	   RefCurTyp;
v_contrat VARCHAR2(15);

BEGIN
 BEGIN


	l_lst_codcfrais := Pack_Global.lire_globaldata(p_userid).codcfrais;

     tmp_req := ' ';


IF(p_typeContrat = 'avenant')THEN
 			tmp_req := tmp_req || '  AND c.cav <> ''00'' ';
 ELSIF (p_typeContrat = 'contrat')THEN
 	  	 	tmp_req := tmp_req || '  AND c.cav = ''00'' ';
 END IF;

 IF(LENGTH(l_lst_codcfrais ) <> 0) AND (l_lst_codcfrais IS NOT NULL ) AND (l_lst_codcfrais <> 0 )THEN
 			tmp_req := tmp_req || '  AND c.ccentrefrais = ''' || l_lst_codcfrais || ''' ';
  END IF;


 IF(LENGTH(p_soccont ) <> 0) AND (p_soccont IS NOT NULL )  THEN
 			tmp_req := tmp_req || '  AND upper(c.soccont) like ''' || UPPER(p_soccont) || ''' ';
 END IF;

  IF(p_contratEncours = 'OUI')  THEN
 			tmp_req := tmp_req ||  '  AND (c.cdatdeb < SYSDATE AND c.cdatfin > SYSDATE)  ';
 END IF;

 IF(LENGTH(p_nomRecherche) <> 0) AND (p_nomRecherche IS NOT NULL )  THEN
 			tmp_req := tmp_req || '  AND upper(c.cobjet1) like ''%' || UPPER(p_nomRecherche) || '%'' ';
 END IF;

 IF(p_nomRessource IS NOT NULL)  AND (LENGTH(p_nomRessource) <> 0)THEN
           	tmp_req := tmp_req ||  '  AND upper(r.rnom) like ''' || UPPER(p_nomRessource) || '%'' ';
  END IF;




       req   :=  req || '  FROM CONTRAT c, LIGNE_CONT lc, RESSOURCE r ';
       req   :=  req || '  WHERE lc.numcont =c.numcont ';
       req   :=  req || '  AND lc.soccont=c.soccont ';
       req   :=  req || '  AND lc.cav=c.cav ';
       req   :=  req || '  AND lc.ident=r.ident ';
	   req   :=  req || '  AND rownum<100 ';
	   req   :=  req || tmp_req ;
	   req   :=  req || ' GROUP BY c.numcont, c.cav,r.rnom, c.cobjet1, TO_CHAR(c.cdatdeb,''dd/mm/yyyy''), TO_CHAR(c.cdatfin,''dd/mm/yyyy'') ';
	   req   :=  req || ' ORDER BY r.rnom, c.numcont, c.cav desc ' ;


	    str := ' SELECT  rtrim(c.numcont), c.cav, r.rnom, c.cobjet1, to_char(c.cdatdeb,''dd/mm/yyyy''), to_char(c.cdatfin,''dd/mm/yyyy'')  ' || req;
		str1 := ' SELECT c.numcont ' || req;

		OPEN cur FOR   str1;

		LOOP

		        FETCH cur INTO v_contrat;
				EXIT WHEN (cur%NOTFOUND) OR (cur%ROWCOUNT > 0);

		END LOOP;

		IF(cur%ROWCOUNT = 0)THEN
		       Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		       RAISE_APPLICATION_ERROR( -20849,  l_msg);
		END IF;



        OPEN p_curseur FOR   str;



   	EXCEPTION

	    WHEN NO_DATA_FOUND THEN
	           Pack_Global.recuperer_message(20849, NULL,NULL,NULL, l_msg);
		       RAISE_APPLICATION_ERROR( -20849,  l_msg);
		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END lister_contrat;


END Pack_Recup_Id;
/
CREATE OR REPLACE PACKAGE Pack_Reestimes_Mass AS

FUNCTION str_reestimes 		(p_string     IN  VARCHAR2,
                           	 p_occurence  IN  NUMBER
                          	 ) RETURN VARCHAR2;

PROCEDURE select_reest_mass  	 (	p_codsg		IN  VARCHAR2,
   							 	 	p_clicode    IN VARCHAR2,
   									p_airt       IN VARCHAR2,
                               		p_userid       	IN  VARCHAR2,
                               		p_libcodsg	OUT STRUCT_INFO.libdsg%TYPE,
                               		p_libclicode OUT CLIENT_MO.clisigle%TYPE,
                               		p_libairt	 OUT APPLICATION.alibel%TYPE,
                               		p_nbpages	OUT VARCHAR2,
                               		p_numpage 	OUT VARCHAR2,
                               		p_nbcurseur	OUT INTEGER,
                               		p_message	OUT VARCHAR2
                             		 );

PROCEDURE update_reest_mass(  p_string    IN  VARCHAR2,
                              p_userid    IN  VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );
END Pack_Reestimes_Mass;
/

CREATE OR REPLACE PACKAGE BODY Pack_Reestimes_Mass AS


   FUNCTION str_reestimes (p_string     IN  VARCHAR2,
                           p_occurence  IN  NUMBER
                          ) RETURN VARCHAR2 IS
   pos1 NUMBER(6);
   pos2 NUMBER(6);
   str  VARCHAR2(111);

   BEGIN

      pos1 := INSTR(p_string,';',1,p_occurence);
      pos2 := INSTR(p_string,';',1,p_occurence+1);

      IF pos2 != 1 THEN
         str := SUBSTR( p_string, pos1+1, pos2-pos1-1);
         RETURN str;
      ELSE
         RETURN 1;
      END IF;

   END str_reestimes;

PROCEDURE select_reest_mass  (		p_codsg		IN VARCHAR2,
   							 		p_clicode    IN VARCHAR2,
   									p_airt       IN VARCHAR2,
                               		p_userid       	IN VARCHAR2,
                               		p_libcodsg	OUT STRUCT_INFO.libdsg%TYPE,
                               		p_libclicode OUT CLIENT_MO.clisigle%TYPE,
                               		p_libairt	 OUT APPLICATION.alibel%TYPE,
                               		p_nbpages	OUT VARCHAR2,
                               		p_numpage 	OUT VARCHAR2,
                               		p_nbcurseur	OUT INTEGER,
                               		p_message	OUT VARCHAR2
                              		) IS

      NB_LIGNES_MAXI 	NUMBER(4);
      NB_LIGNES_PAGES   NUMBER(2);
      l_msg	VARCHAR2(1024);
      l_nbpages	NUMBER(5);
      l_habilitation	VARCHAR2(10);
      l_codsg	VARCHAR2(10);
      l_perime	VARCHAR2(255);
      l_annee	NUMBER(4);



      BEGIN
      -- Nombres de lignes BIP retournées Maxis :
      NB_LIGNES_MAXI := 500;
      -- Nombre de lignes BIP maxi par pages
      NB_LIGNES_PAGES := 10;

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur := 1;
      p_message := '';

      -- Récupérer les périmètres de l'utilisateur
      l_perime := Pack_Global.lire_globaldata(p_userid).perime ;

      p_numpage := 'NumPage#1';



      -- ===================================================================
      -- Test existence et appartenance du DPG au périmètre de l'utilisateur
      -- ===================================================================
      	IF (p_codsg IS NOT NULL) AND (p_codsg != '*******') THEN
   		Pack_Habilitation.verif_habili_me(p_codsg, p_userid ,l_msg);
		IF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,3)||'%';
		ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
			l_codsg :=SUBSTR(LPAD(p_codsg, 7, '0'),1,5)||'%';
		ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) != '**' THEN
			l_codsg :=LPAD(p_codsg, 7, '0');
		END IF;
	END IF;



      -- =========================
      -- On récupère le lib du DPG
      -- =========================
      IF p_codsg IS NOT NULL THEN
      	IF p_codsg = '*******' THEN
      		p_libcodsg := 'Tout le Périmètre';
      	ELSE
      		-- On récupère le lib du DPG
      		BEGIN
      			IF SUBSTR(LPAD(p_codsg, 7, '0'),4,4) = '****' THEN
				SELECT sigdep INTO p_libcodsg FROM STRUCT_INFO
				WHERE TO_CHAR(codsg, 'FM0000000') LIKE l_codsg AND topfer='O' AND ROWNUM < 2;
			ELSIF SUBSTR(LPAD(p_codsg, 7, '0'),6,2) = '**' THEN
				SELECT sigdep || '/' || sigpole INTO p_libcodsg FROM STRUCT_INFO
				WHERE TO_CHAR(codsg, 'FM0000000') LIKE l_codsg AND topfer='O' AND ROWNUM < 2;
			ELSE
				SELECT libdsg INTO p_libcodsg FROM STRUCT_INFO
				WHERE TO_CHAR(codsg, 'FM0000000') = p_codsg AND topfer='O' AND ROWNUM < 2;
			END IF;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				Pack_Global.recuperer_message(20925, '%s1', p_codsg, 'codsg', l_msg);
	               		RAISE_APPLICATION_ERROR(-20925,l_msg);

			WHEN OTHERS THEN
	      			-- Message d'alerte Problème avec le libellé du DPG
	      			Pack_Global.recuperer_message(20738, '%s1', p_codsg, 'codsg', l_msg);
	               		RAISE_APPLICATION_ERROR(-20738,l_msg);
      		END;
      	END IF;
      END IF;


      IF p_clicode IS NOT NULL THEN
      	IF p_clicode = '*****' THEN
      		p_libclicode := 'Tout le Périmètre';
      	ELSE
      		-- On récupère le lib du clicode
      		p_libclicode := Pack_Utile3b.f_get_clisigle_climo(p_clicode);
      	END IF;
      END IF;


      IF (p_airt IS NULL) OR (p_airt='') THEN
   		  p_libairt := 'Tout le Périmètre';
      ELSE
      	  -- On récupère le lib de l'application
		  IF (Pack_Utile3b.f_verif_airt_application(p_airt)) THEN
			  BEGIN
			      SELECT alibel INTO p_libairt
				    FROM APPLICATION
				   WHERE airt = p_airt;
		      EXCEPTION
				  WHEN OTHERS THEN
				  	   p_libairt := '';
			  END;
		  ELSE
		  	  p_libairt := 'Code application inconnu';
          END IF;
      END IF;

      -- =======================================
      -- On récupère le nombre de lignes
      -- =======================================
	SELECT TO_NUMBER(TO_CHAR (DATDEBEX, 'YYYY'))
	INTO l_annee
	FROM DATDEBEX
	WHERE ROWNUM < 2;


      -- Si c'est un code ME = *******
      IF (p_codsg IS NOT NULL) AND (p_codsg = '*******') THEN
      	BEGIN
            -- Compte le nombre de lignes et test si on a des pid
             SELECT COUNT(*)
             INTO   l_nbpages
             FROM     LIGNE_BIP,CONSOMME conso,BUDGET budg,DATDEBEX, vue_dpg_perime vdp
             WHERE    conso.pid(+) = LIGNE_BIP.pid
	     AND      budg.pid(+) = LIGNE_BIP.pid
	     AND      conso.annee(+) = l_annee
	     AND      budg.annee(+) = l_annee
	     AND      ((LIGNE_BIP.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(LIGNE_BIP.adatestatut,'YYYY')) >= l_annee))
             AND       LIGNE_BIP.codsg = vdp.codsg
             AND       INSTR(l_perime, vdp.codbddpg) > 0;
	     -- inutile de tester SQL%NOTFOUND car fonction de groupe renvoie toujours soit NULL, soit une valeur

	     IF (l_nbpages = 0) THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);
             ELSIF (l_nbpages > NB_LIGNES_MAXI) THEN
               Pack_Global.recuperer_message( 20381 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20381 , l_msg);
             END IF;

             l_nbpages := CEIL(l_nbpages/NB_LIGNES_PAGES);
             p_nbpages := 'NbPages#'|| l_nbpages;
      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;


     -- Si c'est un code ME != *******
     ELSIF (p_codsg IS NOT NULL) THEN
      	BEGIN
            -- Compte le nombre de lignes et test si on a des pid
             SELECT COUNT(*)
             INTO   l_nbpages
	     FROM     LIGNE_BIP lb, CONSOMME conso,BUDGET budg
             WHERE    conso.pid(+) = lb.pid
             AND      budg.pid(+) = lb.pid
	     AND      conso.annee(+) = l_annee
	     AND      budg.annee(+) = l_annee
	     AND      TO_CHAR(lb.codsg, 'FM0000000') LIKE l_codsg
	     AND   ((lb.adatestatut IS NULL) OR (TO_NUMBER(TO_CHAR(lb.adatestatut,'YYYY')) >= l_annee))
		 ;
	     -- inutile de tester SQL%NOTFOUND car fonction de groupe renvoie toujours soit NULL, soit une valeur

	     IF (l_nbpages = 0) THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);
             ELSIF (l_nbpages > NB_LIGNES_MAXI) THEN
               Pack_Global.recuperer_message( 20381 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20381 , l_msg);
             END IF;

             l_nbpages := CEIL(l_nbpages/NB_LIGNES_PAGES);
             p_nbpages := 'NbPages#'|| l_nbpages;
      	EXCEPTION
           WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message( 20373 , '%s1', p_codsg, 'codsg', l_msg);
               RAISE_APPLICATION_ERROR(-20373 , l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      	END;
     END IF;

     p_message := l_msg;

  END select_reest_mass;


PROCEDURE update_reest_mass(	p_string    IN  VARCHAR2,
                              	p_userid    IN  VARCHAR2,
                              	p_nbcurseur OUT INTEGER,
                              	p_message   OUT VARCHAR2
                             ) IS

   l_msg    VARCHAR2(10000);
   l_cpt    NUMBER(7);

   l_pid    LIGNE_BIP.pid%TYPE;
   l_preesancou BUDGET.reestime%TYPE;
   l_flaglock   BUDGET.flaglock%TYPE;
   l_datdebex NUMBER(4);
   l_user		LIGNE_BIP_LOGS.user_log%TYPE;
   l_reestime   BUDGET.reestime%TYPE;
   l_tr_flag NUMBER;
   l_tr NUMBER;
    msg           	VARCHAR2(1024);


   BEGIN


      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message   := '';
      l_cpt       := 1;



 l_user := SUBSTR(Pack_Global.lire_globaldata(p_userid).idarpege, 1, 30);


	SELECT TO_NUMBER(TO_CHAR(DATDEBEX,'YYYY')) INTO l_datdebex FROM DATDEBEX;

      WHILE l_cpt != 0 LOOP

         l_pid := Pack_Reestimes_Mass.str_reestimes(p_string,l_cpt);
         l_flaglock   := TO_NUMBER(Pack_Reestimes_Mass.str_reestimes(p_string,l_cpt+1));
       	 l_preesancou := TO_NUMBER(Pack_Reestimes_Mass.str_reestimes(p_string,l_cpt+2), 'FM9999999999D00');

         IF l_pid != '0' THEN


		   SELECT COUNT(*) INTO l_tr
		     FROM BUDGET
             WHERE  pid = l_pid
			 AND annee = l_datdebex;


			IF  (l_tr!=0) THEN

			       SELECT reestime INTO l_reestime
		             FROM BUDGET
                    WHERE  pid = l_pid
			        AND annee = l_datdebex;

			   END IF;


          UPDATE BUDGET SET reestime = l_preesancou
	      WHERE pid = l_pid
	      AND annee = l_datdebex;



	    IF (SQL%NOTFOUND) AND (l_preesancou>0) THEN

	    	INSERT INTO BUDGET (annee, bpdate, reestime, flaglock, pid)
	    	VALUES (l_datdebex, SYSDATE, l_preesancou, 0 , l_pid);

		              Pack_Ligne_Bip.maj_ligne_bip_logs(l_pid, l_user, 'Réestimé ' || l_datdebex, NULL, l_preesancou, 'Saisie en masse/Mes_lignes_réestimé');

	   ELSE

	        		Pack_Ligne_Bip.maj_ligne_bip_logs(l_pid, l_user, 'Réestimé ' || l_datdebex,  l_reestime, l_preesancou, 'Saisie en masse/Mes_lignes_réestimé');

	    END IF;


            l_cpt := l_cpt + 3;

         ELSE
            l_cpt :=0;
         END IF;

      END LOOP;

     Pack_Global.recuperer_message( 20972 , '%s1', 'Réestimé', '', p_message);

   END update_reest_mass;

END Pack_Reestimes_Mass;
/
CREATE OR REPLACE PACKAGE Pack_Rees_Bip AS

   TYPE rees_RecType IS RECORD (pid        LIGNE_BIP.pid%TYPE,
                                pnom       LIGNE_BIP.pnom%TYPE,
                                codsg      VARCHAR2(20),
                                xcusag0    VARCHAR2(20),
                                bnmont     VARCHAR2(20),
                                preesancou VARCHAR2(20),
				estimpluran VARCHAR2(20),
                                flaglock   BUDGET.flaglock%TYPE,
				flag       LIGNE_BIP.flaglock%TYPE
                               );


   TYPE reesCurType IS REF CURSOR RETURN rees_RecType;

   PROCEDURE update_rees_bip (p_pid         IN  LIGNE_BIP.pid%TYPE,
                              p_pnom        IN  LIGNE_BIP.pnom%TYPE,
                              p_codsg       IN  VARCHAR2,
                              p_xcusag0     IN VARCHAR2,
                              p_bnmont      IN  VARCHAR2,
                              p_preesancou  IN  VARCHAR2,
                              p_estimpluran IN  VARCHAR2,
			      p_flag        IN NUMBER,
                              p_flaglock    IN  NUMBER,
                              p_userid      IN  VARCHAR2,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             );


   PROCEDURE select_rees_bip (p_pid       IN LIGNE_BIP.pid%TYPE,
                              p_userid    IN VARCHAR2,
                              p_currees   IN OUT reesCurType,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             );

END Pack_Rees_Bip;
/

CREATE OR REPLACE PACKAGE BODY Pack_Rees_Bip AS

-- *********************************************************************
--  update_rees_bip
-- *********************************************************************

   PROCEDURE update_rees_bip (p_pid         IN  LIGNE_BIP.pid%TYPE,
                              p_pnom        IN  LIGNE_BIP.pnom%TYPE,
                              p_codsg       IN  VARCHAR2,
                              p_xcusag0     IN VARCHAR2,
                              p_bnmont      IN  VARCHAR2,
                              p_preesancou  IN  VARCHAR2,
                              p_estimpluran IN  VARCHAR2,
			                  p_flag        IN NUMBER,
                              p_flaglock    IN  NUMBER,
                              p_userid      IN  VARCHAR2,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             ) IS

   l_msg          			 VARCHAR2(1024);
   l_datdebex 			NUMBER(4);
   l_bud_rst               BUDGET.reestime%TYPE;
   l_estimplurian      LIGNE_BIP.estimplurian%TYPE;
   l_user		              LIGNE_BIP_LOGS.user_log%TYPE;
   l_count                   NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


	  SELECT TO_NUMBER(TO_CHAR(DATDEBEX,'YYYY')) INTO l_datdebex FROM DATDEBEX;

	  --n recupere l'ancien réestimé




	   BEGIN

	        SELECT COUNT(*)
            INTO  l_count
            FROM BUDGET
            WHERE pid = p_pid
            AND   annee =  l_datdebex;

			IF(l_count != 0)THEN


		   	   BEGIN
               		SELECT  NVL(TO_CHAR(reestime, 'FM9999999990D00'), ',00')
            		INTO  l_bud_rst
            		FROM BUDGET
           			 WHERE pid = p_pid
           			  AND   annee =  l_datdebex
					  AND flaglock=p_flaglock;

         			  EXCEPTION


            		  WHEN NO_DATA_FOUND  THEN

              		   -- 'Accès concurrent'

               		   	  		 Pack_Global.recuperer_message( 20999, NULL, NULL,
                                         				 		     NULL, l_msg);
               					RAISE_APPLICATION_ERROR( -20999, l_msg);

            			WHEN OTHERS THEN
               				 RAISE_APPLICATION_ERROR( -20997, SQLERRM);

               END;

		    END IF;

		 END;



      BEGIN


      l_user := SUBSTR(Pack_Global.lire_globaldata(p_userid).idarpege, 1, 30);



         UPDATE BUDGET SET reestime = TO_NUMBER(p_preesancou),
                              flaglock   = DECODE( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  pid = p_pid
	    AND annee = l_datdebex;
        --AND    flaglock = p_flaglock;



      EXCEPTION

        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM );
      END;


	IF SQL%NOTFOUND THEN

		INSERT INTO BUDGET ( 	ANNEE,
 					PID,
 					BNMONT,
 					BPMONTME,
 					BPMONTME2,
 					ANMONT,
 					BPDATE,
 					RESERVE,
 					APDATE,
 					APMONT,
 					BPMONTMO,
 					REESTIME,
 					FLAGLOCK)
			VALUES 	(l_datdebex,
				 p_pid,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 NULL,
				 TO_NUMBER(p_preesancou,'FM9999999990D00'),
				 0);

			 -- On loggue le réestimé insert
            Pack_Ligne_Bip.maj_ligne_bip_logs(p_pid, l_user, 'Réestimé ' || l_datdebex, NULL,TO_NUMBER(p_preesancou,'FM9999999990D00'), 'Par Ligne/Réestimé/Modification du réestimé');

	ELSE

	        -- On loggue le réestimé updat
             Pack_Ligne_Bip.maj_ligne_bip_logs(p_pid, l_user, 'Réestimé ', l_bud_rst, p_preesancou, 'Par Ligne/Réestimé/Modification du réestimé');


	END IF;


	BEGIN


	  BEGIN

          SELECT estimplurian INTO l_estimplurian
		  FROM LIGNE_BIP
          WHERE  pid = p_pid
         AND    flaglock = p_flag;

         EXCEPTION
            WHEN NO_DATA_FOUND THEN

               -- 'Accès concurrent'

               Pack_Global.recuperer_message( 20999, NULL, NULL,
                                              NULL, l_msg);
               RAISE_APPLICATION_ERROR( -20999, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         UPDATE LIGNE_BIP SET estimplurian = TO_NUMBER(p_estimpluran,'FM9999999990D00'),
                              flaglock   = DECODE( p_flag, 1000000, 0, p_flag + 1)
         WHERE  pid = p_pid
         AND    flaglock = p_flag;

		  -- On loggue le Estimation pluriannuelle
          Pack_Ligne_Bip.maj_ligne_bip_logs(p_pid, l_user, 'Estimation pluriannuelle ', l_estimplurian,TO_NUMBER(p_estimpluran,'FM9999999990D00'), 'Par Ligne/Réestimé/Modification du réestimé');

      EXCEPTION

        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM );
      END;

   END update_rees_bip;


-- *********************************************************************
--  select_rees_bip
-- *********************************************************************

   PROCEDURE select_rees_bip (p_pid       IN LIGNE_BIP.pid%TYPE,
                              p_userid    IN VARCHAR2,
                              p_currees   IN OUT reesCurType,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                             ) IS

      msg           	VARCHAR2(1024);
      l_codsg         	LIGNE_BIP.codsg%TYPE;
      l_year_courante 	BUDGET.annee%TYPE;
      l_ges           	NUMBER(3);
      l_habilitation  	VARCHAR2(10);
      l_statut 		VARCHAR2(56);
      l_date_statut 	VARCHAR2(10);
      l_topfer 		CHAR(1);
      l_datdebex 	VARCHAR2(10);
      l_date_statut_number NUMBER(10);
      l_menu 		VARCHAR2(255);



   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
     -- p_message := '';


	l_menu := Pack_Global.lire_globaldata(p_userid).menutil;


      -- TEST d'habilitation

      BEGIN
         SELECT codsg
         INTO   l_codsg
         FROM   LIGNE_BIP
         WHERE  pid = p_pid;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            Pack_Global.recuperer_message( 20504, '%s1', p_pid, NULL, msg);
            RAISE_APPLICATION_ERROR( -20504, msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- ====================================================================
      -- 19/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ligne BIP, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier cette ligne BIP, son DPG est '||l_codsg, 'PID', msg);
                RAISE_APPLICATION_ERROR(-20365, msg);
	END IF;


	-- test de la date statut
	IF (l_menu <> 'DIR') THEN
		SELECT TO_CHAR(adatestatut,'DD/MM/YYYY'),NVL(astatut,'Pas de statut'),topfer INTO l_date_statut,l_statut,l_topfer
		FROM LIGNE_BIP WHERE pid = p_pid;

		SELECT TO_NUMBER(TO_CHAR(adatestatut,'YYYY')) INTO l_date_statut_number
		FROM LIGNE_BIP WHERE pid = p_pid;


		SELECT TO_NUMBER(TO_CHAR(DATDEBEX,'YYYY')) INTO l_datdebex FROM DATDEBEX;


		IF ((l_date_statut IS NOT NULL) AND (l_date_statut_number < l_datdebex)) THEN
		RAISE_APPLICATION_ERROR (-20000,'Vous ne pouvez pas modifier la ligne bip ' || p_pid ||
					' car son statut est ' || l_statut ||
					', son top fermeture est ' || l_topfer ||
					' et sa date de statut ou de top fermeture est ' || l_date_statut);
		END IF;
	END IF;

      -- Annee courante

      SELECT TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'),'9999')
      INTO   l_year_courante
      FROM   DATDEBEX;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN

	 OPEN p_currees FOR
	   SELECT LIGNE_BIP.pid,
	     LIGNE_BIP.pnom,
	     TO_CHAR(LIGNE_BIP.codsg),
	     NVL(TO_CHAR(conso.cusag,'FM999999990D00'),'0,00'),
	     NVL(TO_CHAR(budg.bnmont,'FM999999990D00'),'0,00'),
	     NVL(TO_CHAR(budg.reestime,'FM999999990D00'),'0,00'),
	     NVL(TO_CHAR(LIGNE_BIP.estimplurian,'FM999999990D00'),'0,00'),
	     NVL(budg.flaglock,0),
	     LIGNE_BIP.flaglock
	     FROM   LIGNE_BIP, BUDGET budg, CONSOMME conso
	     WHERE  LIGNE_BIP.pid      = p_pid
	     AND    LIGNE_BIP.pid   = budg.pid(+)
	     AND    LIGNE_BIP.pid   = conso.pid(+)
	     AND    budg.annee(+) = l_year_courante
	     AND    conso.annee(+) = l_year_courante;
      EXCEPTION
         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20997,SQLERRM);
      END;

      -- en cas absence
      -- p_message := ;

      Pack_Global.recuperer_message(5010, NULL, NULL, NULL, msg);
     -- p_message := msg;

   END select_rees_bip;

END Pack_Rees_Bip;
/
CREATE OR REPLACE PACKAGE pack_ree_detail AS
-----------------------------------------


------------------------------------------------------------------------------
-- Constantes globales
------------------------------------------------------------------------------



------------------------------------------------------------------------------
-- Types et Curseurs
------------------------------------------------------------------------------

    -- ------------------------------------------------------------------------
    --le type tableau_numerique définit un tableau de NUMBER
    -- ------------------------------------------------------------------------


    TYPE tableau_numerique IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;





------------------------------------------------------------------------------
-- Les Fonctions
------------------------------------------------------------------------------

-- ------------------------------------------------------------------------
   -- Nom        : tmp_ree_detail_seq
   -- Auteur     : BAA
   -- Decription : mise a jour de la table tmp_reee_detail  a partir des tables
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION tmp_ree_detail_seq (p_codsg IN ligne_bip.codsg%TYPE,
				                p_code_scenario  IN ree_scenarios.code_scenario%TYPE
				               ) RETURN NUMBER;


-- ------------------------------------------------------------------------
   -- Nom        : consom_reestime
   -- Auteur     : BAA
   -- Decription : renvoi la somme des consomes reestimer
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_code_activite  (IN) code de l'activite
   --              p_ident  (IN) identifiant de la ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   --              p_mois  (IN) le numero du mois
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     FUNCTION consom_reestime(p_codsg 	IN ligne_bip.codsg%TYPE,
				            p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							p_code_activite IN ree_activites.code_activite%TYPE,
							p_ident IN ree_ressources.ident%TYPE,
							p_typer IN ree_ressources.type%TYPE,
							p_moismens IN DATE,
							p_mois IN NUMBER
				            ) RETURN NUMBER;


-- ------------------------------------------------------------------------
   -- Nom        : consom_realiser
   -- Auteur     : BAA
   -- Decription : renvoi la somme des consomes realiser
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_activite  (IN) code de l'activite
   --              p_ident  (IN) identifiant de la ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   --              p_mois  (IN) le numero du mois
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     FUNCTION consom_realiser(p_codsg 	IN ligne_bip.codsg%TYPE,
				              p_code_activite IN ree_activites.code_activite%TYPE,
							  p_ident IN ree_ressources.ident%TYPE,
							  p_moismens IN DATE,
							  p_mois IN NUMBER
				            ) RETURN NUMBER;



-- ------------------------------------------------------------------------
   -- Nom        : consom_realiser_absence
   -- Auteur     : BAA
   -- Decription : renvoi la somme des consomes realiser pour l'activite absences
   --
   -- Paramètres : p_ident  (IN) identifiant de la ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   --              p_mois  (IN) le numero du mois
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     FUNCTION consom_realiser_absences(p_ident IN ree_ressources.ident%TYPE,
	 		  						   p_moismens IN DATE,
							           p_mois IN NUMBER
				                       ) RETURN NUMBER;



-- ------------------------------------------------------------------------
   -- Nom        : consom_realiser_fournie
   -- Auteur     : BAA
   -- Decription : renvoi la somme des consomes realiser pour l'activite ss fournie
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_activite  (IN) code de l'activite
   --              p_ident  (IN) identifiant de la ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   --              p_mois  (IN) le numero du mois
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     FUNCTION consom_realiser_fournie(p_codsg 	IN ligne_bip.codsg%TYPE,
				              p_ident IN ree_ressources.ident%TYPE,
							  p_moismens IN DATE,
							  p_mois IN NUMBER
				            ) RETURN NUMBER;




-- ------------------------------------------------------------------------
   -- Nom        : consom_realiser_recu
   -- Auteur     : BAA
   -- Decription : renvoi la somme des consomes realiser pour la ressource reçue
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_activite  (IN) code de l'activite
   --              p_moismens  (IN) le moismens de la table datdebex
   --              p_mois  (IN) le numero du mois
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     FUNCTION consom_realiser_recu(p_codsg 	IN ligne_bip.codsg%TYPE,
   								   p_code_activite IN ree_activites.code_activite%TYPE,
				                   p_moismens IN DATE,
							       p_mois IN NUMBER
				                  ) RETURN NUMBER;



-- ------------------------------------------------------------------------
   -- Nom        : consom
   -- Auteur     : BAA
   -- Decription : renvoi la somme des consomes realiser par code d'activite
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_code_activite  (IN) code de l'activite
   --			   p_typea (IN) type de l'activite
   --              p_ident  (IN) identifiant de la ressource
   --			   p_typeb (IN) type de l'a ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   --              p_mois (IN) le numero du mois
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


   FUNCTION consom(p_codsg 	IN ligne_bip.codsg%TYPE,
				   p_code_scenario IN ree_scenarios.code_scenario%TYPE,
				   p_code_activite IN ree_activites.code_activite%TYPE,
				   p_typea IN ree_activites.type%TYPE,
				   p_ident IN ree_ressources.ident%TYPE,
				   p_typer IN ree_ressources.type%TYPE,
				   p_moismens IN DATE,
				   p_mois IN NUMBER
				   ) RETURN NUMBER;




-- ------------------------------------------------------------------------
   -- Nom        : total_realiser
   -- Auteur     : BAA
   -- Decription : renvoi le total des sommes des consomes realiser par code d'activite
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_code_activite  (IN) code de l'activite
   --			   p_typea (IN) type de l'activite
   --              p_ident  (IN) identifiant de la ressource
   --			   p_typeb (IN) type de l'a ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


   FUNCTION total_realiser(p_codsg 	IN ligne_bip.codsg%TYPE,
				   p_code_scenario IN ree_scenarios.code_scenario%TYPE,
				   p_code_activite IN ree_activites.code_activite%TYPE,
				   p_typea IN ree_activites.type%TYPE,
				   p_ident IN ree_ressources.ident%TYPE,
				   p_typer IN ree_ressources.type%TYPE,
				   p_moismens IN DATE
				   ) RETURN NUMBER;



-- ------------------------------------------------------------------------
   -- Nom        : total_reestimer
   -- Auteur     : BAA
   -- Decription : renvoi le total des sommes des consomes reestimer par code d'activite
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_code_activite  (IN) code de l'activite
   --			   p_typea (IN) type de l'activite
   --              p_ident  (IN) identifiant de la ressource
   --			   p_typeb (IN) type de l'a ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


   FUNCTION total_reestimer(p_codsg 	IN ligne_bip.codsg%TYPE,
				   p_code_scenario IN ree_scenarios.code_scenario%TYPE,
				   p_code_activite IN ree_activites.code_activite%TYPE,
				   p_typea IN ree_activites.type%TYPE,
				   p_ident IN ree_ressources.ident%TYPE,
				   p_typer IN ree_ressources.type%TYPE,
				   p_moismens IN DATE
				   ) RETURN NUMBER;

   -- ------------------------------------------------------------------------
   -- Nom        : total_realiser_t
   -- Auteur     : BAA
   -- Decription : renvoi le total des sommes des consomes realiser par code d'activite
   --
   -- Paramètres : p_1 de p_12 (IN) est la somme des consommé realisé pour chaque mois p_i pour le mois i
   --              p_moismens  (IN) le moismens de la table datdebex
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------

	FUNCTION total_realiser_t(p_1 IN NUMBER,p_2 IN NUMBER,
							  p_3 IN NUMBER,p_4 IN NUMBER,
							  p_5 IN NUMBER,p_6 IN NUMBER,
							  p_7 IN NUMBER,p_8 IN NUMBER,
							  p_9 IN NUMBER,p_10 IN NUMBER,
							  p_11 IN NUMBER,p_12 IN NUMBER,
							  p_moismens IN DATE
							  ) RETURN NUMBER;


   -- ------------------------------------------------------------------------
   -- Nom        : total_reestimer_t
   -- Auteur     : BAA
   -- Decription : renvoi le total des sommes des consomes reestimer par code d'activite
   --
   -- Paramètres : p_1 de p_12 (IN) est la somme des consommé reestimer pour chaque mois p_i pour le mois i
   --              p_moismens  (IN) le moismens de la table datdebex
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------

    FUNCTION total_reestimer_t(p_1 IN NUMBER,p_2 IN NUMBER,
	      	 				   p_3 IN NUMBER,p_4 IN NUMBER,
							   p_5 IN NUMBER,p_6 IN NUMBER,
							   p_7 IN NUMBER,p_8 IN NUMBER,
							   p_9 IN NUMBER,p_10 IN NUMBER,
							   p_11 IN NUMBER,p_12 IN NUMBER,
							   p_moismens IN DATE
							   ) RETURN NUMBER;



-- ------------------------------------------------------------------------
   -- Nom        : total_reestimer
   -- Auteur     : BAA
   -- Decription : renvoi le total des sommes des consomes reestimer par code d'activite
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_code_activite  (IN) code de l'activite
   --			   p_typea (IN) type de l'activite
   --              p_ident  (IN) identifiant de la ressource
   --			   p_typeb (IN) type de l'a ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


   FUNCTION nombre_jour(p_mois 	IN CHAR,
				        p_moismens IN DATE
				       ) RETURN NUMBER;




------------------------------------------------------------------------------
-- Les Procédures
------------------------------------------------------------------------------


END pack_ree_detail;
/

CREATE OR REPLACE PACKAGE BODY pack_ree_detail AS


-- Decription : ajout dans la table tmp_reee_detail les données necessaire pour
--              les editions detail a partir des tables

 FUNCTION tmp_ree_detail_seq (p_codsg IN ligne_bip.codsg%TYPE,
				              p_code_scenario  IN ree_scenarios.code_scenario%TYPE
				              ) RETURN NUMBER IS


        l_var_seq NUMBER; -- numero de sequence
        EXISTE_TYPE VARCHAR2(3);
		v_CODSG NUMBER(7);
		v_LIBDSG VARCHAR2(40);
		v_CODE_SCENARIO VARCHAR2(12);
		v_LIB_SCENARIO VARCHAR2(60);
		v_MOISMENS DATE;
		v_IDENT NUMBER(5);
		v_NOM VARCHAR2(30);
		v_PRENOM VARCHAR2(15);
		v_DATDEP DATE;
		v_TYPEA VARCHAR2(1);
		v_TYPER VARCHAR2(1);
		v_CODE_ACTIVITE VARCHAR2(12);
		v_LIB_ACTIVITE VARCHAR2(60);

		Tab_mois   tableau_numerique; --tableaux qui va contenir les sommes des consomé et realiser pour chaque mois
		R NUMBER; -- la somme du consommé realiser et reestimer
		T NUMBER; -- la somme du consommé realiser et reestimer


      --on recupere toutes les ressources et leurs activites pour un odsg

      cursor l_c_a(c_codsg CHAR,c_code_scenario CHAR) IS
	   SELECT
       	RR.CODSG CODSG,
       	SI.LIBDSG LIBDSG,
       	RS.CODE_SCENARIO CODE_SCENARIO,
       	RS.LIB_SCENARIO LIB_SCENARIO,
       	D.MOISMENS MOISMENS,
	   	RR.IDENT IDENT,
	   	RR.RNOM NOM,
	   	RR.RPRENOM PRENOM,
	   	RR.DATDEP DATDEP,
	   	RR.TYPE TYPER,
		RA.CODE_ACTIVITE CODE_ACTIVITE,
		RA.LIB_ACTIVITE LIB_ACTIVITE,
		RA.TYPE TYPEA
	   FROM
         REE_RESSOURCES RR,
	     REE_ACTIVITES RA,
	     REE_SCENARIOS RS,
	     STRUCT_INFO SI,
	     DATDEBEX D
	  WHERE
         RR.CODSG=c_codsg
	     and RA.CODSG=RR.CODSG
	     and SI.CODSG=RR.CODSG
	     and RS.CODSG=RR.CODSG
	     and RS.CODE_SCENARIO=c_code_scenario
     ORDER BY NOM,CODE_ACTIVITE;



   BEGIN


     BEGIN

      --Création automatique ressource de type S pour le DPG s'il n'existe pas
	  SELECT 'OUI' INTO EXISTE_TYPE FROM REE_RESSOURCES WHERE CODSG=p_codsg AND TYPE='S';

      EXCEPTION

			 WHEN No_Data_Found THEN

				 EXISTE_TYPE := 'NON';

        END;

      IF(EXISTE_TYPE = 'NON')THEN

              INSERT INTO REE_RESSOURCES(CODSG,TYPE,IDENT,RNOM) VALUES(p_codsg,'S',2,'SST RECUE');
      END IF;



      SELECT sdetail.nextval INTO l_var_seq FROM dual; --creation de la sequence


      OPEN l_c_a(p_codsg,p_code_scenario);

      LOOP

	  fetch l_c_a  INTO v_CODSG, v_LIBDSG, v_CODE_SCENARIO, v_LIB_SCENARIO, v_MOISMENS, v_IDENT, v_NOM, v_PRENOM, v_DATDEP, v_TYPER, v_CODE_ACTIVITE, v_LIB_ACTIVITE, v_TYPEA;

	 IF l_c_a%NOTFOUND THEN
	    EXIT;
	 END IF;

 	  --on recupere toutes les consomés de chaque mois pour une ressource
	  --et une activite et on les stock dans un tanleaux
	  FOR i in 1..12 LOOP

	 Tab_mois(i):=consom(v_CODSG,v_CODE_SCENARIO,v_CODE_ACTIVITE,v_TYPEA,v_IDENT,v_TYPER,v_MOISMENS,i);

	 END LOOP;

	 R := total_realiser_t(Tab_mois(1),Tab_mois(2),Tab_mois(3),Tab_mois(4),Tab_mois(5),Tab_mois(6),Tab_mois(7),Tab_mois(8),Tab_mois(9),Tab_mois(10),Tab_mois(11),Tab_mois(12),v_MOISMENS);

	 T := total_reestimer_t(Tab_mois(1),Tab_mois(2),Tab_mois(3),Tab_mois(4),Tab_mois(5),Tab_mois(6),Tab_mois(7),Tab_mois(8),Tab_mois(9),Tab_mois(10),Tab_mois(11),Tab_mois(12),v_MOISMENS);


	 IF((R+T)!=0)THEN

	 -- insert dans la table tmp_ree_detail des lignes pour chaque activite de chaque ressource
	 INSERT INTO tmp_ree_detail (NUMSEQ,
					       		 CODSG,
					  			 LIBDSG,
					   			 CODE_SCENARIO,
					    		 LIB_SCENARIO,
					    		 MOISMENS,
					      		 IDENT,
					      		 NOM,
					      		 PRENOM,
					          	 DATDEP,
					        	 TYPER,
					        	 CODE_ACTIVITE,
								 LIB_ACTIVITE,
								 TYPEA,
								 CJAN,
								 CFEV,
								 CMAR,
								 CAVR,
								 CMAI,
								 CJUN,
								 CJUL,
								 CAOU,
								 CSEP,
								 COCT,
								 CNOV,
								 CDEC,
					        	 JAN,
					        	 FEV,
					        	 MAR,
					        	 AVR,
					        	 MAI,
					        	 JUN,
								 JUL,
					        	 AOU,
					        	 SEP,
					        	 OCT,
					        	 NOV,
					        	 DEC,
								 T_REALISER,
								 T_REESTIMER
								 )
	   VALUES ( l_var_seq,
		        v_CODSG,
				v_LIBDSG,
				v_CODE_SCENARIO,
				v_LIB_SCENARIO,
				v_MOISMENS,
				v_IDENT,
				v_NOM,
				v_PRENOM,
				v_DATDEP,
				v_TYPER,
				v_CODE_ACTIVITE,
				v_LIB_ACTIVITE,
				v_TYPEA,
				nombre_jour('1',v_MOISMENS),
				nombre_jour('2',v_MOISMENS),
				nombre_jour('3',v_MOISMENS),
				nombre_jour('4',v_MOISMENS),
				nombre_jour('5',v_MOISMENS),
				nombre_jour('6',v_MOISMENS),
			 	nombre_jour('7',v_MOISMENS),
				nombre_jour('8',v_MOISMENS),
				nombre_jour('9',v_MOISMENS),
				nombre_jour('10',v_MOISMENS),
				nombre_jour('11',v_MOISMENS),
				nombre_jour('12',v_MOISMENS),
				Tab_mois(1),
				Tab_mois(2),
				Tab_mois(3),
				Tab_mois(4),
				Tab_mois(5),
				Tab_mois(6),
				Tab_mois(7),
				Tab_mois(8),
				Tab_mois(9),
				Tab_mois(10),
				Tab_mois(11),
				Tab_mois(12),
				R,
				T
				);

      END IF;

      END LOOP;

      -- Fermeture du curseur
      close l_c_a;

      RETURN l_var_seq;

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

   END tmp_ree_detail_seq;





   -- Decription : renvoi la somme des consomes reestimer

   FUNCTION consom_reestime(p_codsg 	IN ligne_bip.codsg%TYPE,
				            p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							p_code_activite IN ree_activites.code_activite%TYPE,
							p_ident IN ree_ressources.ident%TYPE,
							p_typer IN ree_ressources.type%TYPE,
							p_moismens IN DATE,
							p_mois IN NUMBER
				            ) RETURN NUMBER IS


      consom NUMBER;

	--on recupere la somme des consomés reestimer pour chaque ressource et activite


      cursor l_c_con(c_codsg CHAR, c_code_scenario CHAR, c_code_activite CHAR, c_ident NUMBER, c_typer CHAR, c_moismens DATE, c_mois NUMBER) IS
	    select SUM(CONSO_PREVU)
        from ree_reestime
		where
			codsg=c_codsg
			and code_scenario=c_code_scenario
			and code_activite=c_code_activite
			and ident=c_ident
			and type=c_typer
			and TO_NUMBER(TO_CHAR(cdeb,'mmyyyy'))=TO_NUMBER(TO_CHAR(c_mois)||TO_CHAR(c_moismens,'yyyy'))
		group by codsg, code_scenario, code_activite, ident;


   BEGIN

		OPEN l_c_con(p_codsg,p_code_scenario,p_code_activite,p_ident, p_typer, p_moismens,p_mois);

	  	fetch l_c_con  INTO consom;

	  	-- Fermeture du curseur
        CLOSE l_c_con;

      RETURN NVL(consom,0);

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

   END consom_reestime;




   -- Decription : renvoi la somme des consomes realiser

   FUNCTION consom_realiser(p_codsg 	IN ligne_bip.codsg%TYPE,
				            p_code_activite IN ree_activites.code_activite%TYPE,
							p_ident IN ree_ressources.ident%TYPE,
							p_moismens IN DATE,
							p_mois IN NUMBER
				            ) RETURN NUMBER IS


     consom NUMBER;

	--on recupere la somme des consomés realiser pour chaque ressource et activite


     cursor l_c_con(c_codsg CHAR, c_code_activite CHAR, c_ident NUMBER, c_moismens DATE, c_mois NUMBER) IS
	    select SUM(PP.CUSAG)
		from REE_ACTIVITES_LIGNE_BIP RAL,PROPLUS PP
		where
			RAL.CODSG=c_codsg
			and RAL.CODE_ACTIVITE=c_code_activite
			--and PP.FACTPDSG=RAL.CODSG
			and PP.TIRES=c_ident
			and PP.FACTPID=RAL.PID
			and PP.PTYPE<>7
			and TO_NUMBER(TO_CHAR(PP.CDEB,'mmyyyy'))=TO_NUMBER(TO_CHAR(c_mois)||TO_CHAR(c_moismens,'yyyy'));

   BEGIN

		OPEN l_c_con(p_codsg,p_code_activite,p_ident,p_moismens,p_mois);

	  	fetch l_c_con  INTO consom;

	  	-- Fermeture du curseur
        CLOSE l_c_con;

      RETURN NVL(consom,0);

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

   END consom_realiser;



   -- Decription : renvoi la somme des consomes realiser pour l'activite absences

   FUNCTION consom_realiser_absences(p_ident IN ree_ressources.ident%TYPE,
   									 p_moismens DATE,
				                     p_mois IN NUMBER
									  ) RETURN NUMBER IS


     consom NUMBER;

     --	on recupere la somme des absences pour une resource de chaque mois de l'activite absence

     cursor l_c_con(c_ident NUMBER,c_moismens DATE, c_mois NUMBER) IS
	   select SUM(PP.CUSAG)
	   from PROPLUS PP
	   where
			PP.TIRES=c_ident
			and PP.PTYPE=7
			and TO_NUMBER(TO_CHAR(PP.CDEB,'mmyyyy'))=TO_NUMBER(TO_CHAR(c_mois)||TO_CHAR(c_moismens,'yyyy'));


   BEGIN

		OPEN l_c_con(p_ident,p_moismens,p_mois);

	  	fetch l_c_con  INTO consom;

	  	-- Fermeture du curseur
        CLOSE l_c_con;

      RETURN NVL(consom,0);

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

   END consom_realiser_absences;



 FUNCTION consom_realiser_fournie(p_codsg 	IN ligne_bip.codsg%TYPE,
				            p_ident IN ree_ressources.ident%TYPE,
							p_moismens IN DATE,
							p_mois IN NUMBER
				            ) RETURN NUMBER IS


     consom NUMBER;


     -- on recupere la somme des jours fournie à une ressource de chaque mois de l'activite ss fournie

     cursor l_c_con(c_codsg CHAR, c_ident NUMBER, c_moismens DATE, c_mois NUMBER) IS
	   select SUM(PP.CUSAG)
	   from PROPLUS PP
	   where
			PP.TIRES=c_ident
			and PP.PTYPE<>7
			and TO_NUMBER(TO_CHAR(PP.CDEB,'mmyyyy'))=TO_NUMBER(TO_CHAR(c_mois)||TO_CHAR(c_moismens,'yyyy'))
			and not exists ( select 1
                             from REE_ACTIVITES_LIGNE_BIP a
                              where a.codsg = c_codsg
                              and a.pid = PP.FACTPID);


   BEGIN

		OPEN l_c_con(p_codsg,p_ident,p_moismens,p_mois);

	  	fetch l_c_con  INTO consom;

	  	-- Fermeture du curseur
        CLOSE l_c_con;

      RETURN NVL(consom,0);

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

   END consom_realiser_fournie;


   FUNCTION consom_realiser_recu(p_codsg 	IN ligne_bip.codsg%TYPE,
   								 p_code_activite IN ree_activites.code_activite%TYPE,
				                 p_moismens IN DATE,
							     p_mois IN NUMBER
				                 ) RETURN NUMBER IS


   consom NUMBER;


--on recupere la somme des jours recu d'une sous traitance pour chaque moi de chaque activite d'une ressource ss reçue

 cursor l_c_con(c_codsg CHAR, c_code_activite CHAR, c_moismens DATE, c_mois NUMBER) IS
	select SUM(PP.CUSAG)
		from REE_ACTIVITES_LIGNE_BIP RAL,PROPLUS PP
		where
			RAL.CODSG=c_codsg
			and RAL.CODE_ACTIVITE=c_code_activite
			--and PP.FACTPDSG=RAL.CODSG
			and PP.FACTPID=RAL.PID
			and PP.PTYPE<>7
			and TO_NUMBER(TO_CHAR(PP.CDEB,'mmyyyy'))=TO_NUMBER(TO_CHAR(c_mois)||TO_CHAR(c_moismens,'yyyy'))
			and not exists ( select 1
                                  from REE_RESSOURCES a
                                  where a.codsg = c_codsg
								  and a.ident=PP.TIRES);

   BEGIN

		OPEN l_c_con(p_codsg,p_code_activite,p_moismens,p_mois);

	  	fetch l_c_con  INTO consom;

	  	-- Fermeture du curseur
        CLOSE l_c_con;

      RETURN NVL(consom,0);

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

   END consom_realiser_recu;



 --cette fonction permet le renvoi des sommes pour n'inport activite et ressource
 -- C'est la fonction maitre des autre fonctions

   FUNCTION consom(p_codsg 	IN ligne_bip.codsg%TYPE,
				   p_code_scenario IN ree_scenarios.code_scenario%TYPE,
				   p_code_activite IN ree_activites.code_activite%TYPE,
				   p_typea IN ree_activites.type%TYPE,
				   p_ident IN ree_ressources.ident%TYPE,
				   p_typer IN ree_ressources.type%TYPE,
				   p_moismens IN DATE,
				   p_mois IN NUMBER
				   ) RETURN NUMBER IS


      consom NUMBER;



   BEGIN
		IF(p_mois<=TO_NUMBER(TO_CHAR(p_moismens,'mm'))) THEN--entraite les consomés realiser
			IF(p_typer='X')THEN-- si la ressource est de type fictive

				 consom:=0;

			ELSIF(p_typer='S')THEN-- si la ressource est de type ss reçu

			     consom:=consom_realiser_recu(p_codsg,p_code_activite,p_moismens,p_mois);

			ELSE


		    	IF(p_typea='A')THEN-- si l'activite est de type Absence

						 consom:=consom_realiser_absences(p_ident,p_moismens,p_mois);

			    ELSIF(p_typea='F')THEN-- si l'activite est de type ss fournie

				         consom:=consom_realiser_fournie(p_codsg,p_ident,p_moismens,p_mois);

			    ELSE -- les autres type d'activites

				         consom:=consom_realiser(p_codsg,p_code_activite,p_ident,p_moismens,p_mois);

				END IF;
			END IF;

		ELSE --on traite  les comsomés  reestimer

			consom:=consom_reestime(p_codsg,p_code_scenario,p_code_activite,p_ident,p_typer,p_moismens,p_mois);

	    END IF;

		return ROUND(consom,1);

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

   END consom;



   FUNCTION total_realiser(p_codsg 	IN ligne_bip.codsg%TYPE,
				   p_code_scenario IN ree_scenarios.code_scenario%TYPE,
				   p_code_activite IN ree_activites.code_activite%TYPE,
				   p_typea IN ree_activites.type%TYPE,
				   p_ident IN ree_ressources.ident%TYPE,
				   p_typer IN ree_ressources.type%TYPE,
				   p_moismens IN DATE
				   ) RETURN NUMBER IS


   nb_m_real NUMBER;	--  p_nb_mois le nombre de mois realiser
   total NUMBER;



   BEGIN


   total:=0;


   SELECT TO_NUMBER(TO_CHAR(p_moismens,'mm')) INTO nb_m_real FROM dual;


   FOR i in 1..nb_m_real LOOP



   total:= total+consom(p_codsg,p_code_scenario,p_code_activite,p_typea,p_ident,p_typer,p_moismens,i);



   END LOOP;


   return total;

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;


   END total_realiser;





   FUNCTION total_reestimer(p_codsg 	IN ligne_bip.codsg%TYPE,
				   p_code_scenario IN ree_scenarios.code_scenario%TYPE,
				   p_code_activite IN ree_activites.code_activite%TYPE,
				   p_typea IN ree_activites.type%TYPE,
				   p_ident IN ree_ressources.ident%TYPE,
				   p_typer IN ree_ressources.type%TYPE,
				   p_moismens IN DATE
				   ) RETURN NUMBER IS


   nb_m_real NUMBER;	--  p_nb_mois le nombre de mois realiser
   total NUMBER;



   BEGIN


   total:=0;


   SELECT TO_NUMBER(TO_CHAR(p_moismens,'mm')) INTO nb_m_real FROM dual;

   nb_m_real:=nb_m_real+1;



   FOR i in nb_m_real..12 LOOP


   total:= total+consom(p_codsg,p_code_scenario,p_code_activite,p_typea,p_ident,p_typer,p_moismens,i);


   END LOOP;


   return total;

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;


   END total_reestimer;


   -- Decription : renvoi le total des sommes des consomes realiser par code d'activite

   FUNCTION total_realiser_t(p_1 IN NUMBER,p_2 IN NUMBER,
							 p_3 IN NUMBER,p_4 IN NUMBER,
							 p_5 IN NUMBER,p_6 IN NUMBER,
							 p_7 IN NUMBER,p_8 IN NUMBER,
							 p_9 IN NUMBER,p_10 IN NUMBER,
							 p_11 IN NUMBER,p_12 IN NUMBER,
							 p_moismens IN DATE
							 ) RETURN NUMBER IS



   nb_m_real NUMBER;	--  p_nb_mois le nombre de mois realiser
   total NUMBER;
   Tab tableau_numerique;


   BEGIN


   total:=0;


   SELECT TO_NUMBER(TO_CHAR(p_moismens,'mm')) INTO nb_m_real FROM dual;

   --on recupere tous les sommes et on les stock dans un tableaux pour pouvoir utiliser une boucle
   Tab(1) := p_1;
   Tab(2) := p_2;
   Tab(3) := p_3;
   Tab(4) := p_4;
   Tab(5) := p_5;
   Tab(6) := p_6;
   Tab(7) := p_7;
   Tab(8) := p_8;
   Tab(9) := p_9;
   Tab(10) := p_10;
   Tab(11) := p_11;
   Tab(12) := p_12;

   --on somme que les consomés realiser

   FOR i in 1..nb_m_real LOOP

   total:= total + Tab(i);

   END LOOP;


   return total;

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;


   END total_realiser_t;



   -- Decription : renvoi le total des sommes des consomes reestimer par code d'activite

   FUNCTION total_reestimer_t(p_1 IN NUMBER,p_2 IN NUMBER,
							  p_3 IN NUMBER,p_4 IN NUMBER,
							  p_5 IN NUMBER,p_6 IN NUMBER,
							  p_7 IN NUMBER,p_8 IN NUMBER,
							  p_9 IN NUMBER,p_10 IN NUMBER,
							  p_11 IN NUMBER,p_12 IN NUMBER,
							  p_moismens IN DATE
							  ) RETURN NUMBER IS


   nb_m_real NUMBER;	--  p_nb_mois le nombre de mois realiser
   total NUMBER;
   Tab tableau_numerique;


   BEGIN


   total:=0;


   SELECT TO_NUMBER(TO_CHAR(p_moismens,'mm')) INTO nb_m_real FROM dual;

   nb_m_real:=nb_m_real+1;

   --on recupere tous les sommes et on les stock dans un tableaux pour pouvoir utiliser une boucle

   Tab(1) := p_1;
   Tab(2) := p_2;
   Tab(3) := p_3;
   Tab(4) := p_4;
   Tab(5) := p_5;
   Tab(6) := p_6;
   Tab(7) := p_7;
   Tab(8) := p_8;
   Tab(9) := p_9;
   Tab(10) := p_10;
   Tab(11) := p_11;
   Tab(12) := p_12;


   --on somme que les consomés reestimer
   FOR i in nb_m_real..12 LOOP

     total:= total + Tab(i);


   END LOOP;


   return total;

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;


   END total_reestimer_t;




   FUNCTION nombre_jour(p_mois 	IN CHAR,
				        p_moismens IN DATE
				       ) RETURN NUMBER IS


	nb NUMBER;


	BEGIN


	select CJOURS INTO nb
          from CALENDRIER
          where TO_NUMBER(TO_CHAR(CALANMOIS,'mmyyyy'))=TO_NUMBER(p_mois||TO_CHAR(p_moismens,'yyyy'));

	return nb;

	EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

	END nombre_jour;


END pack_ree_detail;
/
CREATE OR REPLACE PACKAGE pack_ree_ress AS

 -- Définition curseur

   TYPE ress_ViewType IS RECORD (ident  ree_ressources.ident%TYPE,
   				 lib	VARCHAR2(150)
					);

   TYPE ress_s_ViewType IS RECORD (codsg ree_ressources.codsg%TYPE,
              			   type ree_ressources.type%TYPE,
              			   ident VARCHAR2(6),
              			   rnom ree_ressources.rnom%TYPE,
              			   rprenom ree_ressources.rprenom%TYPE,
              			   datdep VARCHAR2(20)
              			   ,code_ress ree_ressources.ident%TYPE
					);

   TYPE ressCurType IS REF CURSOR RETURN ress_ViewType;
   TYPE ress_s_CurType IS REF CURSOR RETURN ress_s_ViewType;

   TYPE groupe_ListeViewType IS RECORD( ident ressource.ident%TYPE,
                                        LIBELLE VARCHAR2(500)
                                         );

   TYPE groupe_listeCurType IS REF CURSOR RETURN groupe_ListeViewType;

PROCEDURE ress_groupe( p_codsg         IN VARCHAR2,
                       p_userid        IN VARCHAR2,
                       p_curseur       IN OUT groupe_listeCurType
                                );

PROCEDURE ress_liste (  p_codsg 	IN VARCHAR2,
			p_global 	IN VARCHAR2,
   			p_curress 	IN OUT ress_s_CurType,
                	p_nbcurseur   	OUT INTEGER,
                        p_message     	OUT VARCHAR2
                                	);

PROCEDURE select_ress  	 (p_ident	IN  VARCHAR2,
			  p_type	IN  VARCHAR2,
                          p_codsg       IN  VARCHAR2,
                          p_curress 	IN OUT ress_s_CurType,
                          p_nbcurseur	OUT INTEGER,
                          p_message	OUT VARCHAR2
                             		 );

PROCEDURE update_ress(          p_ident    IN  VARCHAR2,
				p_type  IN  VARCHAR2,
				p_codsg	IN VARCHAR2,
				p_rnom  IN VARCHAR2,
				p_rprenom IN VARCHAR2,
				p_datdep IN VARCHAR2,
				p_ident_fict    IN  VARCHAR2,
				p_nbcurseur  OUT INTEGER,
                                p_message    OUT VARCHAR2
                             );

PROCEDURE insert_ress(p_code_ress    IN  VARCHAR2,
				p_ident_hors    IN  VARCHAR2,
				p_ident_fict    IN  VARCHAR2,
				p_choix  IN  VARCHAR2,
				p_codsg	IN VARCHAR2,
				p_rnom  IN VARCHAR2,
				p_rprenom IN VARCHAR2,
				p_datdep IN VARCHAR2,
				p_nbcurseur  OUT INTEGER,
                                p_message    OUT VARCHAR2
                             );

PROCEDURE delete_ress ( 	p_code_ress    IN  VARCHAR2,
				p_type  IN  VARCHAR2,
				p_codsg	IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2
                               	);

PROCEDURE donnees_ress ( 	p_ident    IN  VARCHAR2,
				p_codsg    IN  VARCHAR2,
				p_choix IN VARCHAR2,
				p_rnom  OUT  VARCHAR2,
				p_rprenom  OUT  VARCHAR2,
				p_date OUT VARCHAR2,
				p_choix_retour OUT VARCHAR2,
				p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2
                               	);

PROCEDURE ree_ressource_initialise(p_codsg 	IN ligne_bip.codsg%TYPE,
					p_message   	OUT VARCHAR2 );

PROCEDURE ress_fict_liste (p_codsg         IN VARCHAR2,
                           p_userid        IN VARCHAR2,
                           p_curseur       IN OUT groupe_listeCurType
                                );

END pack_ree_ress;
/

CREATE OR REPLACE PACKAGE BODY pack_ree_ress AS

/* proc qui liste les ressources associées au DPG */
PROCEDURE ress_liste (p_codsg 	IN VARCHAR2,
			p_global 	IN VARCHAR2,
   			p_curress 	IN OUT ress_s_CurType,
                        p_nbcurseur   	OUT INTEGER,
                        p_message     	OUT VARCHAR2
                    ) IS
l_msg VARCHAR2(1024);
l_codsg NUMBER;

BEGIN

	-- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
	p_nbcurseur := 1;
      	p_message := '';

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_global)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

    BEGIN
      OPEN p_curress FOR SELECT
        codsg,
        type,
       	type||nvl(TO_CHAR(ident),''),
      	rnom,
      	rprenom,
      	NVL(TO_CHAR(datdep,'dd/mm/yyyy'), '          ')
      	,nvl(ident,'')
	FROM ree_ressources
	WHERE codsg = TO_NUMBER(p_codsg)
	AND type <> 'S'
	ORDER BY rnom;

EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);END;
        END IF;
     END IF;

     p_message := l_msg;

END ress_liste;

/* proc qui retourne les données d'une ressource */
PROCEDURE select_ress  (  p_ident	IN  VARCHAR2,
			  p_type	IN  VARCHAR2,
                          p_codsg       IN  VARCHAR2,
                          p_curress 	IN OUT ress_s_CurType,
                          p_nbcurseur	OUT INTEGER,
                          p_message	OUT VARCHAR2
                              	) IS
l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)

      BEGIN
         OPEN   p_curress FOR
              SELECT 	codsg,
              		type,
              		type||to_char(ident),
              		rnom,
              		rprenom,
              		to_char(datdep,'dd/mm/yyyy')
              		,ident
              FROM  ree_ressources
              WHERE
              codsg =TO_NUMBER(p_codsg)
              AND type = substr(p_ident,0,1)
              AND ident = to_number(substr(p_ident,2,5))
              ;


      EXCEPTION
	WHEN NO_DATA_FOUND THEN
		pack_global.recuperer_message( 20131, NULL, NULL, NULL, l_msg);
         	p_message := l_msg;
        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;
END select_ress;

/* proc qui fait la maj des données d'une ressource */
PROCEDURE update_ress(p_ident    IN  VARCHAR2,
				p_type  IN  VARCHAR2,
				p_codsg	IN VARCHAR2,
				p_rnom  IN VARCHAR2,
				p_rprenom IN VARCHAR2,
				p_datdep IN VARCHAR2,
				p_ident_fict    IN  VARCHAR2,
				p_nbcurseur  OUT INTEGER,
                                p_message    OUT VARCHAR2
                              	) IS
l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- initialiser le message retour

	p_nbcurseur := 0;
	p_message := '';

	-- On veut remplacer une ressource fictive par une ressource "normale"
	IF p_ident_fict <> '-1' THEN
		begin

		UPDATE ree_reestime
		SET	ident=p_ident,
		type=p_type
		WHERE codsg = TO_NUMBER(p_codsg)
		AND type = 'X'
		AND ident=TO_NUMBER(p_ident_fict);

		UPDATE ree_ressources_activites
		SET	ident=p_ident,
		type=p_type
		WHERE codsg = TO_NUMBER(p_codsg)
		AND type = 'X'
		AND ident=TO_NUMBER(p_ident_fict);

		DELETE FROM ree_ressources
		WHERE codsg = TO_NUMBER(p_codsg)
		AND type = 'X'
		AND ident=TO_NUMBER(p_ident_fict);

		IF SQL%NOTFOUND THEN
	   	   -- 'Accès concurrent'
	 	pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         	raise_application_error( -20999, l_msg );
         	ELSE
		pack_global.recuperer_message( 21020, '%s1', p_ident, NULL, l_msg);
	   	p_message := l_msg;
		END IF;
		end;
	ELSE
		begin
		UPDATE ree_ressources
		SET	rnom=p_rnom,
		rprenom=p_rprenom,
		datdep=to_date(p_datdep,'dd/mm/yyyy')
		WHERE codsg = TO_NUMBER(p_codsg)
		AND type = p_type
		AND ident=TO_NUMBER(p_ident)
		;


		IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	 	pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         	raise_application_error( -20999, l_msg );

      		ELSE

	   	pack_global.recuperer_message( 21013, '%s1', p_ident, NULL, l_msg);
	   	p_message := l_msg;

      	END IF;
	end;
       END IF;
END update_ress;

/* proc pour inserer une nouvelle ressource*/
PROCEDURE insert_ress (p_code_ress    IN  VARCHAR2,
				p_ident_hors    IN  VARCHAR2,
				p_ident_fict    IN  VARCHAR2,
				p_choix  IN  VARCHAR2,
				p_codsg	IN VARCHAR2,
				p_rnom  IN VARCHAR2,
				p_rprenom IN VARCHAR2,
				p_datdep IN VARCHAR2,
				p_nbcurseur  OUT INTEGER,
                                p_message    OUT VARCHAR2
                              ) IS

     	l_msg VARCHAR2(1024);
     	l_type VARCHAR2(1);
     	l_code_ress VARCHAR2(5);

BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';
IF p_choix='h' and p_ident_hors is not null then
	l_code_ress := p_ident_hors;
ELSIF p_code_ress is not null and p_choix='g' then
	l_code_ress := p_code_ress;
ELSIF  p_choix is null then
	l_code_ress := p_code_ress;
END IF      ;

IF p_choix <> 'f' or p_choix is null THEN
	begin
	select rtype into l_type
	from ressource
	where ident=l_code_ress ;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		--raise_application_error( -20997, SQLERRM);
		pack_global.recuperer_message( 21019, NULL, NULL, NULL, l_msg);
               	p_message := l_msg;
        end;
        BEGIN

	INSERT INTO ree_ressources
	    (codsg,
	    type,
	    ident,
	    rnom,
	    rprenom,
	    datdep
 		)
         VALUES ( 	TO_NUMBER(p_codsg),
         		l_type,
         		TO_NUMBER(l_code_ress),
         		nvl(p_rnom,'nom vide'),
         		nvl(p_rprenom,''),
         		TO_DATE(p_datdep,'dd/mm/yyyy')
		);


     EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
      		-- ressource déjà existante
		pack_global.recuperer_message( 21018, '%s1', l_code_ress, NULL, l_msg);
		--raise_application_error(-21018, l_msg);
               	p_message := l_msg;

        WHEN OTHERS THEN
               	raise_application_error( -20997, SQLERRM);
    	END;

ELSIF  p_choix ='f'  THEN
	BEGIN

	select (nvl(max(ident),0) +1)  into l_code_ress
	from ree_ressources
	where codsg=TO_NUMBER(p_codsg)
	and type='X';

	INSERT INTO ree_ressources
	    (codsg,
	    type,
	    ident,
	    rnom,
	    rprenom,
	    datdep
 		)
         VALUES ( 	TO_NUMBER(p_codsg),
         		'X',
         		TO_NUMBER(l_code_ress),
         		nvl(p_rnom,''),
         		nvl(p_rprenom,''),
         		TO_DATE(p_datdep,'dd/mm/yyyy')
		);

     EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
      		-- ressource déjà existante
		pack_global.recuperer_message( 21018, NULL, NULL, NULL, l_msg);
               	p_message := l_msg;

        WHEN OTHERS THEN
               	raise_application_error( -20997, SQLERRM);
    END;
 END IF;

 pack_global.recuperer_message( 21015, '%s1', l_code_ress, NULL, l_msg);
 p_message := l_msg;


END insert_ress;

/* proc qui supprime une ressource */
PROCEDURE delete_ress ( p_code_ress    IN  VARCHAR2,
				p_type  IN  VARCHAR2,
				p_codsg	IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2
                              ) IS


	l_msg VARCHAR2(1024);
      	referential_integrity EXCEPTION;
      	PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN

	DELETE FROM ree_ressources
	WHERE codsg = TO_NUMBER(p_codsg)
	AND type = p_type
	AND ident=TO_NUMBER(p_code_ress)
	;

         EXCEPTION

		WHEN referential_integrity THEN

               -- habiller le msg erreur

               pack_global.recuperation_integrite(-2292);

		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE

	   pack_global.recuperer_message( 21014, '%s1', p_code_ress, NULL, l_msg);
	   p_message := l_msg;

      END IF;

   END delete_ress;

/*lister les ressources du groupe*/
PROCEDURE ress_groupe( p_codsg         IN VARCHAR2,
                       p_userid        IN VARCHAR2,
                       p_curseur       IN OUT groupe_listeCurType
                                ) IS
l_count number(2);
BEGIN


                OPEN p_curseur FOR
	        SELECT distinct r.ident,s.ident||' - '||r.rnom||' '||r.rprenom
		FROM ressource r,situ_ress_full s
		WHERE s.codsg = TO_NUMBER(p_codsg)
		AND s.datsitu IN ( SELECT MAX(sr.datsitu)
		                   FROM situ_ress sr
		                   WHERE sr.ident = r.ident)
		AND (s.datdep IS NULL or s.datdep>sysdate)
		AND s.ident=r.ident
		UNION
		select -1,'                ' from ressource
		ORDER BY 1;


END ress_groupe ;

/*recupération des donnees pour un identifiant*/
PROCEDURE donnees_ress ( 	p_ident    IN  VARCHAR2,
				p_codsg    IN  VARCHAR2,
				p_choix IN VARCHAR2,
				p_rnom  OUT  VARCHAR2,
				p_rprenom  OUT  VARCHAR2,
				p_date OUT VARCHAR2,
				p_choix_retour OUT VARCHAR2,
				p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2
                               	)IS

l_rnom VARCHAR2(50);
l_rprenom VARCHAR2(50);
l_rtype VARCHAR2(1);
l_msg		VARCHAR2(1024);
l_test		NUMBER(1);

BEGIN
	p_nbcurseur := 1;
      	p_message := '';
      	l_test := 0;

    if p_choix='f'  	then
    	p_rnom := '';
    	p_rprenom := '';
    	p_date := '';
    	p_choix_retour := 'f';

    else

      	BEGIN

      	-- test de l existence de la ressource dans l outil des reestimes
      	SELECT 1 INTO l_test
      	FROM ree_ressources
      	WHERE ident=p_ident
      	AND type <> 'X'
      	AND codsg=to_number(p_codsg);

      	EXCEPTION
      		WHEN NO_DATA_FOUND THEN

      		begin
      		SELECT rnom, rprenom,to_char(s.datdep,'dd/mm/yyyy') INTO p_rnom, p_rprenom,p_date
      		FROM ressource r,situ_ress s WHERE s.ident=r.ident
      		and r.ident=p_ident
      		and s.datsitu = (select max(datsitu) from situ_ress where ident=p_ident)
      		;
      		EXCEPTION
        	WHEN NO_DATA_FOUND THEN
        	pack_global.recuperer_message(20437, '%s1', p_ident,'ident', l_msg);
	        p_message := l_msg;
	        --raise_application_error(-20437, l_msg);
		WHEN OTHERS THEN
		-- Message d'alerte Problème inconnu
	      	raise_application_error(-20997, SQLERRM);
		end;
	END;

	if l_test = 1 then
		pack_global.recuperer_message(21018, NULL, NULL, NULL, l_msg);
	       p_message := l_msg;
	       --raise_application_error(-21018, l_msg);
	end if;
    end if;

END donnees_ress;

-- proc pour le bouton initialiser
 PROCEDURE ree_ressource_initialise(p_codsg 	IN ligne_bip.codsg%TYPE,
 					p_message   	OUT VARCHAR2
				    ) IS

    trouver NUMBER;
	v_ident     situ_ress.ident%TYPE;
	v_rtype     ressource.rtype%TYPE;
	v_rnom      ressource.rnom%TYPE;
	v_rprenom   ressource.rprenom%TYPE;
	v_datsitu   DATE;
	v_datdep	DATE;

	p_date		DATE;
	l_msg		VARCHAR2(1024);


	--Le curseur qui recupere la liste des ressources d'un pole
	 cursor l_ress(c_codsg NUMBER, c_date DATE) IS
	 	   SELECT sr.ident, r.rtype,r.rnom,r.rprenom,sr.datsitu,sr.datdep
		   FROM situ_ress sr, ressource r
		   WHERE sr.codsg=c_codsg
		   AND sr.datsitu=pack_situation_full.datsitu_ressource(sr.ident,c_date)
		   AND (sr.datdep is NULL OR sr.datdep>= c_date)
		   AND r.ident=sr.ident;

 BEGIN


	Select to_date(to_char(sysdate,'dd/mm/yyyy'),'dd/mm/yyyy')  into p_date
	from dual;

	p_message := '';

     OPEN l_ress(p_codsg,p_date);

		 LOOP


		    FETCH l_ress INTO v_ident, v_rtype, v_rnom, v_rprenom, v_datsitu, v_datdep;

	        IF l_ress%NOTFOUND THEN
	        EXIT;
	        END IF;


			    SELECT COUNT(ident) INTO trouver
					   FROM ree_ressources
					   WHERE codsg=p_codsg
					   AND ident=v_ident
					   AND type=v_rtype;

				--si la ressource n'existe pas dans la table ree_ressource alors on insere la ressource
			    IF(trouver = 0) THEN


				      INSERT INTO ree_ressources(CODSG,
					  	TYPE,
					 	IDENT,
					 	RNOM,
					  	RPRENOM,
					  	DATDEP
					  	)

					  VALUES(
					  p_codsg,
					  v_rtype,
					  v_ident,
					  v_rnom,
					  v_rprenom,
					  v_datdep
				       );

				--si la ressource existe alors on fait un update
				ELSE


				   UPDATE ree_ressources
				          SET RNOM=v_rnom,
					          RPRENOM=v_rprenom,
					          DATDEP=v_datdep
						  WHERE	codsg=p_codsg
						      AND type=v_rtype
						      AND ident=v_ident;


				END IF;


	     END LOOP;


		 CLOSE l_ress;


 EXCEPTION
           WHEN OTHERS THEN
           	-- Message d'alerte Problème inconnu
	      	raise_application_error(-20997, SQLERRM);

-- pack_global.recuperer_message( 21021, NULL, NULL, NULL, l_msg);
-- p_message := l_msg;

--test
pack_global.recuperer_message( 21015, '%s1', 'mmc', NULL, l_msg);
raise_application_error( -21015, l_msg );
 --p_message := l_msg;

END ree_ressource_initialise;

/*lister les ressources fictives du groupe */
PROCEDURE ress_fict_liste( p_codsg         IN VARCHAR2,
                       	p_userid        IN VARCHAR2,
                       	p_curseur       IN OUT groupe_listeCurType
                                ) IS
l_count number(2);
BEGIN


            OPEN p_curseur FOR
	        SELECT distinct r.ident,r.ident||' - '||r.rnom||' '||r.rprenom
		FROM ree_ressources r
		WHERE r.codsg = TO_NUMBER(p_codsg)
		AND r.type='X'
		UNION
		select -1,'           ' from ree_ressources r
		ORDER BY 1;

END ress_fict_liste ;


END pack_ree_ress;
/
CREATE OR REPLACE PACKAGE pack_ree_ress_act AS

   -- Définition curseur sur la table ree_ressources_activite

   TYPE ress_act_ViewType IS RECORD ( 	codsg varchar2(7),--ree_ressources_activite.codsg%TYPE,
   					ident	VARCHAR2(5),
   					type_ress	VARCHAR2(1),
   					lib_ress 	VARCHAR2(70),
   					code_activite varchar2(12),--ree_ressources_activite.code_activite%TYPE,
   					lib_activite VARCHAR2(60),
					repartition 	VARCHAR2(8)
					);


   TYPE ress_actCurType_Char IS REF CURSOR RETURN ress_act_ViewType;

   TYPE ress_ListeViewType IS RECORD(CODE_RESS   VARCHAR2(6),
  				     LIB_RESS     VARCHAR2(60)
				    );

   TYPE ress_listeCurType IS REF CURSOR RETURN ress_ListeViewType;

   TYPE ligne_ListeViewType IS RECORD(  CODE_ACTIVITE   VARCHAR2(12),
   					LIB   VARCHAR2(250)
				);

   TYPE ligne_listeCurType IS REF CURSOR RETURN ligne_ListeViewType;

   PROCEDURE lister_ress_dpg( 	p_codsg 	IN VARCHAR2,
   				p_userid 	IN VARCHAR2,
   				p_curseur 	IN OUT ress_listeCurType
                             	);

  PROCEDURE lister_ligne_act( 	p_codsg 	IN VARCHAR2,
   				p_code_ress IN VARCHAR2,
   				p_userid 	IN VARCHAR2,
   				p_curseur 	IN OUT ligne_listeCurType
                             	);

   PROCEDURE select_ressource_ligne ( 	p_codsg 		IN VARCHAR2,
   					p_code_ress		IN VARCHAR2,
   					p_global		IN VARCHAR2,
                               		p_curress_ligne 	IN OUT ress_actCurType_Char ,
                               		p_nbcurseur   		OUT INTEGER,
                               		p_message     		OUT VARCHAR2,
   					p_lib_ress		OUT VARCHAR2
   					,p_total_rep		OUT FLOAT
                                );

   FUNCTION str_ress_act 	(	p_string     IN  VARCHAR2,
                           		p_occurence  IN  NUMBER
                          	  ) return VARCHAR2;


   PROCEDURE insert_ressources_activites ( 	p_string 	IN VARCHAR2,
   					p_codsg		IN VARCHAR2,
  					p_code_ress	IN VARCHAR2,
                                	p_nbcurseur  	OUT INTEGER,
                                	p_message    	OUT VARCHAR2
                                );


   PROCEDURE select_ligne (p_code_activite 	IN VARCHAR2,
   			p_codsg			IN VARCHAR2,
   			p_code_ress		IN VARCHAR2,
   			p_lib_activite		OUT VARCHAR2,
   			p_repartition		OUT VARCHAR2
                           );




END pack_ree_ress_act;
/

CREATE OR REPLACE PACKAGE BODY pack_ree_ress_act AS

PROCEDURE lister_ress_dpg( 	p_codsg 	IN VARCHAR2,
   				p_userid 	IN VARCHAR2,
   				p_curseur 	IN OUT ress_listeCurType
                             ) IS

l_msg VARCHAR2(1024);
l_codsg NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_userid)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

	BEGIN
        	OPEN   p_curseur FOR
        	SELECT '' ,
               ' ' LIB_RESSß
        	FROM dual
       		UNION
              	SELECT 	type||ident CODE_RESSß,
              		rnom || ' ' || rprenom|| ' - ' ||type||' ' ||ident LIB_RESSß
              	FROM  ree_ressources
              	WHERE codsg = TO_NUMBER(p_codsg) and type <> 'S'
              	ORDER by 2;

      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
       END;
        END IF;
     END IF;


  END lister_ress_dpg;

  /* pour avoir la liste déroulante avec les activites du dpg */
  PROCEDURE lister_ligne_act( 	p_codsg 	IN VARCHAR2,
   				p_code_ress IN VARCHAR2,
   				p_userid 	IN VARCHAR2,
   				p_curseur 	IN OUT ligne_listeCurType
                             ) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_userid)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

	BEGIN
        	OPEN   p_curseur FOR
              	SELECT 	act.code_activite CODE_ACTIVITE,
			act.code_activite || ' - ' || act.lib_activite LIB
		FROM  ree_activites act
		where act.CODSG = p_codsg
		and act.type <> 'A'
		--MINUS
		--SELECT 	ract.code_activite,
		--	act.code_activite || ' - ' || act.lib_activite
		--FROM  ree_ressources_activites ract,ree_activites act
		--WHERE ract.ident = to_number(substr(p_code_ress,2,5))
		--and ract.type = substr(p_code_ress,0,1)
		--and ract.CODSG = p_codsg
		--and ract.codsg=act.codsg
		--and ract.code_activite=act.code_activite
		;

      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
       END;
        END IF;
     END IF;
  END lister_ligne_act;

 /* proc qui liste les ressources dans un tableau*/
 PROCEDURE select_ressource_ligne ( 	p_codsg 		IN VARCHAR2,
   					p_code_ress		IN VARCHAR2,
   					p_global		IN VARCHAR2,
                               		p_curress_ligne 	IN OUT ress_actCurType_Char ,
                               		p_nbcurseur   		OUT INTEGER,
                               		p_message     		OUT VARCHAR2,
   					p_lib_ress		OUT VARCHAR2
   					,p_total_rep		OUT FLOAT
                              		) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
	p_nbcurseur := 1;
      	p_message := '';

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

     ELSE
     IF ( pack_habilitation.fhabili_me(p_codsg, p_global)= 'faux' )
     THEN
	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	raise_application_error(-20364,l_msg);

     ELSE

	BEGIN
        	OPEN   p_curress_ligne FOR
              	SELECT 	lpad(to_char(ress.CODSG), 7,'0'),
              		to_char(ract.ident),
              		ract.type,
              		ress.rnom,
			ract.CODE_ACTIVITE,
			act.LIB_ACTIVITE,
              		to_char(nvl(ract.tauxrep,0))
              	FROM  	ree_ressources_activites ract,
              		ree_activites act,
              		ree_ressources ress
              	WHERE ract.codsg = TO_NUMBER(p_codsg)
              	and act.type <> 'A'
              	and act.codsg = ract.codsg
              	and act.code_activite = ract.code_activite
              	and ract.ident = to_number(substr(p_code_ress,2,5))
              	and ract.type=substr(p_code_ress,0,1)
              	and ress.ident=ract.ident
              	and ress.type=ract.type
              	and ress.codsg=ract.codsg
              	;

      		EXCEPTION
      			WHEN NO_DATA_FOUND THEN
      				pack_global.recuperer_message(20900, NULL, NULL, NULL, l_msg);
				raise_application_error(-20900,l_msg);
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);

       END;

       BEGIN
        	SELECT 	ress.rnom INTO p_lib_ress
              	FROM  	ree_ressources ress
              	WHERE ress.codsg = TO_NUMBER(p_codsg)
              	and ress.type = substr(p_code_ress,0,1)
              	and ress.ident = to_number(substr(p_code_ress,2,5))
              	;

      		EXCEPTION
      			WHEN NO_DATA_FOUND THEN
      				pack_global.recuperer_message(20900,  NULL, NULL, NULL, l_msg);
				raise_application_error(-20900,l_msg);
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);

       END;

      BEGIN
        	SELECT 	SUM(tauxrep) INTO p_total_rep
              	FROM  	ree_ressources_activites
              	WHERE codsg = TO_NUMBER(p_codsg)
              	and type = substr(p_code_ress,0,1)
              	and ident = to_number(substr(p_code_ress,2,5))
              	;
--
      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);

       END;

        END IF;
     END IF;

     p_message := l_msg;

   END select_ressource_ligne;

FUNCTION str_ress_act (	p_string     IN  VARCHAR2,
                           	p_occurence  IN  NUMBER
                          	) return VARCHAR2 IS
   pos1 NUMBER(6);
   pos2 NUMBER(6);
   str  VARCHAR2(111);

   BEGIN

      pos1 := INSTR(p_string,';',1,p_occurence);
      pos2 := INSTR(p_string,';',1,p_occurence+1);

      IF pos2 != 1 THEN
         str := SUBSTR( p_string, pos1+1, pos2-pos1-1);
         return str;
      ELSE
         return '0';
      END IF;

END str_ress_act;

-- proc pour creation dans ree_ressources_activites
PROCEDURE insert_ressources_activites ( p_string 	IN VARCHAR2,
					p_codsg		IN VARCHAR2,
  					p_code_ress	IN VARCHAR2,
					p_nbcurseur  	OUT INTEGER,
                                	p_message    	OUT VARCHAR2
                              ) IS

   l_msg 		VARCHAR2(1024);
   l_cpt    		NUMBER(7);
   l_codsg  		ree_ressources_activites.codsg%TYPE;
   l_code_activite    	ree_ressources_activites.code_activite%TYPE;
   l_ident  		ree_ressources_activites.ident%TYPE;
   l_type  		ree_ressources_activites.type%TYPE;
   l_ident1  		ree_ressources_activites.ident%TYPE;
   l_type1  		ree_ressources_activites.type%TYPE;
   l_codsg1  		ree_ressources_activites.codsg%TYPE;
   l_tauxrep  		VARCHAR2(6);
   l_test		VARCHAR2(2);

   BEGIN
      -- Initialiser le message retour
      p_message   := '';
      l_cpt       := 3;

      l_codsg  	:= pack_ree_ress_act.str_ress_act(p_string,l_cpt);
      l_ident := to_number(substr(pack_ree_ress_act.str_ress_act(p_string,l_cpt+1),2,5));
      l_type 	:=(substr(pack_ree_ress_act.str_ress_act(p_string,l_cpt+1),0,1));

     l_ident1 := to_number(substr(pack_ree_ress_act.str_ress_act(p_string,2),2,5));
      l_type1 	:=(substr(pack_ree_ress_act.str_ress_act(p_string,2),0,1));
      l_codsg1  := to_number(pack_ree_ress_act.str_ress_act(p_string,1));
      --pack_global.recuperer_message( 1003 , '%s1', l_codsg1, NULL, p_message);
	BEGIN
	if l_type IS NOT NULL then
		delete from ree_ressources_activites
		where codsg = l_codsg
		and ident=l_ident and type=l_type;
		commit;
	else
		delete from ree_ressources_activites
		where codsg = l_codsg1
		--and ident=11 and type='X';
		and ident=l_ident1 and type=l_type1;
		commit;
	end if;
	END;


      WHILE l_cpt != 0 LOOP
      	l_codsg  	:= pack_ree_ress_act.str_ress_act(p_string,l_cpt);
       	l_ident 	:= to_number(substr(pack_ree_ress_act.str_ress_act(p_string,l_cpt+1),2,5));
      	l_type 		:=(substr(pack_ree_ress_act.str_ress_act(p_string,l_cpt+1),0,1));
        l_code_activite := pack_ree_ress_act.str_ress_act(p_string,l_cpt+2);
       	l_tauxrep 	:= to_number(pack_ree_ress_act.str_ress_act(p_string,l_cpt+3));

	 -- Si une ligne est retournée
         IF l_codsg != '0' and l_type is not null THEN
         	INSERT INTO ree_ressources_activites (code_activite,codsg,ident,tauxrep,type)
		VALUES (l_code_activite,
			l_codsg,
			l_ident,
			l_tauxrep,
			l_type);

          l_cpt := l_cpt + 4;

         ELSE
            l_cpt :=0;
         END IF;
      END LOOP;

  -- pack_global.recuperer_message( 1003 , '%s1', l_codsg, NULL, p_message);
  pack_global.recuperer_message( 20366 , '%s1', 'Ressources - Activités rattachées', '', p_message);

END insert_ressources_activites;

-- selection de la ligne activite a ajouter à une ressource
PROCEDURE select_ligne (p_code_activite 	IN VARCHAR2,
			p_codsg			IN VARCHAR2,
			p_code_ress		IN VARCHAR2,
   			p_lib_activite		OUT VARCHAR2,
   			p_repartition		OUT VARCHAR2
                           ) IS

   BEGIN
        	SELECT 	act.lib_activite INTO p_lib_activite
              	FROM  	ree_activites act--,ree_ressources_activites ress
              	WHERE act.code_activite = p_code_activite
              	AND act.codsg= to_number(p_codsg)
              	--AND act.codsg=ress.codsg
              	--AND act.code_activite=ress.code_activite
                --AND ress.ident = to_number(substr(p_code_ress,2,5))
              	--AND ress.type=substr(p_code_ress,0,1)
              	;

      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);

   END select_ligne;



 END pack_ree_ress_act;
/
CREATE OR REPLACE PACKAGE PACK_REE_SAISIE AS

TYPE ress_liste_ViewType IS RECORD ( 	CODE_RESSOURCE     	VARCHAR2(5),
                                    	RESSOURCE     		VARCHAR2(100)
                                     );
TYPE ress_listeCurType IS REF CURSOR RETURN ress_liste_ViewType;
PROCEDURE liste_ress_dpg( 	p_codsg 	IN VARCHAR2,
   							p_userid 	IN VARCHAR2,
   							p_curseur 	IN OUT ress_listeCurType
                             );

TYPE ressource_ViewType IS RECORD ( 	CODE_RESSOURCE     	VARCHAR2(5),
                                    	RESSOURCE     		VARCHAR2(100),
										MOIS 				VARCHAR2(7),
										NBMOIS 				NUMBER,
										KeyList4 			VARCHAR2(60),
										KeyList5 			VARCHAR2(7),
										KeyList6 			VARCHAR2(7),
										TYPE_RESS    		REE_RESSOURCES.TYPE%TYPE,
										date_depart 		NUMBER
                                     );
TYPE ressourceCurType IS REF CURSOR RETURN ressource_ViewType;

TYPE jourouvre_ListeViewType IS RECORD (	MOIS     VARCHAR2(2), NB_JOUR  CALENDRIER.CJOURS%TYPE);
TYPE jourouvre_listeCurType IS REF CURSOR RETURN jourouvre_ListeViewType;

PROCEDURE select_ressource(	p_ident	            IN VARCHAR2,
			    			p_userid 	   	    IN VARCHAR2,
		  					p_codsg 			IN VARCHAR2,
		  					p_code_scenario		IN VARCHAR2,
			    			p_curressource 		IN OUT ressourceCurType,
			   				p_nbpages      		OUT VARCHAR2,
                            p_numpage      		OUT VARCHAR2,
							p_menu		   		OUT VARCHAR2,
                            p_nbcurseur    		OUT INTEGER,
                            p_message      		OUT VARCHAR2
							);

FUNCTION f_get_nbjour_ouv_mois ( p_mois IN VARCHAR2	) RETURN NUMBER;

PROCEDURE lister_nb_jour_ouvre( p_curseur  IN OUT jourouvre_listeCurType );

FUNCTION f_get_activite_mois ( p_ident 		    IN NUMBER,
			  			       p_type_ress	    IN VARCHAR2,
			  			       p_mois 	   		IN VARCHAR2,
			  			       p_codsg			IN VARCHAR2,
			  			       p_code_activite	IN VARCHAR2,
                     				p_code_scenario 	IN VARCHAR2,
			  			       p_nbmois			IN NUMBER
							)  return VARCHAR2;

FUNCTION f_get_total_mois ( p_ident 		    IN NUMBER,
			  			    p_type_ress		    IN VARCHAR2,
			  			    p_mois 	   			IN VARCHAR2,
			  			    p_codsg				IN VARCHAR2,
                       		p_code_scenario 	IN VARCHAR2,
			  			    p_nbmois			IN NUMBER
							)  return VARCHAR2;

FUNCTION f_get_total_activite_annee ( p_ident 		    IN NUMBER,
  			    		    		  p_type_ress		IN VARCHAR2,
			  			    		  p_mois 	   		IN VARCHAR2,
			  			    		  p_codsg			IN VARCHAR2,
                       				  p_code_activite 	IN VARCHAR2,
                       				  p_code_scenario 	IN VARCHAR2,
			  			    		  p_nbmois			IN NUMBER,
			  			    		  p_cons_rees		IN VARCHAR2
									)  return VARCHAR2;

FUNCTION f_get_total_annee ( p_ident 		    IN NUMBER,
			  			    p_type_ress		    IN VARCHAR2,
			  			    p_mois 	   			IN VARCHAR2,
			  			    p_codsg				IN VARCHAR2,
                       		p_code_scenario 	IN VARCHAR2,
			  			    p_nbmois			IN NUMBER,
			  			    p_cons_rees			IN VARCHAR2
							)  return VARCHAR2;

-- Majuscule pour javascript qui utilise le nom des colonnes pour l'automates.
TYPE conso_rees_ListeViewType IS RECORD(
				 	CODE_ACTIVITE REE_ACTIVITES.CODE_ACTIVITE%TYPE,
				 	MOIS_1 		  VARCHAR2(9),
					MOIS_2		  VARCHAR2(9),
					MOIS_3 		  VARCHAR2(9),
					MOIS_4 		  VARCHAR2(9),
					MOIS_5 		  VARCHAR2(9),
					MOIS_6 		  VARCHAR2(9),
					MOIS_7		  VARCHAR2(9),
					MOIS_8		  VARCHAR2(9),
					MOIS_9 		  VARCHAR2(9),
					MOIS_10 	  VARCHAR2(9),
					MOIS_11		  VARCHAR2(9),
					MOIS_12		  VARCHAR2(9),
					TOTAL_CONS	  VARCHAR2(9),
					TOTAL_REES	  VARCHAR2(9),
					TOTAL_MOIS_1  VARCHAR2(9),
					TOTAL_MOIS_2  VARCHAR2(9),
					TOTAL_MOIS_3  VARCHAR2(9),
					TOTAL_MOIS_4  VARCHAR2(9),
					TOTAL_MOIS_5  VARCHAR2(9),
					TOTAL_MOIS_6  VARCHAR2(9),
					TOTAL_MOIS_7  VARCHAR2(9),
					TOTAL_MOIS_8  VARCHAR2(9),
					TOTAL_MOIS_9  VARCHAR2(9),
					TOTAL_MOIS_10 VARCHAR2(9),
					TOTAL_MOIS_11 VARCHAR2(9),
					TOTAL_MOIS_12 VARCHAR2(9)
                                         );

TYPE conso_rees_listeCurType IS REF CURSOR RETURN conso_rees_ListeViewType;


PROCEDURE lister_conso_reestime( 	p_ident         IN VARCHAR2,
                              		p_userid   		IN VARCHAR2,
                              		p_codsg    	    IN VARCHAR2,
                              		p_code_scenario IN VARCHAR2,
                              		p_curseur  		IN OUT conso_rees_listeCurType
								);

FUNCTION get_nb_jour_ouvre( p_date IN VARCHAR2 ) RETURN VARCHAR2;

TYPE total_ouvre_ListeViewType IS RECORD(
					TOTAL_MOIS_1     VARCHAR2(9),
					TOTAL_MOIS_2  	 VARCHAR2(9),
					TOTAL_MOIS_3  	 VARCHAR2(9),
					TOTAL_MOIS_4  	 VARCHAR2(9),
					TOTAL_MOIS_5  	 VARCHAR2(9),
					TOTAL_MOIS_6  	 VARCHAR2(9),
					TOTAL_MOIS_7  	 VARCHAR2(9),
					TOTAL_MOIS_8  	 VARCHAR2(9),
					TOTAL_MOIS_9  	 VARCHAR2(9),
					TOTAL_MOIS_10 	 VARCHAR2(9),
					TOTAL_MOIS_11 	 VARCHAR2(9),
					TOTAL_MOIS_12 	 VARCHAR2(9),
					TOTAL_ANNEE_CONS VARCHAR2(9),
					TOTAL_ANNEE_REES VARCHAR2(9),
					TOTAL_OUVRE_1  	 VARCHAR2(9),
					TOTAL_OUVRE_2  	 VARCHAR2(9),
					TOTAL_OUVRE_3  	 VARCHAR2(9),
					TOTAL_OUVRE_4  	 VARCHAR2(9),
					TOTAL_OUVRE_5  	 VARCHAR2(9),
					TOTAL_OUVRE_6  	 VARCHAR2(9),
					TOTAL_OUVRE_7  	 VARCHAR2(9),
					TOTAL_OUVRE_8  	 VARCHAR2(9),
					TOTAL_OUVRE_9  	 VARCHAR2(9),
					TOTAL_OUVRE_10 	 VARCHAR2(9),
					TOTAL_OUVRE_11 	 VARCHAR2(9),
					TOTAL_OUVRE_12 	 VARCHAR2(9)
                                         );

TYPE total_ouvre_listeCurType IS REF CURSOR RETURN total_ouvre_ListeViewType;

PROCEDURE lister_total_ouvre_mois( 	p_ident         IN VARCHAR2,
                              		p_codsg    	    IN VARCHAR2,
                              		p_code_scenario IN VARCHAR2,
                              		p_curseur  		IN OUT total_ouvre_listeCurType
                             	);

PROCEDURE update_rees(	p_chaine	IN  VARCHAR2,
                        p_nbcurseur OUT INTEGER,
                        p_message   OUT VARCHAR2
					 );

TYPE scenarios_ListeViewType IS RECORD(  CODE_ACTIVITE   VARCHAR2(12),
 							   			 LIB_ACTIVITE     VARCHAR2(75)
					  				  );
TYPE scenarios_listeCurType IS REF CURSOR RETURN scenarios_ListeViewType;
PROCEDURE lister_scenarios_dpg( 	p_codsg IN VARCHAR2,
   			 						p_userid 	IN VARCHAR2,
   									p_curseur IN OUT scenarios_listeCurType
                                 );

TYPE activites_ListeViewType IS RECORD( CODE_ACTIVITE   VARCHAR2(12),
  							 			LIB_ACTIVITE    VARCHAR2(60)
					  					);
TYPE activites_listeCurType IS REF CURSOR RETURN activites_ListeViewType;
PROCEDURE lister_activites_dpg(	p_codsg   		 IN VARCHAR2,
   								p_userid  		 IN VARCHAR2,
		  						p_curseur IN OUT activites_listeCurType
                             );

PROCEDURE ajout_activite( p_chaine	IN  VARCHAR2,
                          p_nbcurseur OUT INTEGER,
                          p_message   OUT VARCHAR2
					 	  );


	-- ------------------------------------------------------------------------
    --le type tableau_numerique définit un tableau de NUMBER
    -- ------------------------------------------------------------------------


    TYPE tableau_numerique IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;

    TYPE Liste_chaine      is varray(500) of VARCHAR2(200);
	TYPE liste_date        is varray(500) of DATE;


   -- ------------------------------------------------------------------------
   -- Nom        : nb_jours_travail
   -- Auteur     : BAA
   -- Decription : renvoi le nombre de jours de travail pour un mois donner
   --
   -- Paramètres : p_ident  (IN) identifiant de la ressource
   --              p_type   (IN) type de la ressource
   --              p_date  (IN)  La date de travail sous from 01/mm/yyyy
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     FUNCTION nb_jours_travail(p_ident IN ree_ressources.ident%TYPE,
     						   p_type IN ree_ressources.type%TYPE,
							  p_date IN DATE
				              ) RETURN NUMBER;


   -- ------------------------------------------------------------------------
   -- Nom        : nb_jours_travail_annee
   -- Auteur     : BAA
   -- Decription : renvoi le nombre de jours de travail pour l'anne en cours
   --
   -- Paramètres : p_ident  (IN) identifiant de la ressource
   --              p_type   (IN) type de la ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     FUNCTION nb_jours_travail_annee(p_ident IN ree_ressources.ident%TYPE,
     								p_type IN ree_ressources.type%TYPE,
							        p_moismens IN DATE
				                    ) RETURN NUMBER;


   -- ------------------------------------------------------------------------
   -- Nom        : ree_saisie_init_date
   -- Auteur     : BAA
   -- Decription : insere les lignes des consu_prevu pour chaque activite mois
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_ident  (IN) identifiant de la ressource
   --              p_type   (IN) type de la ressource
   --              p_date  (IN)  La date de travail sous from 01/mm/yyyy
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     PROCEDURE ree_saisie_init_date(p_codsg 	IN ligne_bip.codsg%TYPE,
				                     p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							         p_ident IN ree_ressources.ident%TYPE,
							         p_type IN ree_ressources.type%TYPE,
									 p_date IN DATE
									 );



   -- ------------------------------------------------------------------------
   -- Nom        : ree_saisie_init_absences
   -- Auteur     : BAA
   -- Decription : insere les lignes des consu_prevu pour de l'activite de l'annee
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_ident  (IN) identifiant de la ressource
   --              p_type   (IN) type de la ressource
   --              p_moismens  (IN) le moismens de la table datdebex
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     PROCEDURE ree_saisie_init_absences(p_codsg 	IN ligne_bip.codsg%TYPE,
				                        p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							            p_ident IN ree_ressources.ident%TYPE,
							            p_type IN ree_ressources.type%TYPE,
										p_moismens IN DATE
									    );


   -- ------------------------------------------------------------------------
   -- Nom        : ree_saisie_init_tous
   -- Auteur     : BAA
   -- Decription : insere les lignes des conso_prevu pour chaque activite l'annee en cours
   --              inclus l'activites absences
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_ident  (IN) identifiant de la ressource
   --              p_type   (IN) type de la ressource
   -- 			   NB_ACTIVITE (IN) le nombre d'activite dans la table ree_ressource_activite
   --              p_moismens  (IN) le moismens de la table datdebex
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     PROCEDURE ree_saisie_init_tous(p_codsg 	     IN ligne_bip.codsg%TYPE,
				                     p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							         p_ident         IN ree_ressources.ident%TYPE,
							         p_type          IN ree_ressources.type%TYPE,
									 NB_ACTIVITE 	 IN NUMBER,
									 p_moismens 	 IN DATE
									 );



   -- ------------------------------------------------------------------------
   -- Nom        : ree_saisie_initialise
   -- Auteur     : BAA
   -- Decription : c'est la methode major qui insere les lignes des consu_prevu pour chaque activite l'annee en cours
   --              inclus les activites absences si les activites existe
   --              sinon elle insere que des lignes de l'activites absences
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_ident  (IN) identifiant de la ressource
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


     PROCEDURE ree_saisie_initialise(p_codsg 	     IN VARCHAR2,
				                     p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							         p_ident         IN VARCHAR2
									 );


END PACK_REE_SAISIE;
/

CREATE OR REPLACE PACKAGE BODY PACK_REE_SAISIE AS

-- ************************************************************************************************
-- Procédure lister_conso_reestime
--
-- Renvoi le nombre de jour consommé et le nb de jour ouvré par mois pour une ressource et un code dpg
--
-- ************************************************************************************************
PROCEDURE lister_conso_reestime( 	p_ident         IN VARCHAR2,
                              		p_userid   		IN VARCHAR2,
                              		p_codsg    	    IN VARCHAR2,
                              		p_code_scenario IN VARCHAR2,
                              		p_curseur  		IN OUT conso_rees_listeCurType
                             	) IS
	l_anneecourante VARCHAR2(4);
	l_datemens 		DATE;
	l_annee 		DATE;
	l_mois_saisie   VARCHAR2(10);
	l_nbmois 		NUMBER(2);
	l_type_ress     REE_RESSOURCES.TYPE%TYPE;
	l_ident 	    REE_RESSOURCES.IDENT%TYPE;
BEGIN

-- On récupère le type de la ressource et l'identifiant de la ressource
	l_type_ress := substr(p_ident,length(p_ident),1);
	l_ident := to_number(substr(p_ident,0,length(p_ident)-1));

-- Nb de mois saisissables calculé suivant la date de la prochaine mensuelle
	select to_char(datdebex,'YYYY'), moismens, datdebex
	  into l_anneecourante, l_datemens, l_annee
	  from datdebex;

-- Correction de début d'annéé
	if (l_datemens<l_annee) then
		l_mois_saisie := TO_CHAR(l_annee,'MM/YYYY');
		l_nbmois := 0;
	else
		l_mois_saisie := TO_CHAR(l_datemens,'MM/YYYY');
		l_nbmois := TO_NUMBER(TO_CHAR(l_datemens,'MM'));
	end if ;

-- Si la ressource n'est pas de type sous-traitance (cas normal)
	if (l_type_ress != 'S') then
	  	OPEN p_curseur FOR
-- On sélectionne le réestimé et le consomme
		select r.CODE_ACTIVITE CODE_ACTIVITE,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '01/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_1,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '02/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_2,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '03/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_3,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '04/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_4,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '05/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_5,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '06/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_6,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '07/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_7,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '08/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_8,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '09/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_9,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '10/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_10,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '11/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_11,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '12/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_12,
			   PACK_REE_SAISIE.f_get_total_activite_annee(l_ident, l_type_ress, l_mois_saisie, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois, 'C') TOTAL_CONS,
			   PACK_REE_SAISIE.f_get_total_activite_annee(l_ident, l_type_ress, l_mois_saisie, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois, 'R') TOTAL_RESS,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '01/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_1,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '02/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_2,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '03/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_3,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '04/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_4,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '05/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_5,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '06/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_6,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '07/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_7,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '08/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_8,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '09/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_9,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '10/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_10,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '11/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_11,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '12/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_12
		  from REE_ACTIVITES r
		 where r.CODE_ACTIVITE in (
		                             -- Activités pour lesquelles il y a du réestimé pour cette ressource
		 							 select distinct(rr.CODE_ACTIVITE)
									  from REE_REESTIME rr
								     where rr.IDENT = l_ident
								       and rr.TYPE = l_type_ress
								   	   and rr.CODSG = to_number(p_codsg)
									   and rr.CODE_SCENARIO = p_code_scenario
									 union
									 -- Activités pour lesquelles il y a du consommé pour cette ressource
									 select distinct(ra.CODE_ACTIVITE)
									  from REE_ACTIVITES_LIGNE_BIP ra, PROPLUS p
								     where ra.PID = p.FACTPID
								       and p.tires = l_ident
								   	   and ra.CODSG = to_number(p_codsg)
								   	   and p.cdeb >= l_annee
								   	 union
								   	 -- Sous traitance fournie
								   	 select 'SST FOURNIE' from dual
								   	 union
								   	 -- Absences
								   	 select 'ABSENCES' from dual
									 )
	   	   and r.CODSG = to_number(p_codsg)
 		 order by 1;
	else
-- si la ressource est une sous-traitance
	  	OPEN p_curseur FOR
		select r.CODE_ACTIVITE CODE_ACTIVITE,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '01/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_1,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '02/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_2,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '03/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_3,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '04/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_4,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '05/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_5,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '06/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_6,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '07/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_7,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '08/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_8,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '09/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_9,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '10/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_10,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '11/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_11,
			   PACK_REE_SAISIE.f_get_activite_mois(l_ident, l_type_ress, '12/'||l_anneecourante, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois) CONSO_12,
			   PACK_REE_SAISIE.f_get_total_activite_annee(l_ident, l_type_ress, l_mois_saisie, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois, 'C') TOTAL_CONS,
			   PACK_REE_SAISIE.f_get_total_activite_annee(l_ident, l_type_ress, l_mois_saisie, r.CODSG, r.CODE_ACTIVITE, p_code_scenario, l_nbmois, 'R') TOTAL_RESS,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '01/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_1,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '02/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_2,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '03/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_3,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '04/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_4,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '05/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_5,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '06/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_6,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '07/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_7,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '08/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_8,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '09/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_9,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '10/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_10,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '11/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_11,
			   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '12/'||l_anneecourante, r.CODSG, p_code_scenario, l_nbmois) TOTAL_MOIS_12
		  from REE_ACTIVITES r
		 where r.CODE_ACTIVITE in (
		 		                     -- Activités pour lesquelles il y a du réestimé pour cette ressource de sous-traitance
									 select distinct(rr.CODE_ACTIVITE)
									  from REE_REESTIME rr
								     where rr.IDENT = l_ident
								       and rr.TYPE = l_type_ress
								   	   and rr.CODSG = to_number(p_codsg)
									   and rr.CODE_SCENARIO = p_code_scenario
									union
									 -- Activités pour lesquelles il y a du consommé en sous-traitance
									select distinct(rr.CODE_ACTIVITE)
									  from REE_ACTIVITES_LIGNE_BIP rr, PROPLUS p
								     where p.FACTPID  = rr.PID
									   and p.FACTPDSG = rr.CODSG
								   	   and rr.CODSG = to_number(p_codsg)
								   	   and p.cdeb >= l_annee
									   and not exists ( select 1 from REE_RESSOURCES ress
							                                 where ress.codsg = to_number(p_codsg)
							                                   and ress.ident = p.tires
							                                   and ress.type <> 'X' )
									   )
	   	   and r.CODSG = to_number(p_codsg)
		 order by 1;
	end if;

END lister_conso_reestime;


--*************************************************************************************************
-- Procédure liste_ress_dpg
--
-- Sélectionne les liste des ressources disponible pour un DPG donné
--
-- ************************************************************************************************
PROCEDURE liste_ress_dpg( 	p_codsg 	IN VARCHAR2,
   							p_userid 	IN VARCHAR2,
   							p_curseur 	IN OUT ress_listeCurType
                             ) IS
	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

BEGIN

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
	    pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
        raise_application_error(-20203,l_msg);
    ELSE
        IF ( pack_habilitation.fhabili_me(p_codsg, p_userid) = 'faux' ) THEN
		    pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
			raise_application_error(-20364,l_msg);
        ELSE
			BEGIN
	        	OPEN p_curseur FOR
	              	SELECT ident||type code, rnom || ' ' || rprenom|| ' - ' ||type||' ' ||ident LIB_RESSß
	              	  FROM ree_ressources
	              	 WHERE codsg = TO_NUMBER(p_codsg)
	              	 ORDER by type,rnom,rprenom;
     		EXCEPTION
			    WHEN No_Data_Found THEN
                 BEGIN
				      l_msg := 'Veuillez selectionner une ressource';
				      raise_application_error(-20203,l_msg);
			     END;
		        WHEN OTHERS THEN
         		    raise_application_error( -20997, SQLERRM);
            END;
        END IF;
    END IF;
END liste_ress_dpg;


--*************************************************************************************************
-- Procédure select_ressource
--
-- Permet de récupérer des infos sur une ressource donnée
--
-- ************************************************************************************************
PROCEDURE select_ressource(	p_ident             IN VARCHAR2,
		  					p_userid 			IN VARCHAR2,
		  					p_codsg 			IN VARCHAR2,
		  					p_code_scenario		IN VARCHAR2,
							p_curressource 		IN OUT ressourceCurType,
			    			p_nbpages       	OUT VARCHAR2,
                            p_numpage       	OUT VARCHAR2,
							p_menu				OUT VARCHAR2,
                            p_nbcurseur     	OUT INTEGER,
                            p_message       	OUT VARCHAR2
							) IS
	l_count_rees NUMBER(3);
	l_count_cons NUMBER(3);
	l_count NUMBER(3);
	l_msg VARCHAR2(500);
	l_cpp_ident REE_RESSOURCES.ident%TYPE;
	l_datemens DATE;
	l_annee DATE;
	l_mois_saisie VARCHAR2(10);
	l_nbmois NUMBER(2);
	l_nbpages  NUMBER(5);
	l_menu VARCHAR2(25);

	l_ident 	    REE_RESSOURCES.IDENT%TYPE;
	l_type_ress REE_RESSOURCES.type%TYPE;
BEGIN

	 p_numpage := 'NumPage#1';

-- Nb de mois saisissables calculé suivant la date de la prochaine mensuelle
	select moismens, datdebex
	  into l_datemens, l_annee
	  from datdebex;


-- On récupère le type de la ressource

   BEGIN
	select type
	  into l_type_ress
	  from REE_RESSOURCES r
	 where to_char(r.ident)||type = p_ident
	   and r.CODSG = to_number(p_codsg);
  EXCEPTION
   WHEN No_Data_Found THEN
        l_msg := 'Veuillez selectionner une ressource';
	    raise_application_error(-20203,l_msg);
    END;

-- On récupère l'identifiant de la ressource
	l_ident := to_number(substr(p_ident,0,length(p_ident)-1));

-- Compter le nombre d'activité dans le réestimé pour la ressource

  BEGIN
   select count(distinct(r.code_activite))
	  into l_count_rees
	  from REE_REESTIME r
	 where r.ident = l_ident
	   and r.type = l_type_ress
	   and r.CODSG = to_number(p_codsg)
	   and r.CODE_SCENARIO = p_code_scenario ;

   EXCEPTION
   WHEN No_Data_Found THEN
        l_msg := 'Veuillez selectionner un scénario';
	    raise_application_error(-20203,l_msg);
    END;

-- Compter le nombre d'activité dans le consommé pour la ressource
-- On ne prend pas en compte le scénario car il est uniquement utilisé pour le réestimé
	select count(distinct(r.code_activite))
	  into l_count_cons
	  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
	 where p.FACTPID  = r.PID
	   and p.FACTPDSG = r.CODSG
	   and r.CODSG = to_number(p_codsg)
	   and p.cdeb >= l_annee
	   and ( (l_type_ress<>'S' and p.TIRES = l_ident )
	         or
			 (l_type_ress='S' and not exists ( select 1 from REE_RESSOURCES ress
                                                where ress.codsg = to_number(p_codsg)
                                                  and ress.ident = p.tires
                                                  and ress.type <> 'X' )
			 )
		   );


	l_count := l_count_rees;
	if (l_count < l_count_cons) then
	   l_count := l_count_cons;
	end if;

	l_nbpages := CEIL(l_count/10);
	if (l_nbpages=0) then
	    l_nbpages := 1;
	end if;
	p_nbpages := 'NbPages#'|| l_nbpages;

-- nom du menu courant
	l_menu := pack_global.lire_globaldata(p_userid).menutil;
	p_menu := 'Menu#'||l_menu;

-- Correction de début d'année
	if (l_datemens<l_annee) then
		l_mois_saisie := TO_CHAR(l_annee,'MM/YYYY');
		l_nbmois := 0;
	else
		l_mois_saisie := TO_CHAR(l_datemens,'MM/YYYY');
		l_nbmois := TO_NUMBER(TO_CHAR(l_datemens,'MM'));
	end if ;


	OPEN p_curressource  FOR
       	SELECT ident||type ident, rnom || ' ' || rprenom|| ' - ' ||type||' ' ||ident ressource,
			   l_mois_saisie  MOIS,
			   l_nbmois  NBMOIS,
			   RNOM||' '||RPRENOM KeyList4,
			   l_mois_saisie  KeyList5,
			   to_char(l_count) KeyList6,
			   type type_ress,
			   DECODE(to_char(datdep,'yyyy'),to_char(l_annee,'yyyy'),DECODE(to_char(datdep,'dd'),'01',to_char(datdep,'mm'),(extract(MONTH FROM datdep)+1)),13)
		 FROM ree_ressources
	     WHERE ident = l_ident
	     AND   type  = l_type_ress
		 AND   codsg = p_codsg;

END select_ressource;


--*************************************************************************************************
-- Procédure f_get_nbjour_ouv_mois
--
-- Renvoi le nombre de jour ouvré pour un mois donné
--
-- ************************************************************************************************
FUNCTION f_get_nbjour_ouv_mois ( p_mois IN VARCHAR2	) RETURN NUMBER IS
	l_nbjour NUMBER;
BEGIN
	select cjours
	  into l_nbjour
	  from calendrier
	 where to_char(calanmois,'MM/YYYY') = p_mois;

	return l_nbjour ;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		Return 0;
END f_get_nbjour_ouv_mois;


--*************************************************************************************************
-- Procédure f_get_activite_mois
--
-- Renvoi le nombre de jour consommé pour une ressource, une activité et un mois donnés
--
-- ************************************************************************************************
FUNCTION f_get_activite_mois ( p_ident 		    IN NUMBER,
			  			       p_type_ress	    IN VARCHAR2,
			  			       p_mois   		IN VARCHAR2,
			  			       p_codsg			IN VARCHAR2,
			  			       p_code_activite	IN VARCHAR2,
                       		   p_code_scenario 	IN VARCHAR2,
			  			       p_nbmois			IN NUMBER
							)  return VARCHAR2  IS
    l_total NUMBER;
BEGIN
-- si on est dans un mois consommé
	if (p_nbmois >= TO_NUMBER(SUBSTR(p_mois,1,2))) then
	   -- Ressource de type Sous-traitance reçue
	    if (p_type_ress = 'S') then
			select nvl(sum(p.cusag),0)
			  into l_total
			  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
		     where p.FACTPID = r.PID
			   and p.FACTPDSG = r.CODSG
		   	   and r.CODSG = to_number(p_codsg)
			   and r.CODE_ACTIVITE = p_code_activite
		   	   and to_char(p.cdeb,'MM/YYYY') = p_mois
			   and not exists ( select 1 from REE_RESSOURCES ress
                                 where ress.codsg = to_number(p_codsg)
                                   and ress.ident = p.tires
                                   and ress.type <> 'X' )
		  group by r.CODE_ACTIVITE;
	    else
			-- Cas particulier pour la sous-traitance
			if (p_code_activite='SST FOURNIE') then
			    -- Activité uniquement pour les personnes de type P ou F
			    if (p_type_ress = 'P' or p_type_ress = 'F') then
					select nvl(sum(p.cusag),0)
					  into l_total
					  from PROPLUS P
					 where P.TIRES = p_ident
					   and P.PTYPE<>7
				   	   and to_char(p.cdeb,'MM/YYYY') = p_mois
					   and not exists ( select 1
					   	   	   		  	  from REE_ACTIVITES_LIGNE_BIP r
										 where r.codsg = to_number(p_codsg)
										   and r.pid   = P.FACTPID);
				else
					l_total := 0;
				end if;
			-- Cas particulier pour les absences
			elsif (p_code_activite='ABSENCES') then
			    -- Activité uniquement pour les personnes de type P ou F
			    if (p_type_ress = 'P' or p_type_ress = 'F') then
					select nvl(sum(p.cusag),0)
					  into l_total
					  from PROPLUS P
					 where P.TIRES = p_ident
					   and P.PTYPE=7
				   	   and to_char(p.cdeb,'MM/YYYY') = p_mois ;
				else
					l_total := 0;
				end if;
			-- Pour les autres activités
			else
				select nvl(sum(p.cusag),0)
				  into l_total
				  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
			     where p.FACTPID = r.PID
			       and p.tires = p_ident
			   	   and r.CODSG = to_number(p_codsg)
				   and r.CODE_ACTIVITE = p_code_activite
			   	   and to_char(p.cdeb,'MM/YYYY') = p_mois
			  group by r.CODE_ACTIVITE;
			end if;
	    end if;
	else
-- sinon on prend le réestimé
		select nvl(conso_prevu,0)
		  into l_total
		  from REE_REESTIME r
	     where r.IDENT = p_ident
	       and r.type = p_type_ress
	   	   and r.CODSG = to_number(p_codsg)
		   and r.CODE_ACTIVITE = p_code_activite
		   and r.CODE_SCENARIO = p_code_scenario
	   	   and to_char(r.CDEB,'MM/YYYY') = p_mois;
	end if;

	if (l_total<1 and l_total>0) then
	      return to_char(l_total,'FM999990D99');
    else
		return to_char(l_total);
    end if;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		Return '0';

END f_get_activite_mois;

--*************************************************************************************************
-- Procédure f_get_total_mois
--
-- Renvoi le nombre de jour consommé ou le réestimé pour une ressource et un mois donné
--
-- ************************************************************************************************
FUNCTION f_get_total_mois ( p_ident 		    IN NUMBER,
			  			    p_type_ress		    IN VARCHAR2,
			  			    p_mois 	   			IN VARCHAR2,
			  			    p_codsg				IN VARCHAR2,
                       		p_code_scenario 	IN VARCHAR2,
			  			    p_nbmois			IN NUMBER
							)  return VARCHAR2  IS
    l_total  NUMBER;
    l_total2 NUMBER;
BEGIN
-- si on est dans un mois consommé
	if (p_nbmois >= TO_NUMBER(SUBSTR(p_mois,1,2))) then
	    if (p_type_ress='S') then
			select nvl(sum(p.cusag),0)
			  into l_total
			  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
		     where p.FACTPID  = r.PID
			   and p.FACTPDSG = r.CODSG
		   	   and r.CODSG = to_number(p_codsg)
		   	   and to_char(p.cdeb,'MM/YYYY') = p_mois
			   and not exists ( select 1 from REE_RESSOURCES ress
                                 where ress.codsg = to_number(p_codsg)
                                   and ress.ident = p.tires
                                   and ress.type <> 'X' );
		else
			select nvl(sum(p.cusag),0)
			  into l_total
			  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
		     where p.FACTPID = r.PID
		       and p.tires = p_ident
		   	   and r.CODSG = to_number(p_codsg)
		   	   and to_char(p.cdeb,'MM/YYYY') = p_mois;

			-- Cas particulier pour la sous-traitance : Activité uniquement pour les personnes de type P ou F
			if (p_type_ress = 'P' or p_type_ress = 'F') then
				select nvl(sum(p.cusag),0)
				  into l_total2
				  from PROPLUS P
				 where P.TIRES = p_ident
				 --  and P.PTYPE<>7
		   	   	   and to_char(p.cdeb,'MM/YYYY') = p_mois
				   and not exists ( select 1
				   	   	   		  	  from REE_ACTIVITES_LIGNE_BIP r
									 where r.codsg = to_number(p_codsg)
									   and r.pid   = P.FACTPID);
				l_total := l_total + l_total2;
			end if;
		end if;
	else
-- sinon on prend le réestimé
		select nvl(sum(r.conso_prevu),0)
		  into l_total
		  from REE_REESTIME r
	     where r.IDENT = p_ident
	       and r.type = p_type_ress
	   	   and r.CODSG = to_number(p_codsg)
		   and r.CODE_SCENARIO = p_code_scenario
	   	   and to_char(r.CDEB,'MM/YYYY') = p_mois;
	end if;

   if (l_total<1 and l_total>0) then
    	return to_char(l_total,'FM999990D99');
	else
		return to_char(l_total);
	end if;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		Return '0';

END f_get_total_mois;

--*************************************************************************************************
-- Procédure f_get_total_activite_annee
--
-- Renvoi le nombre de jour consommé pour une ressource, une activité et une année donnés
--
-- ************************************************************************************************
FUNCTION f_get_total_activite_annee ( p_ident 		    IN NUMBER,
			  			    		  p_type_ress		IN VARCHAR2,
			  			    		  p_mois 	   		IN VARCHAR2,
			  			    		  p_codsg			IN VARCHAR2,
                       				  p_code_activite	IN VARCHAR2,
                       				  p_code_scenario 	IN VARCHAR2,
			  			    		  p_nbmois			IN NUMBER,
			  			    		  p_cons_rees		IN VARCHAR2
									)  return VARCHAR2 IS
    l_total   NUMBER;
	l_datdep  DATE;
	l_annee   DATE;

BEGIN


   SELECT datdep INTO l_datdep
	       FROM ree_ressources
		   where IDENT = p_ident
		   and TYPE = p_type_ress
	   	   and CODSG = to_number(p_codsg);

	SELECT datdebex INTO l_annee
	       FROM datdebex;

-- si on veut le total du consomme
	if (p_cons_rees = 'C') then
		if (p_type_ress = 'S') then
			select nvl(sum(p.cusag),0)
			  into l_total
			  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
		     where p.FACTPID  = r.PID
			   and p.FACTPDSG = r.CODSG
		   	   and r.CODSG = to_number(p_codsg)
			   and r.CODE_ACTIVITE = p_code_activite
		   	   and to_char(p.cdeb,'YYYY') = substr(p_mois,4)
		   	   and to_number(to_char(p.cdeb,'MM')) <= to_number(substr(p_mois,1,2))
			   and not exists ( select 1 from REE_RESSOURCES ress
                                 where ress.codsg = to_number(p_codsg)
                                   and ress.ident = p.tires
                                   and ress.type <> 'X' )
		  group by r.CODE_ACTIVITE;
		else
			-- Cas particulier pour la sous-traitance
			if (p_code_activite='SST FOURNIE') then
			    -- Activité uniquement pour les personnes de type P ou F
			    if (p_type_ress = 'P' or p_type_ress = 'F') then
					select nvl(sum(p.cusag),0)
					  into l_total
					  from PROPLUS P
					 where P.TIRES = p_ident
					   and P.PTYPE<>7
			   	   	   and to_char(p.cdeb,'YYYY') = substr(p_mois,4)
			   	   	   and to_number(to_char(p.cdeb,'MM')) <= to_number(substr(p_mois,1,2))
					   and not exists ( select 1
					   	   	   		  	  from REE_ACTIVITES_LIGNE_BIP r
										 where r.codsg = to_number(p_codsg)
										   and r.pid   = P.FACTPID);
				else
					l_total := 0;
				end if;

			else
				-- Cas particulier des absences
				if (p_code_activite='ABSENCES') then
				    if (p_type_ress = 'P' or p_type_ress = 'F') then
						select nvl(sum(p.cusag),0)
						  into l_total
						  from PROPLUS P
						 where P.TIRES = p_ident
						   and P.PTYPE=7
					   	   and to_char(p.cdeb,'YYYY') = substr(p_mois,4)
   	   			   	   	   and to_number(to_char(p.cdeb,'MM')) <= to_number(substr(p_mois,1,2)) ;
					else
						l_total := 0;
					end if;
				else
					-- Pour les autres activités
						select nvl(sum(p.cusag),0)
						  into l_total
						  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
					     where p.FACTPID = r.PID
					       and p.tires = p_ident
					   	   and r.CODSG = to_number(p_codsg)
						   and r.CODE_ACTIVITE = p_code_activite
					   	   and to_char(p.cdeb,'YYYY') = substr(p_mois,4)
					   	   and to_number(to_char(p.cdeb,'MM')) <= to_number(substr(p_mois,1,2))
					  group by r.CODE_ACTIVITE;
				end if ;
			end if;
	    end if;
	end if;
-- si on veut le total du réestimé
	if (p_cons_rees = 'R') then
		select nvl(sum(conso_prevu),0)
		  into l_total
		  from REE_REESTIME r
	     where r.IDENT = p_ident
	       and r.type = p_type_ress
	   	   and r.CODSG = to_number(p_codsg)
		   and r.CODE_ACTIVITE = p_code_activite
		   and r.CODE_SCENARIO = p_code_scenario
	   	   and to_char(r.cdeb,'YYYY') = substr(p_mois,4)
	   	   and to_number(to_char(r.cdeb,'MM')) > to_number(substr(p_mois,1,2))
		   and to_number(to_char(r.cdeb,'MM')) < to_number(DECODE(to_char(l_datdep,'yyyy'),to_char(l_annee,'yyyy'),DECODE(to_char(l_datdep,'dd'),'01',to_char(l_datdep,'mm'),(extract(MONTH FROM l_datdep)+1)),13));

	end if;

	if (l_total<1 and l_total>0) then
		return to_char(l_total,'FM9990D99');
	else
		return to_char(l_total);
	end if;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		Return '0';

END f_get_total_activite_annee;


--*************************************************************************************************
-- Procédure f_get_total_annee
--
-- Renvoi le nombre de jour consommé pour une ressource, une activité et une année donnés
--
-- ************************************************************************************************
FUNCTION f_get_total_annee (p_ident 		    IN NUMBER,
			  			    p_type_ress		    IN VARCHAR2,
			  			    p_mois 	   			IN VARCHAR2,
			  			    p_codsg				IN VARCHAR2,
                       		p_code_scenario 	IN VARCHAR2,
			  			    p_nbmois			IN NUMBER,
			  			    p_cons_rees			IN VARCHAR2
							)  return VARCHAR2 IS
    l_total  NUMBER;
    l_total2 NUMBER;
    l_total3 NUMBER;
	l_datdep DATE;
	l_annee  DATE;

BEGIN

    SELECT datdep INTO l_datdep
	       FROM ree_ressources
		   where IDENT = p_ident
		   and TYPE = p_type_ress
	   	   and CODSG = to_number(p_codsg);

	SELECT datdebex INTO l_annee
	       FROM datdebex;


-- si on veut le total du consomme
	if (p_cons_rees = 'C') then
	    if (p_type_ress = 'S') then
			select nvl(sum(p.cusag),0)
			  into l_total
			  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
		     where p.FACTPID  = r.PID
			   and p.FACTPDSG = r.CODSG
		   	   and r.CODSG = to_number(p_codsg)
		   	   and to_char(p.cdeb,'YYYY') = substr(p_mois,4)
		   	   and to_number(to_char(p.cdeb,'MM')) <= p_nbmois
			   and not exists ( select 1 from REE_RESSOURCES ress
                                 where ress.codsg = to_number(p_codsg)
                                   and ress.ident = p.tires
                                   and ress.type <> 'X' );
		else
			select nvl(sum(p.cusag),0)
			  into l_total
			  from REE_ACTIVITES_LIGNE_BIP r, PROPLUS p
		     where p.FACTPID = r.PID
		       and p.tires = p_ident
		   	   and r.CODSG = to_number(p_codsg)
		   	   and to_char(p.cdeb,'YYYY') = substr(p_mois,4)
		   	   and to_number(to_char(p.cdeb,'MM')) <= p_nbmois;

			-- Cas particulier pour la sous-traitance : Activité uniquement pour les personnes de type P ou F
			if (p_type_ress = 'P' or p_type_ress = 'F') then
				select nvl(sum(p.cusag),0)
				  into l_total2
				  from PROPLUS P
				 where P.TIRES = p_ident
				   and P.PTYPE<>7
		   	   	   and to_char(p.cdeb,'YYYY') = substr(p_mois,4)
		   	   	   and to_number(to_char(p.cdeb,'MM')) <= p_nbmois
				   and not exists ( select 1
				   	   	   		  	  from REE_ACTIVITES_LIGNE_BIP r
									 where r.codsg = to_number(p_codsg)
									   and r.pid   = P.FACTPID);
				-- Cas particulier pour les absences
				select nvl(sum(p.cusag),0)
				  into l_total3
				  from PROPLUS P
				 where P.TIRES = p_ident
				   and P.PTYPE=7
			   	   and to_char(p.cdeb,'YYYY') = substr(p_mois,4)
		   	   	   and to_number(to_char(p.cdeb,'MM')) <= p_nbmois ;

				l_total := l_total + l_total2+ l_total3;
			end if;
		end if;
	end if;
-- si on veut le total du réestimé
	if (p_cons_rees = 'R') then
		select nvl(sum(conso_prevu),0)
		  into l_total
		  from REE_REESTIME r
	     where r.IDENT = p_ident
	       and r.TYPE = p_type_ress
	   	   and r.CODSG = to_number(p_codsg)
		   and r.CODE_SCENARIO = p_code_scenario
	   	   and to_char(r.cdeb,'YYYY') = substr(p_mois,4)
	   	   and to_number(to_char(r.cdeb,'MM')) > p_nbmois
		   and to_number(to_char(r.cdeb,'MM')) < to_number(DECODE(to_char(l_datdep,'yyyy'),to_char(l_annee,'yyyy'),DECODE(to_char(l_datdep,'dd'),'01',to_char(l_datdep,'mm'),(extract(MONTH FROM l_datdep)+1)),13));


	end if;

	if (l_total<1 and l_total>0) then
		return to_char(l_total,'FM9990D99');
	else
		return to_char(l_total);
	end if;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		Return '0';

END f_get_total_annee;



-- ************************************************************************************************
-- Procédure lister_nb_jour_ouvre
--
-- Renvoi le nombre de jour ouvré par mois pour une année
--
-- ************************************************************************************************
PROCEDURE lister_nb_jour_ouvre( p_curseur  IN OUT jourouvre_listeCurType ) IS
	l_anneecourante VARCHAR2(4);
	l_annee date;
BEGIN
	select to_char(datdebex,'YYYY'), datdebex
	  into l_anneecourante, l_annee
	  from datdebex;

  	OPEN p_curseur FOR
	  select to_char(c.CALANMOIS, 'MM') MOIS, c.CJOURS NB_JOUR
	    from CALENDRIER c
	   where to_char(c.CALANMOIS, 'YYYY') = '2004'
	order by c.CALANMOIS;

END lister_nb_jour_ouvre;


-- ************************************************************************************************
-- Procédure get_nb_jour_ouvre
--
-- Renvoi le nombre de jour ouvré par mois pour une année
--
-- ************************************************************************************************
FUNCTION get_nb_jour_ouvre( p_date IN VARCHAR2 ) RETURN VARCHAR2 IS
	l_nbjour NUMBER;
BEGIN
    select c.CJOURS NB_JOUR
	  into l_nbjour
	  from CALENDRIER c
	 where to_char(c.CALANMOIS, 'MM/YYYY') = p_date;

    return to_char(l_nbjour );

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		Return '0';


END get_nb_jour_ouvre;

-- ************************************************************************************************
-- Procédure lister_total_ouvre_mois
--
-- Renvoi le total de consommée/réestimé et de jour ouvré par mois pour une ressource, un code dpg, et un scénario
--
-- ************************************************************************************************
PROCEDURE lister_total_ouvre_mois( 	p_ident         IN VARCHAR2,
                              		p_codsg    	    IN VARCHAR2,
                              		p_code_scenario IN VARCHAR2,
                              		p_curseur  		IN OUT total_ouvre_listeCurType
                             	) IS
	l_anneecourante VARCHAR2(4);
	l_datemens 		DATE;
	l_annee 		DATE;
	l_mois_saisie   VARCHAR2(10);
	l_nbmois 		NUMBER(2);
	l_ident 	    REE_RESSOURCES.IDENT%TYPE;
	l_type_ress 	REE_RESSOURCES.type%TYPE;

BEGIN

-- On récupère le type de la ressource et l'identifiant de la ressource
	l_type_ress := substr(p_ident,length(p_ident),1);
	l_ident := to_number(substr(p_ident,0,length(p_ident)-1));

-- Nb de mois saisissables calculé suivant la date de la prochaine mensuelle
	select to_char(datdebex,'YYYY'), moismens, datdebex
	  into l_anneecourante, l_datemens, l_annee
	  from datdebex;

-- Correction de début d'année
	if (l_datemens<l_annee) then
		l_mois_saisie := TO_CHAR(l_annee,'MM/YYYY');
		l_nbmois := 0;
	else
		l_mois_saisie := TO_CHAR(l_datemens,'MM/YYYY');
		l_nbmois := TO_NUMBER(TO_CHAR(l_datemens,'MM'));
	end if ;

-- On enlève un mois par rapport à la prochaine mensuelle pour connaitre le dernier mois saisi

  	OPEN p_curseur FOR
	select PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '01/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_1,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '02/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_2,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '03/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_3,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '04/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_4,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '05/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_5,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '06/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_6,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '07/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_7,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '08/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_8,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '09/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_9,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '10/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_10,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '11/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_11,
		   PACK_REE_SAISIE.f_get_total_mois(l_ident, l_type_ress, '12/'||l_anneecourante, p_codsg, p_code_scenario, l_nbmois) TOTAL_MOIS_12,
		   PACK_REE_SAISIE.f_get_total_annee(l_ident, l_type_ress, '01/'||l_anneecourante, p_codsg,p_code_scenario, l_nbmois, 'C') TOTAL_ANNEE_CONS,
		   PACK_REE_SAISIE.f_get_total_annee(l_ident, l_type_ress, '01/'||l_anneecourante, p_codsg,p_code_scenario, l_nbmois, 'R') TOTAL_ANNEE_REES,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('01/'||l_anneecourante) NB_OUVRE_1,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('02/'||l_anneecourante) NB_OUVRE_2,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('03/'||l_anneecourante) NB_OUVRE_3,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('04/'||l_anneecourante) NB_OUVRE_4,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('05/'||l_anneecourante) NB_OUVRE_5,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('06/'||l_anneecourante) NB_OUVRE_6,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('07/'||l_anneecourante) NB_OUVRE_7,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('08/'||l_anneecourante) NB_OUVRE_8,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('09/'||l_anneecourante) NB_OUVRE_9,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('10/'||l_anneecourante) NB_OUVRE_10,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('11/'||l_anneecourante) NB_OUVRE_11,
		   PACK_REE_SAISIE.get_nb_jour_ouvre('12/'||l_anneecourante) NB_OUVRE_12
	  from DUAL;

END lister_total_ouvre_mois;


--*************************************************************************************************
-- Procédure update_rees
--
-- Permet de modifier les réestimés d'une ressource
--
-- ************************************************************************************************
PROCEDURE update_rees(	p_chaine	IN  VARCHAR2,
                        p_nbcurseur OUT INTEGER,
                        p_message   OUT VARCHAR2
					 ) IS
	l_length number(7);
	l_chaine varchar2(32000);
	l_pos number(7);
	l_pos1 number(7);
	l_ident VARCHAR2(6);
	l_ligne varchar2(32000);
	l_code_activite REE_REESTIME.CODE_ACTIVITE%TYPE;
	l_codsg REE_REESTIME.CODSG%TYPE;
	l_code_scenario REE_REESTIME.CODE_SCENARIO%TYPE;
	l_point1 number(7);
	l_point2 number(7);
	l_point3 number(7);
	l_point4 number(7);
	l_separateur number(7);
	l_separateur1 number(7);
	l_ligne_rees varchar2(32000);
	l_mois number(2);
	l_rees varchar2(100);
	l_exist number(1);
	l_annee varchar2(4);
	l_type_ressource REE_RESSOURCES.TYPE%TYPE;
	l_debug varchar2(1) := 'N';
	l_msg VARCHAR2(1024);
BEGIN
	l_debug := 'N';

	p_message:='';
-- p_chaine du type ':ident:code_activite1;REES_<ligne>_<mois>=;REES_<ligne>_<mois+1>=;....;:'
	l_length := LENGTH(p_chaine);
	l_ident  := SUBSTR(p_chaine,1,INSTR(p_chaine,';',1,1)-1);

-- On supprime le type se trouvant à la fin de l'identifiant
    l_type_ressource := substr(l_ident,length(l_ident));
	l_ident := substr(l_ident,0,length(l_ident)-1);

	if (l_debug='O') then
	   dbms_output.put_line('ident:'||l_ident);
	end if;

	l_point1 := INSTR(p_chaine,';',1,1);
	l_point2 := INSTR(p_chaine,';',1,2);
	l_point3 := INSTR(p_chaine,';',1,3);

	l_codsg := SUBSTR(p_chaine,l_point1+1,l_point2-l_point1-1);
	if (l_debug='O') then
	   dbms_output.put_line('codsg:'||l_codsg);
	end if;

	l_code_scenario := SUBSTR(p_chaine,l_point2+1,l_point3-l_point2-1);
	if (l_debug='O') then
	   dbms_output.put_line('code_scenario:'||l_code_scenario);
	end if;

/*	BEGIN
		select r.type
		  into l_type_ressource
		  from REE_RESSOURCES r
		 where to_char(r.IDENT)||r.TYPE = l_ident
		   and r.CODSG = to_number(l_codsg);
    EXCEPTION
	    WHEN NO_DATA_FOUND THEN
		    pack_global.recuperer_message(20978, '%s1', l_ident, '%s2', l_codsg, NULL, l_msg);
	        raise_application_error(-20978, l_msg);
	    WHEN OTHERS THEN
       	    raise_application_error( -20997, SQLERRM);
	END;*/

	FOR i IN 1..l_length LOOP
		l_pos := INSTR(p_chaine,':',1,i);
		l_pos1 := INSTR(p_chaine,':',1,i+1);
		l_ligne := SUBSTR(p_chaine,l_pos+1,l_pos1-l_pos-1);
		l_point1 := INSTR(l_ligne,';',1,1);
		l_point2 := INSTR(l_ligne,';',1,2);
		l_point3 := INSTR(l_ligne,';',1,3);
		l_point4 := INSTR(l_ligne,';',1,4);

		if (l_debug='O') then
		   dbms_output.put_line('ligne:'||l_ligne);
		end if;

		l_code_activite := SUBSTR(l_ligne,1,l_point1-1);

		if (l_debug='O') then
		   dbms_output.put_line('code_activite:'||l_code_activite);
		end if;

		For j IN 1..LENGTH(l_ligne) LOOP
			l_separateur  := INSTR(l_ligne,';',1,j);
			l_separateur1 := INSTR(l_ligne,';',1,j+1);

			l_ligne_rees := SUBSTR(l_ligne,l_separateur+1,l_separateur1-l_separateur-1);

			if (l_debug='O') then
			   dbms_output.put_line('ligne_rees: |'||l_ligne_rees||'|');
			end if;

			if (l_ligne_rees = '' or l_ligne_rees is null) then
				if (l_debug='O') then
				   dbms_output.put_line('Activité suivante');
				   dbms_output.put_line('==========================');
				end if;
			    exit;
			end if;

		-- Rechercher le mois du réestimé
			l_mois:=TO_NUMBER(SUBSTR(l_ligne_rees,INSTR(l_ligne_rees,'_',1,2)+1,INSTR(l_ligne_rees,'=',1,1)-INSTR(l_ligne_rees,'_',1,2)-1));


		-- Rechercher le réestimé
			l_rees:=SUBSTR(l_ligne_rees,INSTR(l_ligne_rees,'=',1,1)+1,LENGTH(l_ligne_rees)-INSTR(l_ligne_rees,'=',1,1));

			if (l_debug='O') then
			   dbms_output.put_line('mois:'||l_mois||' rees:'||l_rees);
			end if;

		-- Rechercher si l'activité a déjà un réestimé pour le mois
		    BEGIN
				select to_char(datdebex,'YYYY') into l_annee from datdebex;

				select 1
				  into l_exist
				  from REE_REESTIME r
				 where r.IDENT = to_number(l_ident)
				   and r.TYPE  = l_type_ressource
				   and r.CODSG = l_codsg
				   and r.CODE_SCENARIO = l_code_scenario
				   and to_char(r.CDEB,'MM/YYYY') = to_char(l_mois,'FM00')||'/'||l_annee
				   and r.CODE_ACTIVITE = l_code_activite;
				-- si cette requête ne ramène rien on déclenche l'exception NO_DATA_FOUND

				-- Modifier le réestimé s'il n'est pas nul
		   	   	if l_rees is not null then

					if (l_debug='O') then
					   dbms_output.put_line('Modification du réestimé');
					end if;

					update REE_REESTIME r
					   set conso_prevu = to_number(l_rees)
					 where r.IDENT = to_number(l_ident)
				       and r.TYPE  = l_type_ressource
					   and r.CODSG = l_codsg
					   and r.CODE_SCENARIO = l_code_scenario
					   and to_char(r.CDEB,'MM/YYYY') = to_char(l_mois,'FM00')||'/'||l_annee
					   and r.CODE_ACTIVITE = l_code_activite;
		   		else

					if (l_debug='O') then
					   dbms_output.put_line('Suppression du réestimé');
					end if;

					delete REE_REESTIME r
					 where r.IDENT = to_number(l_ident)
				       and r.TYPE  = l_type_ressource
					   and r.CODSG = l_codsg
					   and r.CODE_SCENARIO = l_code_scenario
					   and to_char(r.CDEB,'MM/YYYY') = to_char(l_mois,'FM00')||'/'||l_annee
					   and r.CODE_ACTIVITE = l_code_activite;
		   		end if;

		    commit;

	        EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- pas de réestimé pour l'activité
					if (l_rees!='' or l_rees is not null) then
					   -- Ajouter le nouveau réestimé
						insert into REE_REESTIME (
							   CODSG, CODE_SCENARIO,
							   CDEB,
							   TYPE, IDENT, CODE_ACTIVITE, CONSO_PREVU )
					    VALUES (
						       l_codsg, l_code_scenario,
							   to_date('01/'||to_char(l_mois,'FM00')||'/'||l_annee, 'DD/MM/YYYY'),
							   l_type_ressource, to_number(l_ident), l_code_activite, to_number(l_rees));
					end if;
		    END;

		END LOOP;

		if (INSTR(p_chaine,':',1,i+2)=0) then
			exit;
		end if;
	END LOOP;

	commit;

END update_rees;


--*************************************************************************************************
-- Procédure lister_scenarios_dpg
--
-- Permet de lister les cénario d'un dpg
--
-- ************************************************************************************************
PROCEDURE lister_scenarios_dpg( 	p_codsg IN VARCHAR2,
   			 						p_userid 	IN VARCHAR2,
   									p_curseur IN OUT scenarios_listeCurType
                                 ) IS
	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

BEGIN

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
        raise_application_error(-20203,l_msg);
    ELSE
     	IF ( pack_habilitation.fhabili_me(p_codsg, p_userid)= 'faux' ) THEN
		    pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
			raise_application_error(-20364,l_msg);
        ELSE

			BEGIN
        		OPEN p_curseur FOR
              		SELECT CODE_SCENARIO,CODE_SCENARIO||' - '||LIB_SCENARIO LIB_SCENARIO
					  FROM REE_SCENARIOS
				     WHERE CODSG=TO_NUMBER(p_codsg)
				     ORDER BY OFFICIEL desc, CODE_SCENARIO;
      		EXCEPTION
			     WHEN No_Data_Found THEN
				 BEGIN
				      l_msg := 'Veuillez selectionner un scénario';
				      raise_application_error(-20203,l_msg);
			     END;
			    WHEN OTHERS THEN
         			raise_application_error( -20997, SQLERRM);
            END;
        END IF;
    END IF;

END lister_scenarios_dpg;



--*************************************************************************************************
-- Procédure lister_activites_dpg
--
-- Permet de lister les cénario d'un dpg
--
-- ************************************************************************************************
PROCEDURE lister_activites_dpg(	p_codsg   		 IN VARCHAR2,
   								p_userid  		 IN VARCHAR2,
		  						p_curseur   	 IN OUT activites_listeCurType
                             ) IS
    l_msg 	        VARCHAR2(1024);
	l_codsg    		NUMBER;
	l_act_ress 		VARCHAR2(32000);
	l_code_activite REE_REESTIME.code_activite%TYPE;
BEGIN

	If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
	    pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
        raise_application_error(-20203,l_msg);
    ELSE
        IF ( pack_habilitation.fhabili_me(p_codsg, p_userid) = 'faux' ) THEN
		    pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
			raise_application_error(-20364,l_msg);
        ELSE
			BEGIN
	        	    OPEN p_curseur FOR
	              	    SELECT code_activite CODE_ACTIVITEß, code_activite || ' - ' || lib_activite LIB_ACTIVITEß
	              	      FROM ree_activites
	              	     WHERE codsg = TO_NUMBER(p_codsg)
					     ORDER BY type desc, code_activite;
      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
            END;
        END IF;
    END IF;

END lister_activites_dpg;

--*************************************************************************************************
-- Procédure ajout_activite
--
-- Permet d'ajouter une nouvelle activite au réestimé d'une ressource
--
-- 20/06/2005 : INUTILISE car on fait le test d'existance en javascript maintenant dans la page fSaisieRe.jsp
--
-- ************************************************************************************************
PROCEDURE ajout_activite( p_chaine	IN  VARCHAR2,
                          p_nbcurseur OUT INTEGER,
                          p_message   OUT VARCHAR2
					 	  ) IS
	l_length number(7);
	l_chaine varchar2(32000);
	l_pos number(7);
	l_pos1 number(7);
	l_ident VARCHAR2(6);
	l_ligne varchar2(32000);
	l_code_activite REE_REESTIME.CODE_ACTIVITE%TYPE;
	l_codsg REE_REESTIME.CODSG%TYPE;
	l_code_scenario REE_REESTIME.CODE_SCENARIO%TYPE;
	l_point1 number(7);
	l_point2 number(7);
	l_point3 number(7);
	l_point4 number(7);
	l_separateur number(7);
	l_separateur1 number(7);
	l_ligne_rees varchar2(32000);
	l_mois number(2);
	l_rees varchar2(100);
	l_exist number(1);
	l_annee varchar2(4);
	l_type_ressource REE_RESSOURCES.TYPE%TYPE;
	l_debug varchar2(1) := 'N';
	l_msg VARCHAR2(1024);
BEGIN
	l_debug := 'N';

	p_message:='';
-- p_chaine du type ':ident||type:code_activite1;REES_<ligne>_<mois>=;REES_<ligne>_<mois+1>=;....;:'
	l_length := LENGTH(p_chaine);
	l_ident  := SUBSTR(p_chaine,1,INSTR(p_chaine,';',1,1)-1);

-- On supprime le type se trouvant à la fin de l'identifiant
    l_type_ressource := substr(l_ident,length(l_ident));
	l_ident  := substr(l_ident,0,length(l_ident)-1);

	if (l_debug='O') then
	   dbms_output.put_line('ident:'||l_ident);
	end if;

	l_point1 := INSTR(p_chaine,';',1,1);
	l_point2 := INSTR(p_chaine,';',1,2);
	l_point3 := INSTR(p_chaine,';',1,3);

	l_codsg := SUBSTR(p_chaine,l_point1+1,l_point2-l_point1-1);
	if (l_debug='O') then
	   dbms_output.put_line('codsg:'||l_codsg);
	end if;

	l_code_scenario := SUBSTR(p_chaine,l_point2+1,l_point3-l_point2-1);
	if (l_debug='O') then
	   dbms_output.put_line('code_scenario:'||l_code_scenario);
	end if;

/*	BEGIN
		select r.type
		  into l_type_ressource
		  from REE_RESSOURCES r
		 where to_char(r.IDENT)||r.TYPE = l_ident
		   and r.CODSG = to_number(l_codsg);
    EXCEPTION
	    WHEN NO_DATA_FOUND THEN
		    pack_global.recuperer_message(20978, '%s1', l_ident, '%s2', l_codsg, NULL, l_msg);
	        raise_application_error(-20978, l_msg);
	    WHEN OTHERS THEN
       	    raise_application_error( -20997, SQLERRM);
	END;*/

	FOR i IN 1..l_length LOOP
		l_pos := INSTR(p_chaine,':',1,i);
		l_pos1 := INSTR(p_chaine,':',1,i+1);
		l_ligne := SUBSTR(p_chaine,l_pos+1,l_pos1-l_pos-1);
		l_point1 := INSTR(l_ligne,';',1,1);
		l_point2 := INSTR(l_ligne,';',1,2);
		l_point3 := INSTR(l_ligne,';',1,3);
		l_point4 := INSTR(l_ligne,';',1,4);

		if (l_debug='O') then
		   dbms_output.put_line('ligne:'||l_ligne);
		end if;

		l_code_activite := SUBSTR(l_ligne,1,l_point1-1);

		if (l_debug='O') then
		   dbms_output.put_line('code_activite:'||l_code_activite);
		end if;

		For j IN 1..LENGTH(l_ligne) LOOP
			l_separateur  := INSTR(l_ligne,';',1,j);
			l_separateur1 := INSTR(l_ligne,';',1,j+1);

			l_ligne_rees := SUBSTR(l_ligne,l_separateur+1,l_separateur1-l_separateur-1);

			if (l_debug='O') then
			   dbms_output.put_line('ligne_rees: |'||l_ligne_rees||'|');
			end if;

			if (l_ligne_rees = '' or l_ligne_rees is null) then
				if (l_debug='O') then
				   dbms_output.put_line('Activité suivante');
				   dbms_output.put_line('==========================');
				end if;
			    exit;
			end if;

		-- Rechercher le mois du réestimé
			l_mois:=TO_NUMBER(SUBSTR(l_ligne_rees,INSTR(l_ligne_rees,'_',1,2)+1,INSTR(l_ligne_rees,'=',1,1)-INSTR(l_ligne_rees,'_',1,2)-1));


		-- Rechercher le réestimé
			l_rees:=SUBSTR(l_ligne_rees,INSTR(l_ligne_rees,'=',1,1)+1,LENGTH(l_ligne_rees)-INSTR(l_ligne_rees,'=',1,1));

			if (l_debug='O') then
			   dbms_output.put_line('mois:'||l_mois||' rees:'||l_rees);
			end if;

		-- Rechercher si l'activité a déjà un réestimé pour le mois
		    BEGIN
				select to_char(datdebex,'YYYY') into l_annee from datdebex;

				select 1
				  into l_exist
				  from REE_REESTIME r
				 where r.IDENT = to_number(l_ident)
				   and r.TYPE  = l_type_ressource
				   and r.CODSG = l_codsg
				   and r.CODE_SCENARIO = l_code_scenario
				   and to_char(r.CDEB,'MM/YYYY') = to_char(l_mois,'FM00')||'/'||l_annee
				   and r.CODE_ACTIVITE = l_code_activite;
				-- si cette requête ne ramène rien on déclenche l'exception NO_DATA_FOUND

				-- La ressource a déjà un réestimé sur cette activité donc on ne la met pas à jour
				pack_global.recuperer_message(21017, NULL, NULL, NULL, l_msg);
	        	p_message := l_msg;

	        EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- pas de réestimé pour l'activité
					if (l_rees!='' or l_rees is not null) then
					   -- Ajouter le nouveau réestimé
						insert into REE_REESTIME (
							   CODSG, CODE_SCENARIO,
							   CDEB,
							   TYPE, IDENT, CODE_ACTIVITE, CONSO_PREVU )
					    VALUES (
						       l_codsg, l_code_scenario,
							   to_date('01/'||to_char(l_mois,'FM00')||'/'||l_annee, 'DD/MM/YYYY'),
							   l_type_ressource, to_number(l_ident), l_code_activite, to_number(l_rees));
					end if;
		    END;

		END LOOP;

		if (INSTR(p_chaine,':',1,i+2)=0) then
			exit;
		end if;
	END LOOP;

	commit;

END ajout_activite;



--*************************************************************************************************
-- Procédures et Fonctions suivantes sont utililés pour l'initialisation du réestimé d'une ressource
--
--
--
-- ************************************************************************************************

FUNCTION nb_jours_travail( p_ident IN ree_ressources.ident%TYPE,
						   p_type IN ree_ressources.type%TYPE,
						   p_date IN DATE
				         ) RETURN NUMBER IS
    v_SOCCODE VARCHAR2(4);
	NB_JOURS  NUMBER(3,1);
BEGIN

		-- Si on ne traite pas une ressource fictive
		IF p_type <> 'X' THEN

		

		
		    --on recupere le SOCCODE de la ressource
		    SELECT DISTINCT SOCCODE INTO v_SOCCODE
	              FROM SITU_RESS_FULL
	              WHERE IDENT=p_ident
				  	              AND (DATSITU is NULL OR DATSITU<= p_date)
	              AND (DATDEP is NULL OR DATDEP> p_date);
		ELSE
			-- On considère arbitrairement que la ressource fictive est un prestataire
			v_SOCCODE:='XXXX';
		END IF;

		
	    --on compare le soccode si le soccode est = SG..
		--alors le champ CHAMP= NB_TRAVAIL_SG sinon NB_TRAVAIL_SII
	    IF(v_SOCCODE='SG..')THEN
		        --on recupre le nonbre de jours pour un mois donné
	            SELECT NB_TRAVAIL_SG INTO NB_JOURS
			          FROM CALENDRIER
			          WHERE CALANMOIS=p_date;
	    ELSE
	          --on recupre le nonbre de jours pour un mois donné
	            SELECT NB_TRAVAIL_SSII INTO NB_JOURS
			          FROM CALENDRIER
			          WHERE CALANMOIS=p_date;
	    END IF;

	    RETURN NB_JOURS;

EXCEPTION
    WHEN OTHERS THEN raise; --RETURN 0;

END nb_jours_travail;


FUNCTION nb_jours_travail_annee(p_ident IN ree_ressources.ident%TYPE,
								p_type IN ree_ressources.type%TYPE,
							    p_moismens IN DATE
				               ) RETURN NUMBER IS
	    v_SOCCODE	VARCHAR2(4);
		NB_JOURS    NUMBER;


BEGIN

		-- Si on ne traite pas une ressource fictive
		IF p_type <> 'X' THEN

		    --on recupere le SOCCODE de la ressource
		    SELECT DISTINCT SOCCODE INTO v_SOCCODE
	              FROM SITU_RESS_FULL
	              WHERE IDENT=p_ident
				  	              AND (DATSITU is NULL OR DATSITU<= p_moismens)
	              AND (DATDEP is NULL OR DATDEP> p_moismens);
		ELSE
			-- On considère arbitrairement que la ressource fictive est un prestataire
			v_SOCCODE:='XXXX';
		END IF;


	    --on compare le soccode si le soccode est = SG..
		--alors le champ CHAMP= NB_TRAVAIL_SG sinon NB_TRAVAIL_SII
	    IF(v_SOCCODE='SG..')THEN
		        --on recupre le nonbre de jours pour l'annee en cours
	            SELECT SUM(NB_TRAVAIL_SG) INTO NB_JOURS
			          FROM CALENDRIER
			          WHERE to_char(calanmois,'yyyy')=to_char(p_MOISMENS,'yyyy');

	    ELSE
	          --on recupre le nonbre de jours pour l'annee en cours
	            SELECT SUM(NB_TRAVAIL_SSII) INTO NB_JOURS
			          FROM CALENDRIER
			          WHERE to_char(calanmois,'yyyy')=to_char(p_MOISMENS,'yyyy');

	    END IF;


	    RETURN NB_JOURS;


EXCEPTION
    WHEN OTHERS THEN raise; --RETURN 0;

END nb_jours_travail_annee;





PROCEDURE ree_saisie_init_absences( p_codsg 	IN ligne_bip.codsg%TYPE,
			                        p_code_scenario IN ree_scenarios.code_scenario%TYPE,
						            p_ident IN ree_ressources.ident%TYPE,
							        p_type IN ree_ressources.type%TYPE,
								    p_moismens IN DATE
									) IS

	v_CJOURS		      calendrier.CJOURS%TYPE;
	v_NB_JOURS            CALENDRIER.NB_TRAVAIL_SG%TYPE;
	v_date 				  DATE;
BEGIN


	    --on insere toutes les lignes de l'activite absences de toute l'annee
		FOR i in 1..12 LOOP

	            v_date := TO_DATE('01/'||i||'/'||to_char(p_moismens,'yyyy'),'dd/mm/yyyy');

	      	    --On recupere le cjours du mois
	    		SELECT DISTINCT CJOURS INTO v_CJOURS
	       		       FROM CALENDRIER
		     	       WHERE CALANMOIS=v_date;


			    --On recupere le nombre de jour pour le mois
	             v_NB_JOURS := nb_jours_travail(p_ident,p_type,v_date);


	      -- insert dans la table ree_reestime la ligne de l'activite ABSENCES
	       INSERT INTO REE_REESTIME (
			   					 CODSG,
					  			 CODE_SCENARIO,
					    		 CDEB,
								 TYPE,
					      		 IDENT,
								 CODE_ACTIVITE,
								 CONSO_PREVU
								 )
	       VALUES (
		 		   p_codsg,
				   p_code_scenario,
				   v_date,
				   p_type,
				   p_ident,
				   'ABSENCES',
				   (v_CJOURS-v_NB_JOURS)
				 );


	END LOOP;


EXCEPTION
    WHEN OTHERS THEN raise; --RETURN 0;

END ree_saisie_init_absences;







	 PROCEDURE ree_saisie_init_date(p_codsg 	IN ligne_bip.codsg%TYPE,
				                     p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							         p_ident IN ree_ressources.ident%TYPE,
							         p_type IN ree_ressources.type%TYPE,
									 p_date IN DATE
									 ) IS


     v_CODE_ACTIVITE      ree_activites.code_activite%TYPE;
	 v_TAUXREP            ree_ressources_activites.TAUXREP%TYPE;
	 v_CJOURS		      calendrier.CJOURS%TYPE;
	 v_NB_JOURS           CALENDRIER.NB_TRAVAIL_SG%TYPE;
	 NB_ACTIVITE          NUMBER;
	 Tab_consom           tableau_numerique;--Contiendra la liste des consu_prevu pour chaque activite
	 Tab_appr             tableau_numerique;--Contiendra la liste des consu_prevu approcher (consu_prevu -  MOD(consu_prevu,0.5) afin d'avoir la valeur apres la vergule = à 0 ou 0.5)
	 Tab_suppr            tableau_numerique;--Contiendra la liste de la valeur MOD(consu_prevu,0.5) que on a enlevé du consu_prevu
	 Tab_code_activite    Liste_chaine := Liste_chaine(); --Contiendra la liste des codes actiivites
	 nb                   NUMBER;
     dif                  NUMBER;
	 aug                  NUMBER;
	 a                    NUMBER;
	 d                    NUMBER;
	 rest                 NUMBER;
	 indice               NUMBER;
	 mini                 NUMBER;
	 min_found            NUMBER;
	 consom  			  NUMBER;
	 appr 				  NUMBER;
	 code_activite		  ree_activites.code_activite%TYPE;
	 total 				  NUMBER; --le total du consu_prevu approche pour un mois



	 --Le curseur qui recupere la liste des codes activite et leur taux de repartition
	 cursor l_c_a(c_codsg CHAR, c_ident NUMBER, c_type CHAR) IS
	       SELECT CODE_ACTIVITE,TAUXREP
		   FROM REE_RESSOURCES_ACTIVITES
		   WHERE CODSG=c_codsg
		   AND IDENT=c_ident
		   AND TYPE=c_type;

	 BEGIN


	    --On recupere le cjours du mois
	    SELECT DISTINCT CJOURS INTO v_CJOURS
	          FROM CALENDRIER
		      WHERE CALANMOIS=p_date;

		--On recupere le nombre d'activite
		SELECT COUNT(DISTINCT CODE_ACTIVITE) INTO NB_ACTIVITE
		      FROM REE_RESSOURCES_ACTIVITES
		      WHERE CODSG=p_codsg
		      AND IDENT=p_ident
		      AND TYPE=p_type;


	 	--On recupere le nombre de jour pour le mois
	    v_NB_JOURS := nb_jours_travail(p_ident,p_type,p_date);



	    -- insert dans la table ree_reestime la ligne de l'activite ABSENCES
	    INSERT INTO REE_REESTIME (
			   					 CODSG,
					  			 CODE_SCENARIO,
					    		 CDEB,
								 TYPE,
					      		 IDENT,
								 CODE_ACTIVITE,
								 CONSO_PREVU
								 )
	    VALUES (
				p_codsg,
				p_code_scenario,
				p_date,
				p_type,
				p_ident,
				'ABSENCES',
				(v_CJOURS-v_NB_JOURS)
				);



		OPEN l_c_a(p_codsg, p_ident, p_type);

		nb := 1;
		total := 0;

		LOOP


		  FETCH l_c_a  INTO v_CODE_ACTIVITE, v_TAUXREP;

	      IF l_c_a%NOTFOUND THEN
	      EXIT;
	      END IF;


			Tab_code_activite.extend;
		   	Tab_code_activite(Tab_code_activite.count) := v_CODE_ACTIVITE;
		    Tab_consom(nb):= ((v_TAUXREP*v_NB_JOURS)/100);

			Tab_appr(nb) := Tab_consom(nb)-MOD(Tab_consom(nb),0.5);
			Tab_suppr(nb) := MOD(Tab_consom(nb),0.5);

			total := total + Tab_appr(nb);

		 nb := nb + 1;

	   END LOOP;

	   
	   
		-- Fermeture du curseur
        CLOSE l_c_a;
		


		--tri du tableau tab_supp et les tableaux correspondants
		FOR i IN 1..(NB_ACTIVITE-1) LOOP

               min_found := 0;
			   mini := Tab_suppr(i);
			   code_activite := Tab_code_activite(i);
			   appr := Tab_appr(i);
			   consom := Tab_consom(i);


			   FOR j IN (i+1)..NB_ACTIVITE LOOP

		             IF(mini > Tab_suppr(j))THEN

					      mini := Tab_suppr(j);
			     		  code_activite := Tab_code_activite(j);
			   			  appr := Tab_appr(j);
			   			  consom := Tab_consom(j);
						  min_found := 1;
						  indice := j;

					 END IF;

               END LOOP;

			   IF(min_found=1)THEN

			          Tab_suppr(indice) := Tab_suppr(i);
					  Tab_code_activite(indice) := Tab_code_activite(i);
			   		  Tab_appr(indice) := Tab_appr(i);
			   		  Tab_consom(indice) := Tab_consom(i);


					  Tab_suppr(i) := mini;
					  Tab_code_activite(i) := code_activite;
			   		  Tab_appr(i) := appr;
			   		  Tab_consom(i) := consom;


			   END IF;

	   END LOOP;


	   --on calcule la difference entre le total des jours real et le total des jours approché pour le mois
	   --pour trouver combien de fois,

	   nb := (NB_ACTIVITE-((v_NB_JOURS-total)/0.5)+1);


	   -- il faudrait rajouter la valeur 0.5 au consu_prevu
	   -- la valeur 0.5 l'additionne au nb consu_prevu que la valeur enlevée est plus grande

	   FOR k IN 1..NB_ACTIVITE LOOP

	          IF(k>=nb)THEN

                     Tab_consom(k) := Tab_appr(k) + 0.5;

			  ELSE

			         Tab_consom(k) := Tab_appr(k);

			  END IF;

	   END LOOP;


	   
        --la boucle qui permet d'inserer les lignes dans la table ree_reestime pour chaque activite

		FOR i IN 1..NB_ACTIVITE LOOP


		-- insert dans la table tmp_ree_detail des lignes pour chaque activite de chaque ressource
	    INSERT INTO REE_REESTIME (
			   					 CODSG,
					  			 CODE_SCENARIO,
					    		 CDEB,
								 TYPE,
					      		 IDENT,
								 CODE_ACTIVITE,
								 CONSO_PREVU
								 )
	    VALUES (
				p_codsg,
				p_code_scenario,
				p_date,
				p_type,
				p_ident,
				Tab_code_activite(i),
				Tab_consom(i)
				);

				
	   commit;

	   END LOOP;



      EXCEPTION
           WHEN OTHERS THEN raise; --RETURN 0;




	 END ree_saisie_init_date;



	 PROCEDURE ree_saisie_init_tous( p_codsg    	 IN ligne_bip.codsg%TYPE,
				                     p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							         p_ident         IN ree_ressources.ident%TYPE,
							         p_type          IN ree_ressources.type%TYPE,
                              		 NB_ACTIVITE NUMBER,
									 p_moismens IN DATE
									 ) IS


	 v_SOCCODE	          VARCHAR2(4);
	 v_CODE_ACTIVITE      ree_activites.code_activite%TYPE;
	 v_TAUXREP            ree_ressources_activites.TAUXREP%TYPE;
	 v_CDEB               ree_reestime.CDEB%TYPE;
	 v_CONSO_PREVU        ree_reestime.CONSO_PREVU%TYPE;
	 Tab_code_activite    Liste_chaine := Liste_chaine();
	 Tab_a_real           tableau_numerique;--contiendra la somme des jours real pour chaque activite de toute l'annee
	 Tab_a_reestime       tableau_numerique;--contiendra la somme des consu_prevu pour chaque activite de toute l'annee
	 Tab_diff             tableau_numerique;
	 Tab_appr             tableau_numerique;
	 Tab_suppr            tableau_numerique;
	 Tab_ordre            tableau_numerique;
	 Tab_ajout            tableau_numerique;
	 Tab_matrice_conso    tableau_numerique;
	 Tab_matrice_a        Liste_chaine := Liste_chaine();
	 Tab_matrice_cdeb     Liste_date := Liste_date();
	 nb                   NUMBER;
	 nb_ligne_matrice     NUMBER;
	 nb_jour_annee        NUMBER;
	 indice               NUMBER;
	 mini                 NUMBER;
	 min_found            NUMBER;
	 code_activite		  ree_activites.code_activite%TYPE;
	 reel  		    	  NUMBER;
	 reestime  			  NUMBER;
	 appr 				  NUMBER;
	 total 				  NUMBER;
	 i                    NUMBER;
	 j                    NUMBER;
	 trouver 			  NUMBER;
	 f  				  NUMBER;
	 k                    NUMBER;


	 -- ce curseur permet de recupere la liste des codes d'activite
	 cursor l_activite(c_codsg CHAR, c_ident NUMBER, c_type CHAR) IS
	       select code_activite,tauxrep
		   from ree_ressources_activites
		   where codsg=c_codsg
		   and ident=c_ident
		   and type=c_type
		   order by code_activite;


	 -- ce curseur permet de recupere la liste des activite et leurs conso_prevu de la meme annee que moismens
     cursor l_a_conso (c_codsg CHAR, c_code_scenario CHAR, c_ident NUMBER, c_type CHAR, c_MOISMENS DATE) IS
	       select cdeb,code_activite,conso_prevu
		   from ree_reestime
		   where codsg=c_codsg
		   and code_scenario=c_code_scenario
		   and ident=c_ident
		   and type=c_type
		   and code_activite<>'ABSENCES'
		   and to_char(cdeb,'yyyy')=to_char(c_MOISMENS,'yyyy')
		   order by code_activite,cdeb;


	 BEGIN

		--On recupere le nombre de jour pour toute l'annee
		nb_jour_annee := nb_jours_travail_annee(p_ident,p_type,p_MOISMENS);

	

		--on insere toutes les lignes de toute l'annee
		FOR i in 1..12 LOOP

	           ree_saisie_init_date(p_codsg,p_code_scenario,p_ident,p_type,TO_DATE('01/'||i||'/'||to_char(p_MOISMENS,'yyyy'),'dd/mm/yyyy'));

	     END LOOP;



		 --ici on va recalculer les consu_prevu pour que la somme des consu_prevu  de toute l'anne
		 --soit egale à la somme real  pour chaque activite




		 --on recupere tous les consu_prevu de toute l'annee
		 nb := 1;
		 total := 0;

		 OPEN l_activite(p_codsg,p_ident,p_type);

		 LOOP


		    FETCH l_activite  INTO v_CODE_ACTIVITE, v_TAUXREP;

	        IF l_activite%NOTFOUND THEN
	        EXIT;
	        END IF;


			Tab_code_activite.extend;
		   	Tab_code_activite(Tab_code_activite.count) := v_CODE_ACTIVITE;

			Tab_a_real(nb):= (nb_jour_annee*v_TAUXREP)/100;

			Tab_appr(nb) := Tab_a_real(nb)-MOD(Tab_a_real(nb),0.5);
			Tab_suppr(nb) := MOD(Tab_a_real(nb),0.5);
		    total := total + Tab_appr(nb);

			SELECT SUM(CONSO_PREVU) INTO Tab_a_reestime(nb)
			      from ree_reestime
                  where codsg=p_codsg
				  and ident=p_ident
				  and code_scenario=p_code_scenario
				  and code_activite=v_CODE_ACTIVITE;



		    nb := nb + 1;

	     END LOOP;


		 CLOSE l_activite;



		--le tableau qui contindra l'ordre

		FOR i IN 1..NB_ACTIVITE LOOP

		Tab_ordre(i) := 0;

		END LOOP;


		 nb := 1;

		--remplire le tab_ordre, ou  on met le numero d'ordre des valeurs du tableaux tab_a_real
		 FOR k IN 1..NB_ACTIVITE LOOP

		 FOR i IN 1..NB_ACTIVITE LOOP
		        IF(Tab_ordre(i)=0)THEN

                   min_found := 0;
			       mini := Tab_suppr(i);

			       FOR j IN 1..NB_ACTIVITE LOOP

		               IF(Tab_ordre(j)=0)THEN

					       IF(mini > Tab_suppr(j))THEN

							   mini := Tab_suppr(j);
			     		       min_found := 1;
						       indice := j;

						  END IF;
					 END IF;

                   END LOOP;

			   IF(min_found=1)THEN

					  Tab_ordre(indice) := nb;

			   ELSE
			         Tab_ordre(i) := nb;
			   END IF;

			    nb := nb + 1;

			  END IF;

            END LOOP;
	   END LOOP;


       --on calcule la difference entre le total des jours real et le total des jours approché pour toute l'anne
	   --pour trouver combien de fois,

	   nb := (NB_ACTIVITE-((nb_jour_annee-total)/0.5)+1);


	   -- il faudrais rajouter la valeur 0.5 au consu_prevu
	   -- la valeur 0.5 l'additionne au nb consu_prevu que la valeur enleve est plus grande


	   FOR k IN 1..NB_ACTIVITE LOOP

	          IF(k>=nb)THEN

                     Tab_a_real(k) := Tab_appr(k) + 0.5;

			  ELSE

			         Tab_a_real(k) := Tab_appr(k);

			  END IF;

			  Tab_diff(k) := Tab_a_real(k) - Tab_a_reestime(k);

	   END LOOP;


		 nb_ligne_matrice := 1;
		 --on remplis les matrices
		 OPEN l_a_conso (p_codsg,p_code_scenario,p_ident,p_type,p_moismens);

		 LOOP


		    FETCH l_a_conso  INTO v_CDEB, v_CODE_ACTIVITE, v_CONSO_PREVU;

	        IF l_a_conso%NOTFOUND THEN
	        EXIT;
	        END IF;

			        Tab_matrice_cdeb.extend;
					Tab_matrice_a.extend;

				    Tab_matrice_cdeb(Tab_matrice_cdeb.count) := v_CDEB;
				   	Tab_matrice_a(Tab_matrice_a.count) := v_CODE_ACTIVITE;
					Tab_matrice_conso(nb_ligne_matrice) := v_CONSO_PREVU;


			nb_ligne_matrice := nb_ligne_matrice + 1;

	     END LOOP;


		 CLOSE l_a_conso;



		--trier le tabelau Tab_diff an numeroter l'odre des valeurs dans la Tab_ordre


		FOR i IN 1..NB_ACTIVITE LOOP

		Tab_ordre(i) := 0;

		END LOOP;


		nb := 1;

		--remplire le tab_ordre, ou  on met le numero d'ordre des valeurs du tableaux tab_diff
		 FOR k IN 1..NB_ACTIVITE LOOP

		 FOR i IN 1..NB_ACTIVITE LOOP
		        IF(Tab_ordre(i)=0)THEN

                   min_found := 0;
			       mini := ABS(Tab_diff(i));

			       FOR j IN 1..NB_ACTIVITE LOOP

		               IF(Tab_ordre(j)=0)THEN

					       IF(mini > ABS(Tab_diff(j)))THEN

							   mini := ABS(Tab_diff(j));
			     		       min_found := 1;
						       indice := j;

						  END IF;
					 END IF;

                   END LOOP;

			   IF(min_found=1)THEN

					  Tab_ordre(indice) := nb;

			   ELSE
			          Tab_ordre(i) := nb;
			   END IF;

			    nb := nb + 1;

			  END IF;

            END LOOP;
	   END LOOP;



		--on initialise le tableau Tab_ajout
	    FOR i IN 1..12 LOOP

		     Tab_ajout(i) := 0;

		END LOOP;



			 i := NB_ACTIVITE;
			 WHILE  i>=1 LOOP

		     k := 1;

			 trouver := 0;
		     WHILE trouver=0 LOOP

			      IF(Tab_ordre(k)=i)THEN

				       trouver := 1;

				  ELSE

				       k := k + 1;

			      END IF;

			 END LOOP;


			 nb := ABS(Tab_diff(k)/0.5);

			 IF(nb>0)THEN

			       IF(Tab_diff(k)>0)THEN

						-- si la valeur est positif de l'activite numero k
							f := 1;
			                FOR j IN 1..nb LOOP
							trouver := 0;

							WHILE trouver=0 LOOP

							      IF( (MOD(Tab_ajout(f),0.5)=0) AND (Tab_ajout(f)<0) )THEN

								        trouver := 1;
										Tab_ajout(f) := 0;
										Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) := Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) + 0.5;


								  ELSIF(Tab_ajout(f)=0)THEN

								   		trouver := 1;
										Tab_ajout(f) := 0.5;
										Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) := Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) + 0.5;


								  ELSE

								        f := f + 1;

								  END IF;
								  IF(f>=12)THEN
								       trouver := 1;
									   Tab_ajout(1) := Tab_ajout(1) + 0.5;
									   Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) := Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) + 0.5;
                                   END IF;


							 END LOOP;--while

						END LOOP;--for


					ELSE

						    f := 1;
			                FOR j IN 1..nb LOOP
						    trouver := 0;
							WHILE trouver=0 LOOP

							     IF( (MOD(Tab_ajout(f),0.5)=0) and (Tab_ajout(f)>0) )THEN

								        trouver := 1;
										Tab_ajout(f) := 0;
										Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) := Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) - 0.5;


								  ELSE

								        f := f + 1;

								  END IF;
								  IF(f>=12)THEN
								       trouver := 1;
									   Tab_ajout(1) := Tab_ajout(1) - 0.5;
									   Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) := Tab_matrice_conso((k*NB_ACTIVITE)-NB_ACTIVITE+f) - 0.5;
                                   END IF;


							 END LOOP;--while

						  END LOOP;--for

						END IF;



			 END IF;




		i := i - 1;
		END LOOP;--premier while


         --on fait une mise ajoure sur la table ree_reestime
		 FOR i IN 1..(nb_ligne_matrice-1) LOOP

		        UPDATE ree_reestime
			    SET conso_prevu=Tab_matrice_conso(i)
			    WHERE codsg=p_codsg
			         and code_scenario=p_code_scenario
					 and cdeb=Tab_matrice_cdeb(i)
					 and ident=p_ident
					 and code_activite=Tab_matrice_a(i);

		 END LOOP;


		 EXCEPTION
            WHEN OTHERS THEN raise; --RETURN 0;



	 END ree_saisie_init_tous;


   -- ------------------------------------------------------------------------
   -- Nom        : ree_saisie_initialise
   -- Auteur     : BAA
   -- Decription : c'est la methode major qui insere les lignes des consu_prevu pour chaque activite l'annee en cours
   --              inclus les activites absences si les activites existe
   --              sinon elle insere que des lignes de l'activites absences
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_code_scenario  (IN) code du scenario
   --              p_ident  (IN) identifiant de la ressource
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------

PROCEDURE ree_saisie_initialise( p_codsg 	     IN VARCHAR2,
				                 p_code_scenario IN ree_scenarios.code_scenario%TYPE,
							     p_ident         IN VARCHAR2
								) IS
	NB_ACTIVITE NUMBER;
	v_MOISMENS 	DATE;
	l_annee 	DATE;
	l_ident     ree_ressources.ident%TYPE;
	l_type		VARCHAR2(1);
BEGIN

    -- On supprime le type se trouvant à la fin de l'identifiant
	l_ident  := substr(p_ident,0,length(p_ident)-1);
	-- On récupère le type
	l_type   := substr(p_ident,length(p_ident),1) ;

    --On recupere le nombre d'activite
	SELECT COUNT(DISTINCT CODE_ACTIVITE) INTO NB_ACTIVITE
	  FROM REE_RESSOURCES_ACTIVITES
	 WHERE CODSG = to_number(p_codsg)
	   AND to_char(IDENT)||TYPE = p_ident;

    SELECT MOISMENS,DATDEBEX
	  INTO v_MOISMENS,l_annee
	  FROM DATDEBEX;

-- Correction de début d'annéé
	if (v_MOISMENS<l_annee) then
	   v_MOISMENS:=l_annee ;
	end if ;

    --on supprime toutes les lignes de la table ree_reestime s'il existe
	DELETE FROM ree_reestime
	 WHERE codsg = to_number(p_codsg)
	   AND code_scenario = p_code_scenario
	   AND to_char(IDENT)||TYPE = p_ident;



	   
	--si il n'y a pas d'activite alors on insere que des lignes conçernant les activites absences
    IF (NB_ACTIVITE = 0) THEN
		ree_saisie_init_absences(to_number(p_codsg),p_code_scenario,to_number(l_ident),l_type,v_MOISMENS);
	ELSE
	--sinon on insere toutes les lignes pour toutes les activites inclus l'activite absences
	    ree_saisie_init_tous(to_number(p_codsg),p_code_scenario,to_number(l_ident),l_type,NB_ACTIVITE,v_MOISMENS);
    END IF;


EXCEPTION
    WHEN OTHERS THEN raise; --RETURN 0;

END ree_saisie_initialise;


END PACK_REE_SAISIE;
/
CREATE OR REPLACE PACKAGE pack_ree_synthese_locale AS


  FUNCTION RAF_RESSOURCE (	acodsg          IN  NUMBER,
                           	acode_activite  IN  VARCHAR2,
                          	acode_scenario  IN  VARCHAR2,
				amoismens IN DATE
                       		) return NUMBER;
  FUNCTION min_dpg (p_codsg IN VARCHAR2) RETURN NUMBER;

  FUNCTION max_dpg (p_codsg IN VARCHAR2) RETURN NUMBER;

  FUNCTION code_scenario (code_sc IN VARCHAR2) RETURN VARCHAR2;

  FUNCTION officiel (code_sc IN VARCHAR2) RETURN VARCHAR2;


END pack_ree_synthese_locale;
/

CREATE OR REPLACE PACKAGE BODY pack_ree_synthese_locale AS





   FUNCTION RAF_RESSOURCE (	acodsg          IN  NUMBER,
                           	acode_activite  IN  VARCHAR2,
                          	acode_scenario  IN  VARCHAR2,
				amoismens IN DATE
                       		) return NUMBER IS

   CURSOR ct is select SUM(CONSO_PREVU) from REE_REESTIME where codsg=acodsg and code_activite=acode_activite and code_scenario=acode_scenario and CDEB>amoismens;
   CONSO_PREVU NUMBER;

   BEGIN

   open ct;

   Fetch ct into CONSO_PREVU;

   close ct;


   return CONSO_PREVU;

   END RAF_RESSOURCE;






   FUNCTION min_dpg (p_codsg IN VARCHAR2) RETURN NUMBER IS



   BEGIN


	IF substr(p_codsg,6,2)='**' THEN
		IF substr(p_codsg,4,4)='****' THEN

			IF substr(p_codsg,2,6)='******' THEN

				IF p_codsg='*******' THEN

					return '0000000';
				ELSE

					return substr(p_codsg,1,1)||'000000';
				END IF;
			ELSE

				return substr(p_codsg,1,3)||'0000';
			END IF;
		ELSE

			return substr(p_codsg,1,5)||'00';
		END IF;

	ELSE

		return p_codsg;

	END IF;


   END min_dpg;


   FUNCTION max_dpg (p_codsg IN VARCHAR2) RETURN NUMBER IS



   BEGIN

	IF substr(p_codsg,6,2)='**' THEN
		IF substr(p_codsg,4,4)='****' THEN

			IF substr(p_codsg,2,6)='******' THEN

				IF p_codsg='*******' THEN
					return '9999999';

				ELSE

					return substr(p_codsg,1,1)||'999999';
				END IF;
			ELSE

				return substr(p_codsg,1,3)||'9999';
			END IF;

		ELSE
			return substr(p_codsg,1,5)||'99';
		END IF;

	ELSE

		return p_codsg;

	END IF;



   END max_dpg;




   FUNCTION code_scenario (code_sc IN VARCHAR2) RETURN VARCHAR2 IS

   BEGIN


	IF code_sc='***' THEN

		return '%%' ;

	ELSE

		return code_sc;

	END IF;


   END code_scenario;


   FUNCTION officiel (code_sc IN VARCHAR2) RETURN VARCHAR2 IS

   BEGIN


	IF code_sc='***' THEN

		return 'O' ;

	ELSE

		return '%%';

	END IF;


   END officiel;




END pack_ree_synthese_locale;
/
CREATE OR REPLACE PACKAGE pack_RefPCM IS
-- =========================================================================
-- FUNCTION f_facint
-- Role : calcule le cout Standar Total d'un projet(ligne_bip) en KF
-- Parametre : - p_pid   Identifiant de projet informatique

-- -------------------------------------------------------------------------
-- FUNCTION Select_DataReftrans
-- Role : Recheche les donnees de l'édition Reftrans en ouvrant un cursor
--        puis les insere dans la table temporaire tmpreftrans.
-- Retour : Retourne le numéro de sequence qui sera utilisé dans select et
--        les trigers du report
-- Parametre : P_codPADP peut prendre une valeure d'un Code Porjet ou d'un
--        Code Appli ou d'un code Dossier Projet.

-- -------------------------------------------------------------------------
-- FUNCTION Select_DataProref4
-- Role : identique à la foncition Select_DataReftrans mais pour l'édition
-- Proref4
-- -------------------------------------------------------------------------

-- FUNCTION Delete_Donnees
-- Role : Supprime, dans la table Tmpreftrans, les données creees par les
-- fonctions Select_DataReftrans et Select_DataProref4, a la fin de l'édition.

-- -------------------------------------------------------------------------

   FUNCTION f_facint (p_pid IN VARCHAR2) RETURN NUMBER;
   PRAGMA RESTRICT_REFERENCES(f_facint,WNDS,WNPS);

   FUNCTION Select_DataReftrans(p_codPADP IN VARCHAR2,   -- Code Projet ou Code Appli ou code Dossier Projet
				p_global  IN VARCHAR2) RETURN NUMBER;
   FUNCTION Select_DataProref4 (P_codDossProj IN CHAR) RETURN NUMBER;
   FUNCTION Delete_Donnees (P_numseq IN NUMBER) RETURN BOOLEAN;

END pack_RefPCM;
/

CREATE OR REPLACE PACKAGE BODY pack_RefPCM IS
-- ===========================================
-- -------------------------------------------------------------------------
-- FUNCTION f_facint
--
-- En commentaire car faux et inutile
-- -------------------------------------------------------------------------
FUNCTION f_facint (p_pid IN VARCHAR2) RETURN NUMBER IS
      l_facint number(12,2);
BEGIN

	SELECT NVL(cc.ftsg,0) +NVL(cc.ftssii,0)+ NVL(cc.envsg,0)+ NVL(cc.envssii,0)
 	INTO l_facint
	FROM cumul_conso cc,
	datdebex d
	WHERE cc.pid=p_pid
	  AND cc.annee = to_number(to_char(d.datdebex,'YYYY'));

   RETURN round(l_facint/1000, 2); -- arrondi en Montant en KE

END f_facint;

-- -------------------------------------------------------------------------
-- FUNCTION Select_DataReftrans
-- -------------------------------------------------------------------------
FUNCTION Select_DataReftrans (	p_codPADP IN VARCHAR2,   -- Code Projet ou Code Appli ou code Dossier Projet
				p_global  IN VARCHAR2
                        ) RETURN NUMBER IS

   l_annee0  NUMBER(4);
   l_msg  VARCHAR2(1024);


   l_numseq         NUMBER ; -- numéro de séquence identifiant l'edition en cours

   -- déclaration du cursor pour rammener les projets informatiques
   -- Les trois cursors se distingue par les lignes marquées : -- ##
   -- -------------------------------------------------------------

cursor c_curProjet (cp_anneeN Number, cp_CodProj VARCHAR2) IS
select pri.icpi					CODGROUP,
       pri.ilibel                          	NOMGROUP,
       decode(pri.icpi,cp_CodProj,0,1)     	FILS,
       si.coddeppole    			CODEDP,
       si.sigdep || '/' || si.sigpole as   	SIGDP,
       lb.pid              			PID,
       lb.typproj          			PTYPE,
       lb.arctype				ARCTYPE,
       lb.codcamo          			CODCAMO,
       lb.pnom        				LIBPROJET,
       substr(r.rnom,1,8)    			CHEFPROJET,
       lb.clicode				CODMO	  ,
       cm.clisigle				SIGDIRMO,
       lb.codsg					CODSG,
       si.libdsg				LIBDSG,
       nvl(nvl(conso.cusag,0) + nvl(conso_1.cusag,0) + nvl(conso_2.xcusag,0) ,0) CUMULJH,
       nvl(conso.cusag, 0)                      CONSOJH,
       f_facint(lb.pid)     			FACINT,
       nvl(floor(budg.reestime), 0)             REESTJH,
       nvl(budg.bpmontme, 0)                   	PROPOJH,
       nvl(budg.bpmontmo,0)                    	PROPOMOJH,
       nvl(budg.bnmont, 0)                      NOTIFJH,
       nvl(budg.anmont, 0)                      ARBITJH,
       nvl(budg1.bpmontme, 0)                  	PROPOJHN1,
       nvl(budg1.bpmontmo,0)                   	PROPOMOJHN1,
       lb.metier 				METIER
from
      ressource       	r      	,
      budget     	budg   	,
      budget     	budg1  	,
      consomme 		conso  	,
      consomme 		conso_1	,
      consomme 		conso_2	,
      struct_info     	si     	,
      ligne_bip 	lb     	,
      client_mo		cm	,
      proj_info 	pri
where   lb.icpi = pri.icpi   -- ###
    	and lb.pcpi    = r.ident
    	and lb.codsg   = si.codsg
    	and lb.clicode = cm.clicode
    	and lb.typproj in (1,2,3,4,6,8)
    	and ((pri.icpi LIKE DECODE(cp_CodProj, 'P', '%', cp_CodProj)) OR (pri.icpir LIKE DECODE(cp_CodProj, 'P', '%', cp_CodProj)))    -- ###
    	and lb.pid = budg.pid    (+)
	and lb.pid = budg1.pid   (+)
	and lb.pid = conso.pid   (+)
	and lb.pid = conso_1.pid (+)
	and lb.pid = conso_2.pid (+)
   -- Au moins une des donnees n°14 a 21, ou b.xcusag0 ou b.xcusagM1 est different de zero
   	and (      (conso.cusag      <> 0 AND   conso.cusag     is not null )
        	OR (conso_1.cusag    <> 0 AND   conso_1.cusag   is not null )
	  	OR (conso_2.xcusag   <> 0 AND   conso_2.xcusag  is not null )
        	OR (f_facint(lb.pid) <> 0 )
        	OR (budg.reestime    <> 0 AND  budg.reestime    is not null )
        	OR (budg.bpmontme    <> 0 AND  budg.bpmontme    is not null )
		OR (budg.bpmontmo    <> 0 AND  budg.bpmontmo    is not null )
        	OR (budg.bnmont      <> 0 AND  budg.bnmont      is not null )
        	OR (budg.anmont      <> 0 AND budg.anmont       is not null )
        	OR (budg1.bpmontme   <> 0 AND budg1.bpmontme    is not null )
		OR (budg1.bpmontmo   <> 0 AND budg1.bpmontmo    is not null )
        )
	and budg.annee(+)    = cp_anneeN
	and conso.annee(+)   = cp_anneeN
	and conso_1.annee(+) = cp_anneeN-1
	and conso_2.annee(+) = cp_anneeN-2
	and budg1.annee(+)   = cp_anneeN+1;

-- Déclaration du cursor pour rammener les Applications
-- -------------------------------------------------------------

cursor c_curAppli (cp_anneeN Number, cp_CodAppli VARCHAR2) IS
select  app.airt                             	CODGROUP  ,
	app.alibel                           	NOMGROUP  ,
       	decode(app.airt,cp_CodAppli,0,1)     	FILS	  ,
       	si.coddeppole    			CODEDP	  ,
       	si.sigdep || '/' || si.sigpole as   	SIGDP	  ,
       	lb.pid              			PID	  ,
       	lb.typproj          			PTYPE	  ,
        lb.arctype				ARCTYPE	  ,
       	lb.codcamo          			CODCAMO	  ,
	lb.pnom        				LIBPROJET ,
       	substr(r.rnom,1,15)    			CHEFPROJET,
        lb.clicode				CODMO	  ,
        cm.clisigle				SIGDIRMO  ,
        lb.codsg				CODSG	  ,
        si.libdsg				LIBDSG	  ,
       	nvl(nvl(conso.cusag,0) + nvl(conso_1.cusag,0) + nvl(conso_2.xcusag,0) ,0) CUMULJH,
       	nvl(conso.cusag, 0)                     CONSOJH   ,
	f_facint(lb.pid)			FACINT	  ,
       	nvl(floor(budg.reestime), 0)            REESTJH	  ,
       	nvl(budg.bpmontme, 0)                   PROPOJH	  ,
       	nvl(budg.bpmontmo,0)                    PROPOMOJH ,
       	nvl(budg.bnmont, 0)                     NOTIFJH	  ,
       	nvl(budg.anmont, 0)                     ARBITJH	  ,
       	nvl(budg1.bpmontme, 0)                  PROPOJHN1 ,
       	nvl(budg1.bpmontmo,0)                   PROPOMOJHN1,
           lb.metier 				METIER
from
      ressource       	r      ,
      budget     	budg   ,
      budget     	budg1  ,
      consomme 		conso  ,
      consomme 		conso_1,
      consomme 		conso_2,
      struct_info     	si     ,
      client_mo		cm     ,
      ligne_bip 	lb     ,
      application app
where   lb.airt    = app.airt  -- ###
   	and lb.pcpi    = r.ident
   	and lb.codsg   = si.codsg
   	and lb.clicode = cm.clicode
   	and (app.airt LIKE DECODE(cp_CodAppli, 'A', '%', cp_CodAppli) OR app.acdareg LIKE DECODE(cp_CodAppli, 'A', '%', cp_CodAppli))    -- ###
   	AND typproj in (1,2,3,4,6,8)
	and lb.pid = budg.pid     (+)
	and lb.pid = budg1.pid   (+)
	and lb.pid = conso.pid  (+)
	and lb.pid = conso_1.pid (+)
	and lb.pid = conso_2.pid(+)
   	-- Au moins une des donnees n°14 a 21, ou b.xcusag0 ou b.xcusagM1 est different de zero
   	and (      (conso.cusag      <> 0 AND conso.cusag    is not null)
        	OR (conso_1.cusag    <> 0 AND conso_1.cusag  is not null)
	  	OR (conso_2.xcusag   <> 0 AND conso_2.xcusag is not null)
        	OR (f_facint(lb.pid) <> 0)
        	OR (budg.reestime    <> 0 AND budg.reestime  is not null)
        	OR (budg.bpmontme    <> 0 AND budg.bpmontme  is not null)
		OR (budg.bpmontmo    <> 0 AND budg.bpmontmo  is not null)
        	OR (budg.bnmont      <> 0 AND budg.bnmont    is not null)
        	OR (budg.anmont      <> 0 AND budg.anmont    is not null)
        	OR (budg1.bpmontme   <> 0 AND budg1.bpmontme is not null)
		OR (budg1.bpmontmo   <> 0 AND budg1.bpmontmo is not null)
        )
	and budg.annee(+)    = cp_anneeN
	and conso.annee(+)   = cp_anneeN
	and conso_1.annee(+) = cp_anneeN-1
	and conso_2.annee(+) = cp_anneeN-2
	and budg1.annee(+)   = cp_anneeN+1;


-- déclaration du cursor pour rammener les Dossiers Projets
-- -------------------------------------------------------------
cursor c_curDossProj (cp_anneeN Number, cp_CodDossProj VARCHAR2) IS
select 	TO_CHAR(dp.dpcode, 'FM00000')          	CODGROUP,
	dp.dplib                            	NOMGROUP,
       	0                                    	FILS,
       	si.coddeppole			    	CODEDP,
       	si.sigdep || '/' || si.sigpole as   	SIGDP,
       	lb.pid              			PID,
       	lb.typproj          			PTYPE,
        lb.arctype				ARCTYPE,
       	lb.codcamo          			CODCAMO,
	lb.pnom        				LIBPROJET,
       	substr(r.rnom,1,15)   			CHEFPROJET,
        lb.clicode				CODMO	  ,
        cm.clisigle				SIGDIRMO,
        lb.codsg				CODSG,
        si.libdsg				LIBDSG,
       	nvl(nvl(conso.cusag,0) + nvl(conso_1.cusag,0) + nvl(conso_2.xcusag,0) ,0) CUMULJH,
       	nvl(conso.cusag, 0)                     CONSOJH,
       	f_facint(lb.pid)   			FACINT,
       	nvl(floor(budg.reestime), 0)            REESTJH,
       	nvl(budg.bpmontme, 0)                   PROPOJH,
       	nvl(budg.bpmontmo,0)                    PROPOMOJH,
       	nvl(budg.bnmont, 0)                     NOTIFJH,
       	nvl(budg.anmont, 0)                     ARBITJH,
       	nvl(budg1.bpmontme, 0)                  PROPOJHN1,
       	nvl(budg1.bpmontmo,0)              	PROPOMOJHN1,
           lb.metier 				METIER
from
      ressource       	r      ,
      budget     	budg   ,
      budget     	budg1  ,
      consomme 		conso  ,
      consomme      	conso_1,
      consomme 		conso_2,
      client_mo       	cm     ,
      struct_info     	si     ,
      ligne_bip 	lb     ,
      dossier_projet 	dp
where  	lb.dpcode    = dp.dpcode  -- ###
   	and lb.clicode = cm.clicode
   	and lb.pcpi    = r.ident
   	and lb.codsg   = si.codsg
   	and lb.typproj in (1,2,3,4,6,8)
   	and TO_CHAR(dp.dpcode, 'FM00000') LIKE DECODE(cp_CodDossProj, 'DP', '%', LPAD(cp_CodDossProj, 5, '0'))  -- ###
   	and lb.pid = budg.pid     (+)
	and lb.pid = budg1.pid   (+)
	and lb.pid = conso.pid  (+)
	and lb.pid = conso_1.pid (+)
   	and lb.pid = conso_2.pid    (+)
   	-- Au moins une des donnees n°14 a 21, ou b.xcusag0 ou b.xcusagM1 est different de zero
   	and (      (conso.cusag     <> 0 AND conso.cusag    is not null )
        	OR (conso_1.cusag   <> 0 AND conso_1.cusag  is not null )
	  	OR (conso_2.xcusag  <> 0 AND conso_2.xcusag is not null )
        	OR (f_facint(lb.pid)<> 0 )
        	OR (budg.reestime   <> 0 AND budg.reestime  is not null )
        	OR (budg.bpmontme   <> 0 AND budg.bpmontme  is not null )
        	OR (budg.bpmontmo   <> 0 AND budg.bpmontmo  is not null )
        	OR (budg.bnmont     <> 0 AND budg.bnmont    is not null )
        	OR (budg.anmont     <> 0 AND budg.anmont    is not null )
        	OR (budg1.bpmontme  <> 0 AND budg1.bpmontme is not null )
		OR (budg1.bpmontmo  <> 0 AND budg1.bpmontmo is not null )
        )
	and budg.annee(+)  =  cp_anneeN
	and conso.annee(+)  =  cp_anneeN
	and conso_1.annee(+) =  cp_anneeN-1
	and conso_2.annee(+) = cp_anneeN-2
	and budg1.annee(+) =  cp_anneeN+1;

BEGIN
      -- p_msg := '';
      SELECT TO_NUMBER( TO_CHAR( datdebex, 'YYYY') )
	INTO l_annee0
	FROM datdebex;

      SELECT Seqreftrans.nextval INTO l_numseq FROM dual;

      IF SUBSTR(P_codPADP,1,1)='P' OR SUBSTR(P_codPADP,1,1)='I' THEN -- Si un code Projet

         FOR enr_cur IN c_curProjet(l_annee0, P_codPADP)
         LOOP
            INSERT INTO Tmpreftrans
	         (numseq,CODGROUP,NOMGROUP,FILS, CODEDP, SIGDP, PID, PTYPE, ARCTYPE, CODCAMO, LIBPROJET, CHEFPROJET, CODMO, SIGDIRMO, CODSG, LIBDSG,
	          CUMULJH, CONSOJH, FACINT, REESTJH, PROPOJH, NOTIFJH, RESERJH, ARBITJH, PROPOJHN1,PROPOMOJH,PROPOMOJHN1,METIER)
	      VALUES
               (l_numseq,enr_cur.CODGROUP,enr_cur.NOMGROUP,enr_cur.FILS, enr_cur.CODEDP, enr_cur.SIGDP, enr_cur.PID, enr_cur.PTYPE, enr_cur.ARCTYPE,
                enr_cur.CODCAMO, enr_cur.LIBPROJET, enr_cur.CHEFPROJET, enr_cur.CODMO, enr_cur.SIGDIRMO, enr_cur.CODSG, enr_cur.LIBDSG,
                enr_cur.CUMULJH, enr_cur.CONSOJH, enr_cur.FACINT, enr_cur.REESTJH, enr_cur.PROPOJH,
                enr_cur.NOTIFJH, NULL, enr_cur.ARBITJH, enr_cur.PROPOJHN1,enr_cur.PROPOMOJH,enr_cur.PROPOMOJHN1,enr_cur.METIER)  ;
         END LOOP;

      ELSIF SUBSTR(P_codPADP,1,1)='A' THEN -- si un code Application

         FOR enr_cur IN c_curAppli (l_annee0, P_codPADP)
         LOOP
            INSERT INTO Tmpreftrans
	         (numseq,CODGROUP,NOMGROUP,FILS, CODEDP, SIGDP, PID, PTYPE, ARCTYPE, CODCAMO, LIBPROJET, CHEFPROJET, CODMO, SIGDIRMO, CODSG, LIBDSG,
	          CUMULJH, CONSOJH, FACINT, REESTJH, PROPOJH, NOTIFJH, RESERJH, ARBITJH, PROPOJHN1,PROPOMOJH,PROPOMOJHN1,METIER)
	      VALUES
               (l_numseq,enr_cur.CODGROUP,enr_cur.NOMGROUP,enr_cur.FILS, enr_cur.CODEDP, enr_cur.SIGDP, enr_cur.PID, enr_cur.PTYPE, enr_cur.ARCTYPE,
                enr_cur.CODCAMO, enr_cur.LIBPROJET, enr_cur.CHEFPROJET, enr_cur.CODMO, enr_cur.SIGDIRMO, enr_cur.CODSG, enr_cur.LIBDSG,
                enr_cur.CUMULJH, enr_cur.CONSOJH, enr_cur.FACINT, enr_cur.REESTJH, enr_cur.PROPOJH,
                enr_cur.NOTIFJH, NULL, enr_cur.ARBITJH, enr_cur.PROPOJHN1,enr_cur.PROPOMOJH,enr_cur.PROPOMOJHN1,enr_cur.METIER);
         END LOOP;
      ELSE

         FOR enr_cur IN c_curDossProj (l_annee0, P_codPADP)
         LOOP
            INSERT INTO Tmpreftrans
	         (numseq, CODGROUP,NOMGROUP,FILS ,CODEDP, SIGDP, PID, PTYPE, ARCTYPE, CODCAMO, LIBPROJET, CHEFPROJET, CODMO, SIGDIRMO, CODSG, LIBDSG,
	          CUMULJH, CONSOJH, FACINT, REESTJH, PROPOJH, NOTIFJH, RESERJH, ARBITJH, PROPOJHN1,PROPOMOJH,PROPOMOJHN1,METIER)
	      VALUES
               (l_numseq,enr_cur.CODGROUP,enr_cur.NOMGROUP,enr_cur.FILS, enr_cur.CODEDP, enr_cur.SIGDP, enr_cur.PID, enr_cur.PTYPE, enr_cur.ARCTYPE,
                enr_cur.CODCAMO, enr_cur.LIBPROJET, enr_cur.CHEFPROJET, enr_cur.CODMO, enr_cur.SIGDIRMO, enr_cur.CODSG, enr_cur.LIBDSG,
                enr_cur.CUMULJH, enr_cur.CONSOJH, enr_cur.FACINT, enr_cur.REESTJH, enr_cur.PROPOJH,
                enr_cur.NOTIFJH, NULL, enr_cur.ARBITJH, enr_cur.PROPOJHN1,enr_cur.PROPOMOJH,enr_cur.PROPOMOJHN1,enr_cur.METIER);
         END LOOP;

      END IF;

      -----------------
      -- COMMIT
      -----------------
      COMMIT;

      RETURN l_numseq;

EXCEPTION
    WHEN OTHERS THEN
    RETURN 0; -- code d'erreur
END Select_DataReftrans;




-- -------------------------------------------------------------------------
-- FUNCTION Select_DataProref4
-- Role : identique à la foncition Select_DataReftrans mais pour l'édition
-- Proref4
-- -------------------------------------------------------------------------
FUNCTION Select_DataProref4 (P_codDossProj IN CHAR) RETURN NUMBER IS

   l_annee0  NUMBER(4);
   l_msg  VARCHAR2(1024);

   l_numseq         NUMBER ; -- numéro de séquence identifiant l'extraction en cours

-- déclaration du cursor pour rammener les Dossiers Projets
-- -------------------------------------------------------------

cursor c_curDossProj (cp_anneeN Number, cp_CodDossProj char) IS
select
       si.coddeppole   			CODEDP,
       si.sigdep ||'/'|| si.sigpole as	SIGDP,
       lb.pid              		PID,
       lb.typproj          		PTYPE,
       lb.codcamo          		CODCAMO,
       substr(lb.pnom,1,20) 		LIBPROJET,
       substr(r.rnom,1,10)  		CHEFPROJET,
       nvl(nvl(conso.cusag,0) + nvl(conso_1.cusag,0) + nvl(conso_2.xcusag,0) ,0) CUMULJH,
       nvl(conso.cusag, 0)              CONSOJH,
       f_facint(lb.pid)  		FACINT,
       nvl(floor(budg.reestime), 0)     REESTJH,
       nvl(floor(budg.bpmontme), 0)     PROPOJH,
       nvl(budg.bnmont, 0)              NOTIFJH,
       nvl(floor(budg.reserve), 0)      RESERJH,
       nvl(budg.anmont, 0)              ARBITJH,
       nvl(floor(budg1.bpmontme), 0)    PROPOJHN1,
       cm.clicode          		CODMO,
       cm.clisigle         		SIGDIRMO
from  ligne_bip       	lb     ,
      dossier_projet  	dp     ,  -- ###
      ressource       	r      ,
      budget     	budg   ,
      budget     	budg1  ,
      consomme 		conso  ,
      consomme 		conso_1,
      consomme 		conso_2,
      client_mo       	cm     ,
      struct_info     	si
where  lb.dpcode   = dp.dpcode  -- ###
   and lb.clicode  = cm.clicode
   and lb.pcpi     = r.ident
   and lb.codsg    = si.codsg
   and lb.typproj in (1,2,3,4,6,8)
   and lb.dpcode = TO_NUMBER(cp_CodDossProj)  -- ###
   and cm.clicode not in ('999  ', ' AB  ')  -- absent dans Select_DataReftrans
   and lb.pid = budg.pid     (+)
	and lb.pid = budg1.pid   (+)
	and lb.pid = conso.pid  (+)
	and lb.pid = conso_1.pid (+)
   and lb.pid = conso_2.pid    (+)
   -- Au moins une des donnees n°9 a 15, ou b.xcusag0 ou b.xcusagM1 est different de zero
   and (   (  conso.cusag     <> 0 AND   conso.cusag    is not null )
        OR (  conso_1.cusag    <> 0 AND   conso_1.cusag   is not null )
	  OR (  conso_2.xcusag    <> 0 AND   conso_2.xcusag   is not null )
        OR ( f_facint(lb.pid) <> 0 )
        OR ( budg.reestime  <> 0 AND  budg.reestime is not null )
        OR ( budg.bpmontme     <> 0 AND  budg.bpmontme    is not null )
        OR ( budg.bnmont      <> 0 AND  budg.bnmont     is not null )
        OR ( budg.reserve     <> 0 AND  budg.reserve    is not null )
        OR (budg.anmont      <> 0 AND budg.anmont     is not null )
        OR (budg.bpmontme     <> 0 AND budg.bpmontme    is not null )
        )
and budg.annee(+)  =  cp_anneeN
and conso.annee(+)  =  cp_anneeN
and conso_1.annee(+) =  cp_anneeN-1
and conso_2.annee(+) = cp_anneeN-2
and budg1.annee(+) =  cp_anneeN+1;
-- AND ROWNUM < 20;  --


BEGIN

      -- p_msg := '';
      SELECT TO_NUMBER( TO_CHAR( datdebex, 'YYYY'))
	INTO l_annee0
	FROM datdebex;

      SELECT Seqreftrans.nextval INTO l_numseq FROM dual;

      FOR enr_cur IN c_curDossProj (l_annee0, P_codDossProj)
      LOOP
         INSERT INTO Tmpreftrans
	      (numseq, CODEDP, SIGDP, PID, PTYPE, CODCAMO, LIBPROJET, CHEFPROJET, CUMULJH,
            CONSOJH, FACINT, REESTJH, PROPOJH, NOTIFJH, RESERJH, ARBITJH, PROPOJHN1,
            CODMO, SIGDIRMO)
	   VALUES
            (l_numseq, enr_cur.CODEDP, enr_cur.SIGDP, enr_cur.PID, enr_cur.PTYPE,
             enr_cur.CODCAMO, enr_cur.LIBPROJET, enr_cur.CHEFPROJET, enr_cur.CUMULJH,
             enr_cur.CONSOJH, enr_cur.FACINT, enr_cur.REESTJH, enr_cur.PROPOJH,
             enr_cur.NOTIFJH, enr_cur.RESERJH, enr_cur.ARBITJH, enr_cur.PROPOJHN1,
             enr_cur.CODMO, enr_cur.SIGDIRMO);
      END LOOP;

      -----------------
      -- COMMIT
      -----------------
      COMMIT;

      RETURN l_numseq;

EXCEPTION
   WHEN OTHERS THEN
   RETURN 0; -- code d'erreur
END Select_DataProref4;


-- -------------------------------------------------------------------------
-- FUNCTION Delete_Donnees
-- Role : Supprime, dans la table Tmpreftrans, les données creees par la
-- fonction Select_DataReftrans A la fin de l'édition.
-- -------------------------------------------------------------------------

FUNCTION Delete_Donnees (
			 P_numseq IN NUMBER   -- Code Porjet ou Code Appli ou code Dossier Projet
                         ) RETURN BOOLEAN IS
BEGIN
   DELETE FROM tmpreftrans
   WHERE  numseq = p_numseq;
   COMMIT;
   RETURN TRUE;
EXCEPTION
      WHEN OTHERS THEN RETURN(FALSE); -- NOK
END Delete_Donnees;


-- -------------------
END pack_RefPCM;
/
CREATE OR REPLACE PACKAGE pack_RefTrans IS

-- =========================================================================
-- PROCEDURE Verif_Param
-- Role : Verifie l'existance de et l'exactitude du paramettre d'entree de
--        l'édition RefTrans.
-- Parametre : P_codPADP peut prendre une valeure d'un Code Porjet ou d'un
--               Code Appli ou d'un code Dossier Projet.
-- -------------------------------------------------------------------------

-- PROCEDURE Verif_ParamProref4
-- Role : Verifie l'existance de et l'exactitude du paramettre d'entree de
--        l'édition proref4.
-- Parametre : P_codDP : code Dossier Projet.
-- -------------------------------------------------------------------------

-- FUNCTION Titre3
-- Role : Construit et retourne le 3eme ligne du titre de l'édition.
-- -------------------------------------------------------------------------

-- FUNCTION Titre4
-- Role : Construit et retourne le 4eme ligne du titre de l'édition.
-- -------------------------------------------------------------------------

   PROCEDURE Verif_Param (P_codPADP IN VARCHAR2, p_userid  IN VARCHAR2);

   PROCEDURE Verif_ParamProref4 (P_codDP IN CHAR, p_userid  IN VARCHAR2);


   FUNCTION Titre3 (P_codPADP IN CHAR) RETURN VARCHAR2;

   FUNCTION Titre4 (P_codPADP IN CHAR) RETURN VARCHAR2;

   -- Retourne le nombre de lignes de la table pour un codgroup donné
   FUNCTION Get_Nb_Lignes(p_codgroup 	VARCHAR2,
   			  p_numseq 	NUMBER
   			  ) RETURN NUMBER;


   -- Retourne le nombre de lignes de la table pour un codgroup donné
   FUNCTION Get_Nb_Lignes_Clicode(	p_codgroup 	VARCHAR2,
   			  		p_numseq 	NUMBER,
   			  		p_clicode	VARCHAR2
   			  ) RETURN NUMBER;


   -- Retourne le nombre de lignes de la table pour un codgroup donné
   FUNCTION Get_Nb_Lignes_codsg(	p_codgroup 	VARCHAR2,
   			  		p_numseq 	NUMBER,
   			  		p_codsg		VARCHAR2
   			  ) RETURN NUMBER;

END pack_RefTrans;
/

CREATE OR REPLACE PACKAGE BODY pack_RefTrans IS
-- =========================================================================
-- PROCEDURE Verif_Param
-- Role : Verifie l'existance de et l'exactitude du paramettre d'entree.
-- Parametre : P_codPADP peut prendre une valeure d'un Code Porjet ou d'un
--        Code Appli ou d'un code Dossier Projet.
-- -------------------------------------------------------------------------

   PROCEDURE Verif_Param (P_codPADP IN VARCHAR2, p_userid  IN VARCHAR2) IS

   l_codeProj     VARCHAR2(5);
   l_codeAppli    VARCHAR2(5);
   l_codeDossProj NUMBER(5);
   l_msg   	  VARCHAR2(1024);


   BEGIN
       l_msg := '';

       IF SUBSTR(P_codPADP,1,1)= 'P' OR SUBSTR(P_codPADP, 1, 1)='I' THEN
           BEGIN
              SELECT pri.icpi INTO l_codeProj
              FROM proj_info pri
              WHERE pri.icpi = P_codPADP
                AND rownum < 2;

           EXCEPTION
              WHEN NO_DATA_FOUND THEN
                 -- Code projet informatique inexistant
                 pack_global.recuperer_message(20735, null, null, null, l_msg);
                 raise_application_error(-20735, l_msg);

              WHEN OTHERS THEN
                 raise_application_error(-20997, SQLERRM);
           END;


       ELSIF SUBSTR(P_codPADP,1,1)= 'A' THEN
           BEGIN
              SELECT app.airt INTO l_codeAppli
              FROM application app
              WHERE app.airt = P_codPADP
                AND rownum < 2;

           EXCEPTION
              WHEN NO_DATA_FOUND THEN
                 -- Identifiant Application inexistant
                 pack_global.recuperer_message(20733, null, null, null, l_msg);
                 raise_application_error(-20733, l_msg);

              WHEN OTHERS THEN
                 raise_application_error(-20997,SQLERRM);
           END;

       ELSIF SUBSTR(P_codPADP,1,1) IN ('0','1','2','3','4','5','6','7','8','9') THEN

           BEGIN
              SELECT dp.dpcode INTO l_codeDossProj
              FROM dossier_projet dp
              WHERE dp.dpcode = TO_NUMBER(P_codPADP)
                AND rownum < 2;

           EXCEPTION
              WHEN NO_DATA_FOUND THEN
                 -- Code dossier projet inexistant
                 pack_global.recuperer_message(20729, null, null, null, l_msg);
                 raise_application_error(-20729, l_msg);

              WHEN OTHERS THEN
                 raise_application_error(-20997,SQLERRM);
           END;

      ELSE
           -- Code projet informatique inexistant
           pack_global.recuperer_message(20735, null, null, null, l_msg);
           raise_application_error(-20735, l_msg);
      END IF;

END Verif_Param;



-- -------------------------------------------------------------------------
-- PROCEDURE Verif_ParamProref4
-- Role : Verifie l'existance de et l'exactitude du paramettre d'entree de
--        l'édition proref4.
-- Parametre : P_codDP : code Dossier Projet.
-- -------------------------------------------------------------------------

   PROCEDURE Verif_ParamProref4 (P_codDP IN CHAR, p_userid  IN VARCHAR2) IS

   l_codeDossProj NUMBER(5);
   l_msg   VARCHAR2(1024);

   BEGIN
       l_msg := '';

        SELECT dp.dpcode INTO l_codeDossProj
        FROM   dossier_projet dp
        WHERE  dp.dpcode = TO_NUMBER(P_codDP)
        AND    rownum < 2;

   EXCEPTION
        WHEN NO_DATA_FOUND THEN
             -- Code dossier projet inexistant
             pack_global.recuperer_message(20729, null, null, null, l_msg);
             raise_application_error(-20729, l_msg);

        WHEN OTHERS THEN
                 raise_application_error(-20997,SQLERRM);
   END Verif_ParamProref4;


-- =========================================================================
-- FUNCTION Titre3
-- Role : Construit et retourne la 3eme ligne du titre de l'édition.
-- Parametre : P_codPADP peut prendre la valeur d'un Code Porjet ou d'un
--        Code Appli ou d'un code Dossier Projet.
-- =========================================================================

   FUNCTION Titre3 (P_codPADP IN CHAR) RETURN VARCHAR2 IS

   BEGIN
       IF SUBSTR(P_codPADP,1,1)= 'P' OR SUBSTR(P_codPADP,1,1)= 'I' THEN
          RETURN 'PROJET';
       ELSIF SUBSTR(P_codPADP,1,1)= 'A' THEN
          RETURN 'APPLICATION';
       ELSIF SUBSTR(P_codPADP,1,1) IN ('0','1','2','3','4','5','6','7','8','9', 'D') THEN
          RETURN 'DOSSIER PROJET';
       ELSE
          RETURN 'ERREUR';
       END IF;

   END Titre3;


-- =========================================================================
-- FUNCTION Titre4
-- Role : Construit et retourne la 4eme ligne du titre de l'édition.
-- Parametre : P_codPADP peut prendre la valeur d'un Code Porjet ou d'un
--        Code Appli ou d'un code Dossier Projet.
-- =========================================================================

   FUNCTION Titre4 (P_codPADP IN CHAR) RETURN VARCHAR2 IS
   l_titre VARCHAR2(100);
   BEGIN
       IF SUBSTR(P_codPADP,1,1)= 'P' OR SUBSTR(P_codPADP,1,1)= 'I' THEN

          BEGIN
              SELECT pri.ilibel INTO l_titre
              FROM proj_info pri
              WHERE pri.icpi = P_codPADP
                AND rownum < 2;
           EXCEPTION
              WHEN NO_DATA_FOUND THEN
                 RETURN ' ';
              WHEN OTHERS THEN
                 raise_application_error(-20997, SQLERRM);
           END;
       ELSIF SUBSTR(P_codPADP,1,1)= 'A' THEN

          BEGIN
              SELECT app.alibel INTO l_titre
              FROM application app
              WHERE app.airt = P_codPADP
                AND rownum < 2;
           EXCEPTION
              WHEN NO_DATA_FOUND THEN
                 RETURN ' ';
              WHEN OTHERS THEN
                 raise_application_error(-20997, SQLERRM);
           END;

       ELSIF SUBSTR(P_codPADP,1,1) IN ('0','1','2','3','4','5','6','7','8','9') THEN
          BEGIN
              SELECT dp.dplib INTO l_titre
              FROM dossier_projet dp
              WHERE dp.dpcode = TO_NUMBER(P_codPADP)
                AND rownum < 2;
           EXCEPTION
              WHEN NO_DATA_FOUND THEN
                 RETURN ' ';
              WHEN OTHERS THEN
                 raise_application_error(-20997, SQLERRM);
           END;
       ELSE
          RETURN 'ERREUR';
       END IF;

       RETURN LTRIM(RTRIM(l_titre));
   END Titre4;

   -- Retourne le nombre de lignes de la table pour un codgroup donné
   FUNCTION Get_Nb_Lignes(p_codgroup 	VARCHAR2,
   			  p_numseq 	NUMBER
   			  ) RETURN NUMBER IS
   l_nb_lignes NUMBER(10);
   BEGIN
   	SELECT count(*) INTO l_nb_lignes
   	FROM tmpreftrans
   	WHERE codgroup = p_codgroup
   	  AND numseq = p_numseq;

   	RETURN l_nb_lignes;
   END Get_Nb_Lignes;

   -- Retourne le nombre de lignes de la table pour un codgroup donné
   FUNCTION Get_Nb_Lignes_Clicode(	p_codgroup 	VARCHAR2,
   			  		p_numseq 	NUMBER,
   			  		p_clicode	VARCHAR2
   			  ) RETURN NUMBER IS
   l_nb_lignes NUMBER(10);
   BEGIN
   	SELECT count(*) INTO l_nb_lignes
   	FROM tmpreftrans
   	WHERE codgroup = p_codgroup
   	  AND codmo    = p_clicode
   	  AND numseq   = p_numseq;

   	RETURN l_nb_lignes;
   END Get_Nb_Lignes_Clicode;


   -- Retourne le nombre de lignes de la table pour un codgroup donné
   FUNCTION Get_Nb_Lignes_codsg(	p_codgroup 	VARCHAR2,
   			  		p_numseq 	NUMBER,
   			  		p_codsg		VARCHAR2
   			  ) RETURN NUMBER IS
   l_nb_lignes NUMBER(10);
   BEGIN
   	SELECT count(*) INTO l_nb_lignes
   	FROM tmpreftrans
   	WHERE codgroup = p_codgroup
   	  AND codsg    = TO_NUMBER(p_codsg)
   	  AND numseq   = p_numseq;

   	RETURN l_nb_lignes;
   END Get_Nb_Lignes_codsg;


-- -------------------------------------------------------------
END pack_RefTrans;
/
CREATE OR REPLACE PACKAGE PACK_REMONTEE AS

STATUT_ERREUR 		NUMBER :=-1;
STATUT_NON_NO_DATA	NUMBER := 0;
STATUT_NON_CONTROLE	NUMBER := 1;
STATUT_CONTROLE_OK	NUMBER := 2;
STATUT_CONTROLE_KO	NUMBER := 3;
STATUT_REMPLACE		NUMBER := 4;
STATUT_CHARGE		NUMBER := 5;
STATUT_SUPPRIME		NUMBER := 6;

PROCEDURE get_fichier(		p_PID IN REMONTEE.PID%TYPE,
							p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_FICHIER_DATA OUT REMONTEE.FICHIER_DATA%TYPE,
							p_STATUT OUT REMONTEE.STATUT%TYPE,
							p_STATUT_DATE OUT REMONTEE.STATUT_DATE%TYPE,
							p_STATUT_INFO OUT REMONTEE.STATUT_INFO%TYPE);


PROCEDURE insert_fichier(	p_PID IN REMONTEE.PID%TYPE,
							p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_FICHIER_DATA IN REMONTEE.FICHIER_DATA%TYPE,
							p_STATUT IN REMONTEE.STATUT%TYPE,
							p_STATUT_INFO IN REMONTEE.STATUT_INFO%TYPE);

PROCEDURE update_fichier(	p_PID IN REMONTEE.PID%TYPE,
							p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_STATUT IN REMONTEE.STATUT%TYPE,
							p_STATUT_INFO IN REMONTEE.STATUT_INFO%TYPE);

PROCEDURE update_statut(	p_STATUT_IN IN REMONTEE.STATUT%TYPE,
							p_STATUT_OUT IN  REMONTEE.STATUT%TYPE,
							p_STATUT_INFO IN REMONTEE.STATUT_INFO%TYPE);

PROCEDURE remplacer_fichiers(	p_PID IN REMONTEE.PID%TYPE,
								p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE);

PROCEDURE get_data_fichier(	p_PID IN REMONTEE.PID%TYPE,
							p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_DATA IN OUT REMONTEE.DATA%TYPE);

PROCEDURE get_erreur_fichier(	p_PID IN REMONTEE.PID%TYPE,
								p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
								p_ERREUR IN OUT REMONTEE.ERREUR%TYPE);

TYPE remonteeRecType IS RECORD (	PID REMONTEE.PID%TYPE,
									ID_REMONTEUR REMONTEE.ID_REMONTEUR%TYPE,
									FICHIER_DATA REMONTEE.FICHIER_DATA%TYPE,
									STATUT REMONTEE.STATUT%TYPE,
									STATUT_INFO REMONTEE.STATUT_INFO%TYPE,
									STATUT_DATE VARCHAR(32));

TYPE remonteeCurType IS REF CURSOR RETURN remonteeRecType ;

PROCEDURE select_fichiers(	p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_CURSEUR IN OUT remonteeCurType);

PROCEDURE select_fichiers_statut(	p_STATUT IN REMONTEE.STATUT%TYPE,
									p_CURSEUR IN OUT remonteeCurType);

END PACK_REMONTEE;
/

CREATE OR REPLACE PACKAGE BODY PACK_REMONTEE AS

PROCEDURE get_fichier(	p_PID IN REMONTEE.PID%TYPE,
						p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
						p_FICHIER_DATA OUT REMONTEE.FICHIER_DATA%TYPE,
						p_STATUT OUT REMONTEE.STATUT%TYPE,
						p_STATUT_DATE OUT REMONTEE.STATUT_DATE%TYPE,
						p_STATUT_INFO OUT REMONTEE.STATUT_INFO%TYPE)
IS
BEGIN
	SELECT
		FICHIER_DATA, STATUT, STATUT_DATE, STATUT_INFO
	INTO
		p_FICHIER_DATA, p_STATUT, p_STATUT_DATE, p_STATUT_INFO
	FROM
		REMONTEE
	WHERE
		PID = p_PID
	AND	ID_REMONTEUR = p_ID_REMONTEUR;

END get_fichier;

--
-- si un autre utilisateur a deja remonte un fichier pour ce PID pour le traitement a venir, celui-ci passe en statut 'remplace'
-- seul le fichier remonte en dernier est pris en compte
PROCEDURE remplacer_fichiers(	p_PID IN REMONTEE.PID%TYPE,
								p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE)
IS
BEGIN
	update
		REMONTEE
	SET
		STATUT = STATUT_REMPLACE,
		STATUT_DATE = sysdate,
		STATUT_INFO = p_ID_REMONTEUR
	WHERE
		PID = p_PID
	AND STATUT NOT IN (STATUT_CHARGE, STATUT_REMPLACE);

END remplacer_fichiers;

PROCEDURE insert_fichier(	p_PID IN REMONTEE.PID%TYPE,
							p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_FICHIER_DATA IN REMONTEE.FICHIER_DATA%TYPE,
							p_STATUT IN REMONTEE.STATUT%TYPE,
							p_STATUT_INFO IN REMONTEE.STATUT_INFO%TYPE)
IS
BEGIN
	-- si il y a deja un fichier avec ce PID qui a ete remonte : on le passe a 'remplacé'
	remplacer_fichiers(p_PID, p_ID_REMONTEUR);

	-- si le remonteur a deja remonte sur ce PID, on supprime sa ligne pour en recreer une nouvelle
	delete
		REMONTEE
	where
		PID = p_PID
	and ID_REMONTEUR = p_ID_REMONTEUR;

	-- on cree la nouvelle ligne
	insert into
		REMONTEE(PID, ID_REMONTEUR, FICHIER_DATA, DATA, ERREUR, STATUT, STATUT_DATE, STATUT_INFO)
	VALUES(p_PID, p_ID_REMONTEUR, p_FICHIER_DATA, empty_clob(), empty_clob, p_STATUT, sysdate, p_STATUT_INFO);
END insert_fichier;

PROCEDURE update_fichier(	p_PID IN REMONTEE.PID%TYPE,
							p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_STATUT IN REMONTEE.STATUT%TYPE,
							p_STATUT_INFO IN REMONTEE.STATUT_INFO%TYPE)
IS
BEGIN
	update
		REMONTEE
	SET
		STATUT = p_STATUT,
		STATUT_INFO = p_STATUT_INFO,
		STATUT_DATE = sysdate
	WHERE
		PID = p_PID
	AND ID_REMONTEUR = p_ID_REMONTEUR;
END update_fichier;

PROCEDURE select_fichiers(	p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_CURSEUR IN OUT remonteeCurType )
IS
BEGIN

	OPEN p_CURSEUR FOR
	SELECT
		PID,
		ID_REMONTEUR,
		FICHIER_DATA,
		STATUT,
		nvl(STATUT_INFO, ' '),
		to_char(STATUT_DATE, 'DD/MM/YYYY HH24:MI')
	FROM
		REMONTEE
	WHERE
		ID_REMONTEUR = p_ID_REMONTEUR
	--AND	STATUT <> STATUT_SUPPRIME
	ORDER BY PID ASC;

END select_fichiers;


PROCEDURE get_data_fichier(	p_PID IN REMONTEE.PID%TYPE,
							p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
							p_DATA IN OUT REMONTEE.DATA%TYPE)
IS
BEGIN
	SELECT DATA INTO p_DATA
	FROM REMONTEE
	WHERE PID = p_PID
	AND ID_REMONTEUR = p_ID_REMONTEUR;
END get_data_fichier;

PROCEDURE get_erreur_fichier(	p_PID IN REMONTEE.PID%TYPE,
								p_ID_REMONTEUR IN REMONTEE.ID_REMONTEUR%TYPE,
								p_ERREUR IN OUT REMONTEE.ERREUR%TYPE)
IS
BEGIN
	SELECT ERREUR INTO p_ERREUR
	FROM REMONTEE
	WHERE PID = p_PID
	AND ID_REMONTEUR = p_ID_REMONTEUR;
END get_erreur_fichier;

PROCEDURE select_fichiers_statut(	p_STATUT IN REMONTEE.STATUT%TYPE,
									p_CURSEUR IN OUT remonteeCurType)
IS
BEGIN
	OPEN p_CURSEUR FOR
	SELECT
		PID,
		ID_REMONTEUR,
		FICHIER_DATA,
		STATUT,
		nvl(STATUT_INFO, ' '),
		to_char(STATUT_DATE, 'DD/MM/YYYY HH24:MI')
	FROM
		REMONTEE
	WHERE
		STATUT = p_STATUT
	ORDER BY PID ASC;

END select_fichiers_statut;

PROCEDURE update_statut(p_STATUT_IN IN REMONTEE.STATUT%TYPE,
						p_STATUT_OUT IN REMONTEE.STATUT%TYPE,
						p_STATUT_INFO IN REMONTEE.STATUT_INFO%TYPE)
IS
BEGIN
	UPDATE
		REMONTEE
	SET
		STATUT = p_STATUT_OUT,
		STATUT_INFO = p_STATUT_INFO,
		STATUT_DATE = sysdate
	WHERE
		STATUT = p_STATUT_IN;

END update_statut;

END PACK_REMONTEE;
/
CREATE OR REPLACE PACKAGE PACK_REPORT_LOG AS

PROCEDURE insert_log(       p_FICHIER_RDF IN REPORT_LOG.FICHIER_RDF%TYPE,
                            p_ID_USER IN REPORT_LOG.ID_USER%TYPE);

END PACK_REPORT_LOG;
/

CREATE OR REPLACE PACKAGE BODY PACK_REPORT_LOG AS

PROCEDURE insert_log(       p_FICHIER_RDF IN REPORT_LOG.FICHIER_RDF%TYPE,
                            p_ID_USER IN REPORT_LOG.ID_USER%TYPE)
IS
BEGIN
	INSERT INTO REPORT_LOG (FICHIER_RDF, ID_USER, DATE_LOG) VALUES (p_FICHIER_RDF, p_ID_USER, sysdate);
END insert_log;

END PACK_REPORT_LOG;
/
CREATE OR REPLACE PACKAGE pack_rep_facture AS

  -- ------------------------------------------------------------------------
  -- Nom        : verif_facrap
  -- Auteur     : Equipe SOPRA
  -- Decription : Verification des parametres du report facrap
  -- Paramètres : p_param6  (IN) date de filtre
  --              p_userid  (IN)  user
  --              p_message (OUT) message d'erreur si erreur
  --
  -- ------------------------------------------------------------------------
  --                           MODIFICATION
  -- ------------------------------------------------------------------------
PROCEDURE verif_facrap (p_param6  IN VARCHAR2,
			p_userid  IN VARCHAR2,
			p_message OUT VARCHAR2
		       );

  -- ------------------------------------------------------------------------
  -- Nom        : verif_fe61
  -- Auteur     : Equipe SOPRA
  -- Decription : Verification des parametres du report fe61
  -- Paramètres : p_coddeppolegrp (IN)	code département/pole/groupe
  --              p_userid        (IN)  user
  --              p_message       (OUT) message d'erreur si erreur
  --
  -- ------------------------------------------------------------------------
  --                           MODIFICATION
  -- ------------------------------------------------------------------------
PROCEDURE verif_fe61 ( p_codcfrais     IN VARCHAR2,
		       p_coddeppolegrp IN  VARCHAR2,
		       p_anciennete    IN  CHAR,
		       p_message       OUT VARCHAR2
			);
-- ------------------------------------------------------------------------
-- Nom        : verif_fe62
-- Auteur     : Equipe SOPRA
-- Decription : Verification des parametres du report fe62
-- Paramètres : p_soccode       (IN)  code societe
--              p_userid        (IN)  user
--              p_message       (OUT) message d'erreur si erreur
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
PROCEDURE verif_fe62 ( p_soccode IN  VARCHAR2,
		       p_userid  IN  VARCHAR2,
		       p_message OUT VARCHAR2
		     );

-- ------------------------------------------------------------------------
-- Nom        : verif_fe63
-- Auteur     : Equipe SOPRA
-- Decription : Verification des parametres du report fe63
-- Paramètres : p_datdebut      (IN)  date de debut
--              p_datfin        (IN)  date de fin
--              p_userid        (IN)  user
--              p_message       (OUT) message d'erreur si erreur
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
PROCEDURE verif_fe63 ( p_datdebut IN VARCHAR2,
		       p_datfin  IN  VARCHAR2,
		       p_userid  IN  VARCHAR2,
		       p_message OUT VARCHAR2
		     );

-- ------------------------------------------------------------------------
-- Nom        : verif_fe63
-- Auteur     : Equipe SOPRA
-- Decription : Verification des parametres du report fe63
-- Paramètres : p_soccode       (IN)  code societe CHAR(4)
--              p_fregcompta1   (IN)  date
--              p_fregcompta2   (IN)  date
--              p_userid        (IN)  user
--              p_message       (OUT) message d'erreur si erreur
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
PROCEDURE verif_factab6( p_soccode     IN  societe.soccode%TYPE,
			 p_fregcompta1 IN  VARCHAR2,
			 p_fregcompta2 IN  VARCHAR2,
			 p_userid      IN  VARCHAR2,
			 P_message     OUT VARCHAR2
		       );


-- ------------------------------------------------------------------------
-- Nom        : verif_fe63
-- Auteur     : Equipe SOPRA
-- Decription : Verification des parametres du report fe63
-- Paramètres : p_soccode       (IN)  code societe CHAR(4)
--              p_fregcompta1   (IN)  date
--              p_fregcompta2   (IN)  date
--              p_lmoisprest1   (IN)  date
--              p_lmoisprest2   (IN)  date
--              p_fdeppole      (IN)  number(6)
--              p_socnat        (IN)  sans utilite
--              p_comcode       (IN)  varchar2
--              p_fmontht       (IN)  sans utilite
--              p_userid        (IN)  user
--              p_message       (OUT) message d'erreur si erreur
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
PROCEDURE verif_lstfact(
			p_soccode     IN  societe.soccode%TYPE,
			p_fenrcompta1 IN  VARCHAR2,
			p_fenrcompta2 IN  VARCHAR2,
			p_lmoisprest1 IN  VARCHAR2,
			p_lmoisprest2 IN  VARCHAR2,
			p_fdeppole    IN  VARCHAR2,
			p_socnat      IN  VARCHAR2,
			p_comcode     IN  VARCHAR2,
			p_fmontht     IN  VARCHAR2,
			p_userid      IN  VARCHAR2,
			P_message     OUT VARCHAR2
		       );

-- ------------------------------------------------------------------------
-- Nom        : verif_fe63
-- Auteur     : Equipe SOPRA
-- Decription :
-- Paramètres : p_comcode   (IN)
--              p_focus     (IN)
--              p_msg       (IN)
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
PROCEDURE select_CodeComptable(p_comcode IN VARCHAR2,
			       p_focus IN  VARCHAR2,
			       p_msg OUT VARCHAR2
			      );

-- ------------------------------------------------------------------------
-- Nom        : f_prologue_fe60
-- Auteur     : Equipe SOPRA
-- Decription : prologue de fe60
-- Paramètres : p_filiale   (IN) code filiale
-- Retour     : le numéro de sequence d'insersion dans tmpfe60
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
FUNCTION f_prologue_fe60(p_filiale IN CHAR, p_codcfrais IN CHAR) RETURN NUMBER;
FUNCTION f_prologue_tous_fe60(p_filiale IN CHAR) RETURN NUMBER;

-- ------------------------------------------------------------------------
-- Nom        : f_epilogue_fe60
-- Auteur     : Equipe SOPRA
-- Decription : epilogue de fe60
-- Paramètres : p_numseq    (IN) numero de sequence a supprimer dans tmpfe60
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
FUNCTION f_epilogue_fe60(p_numseq NUMBER) RETURN BOOLEAN;



-- ------------------------------------------------------------------------
-- Nom        : f_entetecol_fe65
-- Auteur     : Equipe SOPRA
-- Decription : retourne le libelle des colonnes en fonction de numéro de
--              la colonne (1 à 5) dans l'edition fe65
-- Paramètres : p_numseq    (IN) numero de sequence a supprimer dans tmpfe60
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
function f_entetecol_fe65(
			  p_num NUMBER
			 ) RETURN VARCHAR2;



-- ------------------------------------------------------------------------
-- Nom        : verif_fe65
-- Auteur     : Equipe SOPRA
-- Decription : Procedure qui controle les parametre d'entrées
-- Paramètres : p_datdeb        (IN) date
--              p_datfin        (IN) date
--              p_userid        (IN)  user
--              p_message       (OUT) message d'erreur si erreur
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
-- ------------------------------------------------------------------------
PROCEDURE verif_fe65(
		     p_datdeb  IN VARCHAR2,         -- date
		     p_datfin  IN VARCHAR2,         -- date
		     p_userid  IN VARCHAR2,
		     P_message OUT VARCHAR2
		    );


PROCEDURE verif_facqua6  (p_param6  IN VARCHAR2,
			  p_param7  IN Varchar2,
			  p_userid  IN VARCHAR2,
			  p_message OUT VARCHAR2
			 );


-- Curseur de récupération des factures , classé par pôle.
cursor  c_fact (v_filcode CHAR,v_centrefrais NUMBER) IS
  SELECT
      'PAS DE CONTRAT',
      sti.coddep,
      sti.coddeppole,
      fac.fdatsai
  FROM
      facture fac,
      struct_info sti
  WHERE
      fac.fdeppole = sti.codsg
      AND ( fac.fregcompta IS NULL OR
             fac.faccsec IS NULL
          --OR fac.fenrcompta IS NULL
	    )
     AND fac.numcont IS NULL
     AND fac.fcentrefrais=v_centrefrais
UNION ALL
  SELECT
      'CONTRAT',
      sti.coddep,
      sti.coddeppole,
      fac.fdatsai
  FROM
      facture fac,
      struct_info sti,
      contrat cnt
  WHERE
      fac.fdeppole = sti.codsg
      AND fac.socfact = cnt.soccont
      AND fac.numcont = cnt.numcont
      AND fac.cav = cnt.cav
      AND( fac.fregcompta IS NULL OR
      	 fac.faccsec IS NULL
         --OR fac.fenrcompta IS NULL
	   )
      AND fac.numcont IS NOT NULL
      AND cnt.filcode = v_filcode
      AND fac.fcentrefrais=v_centrefrais
 ORDER BY 3;

-- Curseur de récupération des factures , classé par pôle.
cursor  c_all (v_filcode CHAR) IS
  SELECT
      'PAS DE CONTRAT',
      sti.coddep,
      sti.coddeppole,
      fac.fdatsai
  FROM
      facture fac,
      struct_info sti
  WHERE
      fac.fdeppole = sti.codsg
      AND (--fac.fenrcompta IS NULL OR
       fac.faccsec IS NULL
          OR fac.fregcompta IS NULL
	    )
     AND fac.numcont IS NULL
UNION ALL
  SELECT
      'CONTRAT',
      sti.coddep,
      sti.coddeppole,
      fac.fdatsai
  FROM
      facture fac,
      struct_info sti,
      contrat cnt
  WHERE
      fac.fdeppole = sti.codsg
      AND fac.socfact = cnt.soccont
      AND fac.numcont = cnt.numcont
      AND fac.cav = cnt.cav
      AND(--fac.fenrcompta IS NULL OR
       fac.faccsec IS NULL
         OR fac.fregcompta IS NULL
	   )
      AND fac.numcont IS NOT NULL
      AND cnt.filcode = v_filcode
 ORDER BY 3;


    PRAGMA RESTRICT_REFERENCES(f_entetecol_fe65,WNDS,WNPS);
END pack_rep_facture ;
/

CREATE OR REPLACE PACKAGE BODY pack_rep_facture AS

  -- ------------------------------------------------------------------------
  -- Nom        : verif_facrap
  -- Auteur     : Equipe SOPRA
  -- Decription : Verification des parametres du report facrap
  -- Paramètres : p_param6  (IN) date de filtre
  --              p_userid  (IN)  user
  --              p_message (OUT) message d'erreur si erreur
  --
  -- ------------------------------------------------------------------------
  --                           MODIFICATION
  -- ------------------------------------------------------------------------
PROCEDURE verif_facrap (    p_param6  IN VARCHAR2,
			    p_userid  IN VARCHAR2,
			    p_message OUT VARCHAR2
			   ) IS

   l_msg      VARCHAR2(1024);
   l_datdebex VARCHAR2(20);

BEGIN

   BEGIN

      SELECT to_char(datdebex, 'YYYY')
	INTO l_datdebex
	FROM datdebex;

   EXCEPTION
      WHEN OTHERS THEN
	NULL;
   END;

   -- Si l'annee de la date saisie est <= a l'annee de datdebex on
   -- ne retourne aucun resultat donc erreur.
   IF substr(p_param6,7,4) < l_datdebex THEN
      pack_global.recuperer_message(20200, NULL, NULL, NULL, l_msg);
      raise_application_error(-20200, l_msg);
   END IF;

END verif_facrap;



  -- ------------------------------------------------------------------------
  -- Nom        : f_prologue_fe60

  -- Auteur     : Equipe SOPRA
  -- Decription : Préparation du report fe60, insère dans la table tmpfe60
  -- Paramètres : p_filiale    IN             numéro de filiale
  -- Retour     : Si le prologue ne se passe pas bien, renvoie 0, sinon
  --              renvoie le numéro de séquence sur lequel il faut filtrer
  --              sur tmpfe60
  --
  -- ------------------------------------------------------------------------
  --                           MODIFICATION
  --
  -- ------------------------------------------------------------------------
FUNCTION f_prologue_fe60(p_filiale IN CHAR, p_codcfrais IN CHAR) RETURN NUMBER IS

   -- Variables pour le count
   l_count_pascont  NUMBER := 0;
   l_count00_30     NUMBER := 0;
   l_count31_60     NUMBER := 0;
   l_count61_90     NUMBER := 0;
   l_count91_120    NUMBER := 0;
   l_count120       NUMBER := 0;

   -- Variables de réception du curseur
   l_iscontrat      VARCHAR2(30);
   l_coddep         struct_info.coddep%type ;
   l_coddeppole     struct_info.coddeppole%type;
   l_fdatsai        DATE ;
   l_sysdate        DATE ;
   l_oldcoddeppole  struct_info.coddeppole%type;
   l_oldcoddep      struct_info.coddep%type;
   l_numseq         NUMBER ; -- numéro de séquence identifiant l'extraction en cours
   l_Nbjours        NUMBER(5);

   x_errparms       EXCEPTION;

BEGIN
   -- initialisations
   l_sysdate := trunc(sysdate) ;
   l_oldcoddeppole := -1;   --  On ne prend pas 0 car il y a un dep à 0 et un pole à 0 !!!
   l_oldcoddep    := -1;
   SELECT sfe60.nextval INTO l_numseq FROM dual;

   IF c_fact%ISOPEN THEN
      close c_fact;
   END IF;

    open c_fact(p_filiale, to_number(p_codcfrais));

    LOOP
   	fetch c_fact INTO l_iscontrat, l_coddep, l_coddeppole, l_fdatsai ;
        -- dbms_output.put_line (l_coddep);
      	IF c_fact%notfound THEN
	   	EXIT;
      	END IF;
         -- Sauvegarde de la ligne dans la table temporaire
      IF (l_oldcoddeppole = -1) THEN
	   -- Cas de lancement de la boucle, on initialise oldcoddeppole et on ne fait rien
	   l_oldcoddeppole := l_coddeppole;
	   l_oldcoddep     := l_coddep;
      ELSIF (l_oldcoddeppole != l_coddeppole) THEN
	   -- On a changé de pole, on insere une ligne  ...
	   INSERT INTO tmpfe60
	     (numseq, coddep, coddeppole, count_pascont,
	     count00_30, count31_60, count61_90, count91_120, count120
	     )
	   VALUES (
	     l_numseq, l_oldcoddep, l_oldcoddeppole, l_count_pascont,
	      l_count00_30, l_count31_60, l_count61_90, l_count91_120, l_count120);

	   -- ... Et on remet à 0 les compteurs
	   l_count_pascont := 0;
	   l_count00_30    := 0;
	   l_count31_60    := 0;
	   l_count61_90    := 0;
	   l_count91_120    := 0;
	   l_count120       := 0;

	   -- Et on positionne oldcoddeppole à la nouvelle valeur !
	   l_oldcoddeppole := l_coddeppole;
	   l_oldcoddep     := l_coddep;
      END IF;

      -- Affectation en fonction de la présence d'un contrat
      IF (l_iscontrat = 'PAS DE CONTRAT') THEN
	  l_count_pascont := l_count_pascont + 1;
	  -- dbms_output.putline('PAS CONT');
      ELSIF (l_iscontrat = 'CONTRAT') THEN -- Un autre cas serait étonnant...

 	  -- Affectation en fonction de la date de saisie
        l_Nbjours:= l_sysdate - trunc(l_fdatsai);

	  IF ( (l_Nbjours >= 0) AND (l_Nbjours <= 30)) THEN
	    l_count00_30 := l_count00_30 + 1;
	  ELSIF ( (l_Nbjours >= 31 ) AND (l_Nbjours <= 60)) THEN
	    l_count31_60 := l_count31_60 + 1;
	  ELSIF ( (l_Nbjours >= 61 ) AND (l_Nbjours <= 90)) THEN
	    l_count61_90 := l_count61_90 + 1;
	  ELSIF ( (l_Nbjours >= 91 ) AND (l_Nbjours <= 120)) THEN
	    l_count91_120 := l_count91_120 + 1;
	  ELSIF (l_Nbjours >= 121 ) THEN
	    l_count120 := l_count120 + 1;
	  ELSE
	    NULL;
	  END IF;
      ELSE
	   -- Un autre cas des plus improbables
	   NULL;
      END IF;
    END LOOP;

   -- Si on a au moins traité une ligne
   IF (l_oldcoddeppole != -1) THEN
      -- On a changé de pole, on insere une ligne  ...
      INSERT INTO tmpfe60
	(numseq, coddep, coddeppole, count_pascont,
	count00_30, count31_60, count61_90, count91_120, count120
	)
	VALUES (
	l_numseq, l_oldcoddep, l_oldcoddeppole, l_count_pascont,
	l_count00_30, l_count31_60, l_count61_90, l_count91_120, l_count120);
   END IF;

   -- Fermeture du curseur et retour...
   close c_fact;

   commit;

   RETURN l_numseq;

EXCEPTION
   WHEN OTHERS THEN
     -- dbms_output.putline ('Une erreur !!!');
     rollback;
     RETURN 0;
END;
-- ====================================================================================
-- ***********************************************************************************
-- ====================================================================================
FUNCTION f_prologue_tous_fe60(p_filiale IN CHAR) RETURN NUMBER IS

   -- Variables pour le count
   l_count_pascont  NUMBER := 0;
   l_count00_30     NUMBER := 0;
   l_count31_60     NUMBER := 0;
   l_count61_90     NUMBER := 0;
   l_count91_120     NUMBER := 0;
   l_count120        NUMBER := 0;

   -- Variables de réception du curseur
   l_iscontrat      VARCHAR2(30);
   l_coddep         struct_info.coddep%type ;
   l_coddeppole     struct_info.coddeppole%type;
   l_fdatsai        DATE ;
   l_sysdate        DATE ;
   l_oldcoddeppole  struct_info.coddeppole%type;
   l_oldcoddep      struct_info.coddep%type;
   l_numseq         NUMBER ; -- numéro de séquence identifiant l'extraction en cours
   l_Nbjours        NUMBER(5);

   x_errparms       EXCEPTION;

BEGIN
   -- initialisations
   l_sysdate := trunc(sysdate) ;
   l_oldcoddeppole := -1;   --  On ne prend pas 0 car il y a un dep à 0 et un pole à 0 !!!
   l_oldcoddep    := -1;
   SELECT sfe60.nextval INTO l_numseq FROM dual;

   IF c_all%ISOPEN THEN
      close c_all;
   END IF;

    open c_all(p_filiale);

    LOOP
   	fetch c_all INTO l_iscontrat, l_coddep, l_coddeppole, l_fdatsai ;

      	IF c_all%notfound THEN
	   	EXIT;
      	END IF;
         -- Sauvegarde de la ligne dans la table temporaire
      IF (l_oldcoddeppole = -1) THEN
	   -- Cas de lancement de la boucle, on initialise oldcoddeppole et on ne fait rien
	   l_oldcoddeppole := l_coddeppole;
	   l_oldcoddep     := l_coddep;
      ELSIF (l_oldcoddeppole != l_coddeppole) THEN
	   -- On a changé de pole, on insere une ligne  ...
	   INSERT INTO tmpfe60
	     (numseq, coddep, coddeppole, count_pascont,
	     count00_30, count31_60, count61_90, count91_120, count120
	     )
	   VALUES (
	     l_numseq, l_oldcoddep, l_oldcoddeppole, l_count_pascont,
	    l_count00_30, l_count31_60, l_count61_90, l_count91_120, l_count120);

	   -- ... Et on remet à 0 les compteurs
	   l_count_pascont := 0;
	   l_count00_30    := 0;
	   l_count31_60    := 0;
	   l_count61_90    := 0;
	   l_count91_120    := 0;
	   l_count120       := 0;

	   -- Et on positionne oldcoddeppole à la nouvelle valeur !
	   l_oldcoddeppole := l_coddeppole;
	   l_oldcoddep     := l_coddep;
      END IF;

      -- Affectation en fonction de la présence d'un contrat
      IF (l_iscontrat = 'PAS DE CONTRAT') THEN
	  l_count_pascont := l_count_pascont + 1;
	  -- dbms_output.putline('PAS CONT');
      ELSIF (l_iscontrat = 'CONTRAT') THEN -- Un autre cas serait étonnant...

 	  -- Affectation en fonction de la date de saisie
        l_Nbjours:= l_sysdate - trunc(l_fdatsai);

	  IF ( (l_Nbjours >= 0) AND (l_Nbjours <= 30)) THEN
	    l_count00_30 := l_count00_30 + 1;
	  ELSIF ( (l_Nbjours >= 31 ) AND (l_Nbjours <= 60)) THEN
	    l_count31_60 := l_count31_60 + 1;
	  ELSIF ( (l_Nbjours >= 61 ) AND (l_Nbjours <= 90)) THEN
	    l_count61_90 := l_count61_90 + 1;
	  ELSIF ( (l_Nbjours >= 91 ) AND (l_Nbjours <= 120)) THEN
	    l_count91_120 := l_count91_120 + 1;
	  ELSIF (l_Nbjours >= 121 ) THEN
	    l_count120 := l_count120 + 1;
	  ELSE
	    NULL;
	  END IF;
      ELSE
	   -- Un autre cas des plus improbables
	   NULL;
      END IF;
    END LOOP;

   -- Si on a au moins traité une ligne
   IF (l_oldcoddeppole != -1) THEN
      -- On a changé de pole, on insere une ligne  ...
      INSERT INTO tmpfe60
	(numseq, coddep, coddeppole, count_pascont,
	count00_30, count31_60, count61_90, count91_120, count120
	)
	VALUES (
	l_numseq, l_oldcoddep, l_oldcoddeppole, l_count_pascont,
	 l_count00_30, l_count31_60, l_count61_90, l_count91_120, l_count120);
   END IF;

   -- Fermeture du curseur et retour...
   close c_all;

   commit;

   RETURN l_numseq;

EXCEPTION
   WHEN OTHERS THEN
     --dbms_output.put_line ('Une erreur !!!');
    rollback;
    RETURN 0;
END;


-- ------------------------------------------------------------------------
-- Nom        : f_epilogue_fe60

-- Auteur     : Equipe SOPRA
-- Decription : Efface les lignes de tmpfe60, correspondant à p_numseq
-- Paramètres : p_numseq    IN             numéro de séquence
-- Retour     : Si le prologue ne se passe pas bien, renvoie false, sinon
--              false
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
--
-- ------------------------------------------------------------------------
FUNCTION f_epilogue_fe60(p_numseq NUMBER) RETURN BOOLEAN IS
BEGIN

   DELETE tmpfe60 WHERE numseq = p_numseq;
   commit;
   RETURN true;
EXCEPTION
   WHEN OTHERS THEN
     -- Une erreur oracle
     RETURN false;
END;

-- ------------------------------------------------------------------------
-- Nom        : verif_FE61

-- Auteur     : Equipe SOPRA
-- Decription : Vérification des parametres du report FE61
-- Paramètres :  p_coddeppolegrp (IN)       Code société
--               p_anciennete
--               p_userid        (IN)       User de l'utilisateur
--               p_message       (OUT)      Message eventuel d'erreur
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
--
-- ------------------------------------------------------------------------

PROCEDURE verif_fe61 ( p_codcfrais     IN  VARCHAR2,
		       p_coddeppolegrp IN  VARCHAR2,
		       p_anciennete    IN  CHAR,
		       p_message       OUT VARCHAR2
		     ) IS
l_codsg varchar2(12);
l_centre_frais centre_frais.codcfrais%TYPE;
l_scentrefrais centre_frais.codcfrais%TYPE;
l_msg varchar2(1024) :='';
BEGIN
   -- Vérification de la validité du code :
   IF ((pack_utile.f_verif_dpg(p_coddeppolegrp) != true) AND (p_coddeppolegrp IS NOT NULL)) THEN
      -- Code Département/Pôle/Groupe invalide
      pack_global.recuperer_message(20430, '%s1',p_coddeppolegrp, 'P_param6',l_msg);
      	raise_application_error(-20430, l_msg);

   END IF;
     -- ===================================================================
     -- 22/12/2000 : Test si le DPG appartient bien au centre de frais
     -- ===================================================================
   IF  p_coddeppolegrp IS NOT NULL THEN
	BEGIN

  		select scentrefrais into l_scentrefrais
   		from struct_info
   		where  substr(to_char(codsg,'FM0000000'),1, length(rtrim(rtrim(LPAD(p_coddeppolegrp,7,'0'),'*')))) = rtrim(rtrim(LPAD(p_coddeppolegrp,7,'0'),'*'))
		and rownum<2;

	EXCEPTION
		WHEN NO_DATA_FOUND then
		--msg : Le DPG n'est rattaché à aucun centre de frais
			pack_global.recuperer_message(20339, NULL,NULL,'P_param6', l_msg);
          		raise_application_error(-20339, l_msg);
		WHEN OTHERS THEN
            		raise_application_error(-20997,SQLERRM);

	END ;
     l_centre_frais:=to_number(p_codcfrais);
     IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur

		IF (l_scentrefrais!=l_centre_frais) then
			--msg:Ce DPG n'appartient pas à ce centre de frais
			pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'P_param6', l_msg);
          		raise_application_error(-20334, l_msg);
		END IF;

      END IF;
   END IF;

END verif_fe61;



-- ------------------------------------------------------------------------
-- Nom        : verif_FE62
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des parametres du report FE62
-- Paramètres :  p_soccode (IN)       Code société
--               p_userid  (IN)       User de l'utilisateur
--               p_message (OUT)      Message eventuel d'erreur
--
-- ------------------------------------------------------------------------
--                           MODIFICATION
--
-- ------------------------------------------------------------------------

PROCEDURE verif_fe62 ( p_soccode IN  VARCHAR2,
		       p_userid  IN  VARCHAR2,
		       p_message OUT VARCHAR2
		     ) IS
BEGIN
   -- Vérification du code société :
   pack_utile.verif_soccode_msg(p_soccode,'P_param6',p_message);
END;

-- ------------------------------------------------------------------------
-- Nom        : verif_fe63
-- Auteur     :
-- Decription :  p_datdebut  (IN)       Date de début de la période de
--                                      règlement comptable
--               p_datfin    (IN)       Date de fin de la période de
--                                      règlement comptable
--               p_userid    (IN)       User de l'utilisateur
--               p_message   (OUT)      Message eventuel d'erreur
--

-- ------------------------------------------------------------------------
--                           MODIFICATION
--
-- ------------------------------------------------------------------------
PROCEDURE verif_fe63 ( p_datdebut IN  VARCHAR2,
		       p_datfin   IN  VARCHAR2,
		       p_userid   IN  VARCHAR2,
		       p_message  OUT VARCHAR2
		     ) IS
BEGIN

   -- Vérification de la cohérence des dates
   IF (to_date(p_datdebut,'DD/MM/YYYY')  > to_date(p_datfin,'DD/MM/YYYY')) THEN
      pack_global.recuperer_message(20284,NULL, NULL, 'P_param6', p_message);
   END IF ;

   -- Vérification des bornes pour les dates
   IF (to_number(substr(p_datdebut,7)) < 1985 OR to_number(substr(p_datdebut,7)) > 2099)  THEN
      pack_global.recuperer_message(1000,NULL, NULL, 'P_param6', p_message);
   END IF ;
   IF (to_number(substr(p_datfin,7)) < 1985 OR to_number(substr(p_datfin,7)) > 2099)  THEN
      pack_global.recuperer_message(1000,NULL, NULL, 'P_param7', p_message);
   END IF ;
END;

PROCEDURE verif_factab6(
			p_soccode IN  societe.soccode%TYPE, -- CHAR(4)
  			p_fregcompta1 IN VARCHAR2,          -- date
  			p_fregcompta2 IN VARCHAR2,          -- date
  			p_userid  IN  VARCHAR2,
  			P_message OUT VARCHAR2
		       ) is

   l_message   VARCHAR2(1024);
BEGIN
   l_message := '';

   IF (p_soccode IS NOT NULL) THEN
      pack_ctl_lstcontl.select_societe (p_soccode,'P_param6', l_message);
   END IF;

   -- Controle de la periode
   IF (l_message IS NULL) THEN
      pack_ctl_lstcontl.select_periode(p_fregcompta1 , p_fregcompta2 , 'P_param7','P_param8', l_message);
   END IF;

   p_message := l_message;
END verif_factab6;


PROCEDURE verif_lstfact(
			 p_soccode IN  societe.soccode%TYPE, -- char(4)
			 p_fenrcompta1 IN VARCHAR2,          -- date
 			 p_fenrcompta2 IN VARCHAR2,          -- date
			 p_lmoisprest1 IN VARCHAR2,          -- date
 			 p_lmoisprest2 IN VARCHAR2,          -- date
 			 p_fdeppole    IN VARCHAR2,          --  NUMBER(7)
 			 p_socnat      IN VARCHAR2,          --  char(1)
 			 p_comcode     IN VARCHAR2,          --  varchar(11)
 			 p_fmontht     IN VARCHAR2,          --  Sans utilité
 			 p_userid      IN VARCHAR2,
  			 P_message     OUT VARCHAR2
			) is

   l_message   VARCHAR2(1024);
BEGIN
   l_message := '';

   IF (p_soccode IS NOT NULL) THEN
      pack_ctl_lstcontl.select_societe (p_soccode,'P_param6', l_message);

   END IF;

   -- Controle de la periode
   IF (l_message IS NULL) THEN
      pack_ctl_lstcontl.select_periode(p_fenrcompta1, p_fenrcompta2, 'P_param7', l_message);
   END IF;

   IF (l_message IS NULL) THEN
      pack_ctl_lstcontl.select_periode(p_lmoisprest1 , p_lmoisprest2, 'P_param9', l_message);
   END IF;

   IF (l_message IS NULL) and (p_fdeppole IS NOT NULL ) THEN
      pack_ctl_lstcontl.select_dpg (p_userid,p_fdeppole, 'P_param11', l_message);
   END IF;

   IF (l_message IS NULL) and (p_comcode IS NOT NULL) THEN
      select_CodeComptable (p_comcode,'P_param13',l_message);
   END IF;


   p_message := l_message;
END verif_lstfact;

-- ------------------
PROCEDURE select_CodeComptable(
			       p_comcode IN VARCHAR2,
			       p_focus IN  VARCHAR2,
			       p_msg OUT VARCHAR2
			      ) IS

   l_msg   VARCHAR2(1024);
   l_comcode code_compt.comcode%TYPE;

BEGIN
   l_msg := '';
   BEGIN
      SELECT comcode INTO l_comcode
	FROM   code_compt
	WHERE  comcode = p_comcode;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
	-- Code comptable %s1 inexistant
	pack_global.recuperer_message(2023, '%s1' , p_comcode , p_focus, l_msg);
      WHEN OTHERS THEN
	raise_application_error(-20997,SQLERRM);
   END;

   p_msg := l_msg;
END select_CodeComptable;

function f_entetecol_fe65(
			  p_num NUMBER
			 ) RETURN VARCHAR2
                    IS
BEGIN
 	IF (p_num = 1) THEN
   		RETURN '1NB Factures    entregistrées';
 	END IF ;
 	IF (p_num = 2) THEN
   		RETURN '2NB Factures    réglées';
 	END IF ;
 	IF (p_num = 3) THEN
   		RETURN '3NB Factures    sans contrat';
 	END IF ;
 	IF (p_num = 4) THEN
   		RETURN '4Nb tot. fact.  en att./periode';
 	END IF ;
 	IF (p_num = 5) THEN
   		RETURN '5Nb tot. fact.  en attente';
 	END IF ;

END f_entetecol_fe65;

-- ---------------------------------------------
PROCEDURE verif_fe65(
                 p_datdeb  IN  VARCHAR2,         -- date
                 p_datfin  IN  VARCHAR2,         -- date
                 p_userid  IN  VARCHAR2,
                 P_message OUT VARCHAR2
                 ) is

      l_message   VARCHAR2(1024);
BEGIN
      pack_ctl_lstcontl.select_periode (p_datdeb, p_datfin, 'P_param6', TRUE, l_message);
      p_message := l_message;
END verif_fe65;

PROCEDURE verif_facqua6 (p_param6  IN VARCHAR2,
			 p_param7  IN VARCHAR2,
			 p_userid  IN VARCHAR2,
			 p_message OUT VARCHAR2
			 ) IS

   l_msg   VARCHAR2(1024);

BEGIN

   -- Initialiser le message retour
   p_message := '';

   IF (to_date(p_param6,'DD/MM/YYYY')  > to_date(p_param7,'DD/MM/YYYY')) THEN
      pack_global.recuperer_message(20284, NULL, NULL, NULL, l_msg);
      raise_application_error(-20284, l_msg);
   END IF;

   IF to_number(substr(p_param6, 7,4)) < 1985 THEN
      pack_global.recuperer_message(20291, NULL, NULL, NULL, l_msg);
      raise_application_error(-20291, l_msg);
   END IF;

END verif_facqua6;

END pack_rep_facture ;
/
CREATE OR REPLACE PACKAGE pack_rep_refpca4 IS

-- ------------------------------------------------------------------------
-- Nom        : f_trityp       retourne tritype
--              f_trityplib    retourne Libellé de tritype
-- Auteur     : Equipe SOPRA
-- Paramètres : p_typproj (IN) type de projet (ligne_bip.typproj)
--
-- ------------------------------------------------------------------------
-- Quand       Qui       Quoi
-- 6/12/1999   QHL       Creation
-- ------------------------------------------------------------------------
   FUNCTION f_trityp ( p_ptype   IN   NUMBER
                     ) RETURN VARCHAR2;
      PRAGMA RESTRICT_REFERENCES(f_trityp,WNDS,WNPS);


   FUNCTION f_trityplib ( p_ptype   IN   VARCHAR2
                     ) RETURN VARCHAR2;
      PRAGMA RESTRICT_REFERENCES(f_trityplib,WNDS,WNPS);


-- ------------------------------------------------------------------------
-- Nom        : f_annee_mois0
-- Appel      : Appelé par Before report
-- Auteur     : Equipe SOPRA
-- Decription : retourne l'année du mois précédant le mois système courant
-- Paramètres : pas de paramètre
-- Retour     : année (en char)
-- ------------------------------------------------------------------------
-- Quand       Qui       Quoi
-- 6/12/1999   QHL       Creation
-- ------------------------------------------------------------------------

   FUNCTION f_annee_mois0 RETURN VARCHAR2;
      PRAGMA RESTRICT_REFERENCES(f_annee_mois0,WNDS,WNPS);

END pack_rep_refpca4;
/

CREATE OR REPLACE PACKAGE BODY pack_rep_refpca4 IS

-- ===================================================
   FUNCTION f_trityp(p_ptype  IN  NUMBER
                    ) RETURN VARCHAR2  IS
   BEGIN
      IF p_ptype >= 1 AND p_ptype <= 4
                      THEN   RETURN 'PLAN'; END IF;
      IF p_ptype = 5  THEN   RETURN 'T5';   END IF;
      IF p_ptype = 6  THEN   RETURN 'T6';   END IF;
      IF p_ptype = 7  THEN   RETURN 'T7';   END IF;
      IF p_ptype = 8  THEN   RETURN 'T8';   END IF;
      RETURN 'TXXX';
   END f_trityp;

-- ===================================================
   FUNCTION f_trityplib(p_ptype  IN  VARCHAR2
                    ) RETURN VARCHAR2  IS
   BEGIN
      IF p_ptype >= 1 AND p_ptype <= 4
                      THEN   RETURN 'PLAN PLAN INFORMATIQUE   ';  END IF;
      IF p_ptype = 5  THEN   RETURN 'T5   STRUCTURE           ';  END IF;
      IF p_ptype = 6  THEN   RETURN 'T6   EXPLOITATION        ';  END IF;
      IF p_ptype = 7  THEN   RETURN 'T7   ABSENCES            ';  END IF;
      IF p_ptype = 8  THEN   RETURN 'T8   ACTIVITES TECHNIQUES';  END IF;
      RETURN                        'TXXX Type Projet INCONNU ';
   END f_trityplib;

-- ===================================================

   FUNCTION f_annee_mois0 RETURN VARCHAR2  IS
      l_annee  VARCHAR2(10);
   BEGIN
      -- ====================================================================
      -- Determiner l'annee de traitement N qui est l'annee du mois precedent
      -- ====================================================================
      select to_char(add_months(sysdate,-1),'YYYY') into l_annee from dual ;
      return l_annee;
   END f_annee_mois0;

END pack_rep_refpca4;
/
CREATE OR REPLACE PACKAGE pack_ressource_ecart AS


------------------------------------------------------------------------------
-- Types et Curseurs

------------------------------------------------------------------------------



-- Définition curseur du traitement

   TYPE traitement_ViewType IS RECORD ( numtrait            datdebex.NUMTRAIT%TYPE,
   					                    traitement	        VARCHAR2(200),
										nexttrait  			VARCHAR2(10)
   					                  );


   TYPE traitement_CurType IS REF CURSOR RETURN traitement_ViewType;







-- Définition curseur sur la table ressource_ecart

   TYPE ressource_ecart_ViewType IS RECORD ( codsg           struct_info.codsg%TYPE,
   					                         cdeb	         VARCHAR2(7),
   					                         ident	         ressource.ident%TYPE,
   					                         nom 	         ressource.rnom%TYPE,
   					                         fin_contrat     VARCHAR2(10),
   					                         debut_contrat   VARCHAR2(10),
					                         type 	         VARCHAR2(8),
											 nbjbip	         VARCHAR2(7),
   					                         nbjgersh 	     VARCHAR2(7),
   					                         nbjmois         VARCHAR2(7),
   					                         valider         CHAR(1),
											 commentaire     VARCHAR2(255)
										    );


   TYPE ressource_ecart_CurType IS REF CURSOR RETURN ressource_ecart_ViewType;



   -- Définition curseur des ecarts avec messages

   TYPE ecart_message_ViewType IS RECORD ( codsg           situ_ress_full.codsg%TYPE,
   					                       gnom	           struct_info.GNOM%TYPE,
   					                       libdsg    	   struct_info.LIBDSG%TYPE,
										   nombre 		   NUMBER
   					                     );


   TYPE ecart_message_CurType IS REF CURSOR RETURN ecart_message_ViewType;



   -- Définition curseur des lignes des ecarts

   TYPE ligne_ecart_ViewType IS RECORD ( nombre VARCHAR2(800)
                                       );


   TYPE ligne_ecart_CurType IS REF CURSOR RETURN ligne_ecart_ViewType;



   -- ----------------------------------------------------------------------------
   -- Nom        : select_traitement
   -- Auteur     : BAA
   -- Decription : renvoi les données du traitement
   --
   -- Paramètres : p_curseur(IN OUT) curseur qui contient les données du traitement
   --              p_nbcurseur  (OUT) nombre de lignes du curseur
   --			   p_message (OUT) message
   --
   -- -----------------------------------------------------------------------------


    PROCEDURE select_traitement (  p_curseur 	    IN OUT traitement_CurType,
                               	   p_nbcurseur   	OUT INTEGER
                               	 );



   -- ------------------------------------------------------------------------
   -- Nom        : select_ressource_ecart
   -- Auteur     : BAA
   -- Decription : renvoi la liste des écarts
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_valider  (IN) code du scenario
   --              p_globale  (IN) code de l'activite
   --			   p_curseur(IN OUT) curseur qui contient la liste des écarts
   --              p_nbcurseur  (OUT) nombre de lignes du curseur
   --			   p_message (OUT) message
   --
   -- ------------------------------------------------------------------------


    PROCEDURE select_ressource_ecart ( 	p_codsg 		IN VARCHAR2,
   					                    p_valider		IN VARCHAR2,
   					                    p_global		IN VARCHAR2,
                               		    p_curseur 	    IN OUT ressource_ecart_CurType,
                               		    p_nbcurseur   	OUT INTEGER,
                               		    p_message     	OUT VARCHAR2
   					                  );


   -- ------------------------------------------------------------------------
   -- Nom        : select_ecart_message
   -- Auteur     : BAA
   -- Decription : renvoi la liste des groupes et le nombre d'écarts
   --
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_globale  (IN) code de l'activite
   --			   p_curseur(IN OUT) curseur qui contient la liste des écarts
   --              p_nbcurseur  (OUT) nombre de lignes du curseur
   --			   p_message (OUT) message
   --
   -- ------------------------------------------------------------------------


    PROCEDURE select_ecart_message ( 	p_codsg 		IN VARCHAR2,
   					                    p_global		IN VARCHAR2,
                               		    p_curseur 	    IN OUT ecart_message_CurType,
                               		    p_nbcurseur   	OUT INTEGER,
                               		    p_message     	OUT VARCHAR2
   					                  );



   -- ------------------------------------------------------------------------
   -- Nom        : update_ressource_ecart
   -- Auteur     : BAA
   -- Decription : met à jour la table ressource_ecart
   --
   -- Paramètres : p_chaine (IN) Permet de modifier la table ressource_ecart
   -- 			   				 contient les clées pimaires et les noveaux champs
   --              p_nbcurseur  (OUT) nombre de lignes du curseur
   --			   p_message (OUT) message en cas d'erreur
   --
   -- ------------------------------------------------------------------------


    PROCEDURE update_ressource_ecart(	p_chaine	IN  VARCHAR2,
                                        p_nbcurseur OUT INTEGER,
                                        p_message   OUT VARCHAR2
					                 );




   -- ------------------------------------------------------------------------
   -- Nom        : recupere_message_ecart
   -- Auteur     : BAA
   -- Decription : renvoi le corps du message
   --
   -- Paramètres : p_codsg (IN) code du pole
   -- ------------------------------------------------------------------------


    PROCEDURE recupere_message_ecart( p_codsg	IN  VARCHAR2,
	                                  p_curseur 	IN OUT ligne_ecart_CurType
                               	    ) ;



END pack_ressource_ecart;
/

CREATE OR REPLACE PACKAGE BODY pack_ressource_ecart AS


--*************************************************************************************************
-- Procédure select_traitement
--
-- renvoi les données du traitement
--
-- ************************************************************************************************


  PROCEDURE select_traitement (  p_curseur 	    IN OUT traitement_CurType,
                               	 p_nbcurseur   	OUT INTEGER
                              ) IS



	l_moismens datdebex.moismens%TYPE;
	l_numtrait datdebex.numtrait%TYPE;


   BEGIN


	SELECT moismens, numtrait INTO l_moismens, l_numtrait FROM datdebex;


	IF(l_numtrait = 1) THEN


	   OPEN   p_curseur FOR
              	SELECT l_numtrait, ' à l''issue du 1er traitement', ' Deuxième traitement '||to_char(CPREMENS2,'day dd/MM/yyyy')
				FROM CALENDRIER
				WHERE CALANMOIS=l_moismens;




	ELSIF(l_numtrait = 2) THEN

	   OPEN   p_curseur FOR
              	SELECT l_numtrait, ' à l''issue du 2ème traitement', ' Dernier traitement  '||to_char(CMENSUELLE,'day dd/MM/yyyy')
				FROM CALENDRIER
				WHERE  CALANMOIS=l_moismens;



	ELSIF(l_numtrait = 3) THEN

	   OPEN   p_curseur FOR
              	SELECT l_numtrait, ' à l''issue du dernier traitement', ' merci de corriger ces écarts avant le prochain traitement BIP de ce mois '
				FROM CALENDRIER
				WHERE  CALANMOIS=l_moismens;


	END IF;






   END select_traitement;





--*************************************************************************************************
-- Procédure update_rees
--
-- renvoi la liste des écarts
--
-- ************************************************************************************************



  PROCEDURE select_ressource_ecart ( 	p_codsg 		IN VARCHAR2,
   					                    p_valider		IN VARCHAR2,
   					                    p_global		IN VARCHAR2,
                               		    p_curseur 	IN OUT ressource_ecart_CurType,
                               		    p_nbcurseur   		OUT INTEGER,
                               		    p_message     		OUT VARCHAR2
   					                ) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
	p_nbcurseur := 1;
    p_message := '';



	IF ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

    ELSE

	  --verification de l'habiltation du codsg même s'il contient des *
	  pack_habilitation.verif_habili_me(p_codsg, p_global,p_message);

	  IF ( p_message <> '' ) THEN
           	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	            raise_application_error(-20364,l_msg);


       ELSE

	   BEGIN
        	OPEN   p_curseur FOR
              	SELECT
				      sr.codsg,to_char(re.cdeb,'mm/yyyy'),
					  re.ident,r.rnom,to_char(sr.datsitu,'dd/mm/yyyy'),to_char(sr.datdep,'dd/mm/yyyy'),
					  DECODE(re.type,'TOTAL','JH',re.type),
					  TO_CHAR(re.nbjbip,'FM999999990D0'),
					  TO_CHAR(re.nbjgersh,'FM999999990D0'),
					  DECODE(re.type,'TOTAL',TO_CHAR(re.nbjmois,'FM999999990D0'),''),
					  re.valide,re.commentaire
                FROM ressource_ecart re, ressource r, SITU_RESS_full sr
				WHERE re.valide=p_valider
				AND r.ident=re.ident
				AND sr.ident=re.ident
				AND sr.datsitu=pack_situation_full.datsitu_ressource(re.ident,re.cdeb)
				AND sr.codsg>=to_number(replace(p_codsg,'*','0'))
				AND sr.codsg<=to_number(replace(p_codsg,'*','9'))
				ORDER BY sr.codsg,re.cdeb,r.rnom;

      		EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
            END;

       END IF;

     END IF;


     p_message := l_msg;


   END select_ressource_ecart;



--*************************************************************************************************
-- Procédure update_rees
--
-- renvoi la liste des groupes et le nombre d'écarts
--
-- ************************************************************************************************

 PROCEDURE select_ecart_message ( p_codsg 		IN VARCHAR2,
   					              p_global		IN VARCHAR2,
                               	  p_curseur 	IN OUT ecart_message_CurType,
                               	  p_nbcurseur   		OUT INTEGER,
                               	  p_message     		OUT VARCHAR2
   					            ) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
	p_nbcurseur := 1;
    p_message := '';



	IF ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               raise_application_error(-20203,l_msg);

    ELSE

	  --verification de l'habiltation du codsg même s'il contient des *
	  pack_habilitation.verif_habili_me(p_codsg, p_global,p_message);

	  IF ( p_message <> '' ) THEN
           	pack_global.recuperer_message(20364, '%s1', p_codsg, NULL, l_msg);
	            raise_application_error(-20364,l_msg);


       ELSE

	   BEGIN
        	OPEN   p_curseur FOR
              	SELECT
					  sr.codsg, si.gnom, si.libdsg, COUNT(*)
					  FROM ressource_ecart re, ressource r, SITU_RESS_full sr,struct_info si
					  WHERE re.valide='N'
					  AND r.ident=re.ident
					  AND sr.ident=re.ident
					  AND sr.datsitu=pack_situation_full.datsitu_ressource(re.ident,re.cdeb)
					  AND sr.codsg>=to_number(replace(p_codsg,'*','0'))
					  AND sr.codsg<=to_number(replace(p_codsg,'*','9'))
					  AND si.codsg=sr.codsg
					  GROUP BY sr.codsg, si.gnom, si.libdsg
					  ORDER BY sr.codsg;
			EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);
            END;

       END IF;

     END IF;


     p_message := l_msg;


   END select_ecart_message;




--*************************************************************************************************
-- Procédure update_rees
--
-- Permet de modifier la table ressource_ecart
--
-- ************************************************************************************************
PROCEDURE update_ressource_ecart(	p_chaine	IN  VARCHAR2,
                                    p_nbcurseur OUT INTEGER,
                                    p_message   OUT VARCHAR2
					            ) IS
	l_pos number(7);
	l_pos1 number(7);

	l_debug   VARCHAR2(1) := 'N';
	l_msg     VARCHAR2(1024);

	l_cdeb           RESSOURCE_ECART.CDEB%TYPE;
	l_ident          RESSOURCE.IDENT%TYPE;
	l_type           RESSOURCE_ECART.TYPE%TYPE;

	l_valide         RESSOURCE_ECART.VALIDE%TYPE;
	l_commentaire    RESSOURCE_ECART.COMMENTAIRE%TYPE;



BEGIN
	l_debug := 'N';

	p_message:='';

    -- p_chaine du type ':cdeb;ident;type;valide;commentaire:''


	l_pos := 2;
	l_pos1 := INSTR(p_chaine,';',1,1);
	l_cdeb := to_date(substr(p_chaine,l_pos,l_pos1-l_pos),'mm/yyyy');



	l_pos := INSTR(p_chaine,';',1,1)+1;
	l_pos1 := INSTR(p_chaine,';',1,2);
	l_ident := to_number(substr(p_chaine,l_pos,l_pos1-l_pos));


	l_pos := INSTR(p_chaine,';',1,2)+1;
	l_pos1 := INSTR(p_chaine,';',1,3);
	l_type := substr(p_chaine,l_pos,l_pos1-l_pos);


	l_pos := INSTR(p_chaine,';',1,3)+1;
	l_pos1 := INSTR(p_chaine,';',1,4);
	l_valide := substr(p_chaine,l_pos,l_pos1-l_pos);



	l_pos := INSTR(p_chaine,';',1,4)+1;
	l_pos1 := INSTR(p_chaine,':',1,2);
	l_commentaire := substr(p_chaine,l_pos,l_pos1-l_pos);




	dbms_output.put_line('cdeb:'||l_cdeb);
	dbms_output.put_line('ident:'||l_ident);
	dbms_output.put_line('type:'||l_type);

	dbms_output.put_line('valide:'||l_valide);
	dbms_output.put_line('commentaire:'||l_commentaire);



	UPDATE RESSOURCE_ECART
	SET valide=l_valide,
	    commentaire=l_commentaire
	WHERE cdeb=l_cdeb
	AND ident=l_ident
	AND type=DECODE(l_type,'JH','TOTAL',l_type);
	COMMIT;


	IF SQL%NOTFOUND THEN


	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );


      END IF;


END update_ressource_ecart;





--*************************************************************************************************
-- FUNCTION update_rees
--
-- renvoi le corps du message
--
-- ************************************************************************************************
PROCEDURE recupere_message_ecart( p_codsg	    IN  VARCHAR2,
	                              p_curseur 	IN OUT ligne_ecart_CurType
                               	)  IS


   BEGIN


   OPEN   p_curseur FOR
           SELECT
			        'Mois '||' - '||to_char(re.cdeb,'mm/yyyy')||' - '||r.rnom||' - '||DECODE(re.type,'TOTAL','Consommé BIP : '||TO_CHAR(nbjbip,'FM999999990D0')||' - Nb jours Mois : '||TO_CHAR(nbjmois,'FM999999990D0'),re.type||' BIP : '||TO_CHAR(nbjbip,'FM999999990D0')||' - Gershwin : '||TO_CHAR(nbjgersh,'FM999999990D0'))||' - '||commentaire
					FROM ressource_ecart re, ressource r, SITU_RESS_full sr
					WHERE re.valide='N'
					AND r.ident=re.ident
					AND sr.ident=re.ident
					AND sr.datsitu=pack_situation_full.datsitu_ressource(re.ident,re.cdeb)
					AND sr.codsg=to_number(p_codsg)
					ORDER BY re.cdeb;

			EXCEPTION
			WHEN OTHERS THEN
         		raise_application_error( -20997, SQLERRM);



END recupere_message_ecart;




END pack_ressource_ecart;
/
CREATE OR REPLACE PACKAGE Pack_Ressource_F AS

TYPE ressource_s_ViewType IS RECORD (ident      VARCHAR2(20),
                                     rnom       RESSOURCE.rnom%TYPE,
                                     coutot     VARCHAR2(20),
                                     flaglock   VARCHAR(20),
                                     datsitu    VARCHAR2(20),
                                     datdep     VARCHAR2(20),
                                     coufor       VARCHAR2(20),
                                     PRESTATION SITU_RESS.PRESTATION%TYPE,
                                     --filcode    situ_ress.filcode%TYPE,
                                     soccode    SITU_RESS.soccode%TYPE,
                                     codsg      VARCHAR2(20),
                                     typeForfait RESSOURCE.rtype%TYPE
                                    );

   TYPE ressource_f_sCurType IS REF CURSOR RETURN ressource_s_ViewType;
   TYPE ressourceCurType IS REF CURSOR RETURN RESSOURCE%ROWTYPE;

   PROCEDURE insert_ressource_f (p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
				 p_typeForfait IN RESSOURCE.rtype%TYPE,
				 p_codsg      IN  VARCHAR2,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_datsitu    IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_coutot	IN VARCHAR2,
                                 p_coufor     IN  VARCHAR2,
                                 p_montant_mens     IN  VARCHAR2,
                                 p_flaglock   IN  VARCHAR2,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2,
                                 p_ident    OUT VARCHAR2
                                );


   PROCEDURE update_ressource_f (p_ident     IN  VARCHAR2,
                                 p_datsitu   IN  VARCHAR2,
                                 p_rnom      IN  RESSOURCE.rnom%TYPE,
                                 p_coutot    IN  VARCHAR2,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

   PROCEDURE select_c_ressource_f (p_rnom          IN  RESSOURCE.rnom%TYPE,
				   p_typeForfait    IN  RESSOURCE.rtype%TYPE,
				   p_codsg	   IN  VARCHAR2,
                                   p_ident         IN  VARCHAR2,
                                   p_userid        IN  VARCHAR2,
                                   p_curressource  IN OUT ressourceCurType,
                                   p_date_courante    OUT VARCHAR2,
                                   p_coufor           OUT VARCHAR2,
                                   p_nbcurseur        OUT INTEGER,
                                   p_message          OUT VARCHAR2
                                  );

   PROCEDURE select_m_ressource_f (p_rnom         IN RESSOURCE.rnom%TYPE,
                                   p_prestation   IN SITU_RESS.PRESTATION%TYPE,
				   p_codsg	  IN VARCHAR2,
                                   p_ident        IN VARCHAR2,
                                   p_userid       IN VARCHAR2,
                                   p_curressource IN OUT ressource_f_sCurType,
                                   p_datsitu         OUT VARCHAR2,
                                   p_nbcurseur       OUT INTEGER,
                                   p_message         OUT VARCHAR2
                                  );

   PROCEDURE select_s_ressource_f (p_rnom         IN  RESSOURCE.rnom%TYPE,
				   p_codsg 	  IN  VARCHAR2,
                                   p_prestation   IN  SITU_RESS.PRESTATION%TYPE,
                                   p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
                                   p_curressource IN OUT ressource_f_sCurType,
                                   p_coufor          OUT VARCHAR2,
                                   p_flag            OUT VARCHAR2,
                                   p_nbcurseur       OUT INTEGER,
                                   p_message         OUT VARCHAR2
                                  );

END Pack_Ressource_F;
/

CREATE OR REPLACE PACKAGE BODY Pack_Ressource_F AS

    PROCEDURE insert_ressource_f (p_rnom       IN  RESSOURCE.rnom%TYPE,
                                  p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                  p_typeForfait IN RESSOURCE.rtype%TYPE,
				  p_codsg      IN  VARCHAR2,
                                  p_soccode    IN  SITU_RESS.soccode%TYPE,
                                  p_datsitu    IN  VARCHAR2,
                                  p_cpident    IN  VARCHAR2,
                                  p_coutot	IN VARCHAR2,
                                  p_coufor     IN  VARCHAR2,
                                  p_montant_mens     IN  VARCHAR2,
                                  p_flaglock   IN  VARCHAR2,
                                  p_userid     IN  VARCHAR2,
                                  p_nbcurseur  OUT INTEGER,
                                  p_message    OUT VARCHAR2,
                                  p_ident    OUT VARCHAR2
                                 ) IS

      	l_msg           VARCHAR2(1024);
      	l_ident         RESSOURCE.ident%TYPE;
      	l_rtype         RESSOURCE.rtype%TYPE;
      	ldatsitu        VARCHAR2(10);
      	l_dsocfer       VARCHAR2(20);
      	l_date_courante VARCHAR2(20);
      	l_menu          VARCHAR2(255);
      	l_topfer        STRUCT_INFO.topfer%TYPE;
      	l_habilitation  VARCHAR2(10);
	l_cpident       RESSOURCE.ident%TYPE;

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

     -- La regle de gestion 9.5.5 n'est pas suivie, gestion des utilisateur.
     -- Positionner le nb de curseurs ==> 0
     -- Initialiser le message retour
      p_nbcurseur := 0;

      -- Gestion de l'utilisateur pour cout (RES)

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      -- Contrôle de l'existence du chef de projet.
      BEGIN
        SELECT ident INTO l_cpident FROM RESSOURCE
        WHERE ident=TO_NUMBER(p_cpident);
        EXCEPTION WHEN NO_DATA_FOUND THEN
         Pack_Global.recuperer_message(20226, '%s1', p_cpident, 'CPIDENT', l_msg);
         RAISE_APPLICATION_ERROR(-20226, l_msg);
      END;

       -- Calcul de la nouvelle valeur de ident
      BEGIN
          SELECT MAX(ident)
          INTO l_ident
          FROM RESSOURCE;

      EXCEPTION

        WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;
      l_ident := l_ident +1;

      -- TEST : soccode existe et societe non fermee.
      IF l_menu != 'DIR' THEN
      BEGIN
           SELECT TO_CHAR(socfer,'yyyymmdd')
           INTO l_dsocfer
           FROM SOCIETE
           WHERE soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
              Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
              RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
             Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
     END IF;
     -- Test la validite de la valeur de p_codsg

     IF TO_NUMBER(p_codsg) <= 100000 THEN
          Pack_Global.recuperer_message(20223, '%s1', p_codsg, 'CODSG', l_msg);
          RAISE_APPLICATION_ERROR(-20223, l_msg);
     END IF;

      -- TEST : TOPFER de codsg si menutil = DIR
      IF l_menu != 'DIR' THEN

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;

      END IF;

      -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( p_codsg,p_userid);
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce DPG 20364
		Pack_Global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', l_msg);
                RAISE_APPLICATION_ERROR(-20364, l_msg);
	END IF;
      -- TEST pour savoir si le champ cpident existe

      IF p_cpident IS NOT NULL THEN
           BEGIN

                -- TEST sur l'existance de la ressource
                SELECT rtype
                INTO l_rtype
                FROM RESSOURCE
                WHERE ident = TO_NUMBER(p_cpident);

           EXCEPTION

               WHEN NO_DATA_FOUND THEN
                   Pack_Global.recuperer_message(20226, '%s1', p_cpident, 'CPIDENT', l_msg);
                   RAISE_APPLICATION_ERROR(-20226, l_msg);

               WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR( -20997, SQLERRM);
           END;

           -- TEST pour savoir si cette ressource est une personne
           IF (l_rtype != 'P') AND (l_rtype IS NOT NULL)THEN
               Pack_Global.recuperer_message(20218, NULL, NULL, 'CPIDENT', l_msg);
               RAISE_APPLICATION_ERROR(-20218, l_msg);
           END IF;
      END IF;


      -- la date d'arrivée d'une ressource doit être le 1er jour du mois qu'a saisi l'utilisateur
         ldatsitu := TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';


      -- INSERTION
      BEGIN
         INSERT INTO RESSOURCE (rnom,
                                coutot,
                                ident,
                                rtype,
                                rtel
                               )
                VALUES (p_rnom,
                        TO_NUMBER(p_coutot,'FM9999999999D00'),
                        l_ident,
                        p_typeForfait,
                        '000000'
                       );

      EXCEPTION

         WHEN DUP_VAL_ON_INDEX THEN

               -- msg : 'la ressource existe deja'
               Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
               RAISE_APPLICATION_ERROR( -20219, l_msg );

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      BEGIN

         INSERT INTO SITU_RESS (ident,
                                datsitu,
                                soccode,
                                codsg,
                                cout,
                                dispo,
                                PRESTATION,
                                rmcomp,
                                cpident,
                                datdep,
                                montant_mensuel
                               )
         VALUES (l_ident,
                 TO_DATE(ldatsitu,'yyyymmdd'),
                 p_soccode,
                 TO_NUMBER( p_codsg),
                 TO_NUMBER( p_coufor,'FM9999999999D00'),
                 TO_NUMBER('0,0'),
                 p_prestation,
                 0,
                 TO_NUMBER(p_cpident),
                 NULL,
				 DECODE(TO_NUMBER( p_montant_mens,'FM9999999990D00'),0,'')
                );

          --  'Forfait ' || p_rnom || ' cree avec l''identifiant || l_ident;
         Pack_Global.recuperer_message(2048, '%s1', p_rnom, '%s2',TO_CHAR(l_ident),
                                       NULL, l_msg);
         p_message := l_msg;
         p_ident := l_ident;

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN

             -- 'la ressource existe deja'
             Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
             RAISE_APPLICATION_ERROR( -20219, l_msg );

         WHEN referential_integrity THEN

            -- habiller le msg erreur
            Pack_Global.recuperation_integrite(-2291);

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

      END;

  END insert_ressource_f;


   PROCEDURE update_ressource_f (p_ident     IN  VARCHAR2,
                                 p_datsitu   IN  VARCHAR2,
                                 p_rnom      IN  RESSOURCE.rnom%TYPE,
                                 p_coutot    IN  VARCHAR2,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_hom RESSOURCE.rnom%TYPE;
      l_oldrnom RESSOURCE.rnom%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour
      p_nbcurseur := 0;
      p_message := '';

      -- TEST : interdiction homonyme

      BEGIN
         SELECT rnom
         INTO   l_hom
         FROM   RESSOURCE
         WHERE  rnom = p_rnom
           AND  rtype = 'F'
           AND  ROWNUM < 2;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
              NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      BEGIN
         SELECT rnom
         INTO   l_oldrnom
         FROM   RESSOURCE
         WHERE  ident = TO_NUMBER(p_ident);

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF (l_hom IS NOT NULL) AND (l_hom != l_oldrnom) THEN
        Pack_Global.recuperer_message(20236, NULL, NULL , 'RNOM', l_msg);
        RAISE_APPLICATION_ERROR( -20236, l_msg );
      END IF;

      BEGIN
          UPDATE RESSOURCE SET rnom      = p_rnom,
                            coutot       = TO_NUMBER(NVL(p_coutot,'0')),
                            flaglock     = DECODE( p_flaglock, 1000000, 0, p_flaglock + 1)
          WHERE ident  = TO_NUMBER(p_ident)
          AND flaglock = p_flaglock;

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
        Pack_Global.recuperer_message(20999, NULL,NULL , NULL, l_msg);
        RAISE_APPLICATION_ERROR( -20999, l_msg );
      ELSE

         -- Message : 'ressource || p_rnom || modifie';
         Pack_Global.recuperer_message(2043, '%s1',p_rnom , NULL, l_msg);
         p_message := l_msg;
      END IF;

   END update_ressource_f;





    PROCEDURE select_c_ressource_f (p_rnom          IN  RESSOURCE.rnom%TYPE,
                                   p_typeForfait    IN  RESSOURCE.rtype%TYPE,
				   p_codsg	   IN  VARCHAR2,
                                   p_ident         IN  VARCHAR2,
                                   p_userid        IN  VARCHAR2,
                                   p_curressource  IN  OUT ressourceCurType,
                                   p_date_courante     OUT VARCHAR2,
                                   p_coufor            OUT VARCHAR2,
                                   p_nbcurseur         OUT INTEGER,
                                   p_message           OUT VARCHAR2
                                  ) IS

       l_msg VARCHAR2(1024);
       l_rnom RESSOURCE.rnom%TYPE;
       l_coufor VARCHAR2(20);
       l_typeForfait  RESSOURCE.rtype%TYPE;
       l_codsg	SITU_RESS.codsg%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur := 1;
      p_message := '';

      -- TEST : interdiction des homonymes

      BEGIN
          SELECT rnom
          INTO   l_rnom
          FROM   RESSOURCE
          WHERE  rnom = p_rnom
           AND  ( rtype = 'F' OR rtype='E')
           AND   ROWNUM < 2;

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
               NULL;

           WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF (l_rnom IS NOT NULL) THEN
         Pack_Global.recuperer_message(20236, '%s1',p_rnom , NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20236, l_msg);
      END IF;

    -- ====================================================================
      -- 10/09/2001 ARE: Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
   	Pack_Habilitation.verif_habili_me(p_codsg,p_userid,l_msg);





      -- Renvoie la date courante
      SELECT TO_CHAR(SYSDATE,'mm/yyyy')
      INTO p_date_courante
      FROM DUAL;


	BEGIN
		SELECT
			codsg INTO l_codsg
		FROM
			SITU_RESS
		WHERE
			ident=p_ident
			AND datsitu=Pack_Verif_Restab.f_datsitu_recente(p_ident);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN l_codsg := NULL;
	END;

	IF l_codsg IS NULL AND p_codsg IS NOT NULL THEN l_codsg := TO_NUMBER(p_codsg);END IF;



           l_coufor := '0,00';


      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom
      BEGIN
        OPEN p_curressource FOR
             SELECT *
             FROM RESSOURCE
             WHERE rnom = p_rnom;

      EXCEPTION

        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- en cas absence
      -- 'Le forfait existe deja';
      Pack_Global.recuperer_message(2044, NULL, NULL, NULL, l_msg);
      p_message := l_msg;

   END select_c_ressource_f;




   PROCEDURE select_m_ressource_f (p_rnom         IN  RESSOURCE.rnom%TYPE,
                                   p_prestation   IN  SITU_RESS.PRESTATION%TYPE,
				   p_codsg	  IN  VARCHAR2,
                                   p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
                                   p_curressource IN  OUT ressource_f_sCurType,
                                   p_datsitu          OUT VARCHAR2,
                                   p_nbcurseur        OUT INTEGER,
                                   p_message          OUT VARCHAR2
                                  ) IS

      l_msg      VARCHAR2(1024);
      l_rtype    RESSOURCE.rtype%TYPE;
      l_codsg    SITU_RESS.codsg%TYPE;
      l_idarpege VARCHAR2(255);
      l_habilitation  VARCHAR2(10);
	  l_soccode SOCIETE.SOCCODE%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur := 1;
      p_message := '';

      -- Gestion du niveau d'acces de l'utilisateur.
      BEGIN
         SELECT codsg, soccode
         INTO l_codsg, l_soccode
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident)
         AND datsitu IN (SELECT MAX(datsitu)
                         FROM SITU_RESS
                         WHERE ident = TO_NUMBER(p_ident)
                        );



      EXCEPTION

          WHEN NO_DATA_FOUND THEN
                 Pack_Global.recuperer_message(20512, '%s1', 'Forfait', '%s2', '',NULL, l_msg);
		         RAISE_APPLICATION_ERROR( -20512,l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

	   IF  l_codsg IS NOT NULL THEN
      -- ====================================================================
      -- 23/11/2005 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
     	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier cette ressource, son DPG est '||l_codsg, 'IDENT', l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;
      END IF;


      -- On recherche du type de ressource associe a l'identifiant
      BEGIN
        SELECT rtype
        INTO l_rtype
        FROM RESSOURCE
        WHERE ident = TO_NUMBER(p_ident);


	  IF(l_rtype = 'P' )THEN
		     SELECT DECODE(l_soccode,'SG..','A',l_rtype) INTO l_rtype FROM DUAL;
		END IF;

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
                 Pack_Global.recuperer_message(20512, '%s1', 'Forfait', '%s2', '',NULL, l_msg);
		         RAISE_APPLICATION_ERROR( -20512,l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF (l_rtype != 'F' AND l_rtype !='E') THEN
            Pack_Global.recuperer_message(20233, '%s1', p_ident,
                                                 '%s2', l_rtype, 'IDENT', l_msg);
            RAISE_APPLICATION_ERROR(-20233, l_msg);
      END IF;

      -- On recherche la date d'arrivee de la ressource
      BEGIN
         SELECT TO_CHAR(MIN(datsitu),'dd/mm/yyyy')
         INTO p_datsitu
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
                Pack_Global.recuperer_message(20512, '%s1', 'Forfait', '%s2', '',NULL, l_msg);
		         RAISE_APPLICATION_ERROR( -20512,l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom
      BEGIN
        OPEN p_curressource FOR
             SELECT RESSOURCE.ident,
                    RESSOURCE.rnom,
                    TO_CHAR(RESSOURCE.coutot,'FM9999999990D00'),
                    RESSOURCE.flaglock,
                    TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                    TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                    TO_CHAR(SITU_RESS.cout,'FM9999999990D00'),
                    SITU_RESS.PRESTATION,
                    --situ_ress.filcode,
                    SITU_RESS.soccode,
                    SITU_RESS.codsg,
                    RESSOURCE.rtype
             FROM RESSOURCE,SITU_RESS
             WHERE RESSOURCE.ident = TO_NUMBER(p_ident)
             AND   SITU_RESS.ident = TO_NUMBER(p_ident);

      EXCEPTION

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'Le forfait n''existe pas';
      Pack_Global.recuperer_message(2045, '%s1', p_ident, NULL, l_msg);
      p_message := l_msg;

   END select_m_ressource_f;


   PROCEDURE select_s_ressource_f (p_rnom         IN  RESSOURCE.rnom%TYPE,
				   p_codsg 	  IN  VARCHAR2,
                                   p_prestation   IN  SITU_RESS.PRESTATION%TYPE,
                                   p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
                                   p_curressource IN  OUT ressource_f_sCurType,
                                   p_coufor           OUT VARCHAR2,
                                   p_flag             OUT VARCHAR2,
                                   p_nbcurseur        OUT INTEGER,
                                   p_message          OUT VARCHAR2
                                  ) IS

      l_msg VARCHAR2(1024);
      l_rtype RESSOURCE.rtype%TYPE;
      l_prestation SITU_RESS.PRESTATION%TYPE;
      l_codsg	SITU_RESS.codsg%TYPE;
     l_habilitation VARCHAR2(10);
	 l_soccode SOCIETE.soccode%TYPE;


   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour
      p_nbcurseur := 1;
      p_message := '';

      BEGIN
         SELECT TO_CHAR(flaglock)
         INTO p_flag
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
             NULL;

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      --
      BEGIN

         SELECT PRESTATION,cout,soccode
         INTO   l_prestation,p_coufor,l_soccode
         FROM   SITU_RESS
         WHERE  ident = TO_NUMBER(p_ident)
         AND    TO_CHAR(datsitu,'dd/mm/yyyy') IN (SELECT TO_CHAR(MAX(datsitu),'dd/mm/yyyy')
                                                  FROM SITU_RESS
                                                  WHERE ident = TO_NUMBER(p_ident)
                                                 );



      EXCEPTION

         WHEN NO_DATA_FOUND THEN
                 Pack_Global.recuperer_message(20512, '%s1', 'Forfait', '%s2', '',NULL, l_msg);
		         RAISE_APPLICATION_ERROR( -20512,l_msg);

         WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR( -20997, SQLERRM );
      END;

	BEGIN
		SELECT  codsg INTO  l_codsg
		FROM 	SITU_RESS
		WHERE	ident=p_ident
			AND  datsitu=Pack_Verif_Restab.f_datsitu_recente(p_ident);
	EXCEPTION
		WHEN  NO_DATA_FOUND THEN  l_codsg := NULL ;
	END ;


	/*  IF  l_codsg IS NOT NULL THEN
      -- ====================================================================
      -- 23/11/2005 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
     	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'consulter cette ressource, son DPG est '||l_codsg, 'IDENT', l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;
      END IF;*/

      -- TEST : Le type de la ressource est bien Forfait
      BEGIN
         SELECT rtype
         INTO l_rtype
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);


		 IF(l_rtype = 'P' )THEN
		     SELECT DECODE(l_soccode,'SG..','A',l_rtype) INTO l_rtype FROM DUAL;
		END IF;

      EXCEPTION
          WHEN NO_DATA_FOUND THEN
             NULL;

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF (l_rtype != 'F' AND l_rtype != 'E') THEN
            Pack_Global.recuperer_message(20233, '%s1', p_ident,
                                                 '%s2', l_rtype, 'IDENT', l_msg);
          RAISE_APPLICATION_ERROR( -20233, l_msg);
      END IF;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom
      BEGIN
        OPEN p_curressource FOR
             SELECT RESSOURCE.ident,
                    RESSOURCE.rnom,
                    TO_CHAR(RESSOURCE.coutot,'FM9999999990D00'),
                    RESSOURCE.flaglock,
                    TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                    TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                    TO_CHAR(SITU_RESS.cout,'FM9999999990D00'),
                    SITU_RESS.PRESTATION,
                    --situ_ress.filcode,
                    SITU_RESS.soccode,
                    SITU_RESS.codsg,
                    RESSOURCE.rtype
             FROM RESSOURCE,SITU_RESS
             WHERE RESSOURCE.ident = TO_NUMBER(p_ident)
             AND   SITU_RESS.ident = TO_NUMBER(p_ident);

      EXCEPTION

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'Le forfait n''existe pas';
      Pack_Global.recuperer_message(2045, '%s1', p_ident, NULL, l_msg);
      p_message := l_msg;

   END select_s_ressource_f;

END Pack_Ressource_F;
/
CREATE OR REPLACE PACKAGE Pack_Ressource_L AS

TYPE ressource_s_ViewType IS RECORD (ident      RESSOURCE.ident%TYPE,
                                     rnom       RESSOURCE.rnom%TYPE,
                                     coutot     VARCHAR2(13),
                                     flaglock   RESSOURCE.flaglock%TYPE,
                                     datsitu    VARCHAR2(10),
                                     datdep     VARCHAR2(10),
                                     PRESTATION SITU_RESS.PRESTATION%TYPE,
                                     --filcode    situ_ress.filcode%TYPE,
                                     soccode    SITU_RESS.soccode%TYPE,
                                     codsg      SITU_RESS.codsg%TYPE
                                    );

   TYPE ressource_l_sCurType IS REF CURSOR RETURN ressource_s_ViewType;
   TYPE ressourceCurType IS REF CURSOR RETURN RESSOURCE%ROWTYPE;

   PROCEDURE insert_ressource_l (p_rnom      IN  RESSOURCE.rnom%TYPE,
				 p_codsg     IN  VARCHAR2,
                                 p_soccode   IN  SITU_RESS.soccode%TYPE,
                                 --p_filcode   IN  situ_ress.filcode%TYPE,
                                 p_datsitu   IN  VARCHAR2,
                                 p_cpident   IN  VARCHAR2,
                                 p_coutot    IN  VARCHAR2,
                                 p_flaglock  IN  VARCHAR2,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2,
                                 p_ident   OUT VARCHAR2
                                );


   PROCEDURE update_ressource_l (p_ident     IN  VARCHAR2,
                                 p_datsitu   IN  VARCHAR2,
                                 p_rnom      IN  RESSOURCE.rnom%TYPE,
                                 p_coutot    IN  VARCHAR2,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

   PROCEDURE select_c_ressource_l (p_rnom          IN RESSOURCE.rnom%TYPE,
				   p_codsg 	   IN VARCHAR2,
                                   p_ident         IN VARCHAR2,
                                   p_userid        IN VARCHAR2,
                                   p_curressource  IN OUT ressourceCurType,
                                   p_date_courante    OUT VARCHAR2,
                                   p_coulog           OUT VARCHAR2,
                                   p_nbcurseur        OUT INTEGER,
                                   p_message          OUT VARCHAR2
                                  );

   PROCEDURE select_m_ressource_l (p_rnom         IN RESSOURCE.rnom%TYPE,
				   p_codsg	  IN VARCHAR2,
                                   p_ident        IN VARCHAR2,
                                   p_userid       IN VARCHAR2,
                                   p_curressource IN OUT ressource_l_sCurType,
                                   p_datsitu         OUT VARCHAR2,
                                   p_nbcurseur       OUT INTEGER,
                                   p_message         OUT VARCHAR2
                                  );

   PROCEDURE select_s_ressource_l (p_rnom         IN RESSOURCE.rnom%TYPE,
				   p_codsg	  IN VARCHAR2,
                                   p_ident        IN VARCHAR2,
                                   p_userid       IN VARCHAR2,
                                   p_curressource IN OUT ressource_l_sCurType,
                                   p_coulog          OUT VARCHAR2,
                                   p_flag            OUT VARCHAR2,
                                   p_nbcurseur       OUT INTEGER,
                                   p_message         OUT VARCHAR2
                                  );

END Pack_Ressource_L;
/

CREATE OR REPLACE PACKAGE BODY Pack_Ressource_L AS

-- exec pack_ressource_l.insert_ressource_l('TUTU','IBM2','01','111111','10/05/1999','51110,00','1','100,00','51110','S935705;DIRMENU;T;2222;T',:nb,:msg);

    PROCEDURE insert_ressource_l (p_rnom      IN  RESSOURCE.rnom%TYPE,
				  p_codsg     IN  VARCHAR2,
                                  p_soccode   IN  SITU_RESS.soccode%TYPE,
                                  --p_filcode   IN  situ_ress.filcode%TYPE,
                                  p_datsitu   IN  VARCHAR2,
                                  p_cpident   IN  VARCHAR2,
                                  p_coutot    IN  VARCHAR2,
                                  p_flaglock  IN  VARCHAR2,
                                  p_userid    IN  VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2,
                                  p_ident   OUT VARCHAR2
                                 ) IS

      l_msg           VARCHAR2(1024);
      l_ident         RESSOURCE.ident%TYPE;
      l_rtype         RESSOURCE.rtype%TYPE;
      ldatsitu        VARCHAR2(10);
      l_dsocfer       VARCHAR2(20);
      l_date_courante VARCHAR2(20);
      l_menu          VARCHAR2(255);
      l_topfer        STRUCT_INFO.topfer%TYPE;
      l_habilitation  VARCHAR2(10);
      l_cpident       RESSOURCE.ident%TYPE;

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

     -- La regle de gestion 9.5.5 n'est pas suivie, gestion des utilisateur.
     -- Positionner le nb de curseurs ==> 0
     -- Initialiser le message retour

      p_nbcurseur := 0;
      -- p_message := '';

      -- Gestion de l'utilisateur

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      -- Test de l'existance du champ cpident

      BEGIN

        SELECT ident INTO l_cpident FROM RESSOURCE
        WHERE ident=TO_NUMBER(p_cpident);
        EXCEPTION WHEN NO_DATA_FOUND THEN
         Pack_Global.recuperer_message(20226, '%s1', p_cpident, 'CPIDENT', l_msg);
         RAISE_APPLICATION_ERROR(-20226, l_msg);

      END;

       -- Calcul de la nouvelle valeur de ident

      BEGIN
          SELECT MAX(ident)
          INTO   l_ident
          FROM   RESSOURCE;

-- Clause Where en plus pour les tests a voir plus tard.

      EXCEPTION

        WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;
      l_ident := l_ident +1;

     -- Test la validite de la valeur de p_codsg

     IF TO_NUMBER(p_codsg) <= 100000 THEN
              Pack_Global.recuperer_message(20223, '%s1', p_codsg, 'CODSG', l_msg);
            RAISE_APPLICATION_ERROR(-20223, l_msg);
     END IF;

      -- TEST : TOPFER de codsg si menutil = DIR

      IF l_menu != 'DIR' THEN

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;

      -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( p_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce DPG 20364
		Pack_Global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', l_msg);
                RAISE_APPLICATION_ERROR(-20364, l_msg);
	END IF;

      -- TEST : soccode existe et societe non fermee.

      BEGIN
           SELECT TO_CHAR(socfer,'yyyymmdd')
           INTO   l_dsocfer
           FROM   SOCIETE
           WHERE  soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
              Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
              RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO   l_date_courante
      FROM   DUAL;

      IF l_dsocfer <= l_date_courante THEN
             Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
     END IF;

      IF p_cpident IS NOT NULL THEN
           BEGIN

                -- TEST sur l'existance de la ressource

                SELECT rtype
                INTO   l_rtype
                FROM   RESSOURCE
                WHERE  ident = TO_NUMBER(p_cpident);

           EXCEPTION

               WHEN NO_DATA_FOUND THEN
                   Pack_Global.recuperer_message(20226, '%s1', p_cpident, 'CPIDENT', l_msg);
                   RAISE_APPLICATION_ERROR(-20226, l_msg);

               WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR( -20997, SQLERRM);
           END;

           -- TEST pour savoir si cette ressource est une personne

           IF (l_rtype != 'P') AND (l_rtype IS NOT NULL) THEN
               Pack_Global.recuperer_message(20218, NULL, NULL, 'CPIDENT', l_msg);
               RAISE_APPLICATION_ERROR(-20218, l_msg);
           END IF;
      END IF;



 -- la date d'arrivée d'une ressource doit être le 1er jour du mois qu'a saisi l'utilisateur
         ldatsitu := TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';



      -- INSERTION

      BEGIN
         INSERT INTO RESSOURCE (rnom,
                                coutot,
                                ident,
                                rtype,
                                rtel
                               )
                VALUES (p_rnom,
                        TO_NUMBER(p_coutot,'FM9999999999D00'),
                        l_ident,
                        'L',
                        '000000'
                       );

      EXCEPTION

         WHEN DUP_VAL_ON_INDEX THEN

               -- msg : 'la ressource existe deja'

               Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
               RAISE_APPLICATION_ERROR( -20219, l_msg );

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      BEGIN

         INSERT INTO SITU_RESS (ident,
                                datsitu,
                                soccode,
                                codsg,
                                --filcode,
                                dispo,
                                PRESTATION,
                                rmcomp,
                                cpident,
                                datdep
                               )
         VALUES (l_ident,
                 TO_DATE(ldatsitu,'yyyymmdd'),
                 p_soccode,
                 TO_NUMBER(p_codsg),
                 --p_filcode,
                 TO_NUMBER('0,0'),
                 'LG',
                 0,
                 TO_NUMBER(p_cpident),
                 NULL
                );

          -- p_message := 'Creation du logiciel ' ||
          -- p_rnom || ' et enregistrés.';

         Pack_Global.recuperer_message(2038, '%s1', p_rnom, '%s2',TO_CHAR(l_ident), NULL, l_msg);
         p_message := l_msg;

         p_ident := l_ident;

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN

             -- 'la ressource existe deja'

             Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
             RAISE_APPLICATION_ERROR( -20219, l_msg );

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            Pack_Global.recuperation_integrite(-2291);

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

      END;

  END insert_ressource_l;


   PROCEDURE update_ressource_l (p_ident     IN  VARCHAR2,
                                 p_datsitu   IN  VARCHAR2,
                                 p_rnom      IN  RESSOURCE.rnom%TYPE,
                                 p_coutot    IN  VARCHAR2,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS

      l_msg     VARCHAR2(1024);
      l_hom     RESSOURCE.rnom%TYPE;
      l_oldrnom RESSOURCE.rnom%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- TEST : interdiction homonyme

      BEGIN
         SELECT rnom
         INTO   l_hom
         FROM   RESSOURCE
         WHERE  rnom = p_rnom
         AND    rtype = 'L'
         AND    ROWNUM < 2;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
              NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      BEGIN
         SELECT rnom
         INTO   l_oldrnom
         FROM   RESSOURCE
         WHERE  ident = TO_NUMBER(p_ident);

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF (l_hom IS NOT NULL) AND (l_hom != l_oldrnom) THEN
        Pack_Global.recuperer_message(20236, NULL, NULL , 'RNOM', l_msg);
        RAISE_APPLICATION_ERROR( -20236, l_msg );
      END IF;

      -- UPDATE

      BEGIN
          UPDATE RESSOURCE SET rnom     = p_rnom,
                               coutot   = TO_NUMBER(NVL(p_coutot,'0')),
                               flaglock = DECODE( p_flaglock, 1000000, 0, p_flaglock + 1)
          WHERE ident  = TO_NUMBER(p_ident)
          AND flaglock = p_flaglock;

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL,NULL , NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      ELSE

         -- Message : 'situation || p_rnom || modifie';

         Pack_Global.recuperer_message(2039, '%s1',p_rnom , NULL, l_msg);
         p_message := l_msg;
      END IF;

   END update_ressource_l;


   PROCEDURE select_c_ressource_l (p_rnom          IN  RESSOURCE.rnom%TYPE,
				   p_codsg	   IN  VARCHAR2,
                                   p_ident         IN  VARCHAR2,
                                   p_userid        IN  VARCHAR2,
                                   p_curressource  IN  OUT ressourceCurType,
                                   p_date_courante     OUT VARCHAR2,
                                   p_coulog            OUT VARCHAR2,
                                   p_nbcurseur         OUT INTEGER,
                                   p_message           OUT VARCHAR2
                                  ) IS

       	l_msg VARCHAR2(1024);
       	l_rnom RESSOURCE.rnom%TYPE;
       	l_coulog VARCHAR2(20);
	l_codsg SITU_RESS.codsg%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- TEST : interdiction des homonymes

      BEGIN
          SELECT rnom
          INTO   l_rnom
          FROM   RESSOURCE
          WHERE  rnom = p_rnom
          AND    rtype = 'L'
          AND    ROWNUM < 2;

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
               NULL;

           WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF (l_rnom IS NOT NULL) THEN
         Pack_Global.recuperer_message(20236, '%s1',p_rnom , NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20236, l_msg);
      END IF;


 -- ====================================================================
      -- 10/09/2001 ARE: Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
   	Pack_Habilitation.verif_habili_me(  p_codsg,p_userid,l_msg  );

      -- Renvoie la date courante

      BEGIN
         SELECT TO_CHAR(SYSDATE,'mm/yyyy')
         INTO p_date_courante
         FROM DUAL;

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- cout d'un logiciel de l'annee courante lu ds table des cout.

	BEGIN
		SELECT
			codsg INTO l_codsg
		FROM
			SITU_RESS
		WHERE
			ident=p_ident
			AND datsitu=Pack_Verif_Restab.f_datsitu_recente(p_ident);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_codsg := NULL;
	END;
IF l_codsg IS NULL AND p_codsg IS NOT NULL THEN l_codsg := TO_NUMBER(p_codsg);END IF;



      BEGIN
         SELECT  TO_CHAR(cout_log)
         INTO p_coulog
       	 FROM   COUT_STD2 , DATDEBEX
         WHERE  annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
			AND dpg_bas = ( SELECT dpg_bas FROM COUT_STD2,DATDEBEX WHERE dpg_bas <= l_codsg
						AND l_codsg <= dpg_haut
						AND annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
						AND ROWNUM = 1 );

      EXCEPTION

         WHEN NO_DATA_FOUND THEN

            p_coulog := '0,00';

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom

      BEGIN
        OPEN p_curressource FOR
             SELECT *
             FROM RESSOURCE
             WHERE rnom = p_rnom;

      EXCEPTION

        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'Le logiciel existe deja';

      Pack_Global.recuperer_message(2036, '%s1', p_rnom, NULL, l_msg);
      p_message := l_msg;

   END select_c_ressource_l;


   PROCEDURE select_m_ressource_l (p_rnom         IN  RESSOURCE.rnom%TYPE,
				   p_codsg        IN  VARCHAR2,
                                   p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
                                   p_curressource IN  OUT ressource_l_sCurType,
                                   p_datsitu          OUT VARCHAR2,
                                   p_nbcurseur        OUT INTEGER,
                                   p_message          OUT VARCHAR2
                                  ) IS

      l_msg      VARCHAR2(1024);
      l_rtype    RESSOURCE.rtype%TYPE;
      l_codsg    SITU_RESS.codsg%TYPE;
      l_idarpege VARCHAR2(255);
      l_habilitation  VARCHAR2(10);
	  l_soccode SOCIETE.soccode%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Gestion du niveau d'acces de l'utilisateur.

      BEGIN
         SELECT codsg,soccode
         INTO l_codsg,l_soccode
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident)
         AND datsitu IN (SELECT MAX(datsitu)
                         FROM SITU_RESS
                         WHERE ident = TO_NUMBER(p_ident)
                        );

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
			      Pack_Global.recuperer_message(20512, '%s1', 'Logiciel', '%s2', '',NULL, l_msg);
				   RAISE_APPLICATION_ERROR( -20512,l_msg);


          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier cette ressource, son DPG est '||l_codsg, 'IDENT', l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;

      -- On recherche du type de ressource associe a l'identifiant

      BEGIN
        SELECT rtype
        INTO l_rtype
        FROM RESSOURCE
        WHERE ident = TO_NUMBER(p_ident);

		IF(l_rtype = 'P' )THEN
		     SELECT DECODE(l_soccode,'SG..','A',l_rtype) INTO l_rtype FROM DUAL;
		END IF;

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
                 Pack_Global.recuperer_message(20512, '%s1', 'Logiciel', '%s2', '',NULL, l_msg);
				 RAISE_APPLICATION_ERROR( -20512,l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_rtype != 'L' THEN
            Pack_Global.recuperer_message(20237, '%s1', p_ident, '%s2', l_rtype, 'IDENT', l_msg);
            RAISE_APPLICATION_ERROR( -20237, l_msg);
      END IF;

      -- On recherche la date d'arrivee de la ressource

      BEGIN
         SELECT  TO_CHAR(MIN(datsitu),'dd/mm/yyyy')
         INTO p_datsitu
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
                 Pack_Global.recuperer_message(20512, '%s1', 'Logiciel', '%s2', '',NULL, l_msg);
				 RAISE_APPLICATION_ERROR( -20512,l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom

      BEGIN
        OPEN p_curressource FOR
             SELECT RESSOURCE.ident,
                    RESSOURCE.rnom,
                    TO_CHAR(RESSOURCE.coutot,'FM9999999990D00'),
                    RESSOURCE.flaglock,
                    TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                    TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                    SITU_RESS.PRESTATION,
                    --situ_ress.filcode,
                    SITU_RESS.soccode,
                    SITU_RESS.codsg
             FROM RESSOURCE,SITU_RESS
             WHERE RESSOURCE.ident = TO_NUMBER(p_ident)
             AND   SITU_RESS.ident = TO_NUMBER(p_ident);

      EXCEPTION

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'Le logiciel n''existe pas';

      Pack_Global.recuperer_message(2036, '%s1', p_ident, NULL, l_msg);
      p_message := l_msg;

   END select_m_ressource_l;


   PROCEDURE select_s_ressource_l (p_rnom         IN  RESSOURCE.rnom%TYPE,
				   p_codsg  	  IN  VARCHAR2,
                                   p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
                                   p_curressource IN  OUT ressource_l_sCurType,
                                   p_coulog           OUT VARCHAR2,
                                   p_flag             OUT VARCHAR2,
                                   p_nbcurseur        OUT INTEGER,
                                   p_message          OUT VARCHAR2
                                  ) IS

      l_msg VARCHAR2(1024);
      l_rtype RESSOURCE.rtype%TYPE;
      l_codsg SITU_RESS.codsg%TYPE;
	  l_habilitation VARCHAR2(10);
      l_soccode SOCIETE.soccode%TYPE;


   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';


	  BEGIN
		SELECT
			codsg INTO l_codsg
		FROM
			SITU_RESS
		WHERE
			ident=p_ident
			AND datsitu=Pack_Verif_Restab.f_datsitu_recente(p_ident);
	EXCEPTION

		   WHEN NO_DATA_FOUND THEN
			      Pack_Global.recuperer_message(20512, '%s1', 'Logiciel', '%s2', '',NULL, l_msg);
				   RAISE_APPLICATION_ERROR( -20512,l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;

	/*    -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me(l_codsg, p_userid);
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'consulter cette ligne BIP, son DPG est '||l_codsg, 'IDENT', l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;

*/
      -- TEST : le type de la ressource

      BEGIN
         SELECT rtype
         INTO   l_rtype
         FROM   RESSOURCE
         WHERE  ident = TO_NUMBER(p_ident);

		 IF(l_rtype = 'P' )THEN
		     SELECT DECODE(l_soccode,'SG..','A',l_rtype) INTO l_rtype FROM DUAL;
		END IF;

      EXCEPTION
          WHEN NO_DATA_FOUND THEN
              Pack_Global.recuperer_message(20512, '%s1', 'Logiciel', '%s2', '',NULL, l_msg);
		      RAISE_APPLICATION_ERROR( -20512,l_msg);

          WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_rtype != 'L' THEN
         Pack_Global.recuperer_message(20237, '%s1', p_ident, '%s2', l_rtype, 'IDENT', l_msg);
         RAISE_APPLICATION_ERROR( -20237, l_msg);
      END IF;

      BEGIN
         SELECT TO_CHAR(flaglock)
         INTO p_flag
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message(20512, '%s1', 'Logiciel', '%s2', '',NULL, l_msg);
		      RAISE_APPLICATION_ERROR( -20512,l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;



      BEGIN
         SELECT  TO_CHAR(cout_log)
         INTO   p_coulog
         FROM   COUT_STD2 , DATDEBEX
         WHERE  annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
			AND dpg_bas = ( SELECT dpg_bas FROM COUT_STD2,DATDEBEX WHERE dpg_bas <= l_codsg
						AND l_codsg <= dpg_haut
						AND annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
						AND ROWNUM = 1 );

      EXCEPTION

          WHEN NO_DATA_FOUND THEN

            p_coulog := '';

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom

      BEGIN
        OPEN p_curressource FOR
             SELECT RESSOURCE.ident,
                    RESSOURCE.rnom,
                    TO_CHAR(RESSOURCE.coutot,'FM9999999990D00'),
                    RESSOURCE.flaglock,
                    TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                    TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                    SITU_RESS.PRESTATION,
                    --situ_ress.filcode,
                    SITU_RESS.soccode,
                    SITU_RESS.codsg
             FROM RESSOURCE,SITU_RESS
             WHERE RESSOURCE.ident = TO_NUMBER(p_ident)
             AND   SITU_RESS.ident = TO_NUMBER(p_ident);

      EXCEPTION

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'Le logiciel n''existe pas';

      Pack_Global.recuperer_message(2036, '%s1', p_ident, NULL, l_msg);
      p_message := l_msg;

   END select_s_ressource_l;

END Pack_Ressource_L;
/
CREATE OR REPLACE PACKAGE Pack_Ressource_P AS

TYPE ressource_m_ViewType IS RECORD (ident     RESSOURCE.ident%TYPE,
                                     flaglock  RESSOURCE.flaglock%TYPE,
                                     rnom      RESSOURCE.rnom%TYPE,
                                     rprenom   RESSOURCE.rprenom%TYPE,
                                     matricule RESSOURCE.matricule%TYPE,
                                     icodimm   RESSOURCE.icodimm%TYPE,
                                     batiment  RESSOURCE.batiment%TYPE,
                                     etage     RESSOURCE.etage%TYPE,
                                     bureau    RESSOURCE.bureau%TYPE,
                                     rtel      RESSOURCE.rtel%TYPE
                                     );
TYPE ressource_s_ViewType IS RECORD (ident      RESSOURCE.ident%TYPE,
                                     rnom       RESSOURCE.rnom%TYPE,
                                     rprenom    RESSOURCE.rprenom%TYPE,
                                     matricule  RESSOURCE.matricule%TYPE,
                                     coutot     VARCHAR2(13),
                                     flaglock   RESSOURCE.flaglock%TYPE,
                                     datsitu    VARCHAR2(10),
                                     datdep     VARCHAR2(10),
                                     cout       VARCHAR2(13),
                                     PRESTATION SITU_RESS.PRESTATION%TYPE,
                                     --filcode    situ_ress.filcode%TYPE,
                                     soccode    SITU_RESS.soccode%TYPE,
                                     codsg      SITU_RESS.codsg%TYPE
                                    );

   TYPE ressource_p_mCurType IS REF CURSOR RETURN ressource_m_ViewType;
   TYPE ressource_p_sCurType IS REF CURSOR RETURN ressource_s_ViewType;
   TYPE ressourceCurType IS REF CURSOR RETURN RESSOURCE%ROWTYPE;

   PROCEDURE insert_ressource_p (
    		 					 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_rprenom    IN  RESSOURCE.rprenom%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_datsitu    IN  VARCHAR2,
								 p_datdep 	  IN  VARCHAR2,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_codsg      IN  VARCHAR2,
                                 p_cout       IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_dispo      IN  VARCHAR2,
                                 p_rmcomp     IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_matricule  IN  RESSOURCE.matricule%TYPE,
                                 p_rtel       IN  VARCHAR2,
                                 p_icodimm    IN  VARCHAR2,
                                 p_batiment   IN  RESSOURCE.batiment%TYPE,
                                 p_etage      IN  RESSOURCE.etage%TYPE,
                                 p_bureau     IN  RESSOURCE.bureau%TYPE,
                                 p_userid     IN  VARCHAR2,
								  p_rtype IN RESSOURCE.rtype%TYPE,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2,
                                 p_ident    OUT VARCHAR2
                                );


   PROCEDURE update_ressource_p (p_ident     IN  VARCHAR2,
                                 p_rnom      IN  RESSOURCE.rnom%TYPE,
                                 p_rprenom   IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule IN  RESSOURCE.matricule%TYPE,
                                 p_rtel      IN  VARCHAR2,
                                 p_icodimm   IN  VARCHAR2,
                                 p_batiment  IN  RESSOURCE.batiment%TYPE,
                                 p_etage     IN  RESSOURCE.etage%TYPE,
                                 p_bureau    IN  RESSOURCE.bureau%TYPE,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
								 p_rtype IN RESSOURCE.rtype%TYPE,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

   PROCEDURE select_c_ressource_p (p_rnom          IN  RESSOURCE.rnom%TYPE,
                                   p_rprenom       IN  RESSOURCE.rprenom%TYPE,
                                   p_soccode       IN  SITU_RESS.soccode%TYPE,
	                              p_ident         IN  VARCHAR2,
                                   p_userid        IN  VARCHAR2,
								   p_rtype IN RESSOURCE.rtype%TYPE,
                                   p_curressource  IN  OUT ressourceCurType,
                                   p_date_courante     OUT VARCHAR2,
                                   p_matricule OUT VARCHAR2,
                                   p_id                OUT VARCHAR2,
                                   p_codsg             OUT VARCHAR2,
								   p_nbcurseur         OUT INTEGER,
                                   p_message           OUT VARCHAR2
                                  );

   PROCEDURE select_m_ressource_p (p_rnom         IN RESSOURCE.rnom%TYPE,
                                   p_rprenom      IN RESSOURCE.rprenom%TYPE,
                                   p_ident        IN VARCHAR2,
                                   p_userid       IN VARCHAR2,
								   p_rtype IN RESSOURCE.rtype%TYPE,
                                   p_curressource IN OUT ressource_p_mCurType,
                                   p_datsitu         OUT VARCHAR2,
                                   p_nbcurseur       OUT INTEGER,
                                   p_message         OUT VARCHAR2
                                  );

   PROCEDURE select_s_ressource_p (p_rnom         IN RESSOURCE.rnom%TYPE,
                                   p_rprenom      IN RESSOURCE.rprenom%TYPE,
                                   p_ident        IN VARCHAR2,
                                   p_userid       IN VARCHAR2,
								   p_rtype IN RESSOURCE.rtype%TYPE,
                                   p_curressource IN OUT ressource_p_sCurType,
                                   p_flag            OUT VARCHAR2,
                                   p_nbcurseur       OUT INTEGER,
                                   p_message         OUT VARCHAR2
                                  );


   PROCEDURE select_ressource_p (p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
                                   p_curressource IN  OUT ressource_p_mCurType,
                                   p_nbcurseur    OUT INTEGER,
                                   p_message      OUT VARCHAR2
                                  );



   PROCEDURE verif_homonyme (p_ident     IN  VARCHAR2,
                                 p_rnom      IN  RESSOURCE.rnom%TYPE,
                                 p_rprenom   IN  RESSOURCE.rprenom%TYPE,
                                 p_userid    IN  VARCHAR2,
                                 p_matricule OUT VARCHAR2,
                                 p_id        OUT VARCHAR2,
                                 p_codsg     OUT VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) ;
END Pack_Ressource_P;
/

CREATE OR REPLACE PACKAGE BODY Pack_Ressource_P AS

   PROCEDURE insert_ressource_p (
                               	p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_rprenom    IN  RESSOURCE.rprenom%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_datsitu    IN  VARCHAR2,
								 p_datdep     IN  VARCHAR2,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_codsg      IN  VARCHAR2,
                                 p_cout       IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_dispo      IN  VARCHAR2,
                                 p_rmcomp     IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_matricule  IN  RESSOURCE.matricule%TYPE,
                                 p_rtel       IN  VARCHAR2,
                                 p_icodimm    IN  VARCHAR2,
                                 p_batiment   IN  RESSOURCE.batiment%TYPE,
                                 p_etage      IN  RESSOURCE.etage%TYPE,
                                 p_bureau     IN  RESSOURCE.bureau%TYPE,
                                 p_userid     IN  VARCHAR2,
								  p_rtype IN RESSOURCE.rtype%TYPE,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2,
                                 p_ident    OUT VARCHAR2
                                 ) IS

      l_msg           VARCHAR2(1024);
      l_ident         RESSOURCE.ident%TYPE;
      l_rnom         RESSOURCE.rnom%TYPE;
      l_rprenom         RESSOURCE.rprenom%TYPE;
      l_matricule     VARCHAR2(7);
      l_nb NUMBER(7);
      l_test NUMBER(1);
      l_rtype         RESSOURCE.rtype%TYPE;
      ldatsitu        VARCHAR2(10);
	  ldatdep		  VARCHAR2(10);
      l_dsocfer       VARCHAR2(20);
      l_date_courante VARCHAR2(20);
      l_prest         PRESTATION.PRESTATION%TYPE;
      l_menu          VARCHAR2(255);
      l_ges           NUMBER(3);
      l_codsg         SITU_RESS.codsg%TYPE;
      l_idarpege      VARCHAR2(255);
      l_topfer        STRUCT_INFO.topfer%TYPE;
      l_habilitation VARCHAR2(10);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

      -- La regle de gestion 9.5.5 n'est pas suivie, gestion des utilisateur.
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- Calcul de la nouvelle valeur de ident

      BEGIN
         SELECT MAX(ident)
         INTO l_ident
         FROM RESSOURCE;
--         WHERE  ident < 15000;

-- Clause Where en plus pour les tests a voir plus tard.


      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;
l_ident := l_ident +1;
l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

--     ###################  -- TEST : soccode existe et societe non fermee si

     IF l_menu != 'DIR' THEN

--      BEGIN
--         SELECT TO_CHAR(socfer,'yyyymmdd')
--         INTO l_dsocfer
--         FROM societe
--         WHERE soccode = p_soccode;

--      EXCEPTION

--         WHEN NO_DATA_FOUND THEN
--            pack_global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
--            raise_application_error(-20225, l_msg);

--         WHEN OTHERS THEN
--            raise_application_error( -20997, SQLERRM);
--     END;

--     ###################  -- FIN TEST : soccode existe et societe non fermee si

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
         Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
         RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
    END IF;

      -- TEST : PRESTATION = MO ou GRA

      IF p_prestation != 'MO' AND p_prestation != 'GRA' AND p_prestation != 'IFO'  THEN
         IF (p_cout = ',00' OR p_cout = '0,00' OR p_cout IS NULL) AND (p_soccode <> 'SG..') THEN
            Pack_Global.recuperer_message(20247, NULL, NULL, 'COUT', l_msg);
            RAISE_APPLICATION_ERROR(-20247, l_msg);
         END IF;
      END IF;

      -- TEST : 0< DISPO < 7

      IF (TO_NUMBER(p_dispo) < 0) OR (TO_NUMBER(p_dispo) > 7) THEN
         Pack_Global.recuperer_message(20248, NULL, NULL, 'DISPO', l_msg);
         RAISE_APPLICATION_ERROR(-20248, l_msg);
      END IF;

      -- TEST : Il doit exister ds cout_pres 1codprest pour l'annee d'arrive de la personne


      -- Test TOPFER de codsg si menutil = DIR

      IF l_menu != 'DIR' THEN

	BEGIN
         SELECT PRESTATION
         INTO l_prest
         FROM PRESTATION
         WHERE	UPPER(top_actif)='O'
         AND PRESTATION = p_prestation;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            Pack_Global.recuperer_message(20246, '%s1', p_prestation, 'PRESTATION', l_msg);
            RAISE_APPLICATION_ERROR(-20246, l_msg );

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997,SQLERRM);
      END;

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, NULL, l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;

      END IF;

      -- Teste la validite de la valeur de p_codsg

      IF TO_NUMBER(p_codsg) <= 100000 THEN
         Pack_Global.recuperer_message(20223, '%s1', p_codsg, 'CODSG', l_msg);
         RAISE_APPLICATION_ERROR(-20223, l_msg);
      END IF;

      -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( p_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce DPG 20364
		Pack_Global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', l_msg);
                RAISE_APPLICATION_ERROR(-20364, l_msg);
	END IF;

      -- TEST pour savoir si le champ cpident existe

      IF p_cpident IS NOT NULL THEN
         BEGIN

            -- TEST sur l'existence de la ressource

            SELECT rtype
            INTO l_rtype
            FROM RESSOURCE
            WHERE ident = TO_NUMBER(p_cpident);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20226, '%s1', p_cpident, 'CPIDENT', l_msg);
               RAISE_APPLICATION_ERROR(-20226, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;
	END IF;



	-- TEST sur le matricule selon que la ressource est SG ou pas - Sauf pour les IFO et GRA

	IF p_prestation <> 'IFO' AND p_prestation <> 'GRA' THEN

		-- test d'unicite
		BEGIN
		        SELECT rnom,rprenom,ident INTO l_rnom,l_rprenom,l_ident
		        FROM RESSOURCE WHERE matricule = p_matricule
		        AND EXISTS ( SELECT codsg FROM SITU_RESS
				     WHERE ident = RESSOURCE.ident
				     AND   PRESTATION <> 'IFO' AND PRESTATION <> 'GRA'
				     AND   datsitu IN (  SELECT MAX(datsitu)
				                         FROM SITU_RESS
				                         WHERE ident = RESSOURCE.ident
				                       )
				   );
	        	Pack_Global.recuperer_message(20916, '%s1', p_matricule, '%s2', l_rnom || ' ' || l_rprenom,'%s3', TO_CHAR(l_ident),'MATRICULE', l_msg);
		        RAISE_APPLICATION_ERROR(-20916, l_msg);
	        	EXCEPTION
	            	WHEN NO_DATA_FOUND THEN
	              	NULL;
	              	-- cas des matricules en doublon
	              	WHEN TOO_MANY_ROWS THEN
	              	Pack_Global.recuperer_message(20917, NULL,NULL,'MATRICULE', l_msg);
		        RAISE_APPLICATION_ERROR(-20917, l_msg);
	            	WHEN OTHERS THEN
	              	RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	        END;

		--si SSII
		IF  p_soccode <> 'SG..' THEN
		-- matricule doit etre sur 7 caracteres
			IF  LENGTH(p_matricule) <> 7 THEN
				-- le matricule doit etre sur 7 caracteres !
					Pack_Global.recuperer_message(20915, NULL, NULL,'MATRICULE', l_msg);
					RAISE_APPLICATION_ERROR(-20915, l_msg);

			END IF;
		-- 6 derniers car non numeriques
			IF  SUBSTR(p_matricule,1,1)= 'X' THEN
				BEGIN
					SELECT TO_NUMBER(SUBSTR(p_matricule,2,6)) INTO l_matricule FROM dual;
					EXCEPTION
					WHEN OTHERS THEN
					-- 'le matricule est composé de 7 chiffres'
					-- !!! message a modifier !!!!
					Pack_Global.recuperer_message(20913, NULL, NULL, 'MATRICULE', l_msg);
				        RAISE_APPLICATION_ERROR(-20913, l_msg);
				END;
			ELSE
				-- 1er car = Y -> tests
				IF SUBSTR(p_matricule,1,1)= 'Y' THEN
 					BEGIN
						SELECT 1 INTO l_test FROM RESSOURCE
						WHERE matricule = ('X' || SUBSTR(p_matricule,2,6))
						AND rnom= p_rnom
						AND rprenom=p_rprenom;
						EXCEPTION
						WHEN NO_DATA_FOUND THEN
						--'le matricule d'une ressource SSII doit commencer par X'
						Pack_Global.recuperer_message(20914, NULL, NULL, 'MATRICULE', l_msg);
				        	RAISE_APPLICATION_ERROR(-20914, l_msg);
				        	-- cas des matricules en doublon
              					WHEN TOO_MANY_ROWS THEN
              					NULL ;
			        	END;

			        	BEGIN
						SELECT TO_NUMBER(SUBSTR(p_matricule,2,6)) INTO l_matricule FROM dual;
						EXCEPTION
						WHEN OTHERS THEN
						-- 'le matricule commence par la letttre Y et se poursuit par 6 chiffres '
						Pack_Global.recuperer_message(20918, NULL, NULL, 'MATRICULE', l_msg);
					        RAISE_APPLICATION_ERROR(-20918, l_msg);
			        	END;

		        	ELSE 	--'le matricule d'une ressource SSII doit commencer par X'
					Pack_Global.recuperer_message(20914, NULL, NULL, 'MATRICULE', l_msg);
		        		RAISE_APPLICATION_ERROR(-20914, l_msg);
		        	END IF;
		        END IF;
		END IF;
	END IF;


	--si SG
	IF p_soccode = 'SG..' THEN
			--kha 14/05/2004 test s'applique aussi au matricule SG
		IF  LENGTH(p_matricule) <> 7 THEN
			-- le matricule doit etre saisi sur 7 caracteres !
				Pack_Global.recuperer_message(20913, NULL, NULL,'MATRICULE', l_msg);
				RAISE_APPLICATION_ERROR(-20913, l_msg);

		END IF;
			--que des numeriques
			BEGIN
--			SELECT LPAD(p_matricule,7,'0') INTO l_matricule FROM dual;
			SELECT LPAD(p_matricule,7,'0'), TO_NUMBER(p_matricule) INTO l_matricule, l_nb FROM dual;
			EXCEPTION
			WHEN OTHERS THEN
			-- 'le matricule est composé de 7 chiffres'
			Pack_Global.recuperer_message(20913, NULL, NULL, 'MATRICULE', l_msg);
		        RAISE_APPLICATION_ERROR(-20913, l_msg);
		        END;
	END IF;


         -- TEST pour savoir si cette ressource est une prestation ou un agent SG

         IF (l_rtype != 'P')  AND (l_rtype IS NOT NULL) THEN
            Pack_Global.recuperer_message(20218, NULL, NULL, 'CPIDENT', l_msg);
            RAISE_APPLICATION_ERROR(-20218, l_msg);
         END IF;


      -- la date d'arrivée d'une ressource doit être le 1er jour du mois qu'a saisi l'utilisateur
         ldatsitu := TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';

	  -- date de départ d'une ressource
         ldatdep := TO_CHAR(TO_DATE(p_datdep,'dd/mm/yyyy'),'yyyymmdd');


      -- INSERTION

      BEGIN
         INSERT INTO RESSOURCE (rnom,
                                rprenom,
                                ident,
                                rtype,
                                icodimm,
                                matricule,
                                batiment,
                                etage,
                                bureau,
                                rtel
                               )
         VALUES (p_rnom,
                 p_rprenom,
                 l_ident,
                 'P',
                 p_icodimm,
                 p_matricule,
                 p_batiment,
                 p_etage,
                 p_bureau,
                 p_rtel
                );

      EXCEPTION

         WHEN DUP_VAL_ON_INDEX THEN

            -- msg : 'ressource deja existante'
            Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
            RAISE_APPLICATION_ERROR( -20219, l_msg );

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      BEGIN

         INSERT INTO SITU_RESS (ident,
                                datsitu,
                                soccode,
                                codsg,
                                cout,
                                --filcode,
                                PRESTATION,
                                cpident,
                                dispo,
                                --rmcomp,
                                datdep
                               )
         VALUES (l_ident,
                 TO_DATE(ldatsitu,'yyyymmdd'),
                 p_soccode,
                 TO_NUMBER( p_codsg),
                 TO_NUMBER( p_cout,'FM9999999999D00'),
                 --p_filcode,
                 p_prestation,
                 TO_NUMBER(p_cpident),
                 TO_NUMBER(p_dispo,'FM9D9'),
                 --NVL(TO_NUMBER(p_rmcomp),0),
				 TO_DATE(ldatdep,'yyyymmdd')
                );


         -- p_message := 'Creation de la personne ' ||
         -- p_rnom || ' et enregistrés.';



		  IF(p_soccode='SG..')THEN
	  	             Pack_Global.recuperer_message(21052, '%s1', p_rnom ||' '|| p_rprenom ,'%s2',TO_CHAR(l_ident), NULL, l_msg);
                     p_message := l_msg;
	     ELSE
	  	             Pack_Global.recuperer_message(21053, '%s1', p_rnom ||' '|| p_rprenom ,'%s2',TO_CHAR(l_ident), NULL, l_msg);
                     p_message := l_msg;
	      END IF;

              p_ident := l_ident;

      EXCEPTION

         WHEN DUP_VAL_ON_INDEX THEN

            -- 'la ressource existe deja'

            Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
            RAISE_APPLICATION_ERROR( -20219, l_msg );

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            Pack_Global.recuperation_integrite(-2291);

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

      END;

  END insert_ressource_p;


   PROCEDURE update_ressource_p (p_ident     IN  VARCHAR2,
                                 p_rnom      IN  RESSOURCE.rnom%TYPE,
                                 p_rprenom   IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule IN  RESSOURCE.matricule%TYPE,
                                 p_rtel      IN  VARCHAR2,
                                 p_icodimm   IN  VARCHAR2,
                                 p_batiment  IN  RESSOURCE.batiment%TYPE,
                                 p_etage     IN  RESSOURCE.etage%TYPE,
                                 p_bureau    IN  RESSOURCE.bureau%TYPE,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
								 p_rtype IN RESSOURCE.rtype%TYPE,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_hom RESSOURCE.rnom%TYPE;
      l_matricule VARCHAR2(7);
      l_ident RESSOURCE.ident%TYPE;
      l_rnom RESSOURCE.rnom%TYPE;
      l_test NUMBER(1);
      l_rprenom RESSOURCE.rprenom%TYPE;
      l_soccode SITU_RESS.soccode%TYPE;
      l_prestation SITU_RESS.PRESTATION%TYPE;
	  l_nb NUMBER(7);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';
      l_prestation := '' ;

      -- Récupère la prestation en cours et le soccode
	BEGIN
		SELECT PRESTATION, soccode INTO l_prestation,l_soccode
		     FROM SITU_RESS
		     WHERE ident = p_ident
		     AND   datsitu IN (  SELECT MAX(datsitu)
		                         FROM SITU_RESS
		                         WHERE ident = p_ident
		                       );
		EXCEPTION
            	WHEN OTHERS THEN
              	RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END ;


	-- TEST sur le matricule selon que la ressource est SG ou pas

	-- test d'unicite - Si prestation non IFO ou GRA
	IF l_prestation <> 'IFO' AND l_prestation <> 'GRA' THEN
		BEGIN

	       		SELECT rnom,rprenom,ident INTO l_rnom,l_rprenom,l_ident
		        FROM RESSOURCE WHERE matricule = p_matricule AND ident <> p_ident
		        AND EXISTS ( SELECT codsg FROM SITU_RESS
				     WHERE ident = RESSOURCE.ident
				     AND   PRESTATION <> 'IFO' AND PRESTATION <> 'GRA'
				     AND   datsitu IN (  SELECT MAX(datsitu)
				                         FROM SITU_RESS
				                         WHERE ident = RESSOURCE.ident
				                       )
				   );
	        	Pack_Global.recuperer_message(20916, '%s1', p_matricule, '%s2', l_rnom || ' ' || l_rprenom,'%s3', TO_CHAR(l_ident),'MATRICULE', l_msg);
		        RAISE_APPLICATION_ERROR(-20916, l_msg);
	        	EXCEPTION
	            	WHEN NO_DATA_FOUND THEN
	              	NULL;
	              	-- cas des matricules en doublon
	              	WHEN TOO_MANY_ROWS THEN
	              	Pack_Global.recuperer_message(20917, NULL,NULL,'MATRICULE', l_msg);
		        RAISE_APPLICATION_ERROR(-20917, l_msg);
	            	WHEN OTHERS THEN
	              	RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	        END;
	END IF ;

	--si SSII
	IF  l_soccode <> 'SG..' THEN
		   -- matricule doit etre sur 7 caracteres
			IF  LENGTH(p_matricule) <> 7 THEN
		   -- le matricule doit etre sur 7 caracteres !
		   	    Pack_Global.recuperer_message(20915, NULL, NULL,'MATRICULE', l_msg);
		   		RAISE_APPLICATION_ERROR(-20915, l_msg);
			END IF;
	-- 6 derniers car non numeriques
			IF  SUBSTR(p_matricule,1,1)= 'X' THEN
				BEGIN
				SELECT TO_NUMBER(SUBSTR(p_matricule,2,6)) INTO l_matricule FROM dual;
				EXCEPTION
				WHEN OTHERS THEN
				-- 'le matricule est composé de 7 chiffres'
				-- !!! message a modifier !!!!
				Pack_Global.recuperer_message(20913, NULL, NULL, 'MATRICULE', l_msg);
			        RAISE_APPLICATION_ERROR(-20913, l_msg);
				END;
			ELSE
				-- 1er car = Y -> tests
				IF SUBSTR(p_matricule,1,1)= 'Y' THEN
 					BEGIN
						SELECT 1 INTO l_test FROM RESSOURCE
						WHERE matricule = ('X' || SUBSTR(p_matricule,2,6))
						AND rnom= p_rnom
						AND rprenom=p_rprenom
						AND ident <> p_ident;
						EXCEPTION
						WHEN NO_DATA_FOUND THEN
						--'le matricule d'une ressource SSII doit commencer par X'
						Pack_Global.recuperer_message(20914, NULL, NULL, 'MATRICULE', l_msg);
				        	RAISE_APPLICATION_ERROR(-20914, l_msg);
				        	-- cas des matricules en doublon
              					WHEN TOO_MANY_ROWS THEN
              					NULL ;
			        	END;

			        	BEGIN
					SELECT TO_NUMBER(SUBSTR(p_matricule,2,6)) INTO l_matricule FROM dual;
					EXCEPTION
					WHEN OTHERS THEN
					-- 'le matricule commence par la letttre Y et se poursuit par 6 chiffres '
					Pack_Global.recuperer_message(20918, NULL, NULL, 'MATRICULE', l_msg);
				        RAISE_APPLICATION_ERROR(-20918, l_msg);
			        	END;


		        	ELSE 	--'le matricule d'une ressource SSII doit commencer par X'
					Pack_Global.recuperer_message(20914, NULL, NULL, 'MATRICULE', l_msg);
		        		RAISE_APPLICATION_ERROR(-20914, l_msg);
		        	END IF;
		        END IF;
	END IF;


	--si SG
	IF l_soccode = 'SG..' THEN
			--kha 14/05/2004 test s'applique aussi au matricule SG
		IF  LENGTH(p_matricule) <> 7 THEN
			-- le matricule doit etre saisi sur 7 caracteres !
				Pack_Global.recuperer_message(20913, NULL, NULL,'MATRICULE', l_msg);
				RAISE_APPLICATION_ERROR(-20913, l_msg);

		END IF;
			--que des numeriques
			BEGIN
			SELECT LPAD(p_matricule,7,'0'), TO_NUMBER(p_matricule) INTO l_matricule, l_nb FROM dual;
			EXCEPTION
			WHEN OTHERS THEN
			-- 'le matricule est composé de 7 chiffres'
			Pack_Global.recuperer_message(20913, NULL, NULL, 'MATRICULE', l_msg);
		        RAISE_APPLICATION_ERROR(-20913, l_msg);
		        END;
	END IF;



      BEGIN
         UPDATE RESSOURCE SET rnom      = p_rnom,
                              rprenom   = p_rprenom,
                              matricule = p_matricule,
                              icodimm   = p_icodimm,
                              batiment  = p_batiment,
                              etage     = p_etage,
                              bureau    = p_bureau,
                              rtel      = p_rtel,
                              flaglock  = DECODE( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE ident  = TO_NUMBER(p_ident)
         AND flaglock = p_flaglock;

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL,NULL , NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      ELSE

         -- Message : 'situation || p_rnom || modifie';


       IF ( l_soccode='SG..' )THEN
               Pack_Global.recuperer_message(21046, '%s1',p_rnom , NULL, l_msg);
              p_message := l_msg;
	  ELSE
	          Pack_Global.recuperer_message(21047, '%s1',p_rnom , NULL, l_msg);
              p_message := l_msg;
	  END IF;



      END IF;

   END update_ressource_p;





   PROCEDURE select_c_ressource_p (p_rnom          IN  RESSOURCE.rnom%TYPE,
                                   p_rprenom       IN  RESSOURCE.rprenom%TYPE,
                                   p_soccode       IN  SITU_RESS.soccode%TYPE,
                                   p_ident         IN  VARCHAR2,
                                   p_userid        IN  VARCHAR2,
								   p_rtype IN RESSOURCE.rtype%TYPE,
                                   p_curressource  IN  OUT ressourceCurType,
                                   p_date_courante OUT VARCHAR2,
                                   p_matricule     OUT VARCHAR2,
                                   p_id            OUT VARCHAR2,
                                   p_codsg         OUT VARCHAR2,
                                   p_nbcurseur     OUT INTEGER,
                                   p_message       OUT VARCHAR2
                                  ) IS

	-- SOCODE LOCAL VAR
	l_menu   VARCHAR2(255);
	l_dsocfer       VARCHAR2(20);
	l_date_courante VARCHAR2(20);

	-- FIN SOCODE LOCAL VAR

	l_msg    VARCHAR2(1024);
	l_rnom   RESSOURCE.rnom%TYPE;
	l_id     RESSOURCE.ident%TYPE;


   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Renvoie la date courante

       -- SELECT 'DATSITU#' || TO_CHAR(SYSDATE,'mm/yyyy')

	SELECT TO_CHAR(SYSDATE,'mm/yyyy')
	INTO   p_date_courante FROM   DUAL;

	-- TEST : soccode existe et societe non fermee si

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

     IF l_menu != 'DIR' THEN

      BEGIN
         SELECT TO_CHAR(socfer,'yyyymmdd')
         INTO l_dsocfer
         FROM SOCIETE
         WHERE soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
            RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;


      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
         Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
         RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
    END IF;


      -- IDENT : cas d'un homonyme

      BEGIN
         SELECT MAX(ident)
         INTO   l_id
         FROM   RESSOURCE
         WHERE  rnom = p_rnom
         AND    rprenom = p_rprenom;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;
	-- MATRICULE :cas d un homonyme
	BEGIN
		SELECT matricule
		INTO p_matricule
		FROM RESSOURCE
		WHERE ident= l_id
	        ;

         EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;

      --  CODSG : cas d'un homonyme

      BEGIN
         SELECT codsg
         INTO   p_codsg
         FROM   SITU_RESS
         WHERE  ident = l_id
         AND    datsitu IN (
                         SELECT MAX(datsitu)
                         FROM SITU_RESS
                         WHERE ident = TO_NUMBER(l_id)
                        );

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      p_id :=  l_id;

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom

      -- TEST ident vide -> curseur normal ->, non vide -> curseur vide

      IF p_ident IS NULL THEN

         BEGIN

           OPEN p_curressource FOR
                SELECT *
                FROM   RESSOURCE
                WHERE  rnom = p_rnom
                AND    rprenom = p_rprenom;

         EXCEPTION

           WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

      ELSE
         BEGIN

           OPEN p_curressource FOR
                SELECT *
                FROM   RESSOURCE
                WHERE  rnom = ''
                AND    rprenom = '';

         EXCEPTION

           WHEN OTHERS THEN

              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;
      END IF;

      -- en cas absence
      -- p_message := 'Le logiciel existe deja';

	  IF(p_soccode='SG..')THEN
	  	             Pack_Global.recuperer_message(21044, '%s1', p_rnom, NULL, l_msg);
                    p_message := l_msg;
	  ELSE
	  	            Pack_Global.recuperer_message(21045, '%s1', p_rnom, NULL, l_msg);
                    p_message := l_msg;
	  END IF;



   END select_c_ressource_p;



   PROCEDURE select_m_ressource_p (p_rnom         IN  RESSOURCE.rnom%TYPE,
                                   p_rprenom      IN  RESSOURCE.rprenom%TYPE,
                                   p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
								   p_rtype IN RESSOURCE.rtype%TYPE,
                                   p_curressource IN  OUT ressource_p_mCurType,
                                   p_datsitu      OUT VARCHAR2,
                                   p_nbcurseur    OUT INTEGER,
                                   p_message      OUT VARCHAR2
                                  ) IS

      l_msg      VARCHAR2(1024);
      l_rtype    RESSOURCE.rtype%TYPE;
      l_codsg    SITU_RESS.codsg%TYPE;
	  l_soccode    SITU_RESS.soccode%TYPE;
      l_idarpege VARCHAR2(255);
      l_ges      NUMBER(3);
      l_habilitation VARCHAR2(10);
   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Gestion du niveau d'acces de l'utilisateur.

      BEGIN
         SELECT codsg,soccode
         INTO l_codsg, l_soccode
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident)
         AND datsitu IN (
                         SELECT MAX(datsitu)
                         FROM SITU_RESS
                         WHERE ident = TO_NUMBER(p_ident)
                        );

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             IF(p_rtype='A')THEN
	  	             Pack_Global.recuperer_message(20512, '%s1', 'Agent SG', '%s2', '',NULL, l_msg);
				   RAISE_APPLICATION_ERROR( -20512,l_msg);
	       ELSE
	  	             Pack_Global.recuperer_message(20512, '%s1', 'Prestation', '%s2', 'e',NULL, l_msg);
				   RAISE_APPLICATION_ERROR( -20512,l_msg);
	        END IF;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

  IF  l_codsg IS NOT NULL THEN
      -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
     	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier cette ressource, son DPG est '||l_codsg, 'IDENT', l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;
END IF;
      -- On recherche le type de ressource associe a l'identifiant

      BEGIN
         SELECT rtype
         INTO l_rtype
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_rtype != 'P' THEN

	         IF p_rtype = 'A' THEN
                  Pack_Global.recuperer_message(20951, '%s1', p_ident,  '%s2', l_rtype, 'IDENT', l_msg);
                  RAISE_APPLICATION_ERROR( -20951, l_msg);
		      ELSE
		          Pack_Global.recuperer_message(20952, '%s1', p_ident,  '%s2', l_rtype, 'IDENT', l_msg);
                  RAISE_APPLICATION_ERROR( -20952, l_msg);
		       END IF;

	  ELSE
	  		   	  IF l_soccode!='SG..' AND p_rtype='A' THEN
				          Pack_Global.recuperer_message(20951, '%s1', p_ident,  '%s2', l_rtype, 'IDENT', l_msg);
                          RAISE_APPLICATION_ERROR( -20951, l_msg);

				   ELSIF l_soccode='SG..' AND p_rtype='P' THEN
				          Pack_Global.recuperer_message(20952, '%s1', p_ident,  '%s2','A', 'IDENT', l_msg);
                          RAISE_APPLICATION_ERROR( -20952, l_msg);

					END IF;


      END IF;


      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom

      BEGIN
         OPEN p_curressource FOR
            SELECT ident,
                   flaglock,
                   rnom,
                   rprenom,
                   matricule,
                   icodimm,
                   batiment,
                   etage,
                   bureau,
                   rtel
            FROM RESSOURCE
            WHERE ident = TO_NUMBER(p_ident)
            ;

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'La personne n''existe pas';

	  IF ( l_soccode='SG..' )THEN
	             Pack_Global.recuperer_message(21044, '%s1', p_rnom, NULL, l_msg);
                 p_message := l_msg;
	  ELSE
	             Pack_Global.recuperer_message(21045, '%s1', p_rnom, NULL, l_msg);
                 p_message := l_msg;
	  END IF;



   END select_m_ressource_p;


   PROCEDURE select_s_ressource_p (p_rnom         IN  RESSOURCE.rnom%TYPE,
                                   p_rprenom      IN  RESSOURCE.rprenom%TYPE,
                                   p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
								   p_rtype IN RESSOURCE.rtype%TYPE,
                                   p_curressource IN  OUT ressource_p_sCurType,
                                   p_flag         OUT VARCHAR2,
                                   p_nbcurseur    OUT INTEGER,
                                   p_message      OUT VARCHAR2
                                  ) IS

      l_msg VARCHAR2(1024);
      l_rtype RESSOURCE.rtype%TYPE;
	  l_soccode SITU_RESS.soccode%TYPE;
	  l_codsg SITU_RESS.codsg%TYPE;
	  l_habilitation VARCHAR2(10);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      BEGIN
         SELECT TO_CHAR(flaglock)
         INTO p_flag
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- TEST : Le type de la ressource est bien une personne

      BEGIN
         SELECT rtype
         INTO l_rtype
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;



      BEGIN
         SELECT codsg,soccode
         INTO l_codsg, l_soccode
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident)
         AND datsitu IN (
                         SELECT MAX(datsitu)
                         FROM SITU_RESS
                         WHERE ident = TO_NUMBER(p_ident)
                        );

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
        --  pack_global.recuperer_message(2050, '%s1', p_rnom, NULL, l_msg);
    --  p_message := l_msg;
           NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;


	/*    IF  l_codsg IS NOT NULL THEN
      -- ====================================================================
      -- 24/11/2005 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
     	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'consulter cette ressource, son DPG est '||l_codsg, 'IDENT', l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	  END IF;
     END IF;
*/

	      IF l_rtype != 'P' THEN

	         IF p_rtype = 'A' THEN
                  Pack_Global.recuperer_message(20951, '%s1', p_ident,  '%s2', l_rtype, 'IDENT', l_msg);
                  RAISE_APPLICATION_ERROR( -20951, l_msg);
		      ELSE
		          Pack_Global.recuperer_message(20952, '%s1', p_ident,  '%s2', l_rtype, 'IDENT', l_msg);
                  RAISE_APPLICATION_ERROR( -20952, l_msg);
		       END IF;

	  ELSE
	  		   	  IF l_soccode!='SG..' AND p_rtype='A' THEN
				          Pack_Global.recuperer_message(20951, '%s1', p_ident,  '%s2', l_rtype, 'IDENT', l_msg);
                          RAISE_APPLICATION_ERROR( -20951, l_msg);

					ELSIF l_soccode='SG..' AND p_rtype='P' THEN
				          Pack_Global.recuperer_message(20952, '%s1', p_ident,  '%s2', 'A', 'IDENT', l_msg);
                          RAISE_APPLICATION_ERROR( -20952, l_msg);

					END IF;


      END IF;



      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom

      BEGIN
         OPEN p_curressource FOR
            SELECT RESSOURCE.ident,
                   RESSOURCE.rnom,
                   RESSOURCE.rprenom,
                   RESSOURCE.matricule,
                   TO_CHAR(RESSOURCE.coutot,'FM9999999990D00'),
                   RESSOURCE.flaglock,
                   TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy'),
                   TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                   TO_CHAR(SITU_RESS.cout,'FM9999999990D00'),
                   SITU_RESS.PRESTATION,
                   --situ_ress.filcode,
                   SITU_RESS.soccode,
                   SITU_RESS.codsg
            FROM RESSOURCE,SITU_RESS
            WHERE RESSOURCE.ident = TO_NUMBER(p_ident)
            AND   SITU_RESS.ident = TO_NUMBER(p_ident)
		ORDER BY SITU_RESS.datsitu DESC;       --Ajout du 04/09/2001 pour position du curseur sur la liste

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;




      -- si l identifiant ne correspond pas a une ressource
      -- p_message := 'La personne n''existe pas';

	   IF ( p_rtype='A' )THEN
                Pack_Global.recuperer_message(21044, '%s1', p_ident, NULL, l_msg);
                p_message := l_msg;
	  ELSIF(p_rtype='P')THEN
	            Pack_Global.recuperer_message(21045, '%s1', p_ident, NULL, l_msg);
                p_message := l_msg;
	  ELSE
	            Pack_Global.recuperer_message(2050, '%s1', p_ident, NULL, l_msg);
                p_message := l_msg;
	  END IF;



   END select_s_ressource_p;




 PROCEDURE select_ressource_p (  p_ident        IN  VARCHAR2,
                                   p_userid       IN  VARCHAR2,
                                   p_curressource IN  OUT ressource_p_mCurType,
                                   p_nbcurseur    OUT INTEGER,
                                   p_message      OUT VARCHAR2
                                  ) IS

      l_msg      VARCHAR2(1024);
      l_rtype    RESSOURCE.rtype%TYPE;
      l_codsg    SITU_RESS.codsg%TYPE;
      l_idarpege VARCHAR2(255);
      l_ges      NUMBER(3);
      l_habilitation VARCHAR2(10);
   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Gestion du niveau d'acces de l'utilisateur.

      BEGIN
         SELECT codsg
         INTO l_codsg
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident)
         AND datsitu IN (
                         SELECT MAX(datsitu)
                         FROM SITU_RESS
                         WHERE ident = TO_NUMBER(p_ident)
                        );

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
        --  pack_global.recuperer_message(2050, '%s1', p_rnom, NULL, l_msg);
    --  p_message := l_msg;
           NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

  IF  l_codsg IS NOT NULL THEN
      -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
     	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier cette ressource, son DPG est '||l_codsg, 'IDENT', l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;
END IF;
      -- On recherche le type de ressource associe a l'identifiant

      BEGIN
         SELECT rtype
         INTO l_rtype
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_rtype != 'P' THEN
         Pack_Global.recuperer_message(20251, '%s1', l_rtype, 'IDENT', l_msg);
         RAISE_APPLICATION_ERROR( -20251, l_msg);
      END IF;


      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *
      -- On ouvre le curseur suivant p_rnom

      BEGIN
         OPEN p_curressource FOR
            SELECT ident,
                   flaglock,
                   rnom,
                   rprenom,
                   matricule,
                   icodimm,
                   batiment,
                   etage,
                   bureau,
                   rtel
            FROM RESSOURCE
            WHERE ident = TO_NUMBER(p_ident)
            ;

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'La personne n''existe pas';
      Pack_Global.recuperer_message(2050, '%s1', p_ident, NULL, l_msg);
     p_message := l_msg;

   END select_ressource_p;









 --lot 4.3 fich 187 nouvelle procedure de test des homonymes

   PROCEDURE verif_homonyme (p_ident     IN  VARCHAR2,
                                 p_rnom      IN  RESSOURCE.rnom%TYPE,
                                 p_rprenom   IN  RESSOURCE.rprenom%TYPE,
                                 p_userid    IN  VARCHAR2,
                                 p_matricule OUT VARCHAR2,
                                 p_id        OUT VARCHAR2,
                                 p_codsg     OUT VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                )  IS

      l_id       RESSOURCE.ident%TYPE;
      l_rprenom  RESSOURCE.rprenom%TYPE;
      l_rnom     RESSOURCE.rnom%TYPE;

	l_msg    VARCHAR2(1024);



   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := ' ';

BEGIN
	SELECT rnom, rprenom
	INTO l_rnom, l_rprenom
	FROM RESSOURCE
	WHERE ident = p_ident;

EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

IF l_rnom != p_rnom OR l_rprenom != p_rprenom THEN

      -- IDENT : cas d'un homonyme

      BEGIN
         SELECT MAX(ident)
         INTO   l_id
         FROM   RESSOURCE
         WHERE  rnom = p_rnom
         AND    rprenom = p_rprenom;


      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;
	-- MATRICULE :cas d un homonyme
	BEGIN
		SELECT matricule
		INTO p_matricule
		FROM RESSOURCE
		WHERE ident= l_id
	        ;
         p_message := 'homonyme existant';
         EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;

      --  CODSG : cas d'un homonyme

      BEGIN
         SELECT codsg
         INTO   p_codsg
         FROM   SITU_RESS
         WHERE  ident = l_id
         AND    datsitu IN (
                         SELECT MAX(datsitu)
                         FROM SITU_RESS
                         WHERE ident = TO_NUMBER(l_id)
                        );

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      p_id :=  l_id;
      --pack_global.recuperer_message(2050, '%s1', p_rnom, NULL, l_msg);
      --p_message := 'homonyme existant';
END IF;

   --   pack_global.recuperer_message(2050, '%s1', p_rnom, NULL, l_msg);
   --   p_message := l_msg;

   END verif_homonyme;


END Pack_Ressource_P;
/
CREATE OR REPLACE PACKAGE pack_restab1 AS
  -- ------------------------------------------------------------------------
  -- Nom        :  prologue
  -- Auteur     :  Equipe SOPRA
  -- Decription :  vérifie l'existence du code dpg  pour l'edition restab1
  -- Paramètres :  p_param6 (IN) situ_ress.codsg%type: code dpg
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------

PROCEDURE  verif_restab1(       p_codcfrais IN varchar2,
				p_param8    IN varchar2,
				p_param6    IN varchar2,
				p_global    IN VARCHAR2,
			 	p_message   OUT VARCHAR2);
END pack_restab1;
/

CREATE OR REPLACE PACKAGE BODY pack_restab1 AS

  -- ------------------------------------------------------------------------
   -- Nom        :  prologue
  -- Auteur     :  Equipe SOPRA
  -- Decription :  vérifie l'existence du code dpg  pour l'edition restab1
  -- Paramètres :  p_param6 (IN) Varchar2: code dpg
  --               p_message (out) varchar2
  -- Retour     :  renvoie rien si ok, erreur sinon
  --
  -- ------------------------------------------------------------------------
PROCEDURE  verif_restab1(       p_codcfrais IN varchar2,   	-- centre de frais
				p_param8    IN varchar2,   	-- menu courant
				p_param6    IN varchar2,	-- code dPG
				p_global    IN VARCHAR2,
			 	p_message   OUT VARCHAR2) IS
  l_msg VARCHAR2(1024) :='';
  l_codsg2 struct_info.codsg%type;
  l_centre_frais centre_frais.codcfrais%TYPE;
  l_scentrefrais centre_frais.codcfrais%TYPE;


BEGIN
   BEGIN
      -- P_codsg peut avoir une valeur = '01313**' ou '0131312' ou '01312  ' (avec des blancs)
      -- S'il possed un metacaractere (' ', '*'), on va le supprimer
      -- Puis former la condition Where du Select en fonction du longueur de P_codsg
 	if p_param6!='*******' then
      		SELECT   codsg, scentrefrais   INTO  l_codsg2, l_scentrefrais
      		FROM   struct_info
	   	WHERE  substr(to_char(codsg,'FM0000000'),1, length(rtrim(LPAD(p_param6, 7, '0'),'*'))) = rtrim(LPAD(p_param6, 7, '0'),'*')
	     	 AND ROWNUM <= 1;
  	end if;

   EXCEPTION
	WHEN NO_DATA_FOUND then
		pack_global.recuperer_message(20215, '%s1', p_param6, 'p_param6', l_msg);
     	 	raise_application_error(-20215, l_msg);
   	p_message := l_msg;
   END;

  IF p_param8='ACH' THEN
     -- ===================================================================
     -- 28/12/2000 : Test si le DPG appartient bien au centre de frais
     -- ===================================================================
     -- On récupère le code centre de frais de l'utilisateur
	l_centre_frais := to_number(p_codcfrais);
   	IF p_param6!='*******' then
     		IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
      			IF (l_scentrefrais is null)   then
			--msg : Le DPG n'est rattaché à aucun centre de frais
				pack_global.recuperer_message(20339, NULL,NULL,'CODSG', l_msg);
          			raise_application_error(-20339, l_msg);
			ELSE
				IF (l_scentrefrais!=l_centre_frais) then
				--msg:Ce DPG n'appartient pas à ce centre de frais
				pack_global.recuperer_message(20334, '%s1',to_char(l_centre_frais),'CODSG', l_msg);
          			raise_application_error(-20334, l_msg);
				END IF;
      			END IF;
     		END IF;
   	END IF;

  ELSE
     -- =====================================================================
     -- 07/02/2001 : Test si le DPG appartient au périmètre de l'utilisateur
     -- =====================================================================
     pack_habilitation.verif_habili_me ( p_param6,p_global  , p_message  );

  END IF;
END verif_restab1;

END pack_restab1;
/
CREATE OR REPLACE PACKAGE pack_RestPro3 AS
-- ----------------------------------------------------------------------------
-- PROCEDURE qui verifie les parametres de l'édition RestPro3.
   PROCEDURE Verif_ParamRestPro3 (
                       p_pid      IN ligne_bip.pid%TYPE,  -- varchar2(4)
                       p_global   IN VARCHAR2,
                       p_msg      OUT VARCHAR2

                       ) ;
END pack_RestPro3;
/

CREATE OR REPLACE PACKAGE BODY pack_RestPro3 AS

-- ============================================================================
-- ----------------------------------------------------------------------------
-- PROCEDURE Verif_ParamRestPro3
-- Role : Verifie l'existence et l'exactitude du paramettre d'entree de
--        l'édition RestPro3.
-- ----------------------------------------------------------------------------

   PROCEDURE Verif_ParamRestPro3 (
                       p_pid      IN ligne_bip.pid%TYPE,  -- varchar2(4)
                       p_global   IN VARCHAR2,
                       p_msg  OUT VARCHAR2
                       ) IS

   l_msg  VARCHAR2(1024);
   l_UserDepPole VARCHAR2(5);
   l_codsg ligne_bip.codsg%TYPE;
   l_annee NUMBER(4);
   l_habilitation varchar2(10);

  BEGIN

      p_msg := '';

      -- Rechercher le code departement pole de l'utilisateur.
      l_UserDepPole := substr(LPAD(pack_global.lire_globaldata(p_global).codpole,7,'0'), 1, 5);

     -- Rechercher le code departement pole du projet
     BEGIN

         SELECT lb.codsg INTO l_codsg
         FROM   ligne_bip lb
         WHERE  lb.pid = p_pid
           AND  ROWNUM  < 2;

     EXCEPTION
         WHEN NO_DATA_FOUND THEN
              -- Code ligne BIP inexistant
              pack_global.recuperer_message(20504, '%s1', p_pid, NULL, l_msg);
              raise_application_error(-20504, l_msg);

     END;

     -- Verifier l'habilitation de l'utilisateur sur le projet

      	-- ====================================================================
      	-- 20/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      	-- ====================================================================
     	l_habilitation := pack_habilitation.fhabili_me( l_codsg,p_global);
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce projet
		pack_global.recuperer_message(20364,'%s1',  'à ce projet, son DPG est '||l_codsg, 'P_param6', l_msg);
	  	raise_application_error( -20364, l_msg );
	END IF;



     EXCEPTION
        WHEN OTHERS THEN raise_application_error(-20997,SQLERRM);

  END Verif_ParamRestPro3;

END pack_RestPro3;
/
CREATE OR REPLACE PACKAGE PACK_RJH_LOAD_TR AS

   -- Définition curseur sur la table RJH_TABREPART

   TYPE LoadTableRepart_ViewType IS RECORD ( codchr RJH_CHARGEMENT.CODCHR%TYPE,
   								 		     codrep RJH_CHARGEMENT.CODREP%TYPE,
   							 		   	 	 moisrep RJH_CHARGEMENT.MOISREP%TYPE,
										 	 fichier RJH_CHARGEMENT.FICHIER%TYPE,
										 	 statut RJH_CHARGEMENT.STATUT%TYPE,
										 	 datechg RJH_CHARGEMENT.DATECHG%TYPE
									       );

   TYPE load_tablerepartCurType_Char IS REF CURSOR RETURN LoadTableRepart_ViewType;

-- ----------------------------------------------------------------------
-- Procédure qui insert un nouveau chargement de table de répartition
-- ----------------------------------------------------------------------
   PROCEDURE insert_table ( p_codrep      	IN  RJH_CHARGEMENT.CODREP%TYPE,
				  		  	p_moisrep     	IN  VARCHAR2,
                            p_fichier     	IN  RJH_CHARGEMENT.FICHIER%TYPE,
                           	p_userid     	IN  VARCHAR2,
                            p_nbcurseur  	OUT INTEGER,
                            p_message    	OUT VARCHAR2,
                            p_codchr    	OUT VARCHAR2
                          );

-- ----------------------------------------------------------------------
-- Procédure qui modifie le statut d'un nouveau chargement
-- ----------------------------------------------------------------------
   PROCEDURE modifier_statut ( p_codchr     IN  VARCHAR2,
				  		  	   p_statut     IN  VARCHAR2,
                               p_nbcurseur  OUT INTEGER,
                               p_message    OUT VARCHAR2
                             );

-- ----------------------------------------------------------------------------------
-- Procédure qui insert une nouvelle erreur de chargement de table de répartition
-- ----------------------------------------------------------------------------------
   PROCEDURE insert_erreur ( p_codchr      	IN  RJH_CHARGEMENT.CODCHR%TYPE,
				  		  	p_numligne     	IN  NUMBER,
                            p_ligne     	IN  VARCHAR2,
                           	p_erreur     	IN  VARCHAR2,
                            p_nbcurseur  	OUT INTEGER,
                            p_message    	OUT VARCHAR2
                          );

-- ----------------------------------------------------------------------
-- Procédure qui controle qu'une ligne du fichier chargé est conforme
-- ----------------------------------------------------------------------
   PROCEDURE test_ligne_rjh ( p_codrep      IN  RJH_CHARGEMENT.CODREP%TYPE,
				  		  	  p_moisrep     IN  VARCHAR2,
                              p_codcamo     IN  VARCHAR2,
                           	  p_pid     	IN  VARCHAR2,
                              p_nbcurseur  	OUT INTEGER,
                              p_message    	OUT VARCHAR2,
                              p_info    	OUT VARCHAR2,
                              p_erreur    	OUT VARCHAR2
                            );

-- -----------------------------------------------------------------------------------
-- Procédure qui supprime le détail d'une table de répartition pour un mois donné
-- -----------------------------------------------------------------------------------
   PROCEDURE delete_detail ( p_codrep    IN  RJH_TABREPART_DETAIL.CODREP%TYPE,
                             p_moisrep   IN  VARCHAR2,
                          	 p_aff_msg   IN  VARCHAR2,
							 p_typtab    IN  VARCHAR2,
                             p_nbcurseur OUT INTEGER,
                             p_message   OUT VARCHAR2
                           );


-- ----------------------------------------------------------------------
-- Procédure qui insert une ligne dans la table DETAIL
-- ----------------------------------------------------------------------
   PROCEDURE insert_detail ( p_codrep      	IN  RJH_TABREPART_DETAIL.CODREP%TYPE,
				  		  	 p_moisrep     	IN  VARCHAR2,
                             p_pid     	    IN  RJH_TABREPART_DETAIL.PID%TYPE,
                           	 p_taux     	IN  VARCHAR2,
                           	 p_liblignerep  IN  RJH_TABREPART_DETAIL.LIBLIGNEREP%TYPE,
							 p_typtab       IN  VARCHAR2,
                             p_nbcurseur  	OUT INTEGER,
                             p_message    	OUT VARCHAR2
                           );


-- ----------------------------------------------------------------------
-- Procédure qui duplique le dernier mois saisi
-- ----------------------------------------------------------------------
   PROCEDURE dupliquer_detail ( p_codrep      	IN  RJH_TABREPART_DETAIL.CODREP%TYPE,
				  		  	    p_moisrep     	IN  VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                              );

-- ----------------------------------------------------------------------
-- Procédure qui recherche l'exercice courant
-- ----------------------------------------------------------------------
   PROCEDURE get_exercice (  p_nbcurseur  	OUT INTEGER,
                             p_message    	OUT VARCHAR2,
                             p_exercice    	OUT INTEGER
                           );

END PACK_RJH_LOAD_TR;
/

CREATE OR REPLACE PACKAGE BODY PACK_RJH_LOAD_TR AS

-- ----------------------------------------------------------------------
-- Procédure qui insert un nouveau chargement de table de répartition
-- ----------------------------------------------------------------------
PROCEDURE insert_table ( p_codrep      	IN  RJH_CHARGEMENT.CODREP%TYPE,
				  		 p_moisrep     	IN  VARCHAR2,
                         p_fichier     	IN  RJH_CHARGEMENT.FICHIER%TYPE,
                         p_userid     	IN  VARCHAR2,
                         p_nbcurseur  	OUT INTEGER,
                         p_message    	OUT VARCHAR2,
                         p_codchr    	OUT VARCHAR2
                       ) IS
     l_msg 		   VARCHAR2(1024);
	 l_next_codchr NUMBER;
	 l_idarpege    VARCHAR2(20);
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';
	l_idarpege := PACK_GLOBAL.lire_globaldata(p_userid).idarpege;

	BEGIN
		select nvl(max(codchr),0)+1
		  into l_next_codchr
		  from RJH_CHARGEMENT;

   	    INSERT INTO RJH_CHARGEMENT (
			   codchr,
	    	   codrep,
 			   moisrep,
 			   fichier,
 			   statut,
			   datechg,
			   userid)
        VALUES (
		   	   l_next_codchr,
		   	   p_codrep,
		   	   to_date(p_moisrep,'mm/yyyy'),
		   	   p_fichier,
			   0,
			   sysdate(),
			   l_idarpege);

		p_codchr := to_char(l_next_codchr);
    EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		    pack_global.recuperer_message( 20008, '%s1', 'chargement '||l_next_codchr, NULL, l_msg);
            raise_application_error( -20008, l_msg );
        WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
    END;

END insert_table;



-- ----------------------------------------------------------------------
-- Procédure qui modifie le statut d'un nouveau chargement
-- ----------------------------------------------------------------------
PROCEDURE modifier_statut ( p_codchr     IN  VARCHAR2,
				  		  	p_statut     IN  VARCHAR2,
                            p_nbcurseur  OUT INTEGER,
                            p_message    OUT VARCHAR2
                          ) IS
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	update RJH_CHARGEMENT
	   set statut = to_number(p_statut)
	 where codchr = to_number(p_codchr);

END modifier_statut;




-- ----------------------------------------------------------------------------------
-- Procédure qui insert une nouvelle erreur de chargement de table de répartition
-- ----------------------------------------------------------------------------------
PROCEDURE insert_erreur ( p_codchr      IN  RJH_CHARGEMENT.CODCHR%TYPE,
				  		  p_numligne    IN  NUMBER,
                          p_ligne     	IN  VARCHAR2,
                          p_erreur     	IN  VARCHAR2,
                          p_nbcurseur  	OUT INTEGER,
                          p_message    	OUT VARCHAR2
                        ) IS
     l_msg 		   VARCHAR2(1024);
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	BEGIN
   	    INSERT INTO RJH_CHARG_ERREUR (
			   codchr,
	    	   numligne,
 			   txtligne,
 			   liberr)
        VALUES (
		   	   p_codchr,
		   	   p_numligne,
		   	   p_ligne,
		   	   p_erreur);

    EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		    pack_global.recuperer_message( 20008, '%s1', 'chargement ', NULL, l_msg);
            raise_application_error( -20008, l_msg );
        WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
    END;

END insert_erreur;






-- ----------------------------------------------------------------------
-- Procédure qui control qu'une ligne du fichier chargé est conforme
-- ----------------------------------------------------------------------
PROCEDURE test_ligne_rjh ( p_codrep      IN  RJH_CHARGEMENT.CODREP%TYPE,
				  		   p_moisrep     IN  VARCHAR2,
                           p_codcamo     IN  VARCHAR2,
                           p_pid     	 IN  VARCHAR2,
                           p_nbcurseur   OUT INTEGER,
                           p_message     OUT VARCHAR2,
                           p_info    	 OUT VARCHAR2,
                           p_erreur    	 OUT VARCHAR2
                         ) IS
     l_msg 		      VARCHAR2(1024);
     l_nb_lign_in_tab NUMBER;
	 l_pid            LIGNE_BIP.PID%TYPE;
	 l_codrep         LIGNE_BIP.CODREP%TYPE;
	 l_typproj        LIGNE_BIP.TYPPROJ%TYPE;
	 l_codcamo        LIGNE_BIP.CODCAMO%TYPE;
	 l_topfer         LIGNE_BIP.TOPFER%TYPE;
	 l_datedebut      LIGNE_BIP.PDATDEBPRE%TYPE;
	 l_cdateferm      CENTRE_ACTIVITE.CDATEFERM%TYPE;
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message   := '';
	p_info      := 'false';
	p_erreur    := 'false';


	-- --------------------------------
	--    Test existance ligne BIP
	-- --------------------------------
	BEGIN
	    SELECT PID, CODREP, TYPPROJ, CODCAMO, TOPFER, l.PDATDEBPRE
		  INTO l_pid, l_codrep, l_typproj, l_codcamo, l_topfer, l_datedebut
		  FROM LIGNE_BIP l
		 WHERE l.pid = p_pid;

		-- Test sur le type de la ligne
		if (l_typproj!=9) then
		    pack_global.recuperer_message( 21037, null, null, NULL, l_msg);
			if (length(p_message)>0) then
			    p_message := p_message || '</li><li>';
			end if;
			p_message := p_message || l_msg;
			p_erreur := 'true';
		end if;

		-- Test si la ligne BIP est fermé
		if (l_topfer <> 'N') then
		    pack_global.recuperer_message( 20371, '%s1', p_pid, NULL, l_msg);
			if (length(p_message)>0) then
			    p_message := p_message || '</li><li>';
			end if;
			p_message := p_message || l_msg;
			p_erreur := 'true';
		end if;

		-- Test si la ligne BIP est ouverte
		if (l_datedebut > to_date(p_moisrep,'mm/yyyy') ) then
		    pack_global.recuperer_message( 21041, null, null, NULL, l_msg);
			if (length(p_message)>0) then
			    p_message := p_message || '</li><li>';
			end if;
			p_message := p_message || l_msg;
			p_info := 'true';
		end if;

		-- Test si la ligne BIP n'est pas déjà dans une autre table de répartition
		BEGIN
		    SELECT count(*)
			  INTO l_nb_lign_in_tab
			  FROM RJH_TABREPART_DETAIL d
			 WHERE d.PID     = p_pid
			   AND d.CODREP != p_codrep
			   AND d.MOISREP = to_date(p_moisrep, 'mm/yyyy');

			if (l_nb_lign_in_tab>0) then
			    pack_global.recuperer_message( 21038, '%s1', l_codrep, NULL, l_msg);
				if (length(p_message)>0) then
				    p_message := p_message || '</li><li>';
				end if;
				p_message := p_message || l_msg;
				p_info := 'true';
			end if;
		END;


		-- Test CA fichier = CA ligne BIP
		if (to_char(l_codcamo) <> p_codcamo) then
		    pack_global.recuperer_message( 21040, null, null, NULL, l_msg);
			if (length(p_message)>0) then
			    p_message := p_message || '</li><li>';
			end if;
			p_message := p_message || l_msg;
			p_info := 'true';
		end if;


		BEGIN
		    SELECT cdateferm
			  INTO l_cdateferm
			  FROM CENTRE_ACTIVITE c
			 WHERE c.CODCAMO = p_codcamo;

			-- Test sur le type de la ligne
			if (to_date(p_moisrep,'mm/yyyy') > l_cdateferm) then
			    pack_global.recuperer_message( 21039, null, null, NULL, l_msg);
				if (length(p_message)>0) then
				    p_message := p_message || '</li><li>';
				end if;
				p_message := p_message || l_msg;
				p_info := 'true';
			end if;

	    EXCEPTION
	      	WHEN NO_DATA_FOUND THEN
			    pack_global.recuperer_message( 21034, '%s1', 'centre d''activité', NULL, l_msg);
				if (length(p_message)>0) then
				    p_message := p_message || '</li><li>';
				end if;
				p_message := p_message || l_msg;
				p_erreur := 'true';
	            return;
	        WHEN OTHERS THEN
	            raise_application_error( -20997, SQLERRM);
	    END;

    EXCEPTION
      	WHEN NO_DATA_FOUND THEN
		    pack_global.recuperer_message( 21034, '%s1', 'ligne BIP', NULL, l_msg);
			if (length(p_message)>0) then
			    p_message := p_message || '</li><li>';
			end if;
			p_message := p_message || l_msg;
			p_erreur := 'true';
            return;
        WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
    END;

END test_ligne_rjh;




-- -----------------------------------------------------------------------------------
-- Procédure qui supprime le détail d'une table de répartition pour un mois donné
-- -----------------------------------------------------------------------------------
PROCEDURE delete_detail ( p_codrep    IN  RJH_TABREPART_DETAIL.CODREP%TYPE,
                          p_moisrep   IN  VARCHAR2,
                          p_aff_msg   IN  VARCHAR2,
						  p_typtab    IN  VARCHAR2,
                          p_nbcurseur OUT INTEGER,
                          p_message   OUT VARCHAR2
                        ) IS
	l_msg VARCHAR2(1024);
    referential_integrity EXCEPTION;
    PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	BEGIN
		-- suppression de la table DETAIL
	    DELETE FROM RJH_TABREPART_DETAIL
		 WHERE codrep = p_codrep
		   AND moisrep = to_date(p_moisrep, 'mm/yyyy')
		   AND typtab = p_typtab;

		if (p_aff_msg='OUI') then
	        pack_global.recuperer_message( 20007, '%s1', 'La table de répartition de type '||p_typtab||' pour le mois de '||p_moisrep||' a été ', NULL, l_msg);
			p_message := l_msg;
		end if;

    EXCEPTION
		WHEN referential_integrity THEN
            -- habiller le msg erreur
            pack_global.recuperation_integrite(-2292);
		WHEN OTHERS THEN
		    raise_application_error( -20997, SQLERRM);
    END;

END delete_detail;



-- ----------------------------------------------------------------------
-- Procédure qui insert une ligne dans la table DETAIL
-- ----------------------------------------------------------------------
PROCEDURE insert_detail ( p_codrep      	IN  RJH_TABREPART_DETAIL.CODREP%TYPE,
				  		  p_moisrep     	IN  VARCHAR2,
                          p_pid     	    IN  RJH_TABREPART_DETAIL.PID%TYPE,
                          p_taux     	    IN  VARCHAR2,
                          p_liblignerep     IN  RJH_TABREPART_DETAIL.LIBLIGNEREP%TYPE,
						  p_typtab          IN  VARCHAR2,
                          p_nbcurseur  	    OUT INTEGER,
                          p_message    	    OUT VARCHAR2
                       ) IS
     l_msg 		   VARCHAR2(1024);
	 l_next_codchr NUMBER;
	 l_idarpege    VARCHAR2(20);
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	BEGIN
   	    INSERT INTO RJH_TABREPART_DETAIL (
			   codrep,
	    	   moisrep,
 			   pid,
 			   tauxrep,
 			   liblignerep,
			   typtab)
        VALUES (
		   	   p_codrep,
		   	   to_date(p_moisrep,'mm/yyyy'),
		   	   p_pid,
			   to_number(p_taux),
			   p_liblignerep,
			   p_typtab);

    EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		    pack_global.recuperer_message( 20009, '%s1', p_pid, NULL, l_msg);
			p_message := l_msg;
        WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
    END;

END insert_detail;



-- ----------------------------------------------------------------------
-- Procédure qui duplique le dernier mois saisi
-- ----------------------------------------------------------------------
PROCEDURE dupliquer_detail ( p_codrep      	IN  RJH_TABREPART_DETAIL.CODREP%TYPE,
				  		  	 p_moisrep     	IN  VARCHAR2,
                             p_nbcurseur  	OUT INTEGER,
                             p_message    	OUT VARCHAR2
                           ) IS
     l_msg 		   VARCHAR2(1024);
	 l_nb_enr      NUMBER;
	 l_last_month  DATE;
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	BEGIN
	    SELECT count(*)
		  INTO l_nb_enr
		  FROM RJH_TABREPART_DETAIL
		 WHERE codrep = p_codrep
		   AND moisrep = to_date(p_moisrep, 'mm/yyyy');

		if (l_nb_enr>0) then
			-- Le mois sélectionné est déjà chargé, veuillez d'abord le supprimer
			pack_global.recuperer_message( 20028, NULL, NULL, NULL, l_msg);
	        raise_application_error( -20028, l_msg );
		end if;

	END;

	BEGIN
	    SELECT max(moisrep)
		  INTO l_last_month
		  FROM RJH_TABREPART_DETAIL
		 WHERE codrep = p_codrep;

		if (l_last_month is null) then
		    pack_global.recuperer_message( 20010, NULL, NULL, NULL, l_msg);
            raise_application_error( -20010, l_msg );
		end if;

		BEGIN

	   	    INSERT INTO RJH_TABREPART_DETAIL (
				   codrep,
		    	   moisrep,
	 			   pid,
	 			   tauxrep,
	 			   liblignerep)
			SELECT p_codrep,
			   	   to_date(p_moisrep,'mm/yyyy'),
			   	   pid,
				   tauxrep,
				   liblignerep
			  FROM RJH_TABREPART_DETAIL
			 WHERE codrep = p_codrep
			   AND moisrep = l_last_month;

	    EXCEPTION
	        WHEN OTHERS THEN
	            raise_application_error( -20997, SQLERRM);
	    END;

    EXCEPTION
      	WHEN NO_DATA_FOUND THEN
		    pack_global.recuperer_message( 20010, NULL, NULL, NULL, l_msg);
            raise_application_error( -20010, l_msg );
        WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
    END;

END dupliquer_detail;



-- ----------------------------------------------------------------------
-- Procédure qui recherche l'exercice courant
-- ----------------------------------------------------------------------
PROCEDURE get_exercice ( p_nbcurseur  	OUT INTEGER,
                         p_message    	OUT VARCHAR2,
                         p_exercice    	OUT INTEGER
                       ) IS
	l_annee NUMBER;
BEGIN

	SELECT to_number(to_char(DATDEBEX,'yyyy'))
	  INTO l_annee
	  FROM DATDEBEX;

    p_exercice := l_annee;

EXCEPTION
   	WHEN NO_DATA_FOUND THEN
		p_message := 'Année de l''exercice inconnu.';
    WHEN OTHERS THEN
        raise_application_error( -20997, SQLERRM);

END get_exercice;



END PACK_RJH_LOAD_TR;
/
CREATE OR REPLACE PACKAGE     PACK_RJH_RAPPORT AS

   -- Définition curseur sur la table RJH_CHARGEMENT
   TYPE LoadTableRepart_ViewType IS RECORD ( codchr  RJH_CHARGEMENT.CODCHR%TYPE,
   								 		     codrep  RJH_CHARGEMENT.CODREP%TYPE,
   							 		   	 	 moisrep VARCHAR2(10),
										 	 fichier RJH_CHARGEMENT.FICHIER%TYPE,
										 	 statut  RJH_CHARGEMENT.STATUT%TYPE,
										 	 datechg VARCHAR2(20)
									       );

   TYPE load_tablerepartCurType IS REF CURSOR RETURN LoadTableRepart_ViewType;

-- ----------------------------------------------------------------------
-- Procédure qui ramène tous les chargements pour un utilisateur
-- ----------------------------------------------------------------------
   PROCEDURE select_all_rapport ( p_userid     IN     VARCHAR2,
							      p_curseur    IN OUT load_tablerepartCurType,
                               	  p_nbcurseur     OUT INTEGER,
                               	  p_message       OUT VARCHAR2
                          		);

-- ----------------------------------------------------------------------
-- Procédure qui ramène un chargement
-- ----------------------------------------------------------------------
   PROCEDURE select_rapport ( p_codchr     IN     NUMBER,
							  p_curseur    IN OUT load_tablerepartCurType,
                              p_nbcurseur     OUT INTEGER,
                              p_message       OUT VARCHAR2
                          	);

-- ----------------------------------------------------------------------------------------
-- Procédure qui supprime le rapport sélectionné
-- ----------------------------------------------------------------------------------------
   PROCEDURE delete_rapport ( p_codchr      IN  NUMBER,
   			 				  p_userid     	IN  VARCHAR2,
                              p_nbcurseur  	OUT INTEGER,
                              p_message    	OUT VARCHAR2
                          	);

-- ----------------------------------------------------------------------------------------
-- Procédure qui supprime tous les chargments pour un utilisateur sauf ceux du jour
-- ----------------------------------------------------------------------------------------
   PROCEDURE delete_all_rapport ( p_userid     	IN  VARCHAR2,
                            	  p_nbcurseur  	OUT INTEGER,
                            	  p_message    	OUT VARCHAR2
                          		);



-- Définition curseur sur la table RJH_TABREPART_DETAIL
   TYPE TableRepartDetail_ViewType IS RECORD ( codrep  RJH_TABREPART_DETAIL.CODREP%TYPE,
   							 		   	 	   moisrep VARCHAR2(10),
										 	   pid     RJH_TABREPART_DETAIL.PID%TYPE,
										 	   libPID  LIGNE_BIP.PNOM%TYPE,
   							 		   	 	   tauxrep VARCHAR2(10),
										 	   libelle RJH_TABREPART_DETAIL.LIBLIGNEREP%TYPE,
										 	   codcamo LIGNE_BIP.CODCAMO%TYPE,
										 	   libCA   CENTRE_ACTIVITE.CLIBRCA%TYPE
									         );

   TYPE tablerepartDetailCurType IS REF CURSOR RETURN TableRepartDetail_ViewType;
-- ----------------------------------------------------------------------
-- Procédure qui ramène le détail d'une table
-- ----------------------------------------------------------------------
   PROCEDURE select_detail ( p_codrep     IN     VARCHAR2,
							 p_moisrep    IN     VARCHAR2,
							 p_curseur    IN OUT tablerepartDetailCurType,
                             p_nbcurseur     OUT INTEGER,
                             p_message       OUT VARCHAR2
                          	);



-- Définition curseur sur la table RJH_CHARGEMENT
   TYPE LoadTableRepartErreur_ViewType IS RECORD ( codchr    RJH_CHARG_ERREUR.CODCHR%TYPE,
   								 		     	   numligne  RJH_CHARG_ERREUR.NUMLIGNE%TYPE,
   								 		     	   txtligne  RJH_CHARG_ERREUR.TXTLIGNE%TYPE,
   								 		     	   liberr    RJH_CHARG_ERREUR.LIBERR%TYPE
									       		 );

   TYPE load_Erreur_tablerepartCurType IS REF CURSOR RETURN LoadTableRepartErreur_ViewType;
-- ----------------------------------------------------------------------
-- Procédure qui ramène les erreurs d'un chargement
-- ----------------------------------------------------------------------
   PROCEDURE select_erreur ( p_codchr     IN     NUMBER,
					         p_curseur    IN OUT load_Erreur_tablerepartCurType,
                             p_nbcurseur     OUT INTEGER,
                             p_message       OUT VARCHAR2
                           );


END PACK_RJH_RAPPORT;
/

CREATE OR REPLACE PACKAGE BODY     PACK_RJH_RAPPORT AS



-- ----------------------------------------------------------------------
-- Procédure qui ramène tous les chargements pour un utilisateur
-- ----------------------------------------------------------------------
PROCEDURE select_all_rapport ( p_userid   IN     VARCHAR2,
							   p_curseur  IN OUT load_tablerepartCurType,
                               p_nbcurseur         OUT INTEGER,
                               p_message           OUT VARCHAR2
                              ) IS

	l_msg    VARCHAR2(1024);
    l_userid VARCHAR2(20);
BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
    p_nbcurseur := 1;
    p_message := '';

   	-- Récupérer l'identifiant de l'utilisateur
   	l_userid := pack_global.lire_globaldata(p_userid).idarpege;

	OPEN p_curseur FOR
	    SELECT codchr, codrep, to_char(moisrep,'mm/yyyy'), fichier, statut, to_char(datechg,'dd/mm/yyyy HH24:mi')
	      FROM RJH_CHARGEMENT
	     WHERE userid = l_userid
	     ORDER BY datechg desc;


EXCEPTION
    WHEN OTHERS THEN
		raise_application_error(-20997, SQLERRM);

END select_all_rapport;




-- ----------------------------------------------------------------------
-- Procédure qui ramène un chargement
-- ----------------------------------------------------------------------
PROCEDURE select_rapport ( p_codchr     IN     NUMBER,
						   p_curseur    IN OUT load_tablerepartCurType,
                           p_nbcurseur     OUT INTEGER,
                           p_message       OUT VARCHAR2
                         ) IS
	l_msg    VARCHAR2(1024);
BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
    p_nbcurseur := 1;
    p_message := '';

	OPEN p_curseur FOR
	    SELECT codchr, codrep, to_char(moisrep,'mm/yyyy'), fichier, statut, to_char(datechg,'dd/mm/yyyy HH24:mi')
	      FROM RJH_CHARGEMENT
	     WHERE codchr = p_codchr;

EXCEPTION
    WHEN OTHERS THEN
		raise_application_error(-20997, SQLERRM);

END select_rapport;




-- ----------------------------------------------------------------------------------------
-- Procédure qui supprime le rapport sélectionné
-- ----------------------------------------------------------------------------------------
PROCEDURE delete_rapport ( p_codchr     IN  NUMBER,
   			 			   p_userid     IN  VARCHAR2,
                           p_nbcurseur  OUT INTEGER,
                           p_message    OUT VARCHAR2
                        ) IS
	l_msg VARCHAR2(1024);
    referential_integrity EXCEPTION;
    PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	BEGIN
		-- suppression de la table des erreurs
	    DELETE FROM RJH_CHARG_ERREUR
		 WHERE codchr = p_codchr;

		-- suppression de la table des chargements
	    DELETE FROM RJH_CHARGEMENT
		 WHERE codchr = p_codchr;

    EXCEPTION
		WHEN referential_integrity THEN
            -- habiller le msg erreur
            pack_global.recuperation_integrite(-2292);
		WHEN OTHERS THEN
		    raise_application_error( -20997, SQLERRM);
    END;

END delete_rapport;




-- ----------------------------------------------------------------------------------------
-- Procédure qui supprime tous les chargments pour un utilisateur sauf ceux du jour
-- ----------------------------------------------------------------------------------------
PROCEDURE delete_all_rapport ( p_userid     	IN  VARCHAR2,
                           	   p_nbcurseur  	OUT INTEGER,
                           	   p_message    	OUT VARCHAR2
							 ) IS
	l_msg VARCHAR2(1024);
    referential_integrity EXCEPTION;
    PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
    l_userid VARCHAR2(255);
BEGIN
   	-- Récupérer l'identifiant de l'utilisateur
   	l_userid := pack_global.lire_globaldata(p_userid).idarpege;

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	BEGIN
		-- suppression de la table des erreurs
	    DELETE FROM RJH_CHARG_ERREUR
		 WHERE codchr in (SELECT codchr
		                    FROM RJH_CHARGEMENT
						   WHERE userid = l_userid
						     AND trunc(datechg) < trunc(sysdate) );

		-- suppression de la table des chargements
	    DELETE FROM RJH_CHARGEMENT
	     WHERE userid = l_userid
		   AND trunc(datechg) < trunc(sysdate);

    EXCEPTION
		WHEN referential_integrity THEN
            -- habiller le msg erreur
            pack_global.recuperation_integrite(-2292);
		WHEN OTHERS THEN
		    raise_application_error( -20997, SQLERRM);
    END;

END delete_all_rapport;




-- ----------------------------------------------------------------------
-- Procédure qui ramène le détail d'une table
-- ----------------------------------------------------------------------
PROCEDURE select_detail ( p_codrep     IN     VARCHAR2,
						  p_moisrep    IN     VARCHAR2,
						  p_curseur    IN OUT tablerepartDetailCurType,
                          p_nbcurseur     OUT INTEGER,
                          p_message       OUT VARCHAR2
                        ) IS
BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
    p_nbcurseur := 1;
    p_message := '';

	OPEN p_curseur FOR
	    SELECT d.CODREP, d.MOISREP, d.PID, l.PNOM , d.TAUXREP, d.LIBLIGNEREP , l.CODCAMO, c.CLIBRCA
	      FROM RJH_TABREPART_DETAIL d, LIGNE_BIP l, CENTRE_ACTIVITE c
	     WHERE d.codrep = p_codrep
		   AND to_char(d.moisrep,'mm/yyyy') = p_moisrep
		   AND d.PID = l.PID
		   AND l.CODCAMO = c.CODCAMO
	     ORDER BY d.LIBLIGNEREP;

EXCEPTION
    WHEN OTHERS THEN
		raise_application_error(-20997, SQLERRM);

END select_detail;





-- ----------------------------------------------------------------------
-- Procédure qui ramène les erreurs d'un chargement
-- ----------------------------------------------------------------------
PROCEDURE select_erreur ( p_codchr     IN     NUMBER,
				          p_curseur    IN OUT load_Erreur_tablerepartCurType,
                          p_nbcurseur     OUT INTEGER,
                          p_message       OUT VARCHAR2
                        ) IS
BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
    p_nbcurseur := 1;
    p_message := '';

	OPEN p_curseur FOR
	    SELECT e.CODCHR, e.NUMLIGNE, e.TXTLIGNE, e.LIBERR
	      FROM RJH_CHARG_ERREUR e
	     WHERE e.CODCHR = p_codchr
	     ORDER BY e.NUMLIGNE;

EXCEPTION
    WHEN OTHERS THEN
		raise_application_error(-20997, SQLERRM);

END select_erreur;

END PACK_RJH_RAPPORT;
/
CREATE OR REPLACE PACKAGE Pack_Rjh_Tablerepart AS

   -- Définition curseur sur la table RJH_TABREPART

   TYPE TableRepart_ViewType IS RECORD ( codrep RJH_TABREPART.CODREP%TYPE,
   							 		   	 librep RJH_TABREPART.LIBREP%TYPE,
										 coddir RJH_TABREPART.CODREP%TYPE,
										 libdir DIRECTIONS.LIBDIR%TYPE,
										 flagactif RJH_TABREPART.FLAGACTIF%TYPE
									   );

   TYPE tablerepartCurType_Char IS REF CURSOR RETURN TableRepart_ViewType;

-- ----------------------------------------------------------------
-- Procédure qui ramène une table de répartition suivant son code
-- ----------------------------------------------------------------
   PROCEDURE select_table ( p_codrep	   	 IN VARCHAR2,
                            p_userid         IN VARCHAR2,
                            p_curTableRepart IN OUT tablerepartCurType_Char ,
                            p_nbcurseur         OUT INTEGER,
                            p_message           OUT VARCHAR2
                          );

-- ----------------------------------------------------------------
-- Procédure qui insert une table de répartition
-- ----------------------------------------------------------------
   PROCEDURE insert_table ( p_codrep      	IN  RJH_TABREPART.CODREP%TYPE,
				  		  	p_librep     	IN  RJH_TABREPART.LIBREP%TYPE,
                            p_coddir     	IN  RJH_TABREPART.CODDIR%TYPE,
                            p_flagactif   	IN  RJH_TABREPART.FLAGACTIF%TYPE,
                           	p_userid     	IN  VARCHAR2,
                            p_nbcurseur  	OUT INTEGER,
                            p_message    	OUT VARCHAR2
                          );

-- ----------------------------------------------------------------
-- Procédure qui met à jour une table de répartition
-- ----------------------------------------------------------------
   PROCEDURE update_table ( p_codrep      	IN  RJH_TABREPART.CODREP%TYPE,
				  		  	p_librep     	IN  RJH_TABREPART.LIBREP%TYPE,
                            p_coddir     	IN  RJH_TABREPART.CODDIR%TYPE,
                            p_flagactif   	IN  RJH_TABREPART.FLAGACTIF%TYPE,
                           	p_userid     	IN  VARCHAR2,
                            p_nbcurseur  	OUT INTEGER,
                            p_message    	OUT VARCHAR2
                          );

-- ----------------------------------------------------------------
-- Procédure qui supprime une table de répartition
-- ----------------------------------------------------------------
   PROCEDURE delete_table ( p_codrep    IN  RJH_TABREPART.CODREP%TYPE,
                            p_userid    IN  VARCHAR2,
                            p_nbcurseur OUT INTEGER,
                            p_message   OUT VARCHAR2
                          );


-- ----------------------------------------------------------------
-- Procédure qui mis à jour les proposés
-- ----------------------------------------------------------------
   PROCEDURE update_propose_rjh ( p_annee      	IN  INTEGER,
   			 					  											p_coddir IN VARCHAR,
																			p_mois_table IN VARCHAR,
																			p_nbcurseur  	OUT INTEGER,
                            												p_message    	OUT VARCHAR2
                         												   );

-- -----------------------------------------------------------------------
-- Procédure qui initialise les budgets Arbitrés Proposés sur les types 9.
-- -----------------------------------------------------------------------
   PROCEDURE update_arbitre_rjh ( p_annee      	IN  INTEGER,
   			 	  p_coddir 	IN  VARCHAR,
				  p_mois_table 	IN  VARCHAR,
				  p_nbcurseur  	OUT INTEGER,
                            	  p_message    	OUT VARCHAR2
                         		);

END Pack_Rjh_Tablerepart;
/

CREATE OR REPLACE PACKAGE BODY Pack_Rjh_Tablerepart AS


VIOLATION_CONSTRAINT_UNIQUE EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( VIOLATION_CONSTRAINT_UNIQUE, -00001 );


-- ----------------------------------------------------------------
-- Procédure qui ramène une table de répartition suivant son code
-- ----------------------------------------------------------------
PROCEDURE select_table ( p_codrep         IN VARCHAR2,
                         p_userid         IN VARCHAR2,
                         p_curTableRepart IN OUT tablerepartCurType_Char ,
                         p_nbcurseur         OUT INTEGER,
                         p_message           OUT VARCHAR2
                       ) IS
	l_msg VARCHAR2(1024);
BEGIN

    -- Positionner le nb de curseurs ==> 1
    -- Initialiser le message retour
    p_nbcurseur := 1;
    p_message := '';

	BEGIN
	    OPEN p_curTableRepart FOR
	        SELECT r.codrep,
	               r.librep,
	               r.coddir,
	               d.libdir,
				   r.flagactif
	          FROM RJH_TABREPART r, DIRECTIONS d
	         WHERE r.CODDIR = d.CODDIR
			   AND r.CODREP = p_codrep;

	EXCEPTION
	   WHEN OTHERS THEN
		   RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;

	-- En cas d'absence
    Pack_Global.recuperer_message( 21034, '%s1', 'table de répartition', NULL, l_msg);
    p_message := l_msg;

END select_table;





-- ----------------------------------------------------------------
-- Procédure qui insert une table de répartition
-- ----------------------------------------------------------------
PROCEDURE insert_table ( p_codrep      	IN  RJH_TABREPART.CODREP%TYPE,
			  		  	 p_librep     	IN  RJH_TABREPART.LIBREP%TYPE,
                         p_coddir     	IN  RJH_TABREPART.CODDIR%TYPE,
                         p_flagactif   	IN  RJH_TABREPART.FLAGACTIF%TYPE,
                         p_userid     	IN  VARCHAR2,
                         p_nbcurseur  	OUT INTEGER,
                         p_message    	OUT VARCHAR2
                       ) IS

     l_msg VARCHAR2(1024);
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	BEGIN
   	    INSERT INTO RJH_TABREPART (
	    	   codrep,
 			   librep,
 			   coddir,
 			   flagactif)
        VALUES (
		   	   p_codrep,
		   	   p_librep,
		   	   p_coddir,
		   	   p_flagactif);

	    -- Table de répartiton p_codrep créée'
        Pack_Global.recuperer_message( 21035, '%s1', 'Table de répartition '||p_codrep, NULL, l_msg);
    EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		    Pack_Global.recuperer_message( 20001, NULL, NULL, NULL, l_msg);
            RAISE_APPLICATION_ERROR( -20001, l_msg );
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
    END;

END insert_table;




-- ----------------------------------------------------------------
-- Procédure qui met à jour une table de répartition
-- ----------------------------------------------------------------
PROCEDURE update_table ( p_codrep      	IN  RJH_TABREPART.CODREP%TYPE,
				  		 p_librep     	IN  RJH_TABREPART.LIBREP%TYPE,
                         p_coddir     	IN  RJH_TABREPART.CODDIR%TYPE,
                         p_flagactif   	IN  RJH_TABREPART.FLAGACTIF%TYPE,
                         p_userid     	IN  VARCHAR2,
                         p_nbcurseur  	OUT INTEGER,
                         p_message    	OUT VARCHAR2
                       ) IS

	l_msg VARCHAR2(1024);
	l_codcamo CENTRE_ACTIVITE.codcamo%TYPE;
BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- initialiser le message retour
	p_nbcurseur := 0;
	p_message := '';

	BEGIN

        UPDATE RJH_TABREPART
		   SET librep    = p_librep,
		   	   coddir    = p_coddir,
			   flagactif = p_flagactif
		 WHERE codrep = p_codrep;

    EXCEPTION
		WHEN OTHERS THEN
		    Pack_Global.recuperer_message( 20006, '%s1', 'Table de répartition', NULL, l_msg);
	        RAISE_APPLICATION_ERROR( -20006, l_msg );
	END;

END update_table;




-- ----------------------------------------------------------------
-- Procédure qui supprime une table de répartition
-- ----------------------------------------------------------------
PROCEDURE delete_table ( p_codrep    IN  RJH_TABREPART.CODREP%TYPE,
                         p_userid    IN  VARCHAR2,
                         p_nbcurseur OUT INTEGER,
                         p_message   OUT VARCHAR2
                       ) IS

	l_msg VARCHAR2(1024);
	nb_ligne_bip NUMBER;
    referential_integrity EXCEPTION;
    PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

BEGIN

    -- Positionner le nb de curseurs ==> 0
    -- Initialiser le message retour
    p_nbcurseur := 0;
    p_message := '';

	-- test si une ligne bip est reliée à la table on ne la supprime pas
	BEGIN
	    SELECT COUNT(*)
		  INTO nb_ligne_bip
		  FROM LIGNE_BIP
		 WHERE codrep = p_codrep;

		IF (nb_ligne_bip > 0) THEN
		    -- Suppression interdite. Des lignes BIP sont rattachées à cette table.
			Pack_Global.recuperer_message( 21036, NULL, NULL, NULL, l_msg);
			p_message := l_msg;
		ELSE

    		BEGIN
				-- suppression de la table DETAIL
			    DELETE FROM RJH_TABREPART_DETAIL
				 WHERE codrep = p_codrep;

			    -- suppression de la table des erreurs de chargement
			    DELETE FROM RJH_CHARG_ERREUR e
				 WHERE e.codchr IN (SELECT c.codchr FROM RJH_CHARGEMENT c WHERE c.codrep = p_codrep);

			    -- suppression de la table des chargements
			    DELETE FROM RJH_CHARGEMENT
				 WHERE codrep = p_codrep;

			    -- suppression de la table de répartition
			    DELETE FROM RJH_TABREPART
				 WHERE codrep = p_codrep;
		    EXCEPTION
				WHEN referential_integrity THEN
		            -- habiller le msg erreur
		            Pack_Global.recuperation_integrite(-2292);
				WHEN OTHERS THEN
				    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
		    END;

			-- Table de répartiton p_coderep supprimée'
			Pack_Global.recuperer_message( 20007, '%s1', 'Table de répartition '||p_codrep, NULL, l_msg);
			p_message := l_msg;

		END IF;

	END;

END delete_table;



-- ----------------------------------------------------------------
-- Procédure qui mis à jour les proposés
-- ----------------------------------------------------------------
   PROCEDURE update_propose_rjh ( p_annee      	IN  INTEGER,
   			 					  											p_coddir IN VARCHAR,
																			p_mois_table IN VARCHAR,
																			p_nbcurseur  	OUT INTEGER,
                            												p_message    	OUT VARCHAR2
                        												   ) IS
		l_bpmontmo NUMBER(12,2);
		l_bpmontme NUMBER(12,2);

		l_date DATE;

		v_bpmontmo NUMBER(12,2);
		v_bpmontme NUMBER(12,2);

		l_count NUMBER;

--
--  Ramene toutes les tables de repartition qui ont la direction passée en parametre
		CURSOR cur_tab(c_coddir CHAR, c_mois_table CHAR) IS
                     SELECT DISTINCT codrep
					 FROM RJH_TABREPART_DETAIL
					 WHERE codrep IN ( SELECT codrep from RJH_TABREPART
					                   WHERE coddir = TO_NUMBER ( c_coddir )
					                  )
                     AND moisrep=TO_DATE(c_mois_table,'mm/yyyy')
                     AND TYPTAB='P'
					 ;

		CURSOR cur_prop(c_table_rep CHAR, c_mois_table CHAR) IS
                     SELECT
				 	 		pid,
							tauxrep
					 FROM RJH_TABREPART_DETAIL
					 WHERE CODREP=c_table_rep
                     AND MOISREP=TO_DATE(c_mois_table,'mm/yyyy')
                     AND TYPTAB='P'
					 ;

 BEGIN
 	SELECT SYSDATE INTO l_date FROM DUAL;

    -- Remet à zero tous les proposes des lignes T9 de la direction
    UPDATE BUDGET
    SET  bpmontmo = 0, bpmontme = 0, bpdate = l_date, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
    WHERE  pid IN ( SELECT pid FROM LIGNE_BIP
                    WHERE typproj = 9
                    AND codsg IN ( SELECT codsg FROM STRUCT_INFO
                    			   WHERE coddir = TO_NUMBER ( p_coddir )
					           	 )
					)
	AND annee = p_annee
	;
    COMMIT;


	-- Boucle sur toutes les tables de répartition
	FOR curseur_tab IN cur_tab(p_coddir, p_mois_table) LOOP

 		-- Recherche le proposé à répartir pour une table de répartition
	    SELECT SUM(b.BPMONTMO), SUM(b.BPMONTME) INTO l_bpmontmo, l_bpmontme
        FROM LIGNE_BIP l,BUDGET b
        WHERE l.CODREP=curseur_tab.codrep
        AND b.pid=l.pid
        AND b.ANNEE=p_annee
        AND l.codcamo=66666
        ;

		-- Boucle sur les lignes BIP de la table de répartition
	    FOR curseur_prop IN cur_prop(curseur_tab.codrep, p_mois_table) LOOP
			BEGIN

			-- Calcule le montant réparti
          	v_bpmontmo := l_bpmontmo * curseur_prop.tauxrep ;
          	v_bpmontme := l_bpmontme * curseur_prop.tauxrep ;

			-- Essaie d'insérer dans budget
			INSERT INTO BUDGET (
			 				  	 PID,
								 ANNEE,
								 BPMONTMO,
								 BPMONTME,
								 BPDATE,
								 FLAGLOCK
								)
             VALUES(
					     		curseur_prop.pid,
								p_annee,
					 			v_bpmontmo,
					 			v_bpmontme,
								l_date,
							    0
								);


			EXCEPTION

            WHEN VIOLATION_CONSTRAINT_UNIQUE THEN

			-- Fait la mise à jour dans budget en ajoutant les proposés
			-- aux proposés existants
                    UPDATE BUDGET
                    SET  bpmontmo = bpmontmo + v_bpmontmo, bpmontme = bpmontme + v_bpmontme, bpdate = l_date, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
                    WHERE  pid = curseur_prop.pid
					AND annee = p_annee ;

					END;


		END LOOP;

	END LOOP;

	Pack_Global.recuperer_message(21042, NULL,  NULL, NULL, p_message);
	COMMIT;


    EXCEPTION
    	WHEN OTHERS THEN
		    ROLLBACK;
        	RAISE_APPLICATION_ERROR( -20997, SQLERRM);



 END update_propose_rjh;

-- -----------------------------------------------------------------------
-- Procédure qui initialise les budgets Arbitrés Notifié sur les types 9.
-- -----------------------------------------------------------------------
   PROCEDURE update_arbitre_rjh ( p_annee      	IN  INTEGER,
   			 	  p_coddir 	IN VARCHAR,
				  p_mois_table 	IN VARCHAR,
				  p_nbcurseur  	OUT INTEGER,
                            	  p_message    	OUT VARCHAR2
                        		) IS
		l_anmont INTEGER;
		l_date DATE;
		v_anmont INTEGER(12,2);
		l_count NUMBER;

--
--  Ramene toutes les tables de repartition qui ont la  direction passée en parametre
		CURSOR cur_tab(c_coddir CHAR, c_mois_table CHAR) IS
                     SELECT DISTINCT codrep
		     FROM RJH_TABREPART_DETAIL
		     WHERE codrep IN ( SELECT codrep
		     			from RJH_TABREPART
			                WHERE coddir = TO_NUMBER ( c_coddir )
					                  )
                     AND moisrep=TO_DATE(c_mois_table,'mm/yyyy')
                     AND TYPTAB='A'
					 ;

		CURSOR cur_prop(c_table_rep CHAR, c_mois_table CHAR) IS
                     SELECT pid,
			    tauxrep
		     FROM RJH_TABREPART_DETAIL
		     WHERE CODREP=c_table_rep
                     AND MOISREP=TO_DATE(c_mois_table,'mm/yyyy')
                     AND TYPTAB='A'
					 ;

 BEGIN
 	SELECT SYSDATE INTO l_date FROM DUAL;

    -- Remet à zero tous les arbitres des lignes T9 de la direction
    UPDATE BUDGET
    SET  anmont = 0, apdate = l_date, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
    WHERE  pid IN ( SELECT pid FROM LIGNE_BIP
                    WHERE typproj = 9
                    AND codsg IN ( SELECT codsg FROM STRUCT_INFO
                    			   WHERE coddir = TO_NUMBER ( p_coddir )
					           	 )
					)
	AND annee = p_annee
	;
    COMMIT;


	-- Boucle sur toutes les tables de répartition
	FOR curseur_tab IN cur_tab(p_coddir, p_mois_table) LOOP

 		-- Recherche le proposé à répartir pour une table de répartition
	    SELECT SUM(b.ANMONT) INTO l_anmont
        FROM LIGNE_BIP l,BUDGET b
        WHERE l.CODREP=curseur_tab.codrep
        AND b.pid=l.pid
        AND b.ANNEE=p_annee
        AND l.codcamo=66666
        ;

		-- Boucle sur les lignes BIP de la table de répartition
	    FOR curseur_prop IN cur_prop(curseur_tab.codrep, p_mois_table) LOOP
			BEGIN

			-- Calcule le montant réparti
          	v_anmont := l_anmont * curseur_prop.tauxrep ;

			-- Essaie d'insérer dans budget
			INSERT INTO BUDGET (
			 				  	 PID,
								 ANNEE,
								 ANMONT,
								 APDATE,
								 FLAGLOCK
								)
             VALUES(
					     		curseur_prop.pid,
								p_annee,
					 			v_anmont,
								l_date,
							    0
								);


			EXCEPTION

            WHEN VIOLATION_CONSTRAINT_UNIQUE THEN

			-- Fait la mise à jour dans budget en ajoutant les arbitrés
			-- aux arbitrés existants
                    UPDATE BUDGET
                    SET  anmont = anmont + v_anmont, apdate = l_date, flaglock = DECODE(flaglock, 1000000, 0, flaglock + 1)
                    WHERE  pid = curseur_prop.pid
					AND annee = p_annee ;

					END;


		END LOOP;

	END LOOP;

	Pack_Global.recuperer_message(21050,  NULL, NULL, NULL, p_message);
	COMMIT;


    EXCEPTION
    	WHEN OTHERS THEN
		    ROLLBACK;
        	RAISE_APPLICATION_ERROR( -20997, SQLERRM);



 END update_arbitre_rjh;




END Pack_Rjh_Tablerepart;
/
CREATE OR REPLACE PACKAGE Pack_Rtfe AS




   -- ------------------------------------------------------------------------
   -- Nom        : estHabiliteMe
   -- Appel      : Appelé par la requette report
   -- Auteur     : BAA
   -- Decription : retourne OUI si bddpg_defaut et perim_me correspond bien à ses périmètres
   -- Paramètres : p_ident (IN) l'identifiant de la ressource
   -- 			   p_bddpg_defaut (IN) le bddpg par defaut de l'utilisateur
   --			   p_perim_me (IN) perimetre me
   -- Retour     : OUI ou NON
   -- ------------------------------------------------------------------------

   FUNCTION estHabiliteMe(p_ident IN VARCHAR2, p_bddpg_defaut IN VARCHAR2, p_perim_me IN VARCHAR2) RETURN VARCHAR2;



   -- ------------------------------------------------------------------------
   -- Nom        : bddpg_ress
   -- Auteur     : BAA
   -- Decription : retourne bddpg à partir des données de la bip
   -- Paramètres : p_ident (IN) l'identifiant de la ressource
   -- Retour     : bddpg sur 11 caracteres
   -- ------------------------------------------------------------------------

   FUNCTION bddpg_ress(p_ident IN VARCHAR2) RETURN VARCHAR2;



   -- ------------------------------------------------------------------------
   -- Nom        : tmp_saisie_realisee_seq
   -- Auteur     : BAA
   -- Decription : mise a jour de la table tmp_saisie_realisee
   --
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------
   FUNCTION tmp_saisie_realisee_seq RETURN NUMBER;




END Pack_Rtfe;
/

CREATE OR REPLACE PACKAGE BODY Pack_Rtfe AS



   -- ------------------------------------------------------------------------
   -- Nom        : estHabiliteMe
   -- Appel      : Appelé par la requette report
   -- Auteur     : BAA
   -- Decription : retourne OUI si bddpg_defaut et perim_me correspond bien à ses périmètres
   -- Paramètres : p_ident (IN) l'identifiant de la ressource
   -- 			   p_bddpg_defaut (IN) le bddpg par defaut de l'utilisateur
   --			   p_perim_me (IN) perimetre me
   -- Retour     : OUI ou NON
   -- ------------------------------------------------------------------------

   FUNCTION estHabiliteMe(p_ident IN VARCHAR2, p_bddpg_defaut IN VARCHAR2, p_perim_me IN VARCHAR2) RETURN VARCHAR2 IS

   l_hab 			CHAR(3);
   l_perim_me  		CHAR(11);
   l_tmp			CHAR(11);




   l_pos NUMBER(7);
   l_pos1 NUMBER(7);
   l_chaine VARCHAR2(4000);

   BEGIN

       l_hab:='OUI';

	   l_perim_me := bddpg_ress(p_ident);

	   DBMS_OUTPUT.PUT_LINE(l_perim_me);



	   --On verifie si le bddpg_defaut correspond à son codsg
	   IF(p_bddpg_defaut IS NOT NULL) AND (p_bddpg_defaut <> '') AND (SUBSTR(p_bddpg_defaut,1,9) <> SUBSTR(l_perim_me,1,9))THEN

	   		 RETURN 'NON';

	   ELSIF(SUBSTR(p_bddpg_defaut,10,2) <> '00') AND (SUBSTR(p_bddpg_defaut,10,2) <> SUBSTR(l_perim_me,10,2)) THEN

		     RETURN 'NON';

	   END IF;



       l_chaine := p_perim_me;

	   DBMS_OUTPUT.PUT_LINE('l_chaine '||l_chaine);


	  WHILE l_chaine IS NOT NULL LOOP

         l_tmp := SUBSTR(l_chaine,1,11);


		 IF(l_tmp<> '') AND (SUBSTR(l_tmp,1,9) <> SUBSTR(l_tmp,1,9))THEN

	   		 RETURN 'NON';

	     ELSIF(SUBSTR(l_tmp,10,2) <> '00') AND (SUBSTR(l_tmp,10,2) <> SUBSTR(l_perim_me,10,2)) THEN

		     RETURN 'NON';

	     END IF;



         DBMS_OUTPUT.PUT_LINE(l_tmp);
         l_chaine := SUBSTR(l_chaine,13);

      END LOOP;




	   RETURN l_hab;

   END estHabiliteMe;




   -- ------------------------------------------------------------------------
   -- Nom        : bddpg_ress
   -- Auteur     : BAA
   -- Decription : retourne bddpg à partir des données de la bip
   -- Paramètres : p_ident (IN) l'identifiant de la ressource
   -- Retour     : bddpg sur 11 caracteres
   -- ------------------------------------------------------------------------

   FUNCTION bddpg_ress(p_ident IN VARCHAR2) RETURN VARCHAR2 IS

   l_perim_me  		CHAR(11);

   BEGIN


     SELECT TO_CHAR(d.codbr,'FM00')||TO_CHAR(si.coddir,'FM00')||TO_CHAR(si.coddep,'FM000')||TO_CHAR(si.codpole,'FM00')||TO_CHAR(si.codgro,'FM00')
            INTO l_perim_me
	   FROM SITU_RESS_FULL sr, DATDEBEX d, STRUCT_INFO si,DIRECTIONS d
	   WHERE sr.ident=p_ident
	   AND (d.moismens>=sr.datsitu OR sr.datsitu IS NULL)
	   AND (d.moismens<=sr.datdep OR sr.datdep IS NULL)
	   AND si.codsg=sr.codsg
	   AND d.coddir=si.coddir;


	RETURN l_perim_me;


   END bddpg_ress;


	  -- ------------------------------------------------------------------------
   -- Nom        : tmp_saisie_realisee_seq
   -- Auteur     : BAA
   -- Decription : mise a jour de la table tmp_saisie_realisee
   --
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- ------------------------------------------------------------------------


   FUNCTION tmp_saisie_realisee_seq RETURN NUMBER IS


    l_var_seq   NUMBER; -- numero de sequence

	v_liste     VARCHAR2(2000);
	v_nombre 	NUMBER;

    CURSOR cur_ress IS
	       SELECT ident, matricule, rnom, rprenom FROM RESSOURCE;


 	CURSOR cur_user(c_chef_projet CHAR)  IS
          SELECT ident FROM RTFE
		  WHERE ROLE='SAISIE_REALISEE'
		  AND INSTR(';'||chef_projet||';',';'||c_chef_projet||';')>0;


   BEGIN

     SELECT sdetail.NEXTVAL INTO l_var_seq FROM dual; --creation de la sequence



     FOR curseur IN cur_ress LOOP


	    v_nombre := 0;
	    v_liste := '';

        FOR curseur1 IN cur_user(curseur.ident) LOOP

		    v_nombre := v_nombre + 1;
		    v_liste := v_liste ||';'|| curseur1.ident;

        END LOOP;



	    INSERT INTO TMP_SAISIE_REALISEE ( NUMSEQ,
					       		          CHEF_PROJET,
								          MATRICULE,
									      RNOM,
									      RPRENOM,
									      USER_QUI_SAISIE,
									      NOMBRE
		  			      		         )
	    VALUES ( l_var_seq,
		         curseur.ident,
				 curseur.matricule,
				 curseur.rnom,
				 curseur.rprenom,
				 SUBSTR(v_liste,2),
				 v_nombre
			   );

	    COMMIT;



	 END LOOP;


	 RETURN l_var_seq;


   END 	tmp_saisie_realisee_seq;



END Pack_Rtfe;
/
CREATE OR REPLACE PACKAGE Pack_Rtfe_Log AS

-- --------------------------------------------------------------------------------------------------
-- Procédure qui alimente la table rtfe_log lors de chaque connexion
-- -------------------------------------------------------------------------------------------------
   PROCEDURE alim_rtfe_log ( p_user_rtfe     	      IN  VARCHAR2 );

END Pack_Rtfe_Log;
/

CREATE OR REPLACE PACKAGE BODY Pack_Rtfe_Log AS

-----------------------------------------------------
-- Gestions exceptions
-----------------------------------------------------
CALLEE_FAILED EXCEPTION;
PRAGMA EXCEPTION_INIT( CALLEE_FAILED, -20000 );
CALLEE_FAILED_ID     NUMBER := -20000;   -- pour propagation dans pile d'appel
TRCLOG_FAILED_ID     NUMBER := -20001;   -- problème : erreur dans la gestion d'erreur !
ERR_FONCTIONNELLE_ID NUMBER := -20002;   -- pour provoquer erreur alors que Oracle OK
CONSTRAINT_VIOLATION EXCEPTION;          -- pour clause when
VIOLATION_CONSTRAINT_UNIQUE EXCEPTION;          -- pour clause when
PRAGMA EXCEPTION_INIT( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère
PRAGMA EXCEPTION_INIT( VIOLATION_CONSTRAINT_UNIQUE, -00001 );



-- --------------------------------------------------------------------------------------------------
-- Procédure qui alimente la table rtfe_log lors de chaque connexion
-- -------------------------------------------------------------------------------------------------
   PROCEDURE alim_rtfe_log ( p_user_rtfe     	      IN  VARCHAR2 ) IS


	BEGIN

	                     INSERT INTO RTFE_LOG(USER_RTFE,
					   					 				 				  	 	MOIS,
																				NBR_CONNEXION
																				)
				                                              VALUES(
																 				  p_user_rtfe,
																				  TO_DATE(TO_CHAR(SYSDATE,'mm/yyyy'),'mm/yyyy') ,
																				  1
																				 );
                             COMMIT;

				       EXCEPTION

             			    WHEN VIOLATION_CONSTRAINT_UNIQUE THEN

	                                    UPDATE RTFE_LOG
				                        SET  NBR_CONNEXION = NVL(NBR_CONNEXION,0) + 1
			  	   	                               WHERE   UPPER(USER_RTFE) = UPPER(p_user_rtfe)
							                       AND TO_CHAR(MOIS,'mm/yyyy') = TO_CHAR(SYSDATE,'mm/yyyy')
			                                      ;
										COMMIT;

							 WHEN OTHERS THEN
					              		RAISE_APPLICATION_ERROR( -20997, SQLERRM);



	END alim_rtfe_log ;



END  Pack_Rtfe_Log;
/
CREATE OR REPLACE PACKAGE Pack_Rubrique AS

   -- Définition curseur sur la table struct_info

   TYPE Rubrique_ViewType IS RECORD ( codrub                 RUBRIQUE.codrub%TYPE,
   						  	 		  						 					  	  coddir                  RUBRIQUE.coddir%TYPE,
   			  				          		 					  		              libdir                     VARCHAR2(80),
																					  libelle                   VARCHAR2(80),
																					  codep                  RUBRIQUE.codep%TYPE,
    																				  codfei                   RUBRIQUE.codfei%TYPE,
   																					  CAFI                      RUBRIQUE.CAFI%TYPE,
																					  LIBCAFI                VARCHAR2(80),
   																					  comptedeb         RUBRIQUE.comptedeb%TYPE,
																					  libcomptedeb     VARCHAR2(80),
   																					  comptecre           RUBRIQUE.comptecre%TYPE,
																					  libcomptecre      VARCHAR2(80),
   																					  schemacpt          RUBRIQUE.schemacpt%TYPE,
   																					  appli                      RUBRIQUE.appli%TYPE,
  																					  datedemande    RUBRIQUE.datedemande%TYPE,
   																					  dateretour            RUBRIQUE.dateretour%TYPE,
   																					  commentaires    RUBRIQUE.commentaires%TYPE,
   																					  flaglock   	           RUBRIQUE.flaglock%TYPE
					 					                                          );

   TYPE RubriqueCurType_Char IS REF CURSOR RETURN Rubrique_ViewType;


    PROCEDURE insert_Rubrique( 	p_codrub                 IN  VARCHAR2,
   			  				          		 					  	p_coddir                   IN VARCHAR2,
																	p_codep                   IN VARCHAR2,
    																p_codfei                    IN VARCHAR2,
   																	p_CAFI                       IN VARCHAR2,
   																	p_comptedeb          IN VARCHAR2,
   																	p_comptecre            IN VARCHAR2,
   																	p_schemacpt           IN VARCHAR2,
   																	p_appli                       IN VARCHAR2,
  																	p_datedemande     IN VARCHAR2,
   																	p_dateretour             IN VARCHAR2,
   																	p_commentaires     IN VARCHAR2,
                                  									p_userid     	             IN  VARCHAR2,
                                  									p_nbcurseur             OUT INTEGER,
                                  									p_message              OUT VARCHAR2
                                									)  ;


	PROCEDURE update_rubrique ( 	p_codrub                IN VARCHAR2,
   			  				          		 					  	  p_coddir                  IN VARCHAR2,
																	  p_codep                   IN VARCHAR2,
    																  p_codfei                   IN VARCHAR2,
   																	  p_CAFI                      IN VARCHAR2,
   																	  p_comptedeb       IN VARCHAR2,
   																	  p_comptecre           IN VARCHAR2,
   																	  p_schemacpt          IN VARCHAR2,
   																	  p_appli                       IN VARCHAR2,
  																	  p_datedemande     IN VARCHAR2,
   																	  p_dateretour             IN VARCHAR2,
   																	  p_commentaires    IN VARCHAR2,
                                  	 						 	      p_userid     	               IN  VARCHAR2,
																	  p_flaglock   	             IN VARCHAR2,
				  													  p_nbcurseur  	  OUT INTEGER,
                                  									  p_message    	 OUT VARCHAR2
                              										);



	PROCEDURE delete_rubrique ( p_codrub                  IN  RUBRIQUE.codrub%TYPE,
			  				  							  	  		p_flaglock 	                IN  NUMBER,
   			  				          		 					  	p_userid                     IN  VARCHAR2,
																    p_nbcurseur             OUT INTEGER,
                                  								    p_message               OUT VARCHAR2
                         										   );

	 PROCEDURE select_Rubrique( p_codrub          	       IN RUBRIQUE.CODRUB%TYPE,
					 	                                          	 p_userid     	              IN  VARCHAR2,
																	 p_curRubrique         IN OUT RubriqueCurType_Char ,
                                  									 p_nbcurseur             OUT INTEGER,
                                  									 p_message              OUT VARCHAR2
                                									) ;

END Pack_Rubrique;
/

CREATE OR REPLACE PACKAGE BODY Pack_Rubrique AS



 PROCEDURE insert_Rubrique( 	p_codrub                 IN  VARCHAR2,
   			  				          		 					  	p_coddir                   IN VARCHAR2,
																	p_codep                   IN VARCHAR2,
    																p_codfei                    IN VARCHAR2,
   																	p_CAFI                       IN VARCHAR2,
   																	p_comptedeb          IN VARCHAR2,
   																	p_comptecre            IN VARCHAR2,
   																	p_schemacpt           IN VARCHAR2,
   																	p_appli                       IN VARCHAR2,
  																	p_datedemande     IN VARCHAR2,
   																	p_dateretour             IN VARCHAR2,
   																	p_commentaires     IN VARCHAR2,
                                  									p_userid     	             IN  VARCHAR2,
                                  									p_nbcurseur             OUT INTEGER,
                                  									p_message              OUT VARCHAR2
                                									)  IS

     l_msg VARCHAR2(1024);
     l_msg_alert VARCHAR2(1024);
     l_exist NUMBER;
     l_count NUMBER;
	 l_count2 NUMBER;
	 l_diff NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


	  SELECT COUNT(*)   INTO l_count2 FROM RUBRIQUE
	                              WHERE codfei =  TO_NUMBER(p_codfei)
								  AND CAFI =  TO_NUMBER(p_CAFI);

	IF(l_count2 <> 0)THEN

	          Pack_Global.recuperer_message(20958, '%s1', TO_NUMBER(p_cafi),NULL, l_msg);
			  RAISE_APPLICATION_ERROR( -20958, l_msg );

	END IF;

	 IF(TO_NUMBER(p_cafi) = 99999) OR (TO_NUMBER(p_cafi)=88888)THEN

	          Pack_Global.recuperer_message(20957, '%s1', TO_NUMBER(p_cafi),NULL, l_msg);
			  RAISE_APPLICATION_ERROR( -20957, l_msg );

	END IF;

    SELECT COUNT(*) INTO l_count FROM STRUCT_INFO WHERE CAFI=p_cafi AND TOPFER='O';

	IF(p_dateretour IS NOT NULL) AND (p_datedemande IS NOT  NULL) THEN

	                SELECT TO_DATE(p_dateretour,'dd/mm/yyyy') - TO_DATE(p_datedemande,'dd/mm/yyyy') INTO l_diff FROM dual;

					IF(l_diff < 0)THEN

	         		 		  Pack_Global.recuperer_message(20956, '%s1', p_cafi,NULL, l_msg);
			  		 		RAISE_APPLICATION_ERROR( -20956, l_msg );

				  END IF;

	END IF;


	IF(l_count != 0)THEN


	BEGIN
     	   INSERT INTO RUBRIQUE
	       		  	   		 		   	                  ( codrub,
   			  				        					   coddir,
								    					   codep,
    													   codfei,
   														   CAFI,
   														   comptedeb,
   														   comptecre,
   														   schemacpt,
   														   appli,
  														   datedemande,
   														   dateretour,
   														   commentaires,
   														   flaglock)
         VALUES ( TO_NUMBER(p_codrub),
		   		  			  TO_NUMBER(p_coddir),
							  TO_NUMBER(p_codep),
    						  TO_NUMBER(p_codfei),
   							  TO_NUMBER(p_CAFI),
   							  TO_NUMBER(p_comptedeb),
   							  TO_NUMBER(p_comptecre),
   							  TO_NUMBER(p_schemacpt),
   							  p_appli,
  							  TO_DATE(p_datedemande,'dd/mm/yyyy'),
   							  TO_DATE(p_dateretour,'dd/mm/yyyy'),
   							   p_commentaires,
   							   0
							  );

		COMMIT;

	  Pack_Global.recuperer_message( 20971, '%s1', p_codrub, NULL, l_msg);

	 p_message := l_msg;

     EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		       Pack_Global.recuperer_message( 21059, NULL, NULL, NULL, l_msg);
               RAISE_APPLICATION_ERROR( -20001, l_msg );

     END;


	 ELSE
			  Pack_Global.recuperer_message(20955, '%s1', p_cafi,NULL, l_msg);
			  RAISE_APPLICATION_ERROR( -20955, l_msg );
	 END IF;


   END insert_rubrique;

	PROCEDURE update_rubrique ( 	p_codrub                IN VARCHAR2,
   			  				          		 					  	  p_coddir                  IN VARCHAR2,
																	  p_codep                   IN VARCHAR2,
    																  p_codfei                   IN VARCHAR2,
   																	  p_CAFI                      IN VARCHAR2,
   																	  p_comptedeb       IN VARCHAR2,
   																	  p_comptecre           IN VARCHAR2,
   																	  p_schemacpt          IN VARCHAR2,
   																	  p_appli                       IN VARCHAR2,
  																	  p_datedemande     IN VARCHAR2,
   																	  p_dateretour             IN VARCHAR2,
   																	  p_commentaires    IN VARCHAR2,
                                  	 						 	      p_userid     	               IN  VARCHAR2,
																	  p_flaglock   	             IN VARCHAR2,
				  													  p_nbcurseur  	  OUT INTEGER,
                                  									  p_message    	 OUT VARCHAR2
                              										)  IS

	 l_msg               VARCHAR2(1024);
	 l_type               VARCHAR2(10);
	 l_count             NUMBER;
	 l_count1           NUMBER;
	 l_count2           NUMBER;
     l_diff 			     NUMBER;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- initialiser le message retour

	p_nbcurseur := 0;
	p_message := '';


	SELECT COUNT(*)  INTO l_count2 FROM RUBRIQUE
	                              WHERE codfei =  TO_NUMBER(p_codfei)
								  AND CAFI =  TO_NUMBER(p_CAFI)
								  AND CODRUB <> p_codrub ;

	IF(l_count2 <> 0)THEN

	          Pack_Global.recuperer_message(20958, '%s1', TO_NUMBER(p_cafi),NULL, l_msg);
			  RAISE_APPLICATION_ERROR( -20958, l_msg );

	END IF;

	 IF(TO_NUMBER(p_cafi) = 99999) OR (TO_NUMBER(p_cafi)=88888)THEN

	          Pack_Global.recuperer_message(20957, '%s1', TO_NUMBER(p_cafi),NULL, l_msg);
			  RAISE_APPLICATION_ERROR( -20957, l_msg );

	END IF;


	SELECT COUNT(*) INTO l_count1 FROM STRUCT_INFO WHERE CAFI=p_cafi AND TOPFER='O';

	IF(p_dateretour IS NOT  NULL) AND (p_datedemande IS NOT NULL) THEN

	                SELECT TO_DATE(p_dateretour,'dd/mm/yyyy') - TO_DATE(p_datedemande,'dd/mm/yyyy') INTO l_diff FROM dual;

					IF(l_diff < 0)THEN

	         		 		  Pack_Global.recuperer_message(20956, '%s1', p_cafi,NULL, l_msg);
			  		 		RAISE_APPLICATION_ERROR( -20956, l_msg );

				  END IF;

	END IF;


   IF(l_count1 != 0)THEN


	BEGIN

        UPDATE RUBRIQUE
		SET	 codrub = TO_NUMBER(p_codrub),
		   		   coddir = TO_NUMBER(p_coddir),
				   codep =  TO_NUMBER(p_codep),
    			   codfei =  TO_NUMBER(p_codfei),
   				   CAFI =  TO_NUMBER(p_CAFI),
   				   comptedeb = TO_NUMBER(p_comptedeb),
   				   comptecre =  TO_NUMBER(p_comptecre),
   				   schemacpt =  TO_NUMBER(p_schemacpt),
   				   appli =  p_appli,
  				   datedemande = TO_DATE(p_datedemande,'dd/mm/yyyy'),
   				   dateretour = TO_DATE(p_dateretour,'dd/mm/yyyy'),
   				   commentaires = p_commentaires,
				   flaglock 	= DECODE( p_flaglock, 1000000, 0, p_flaglock + 1 )
				 WHERE codrub 	= TO_NUMBER(p_codrub)
                 AND flaglock 	= p_flaglock;

	EXCEPTION

		WHEN OTHERS THEN
	         RAISE_APPLICATION_ERROR( -20754, l_msg );
		 END;


      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	      Pack_Global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );

      ELSE


	   -- 'La rubrique  p_codrub a été modifié'

	         Pack_Global.recuperer_message( 20972, '%s1', p_codrub, NULL, l_msg);
		  	 p_message := l_msg;
      END IF;

	  ELSE
			  Pack_Global.recuperer_message(20955, '%s1', p_cafi,NULL, l_msg);
			  RAISE_APPLICATION_ERROR( -20955, l_msg );
	 END IF;


   END update_rubrique;

	PROCEDURE delete_rubrique ( p_codrub                  IN  RUBRIQUE.codrub%TYPE,
			  				  							  	  		p_flaglock 	                IN  NUMBER,
   			  				          		 					  	p_userid                     IN  VARCHAR2,
																    p_nbcurseur             OUT INTEGER,
                                  								    p_message               OUT VARCHAR2
                         										   ) IS


	  l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
	  l_count NUMBER;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';


	  SELECT COUNT(*) INTO l_count FROM STRUCT_INFO
	                           WHERE TOPFER='O'
							   AND CAFI IN (SELECT CAFI FROM RUBRIQUE WHERE codrub=p_codrub);

	  IF(l_count = 0)THEN

      BEGIN
	   DELETE FROM RUBRIQUE
		    WHERE codrub = TO_NUMBER(p_codrub)
			AND flaglock = TO_NUMBER(p_flaglock);

         EXCEPTION
		WHEN referential_integrity THEN
		         Pack_Global.recuperer_message( 20954, NULL, NULL, NULL, l_msg);
                RAISE_APPLICATION_ERROR( -20954, l_msg );

		WHEN OTHERS THEN
				    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
		END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   Pack_Global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
      RAISE_APPLICATION_ERROR( -20999, l_msg );

      ELSE

	   -- ' p_codcompte a été supprimé'

	   Pack_Global.recuperer_message( 20973, '%s1', p_codrub, NULL, l_msg);
	   p_message := l_msg;

      END IF;

	  ELSE


	       Pack_Global.recuperer_message( 20996, '%s1', p_codrub, NULL, l_msg);
	       p_message := l_msg;

	  END IF;


   END delete_rubrique;




    PROCEDURE select_Rubrique( p_codrub          	       IN RUBRIQUE.CODRUB%TYPE,
					 	                                          	 p_userid     	              IN  VARCHAR2,
																	 p_curRubrique         IN OUT RubriqueCurType_Char ,
                                  									 p_nbcurseur             OUT INTEGER,
                                  									 p_message              OUT VARCHAR2
                                									)   IS


	l_msg VARCHAR2(1024);

   BEGIN

        -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         OPEN   p_curRubrique FOR
              SELECT 	r.codrub,
			  					 	d.CODDIR,
   			  				        d.LIBDIR,
									r.codep || ' - ' || r.codfei || ' - ' || tr.librubst,
								    r.codep,
    								r.codfei,
   									r.CAFI,
									r.CAFI || ' - '|| ca.CLIBRCA,
									r.comptedeb,
   									RPAD(TO_CHAR(c1.codcompte),10,' ') || ' - '|| c1.libcompte,
									r.comptecre,
   									RPAD(TO_CHAR(c2.codcompte),10,' ') || ' - '|| c2.libcompte,
   									r.schemacpt,
   									r.appli,
  									TO_CHAR(r.datedemande,'dd/mm/yyyy'),
   									TO_CHAR(r.dateretour,'dd/mm/yyyy'),
   									r.commentaires,
   									r.flaglock
		     FROM  RUBRIQUE r, TYPE_RUBRIQUE tr, COMPTE c1, COMPTE c2, CENTRE_ACTIVITE ca, DIRECTIONS d
              WHERE r.codrub = TO_NUMBER(p_codrub)
			  AND r.CODEP=tr.CODEP(+)
			  AND r.CODFEI=tr.CODFEI
			  AND c1.codcompte(+)=r.comptedeb
			   AND c2.codcompte(+)=r.comptecre
			   AND ca.CODCAMO(+)=r.CAFI
			   AND d.coddir(+)=r.coddir;


          Pack_Global.recuperer_message( 21034, '%s1', p_codrub, NULL, l_msg);
      p_message := l_msg;

      EXCEPTION

        WHEN OTHERS THEN

		  RAISE_APPLICATION_ERROR( -20997, SQLERRM);
  END;

   END select_Rubrique;

END Pack_Rubrique;
/
CREATE OR REPLACE PACKAGE pack_scenario AS

   -- Définition curseur sur la table scenario

   TYPE scenario_ViewType IS RECORD ( 	codsg  		ree_scenarios.codsg%TYPE,
					code_scenario 	ree_scenarios.code_scenario%TYPE,
					lib_scenario 	ree_scenarios.lib_scenario%TYPE,
					officiel 	VARCHAR2(3),
					commentaire 	ree_scenarios.commentaire%TYPE
					);


   TYPE scenarioCurType_Char IS REF CURSOR RETURN scenario_ViewType;


   PROCEDURE insert_scenario ( 	p_codsg 	IN VARCHAR2,
				p_code_scenario IN VARCHAR2,
				p_lib_scenario 	IN VARCHAR2,
				p_init_scenario IN VARCHAR2,
				p_officiel      IN VARCHAR2,
				p_commentaire   IN VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                                );

   PROCEDURE update_scenario ( 	p_codsg 	IN VARCHAR2,
				p_code_scenario IN VARCHAR2,
				p_lib_scenario 	IN VARCHAR2,
				p_init_scenario IN VARCHAR2,
				p_officiel      IN VARCHAR2,
				p_commentaire   IN VARCHAR2,
				p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                              	);

   PROCEDURE delete_scenario ( 	p_codsg 	IN VARCHAR2,
				p_code_scenario IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2
                              	);

   PROCEDURE select_scenario_liste ( 	p_codsg 	IN VARCHAR2,
   					p_global 	IN VARCHAR2,
                               		p_curscenario 	IN OUT scenarioCurType_Char ,
                               		p_nbcurseur   	OUT INTEGER,
                               		p_message     	OUT VARCHAR2
                                	);

    PROCEDURE select_scenario ( 	p_codsg 	IN VARCHAR2,
					p_code_scenario IN VARCHAR2,
                               		p_curscenario 	IN OUT scenarioCurType_Char ,
                               		p_nbcurseur   	OUT INTEGER,
                               		p_message     	OUT VARCHAR2
                                	);

   PROCEDURE scenario_officiel ( 	p_codsg 	IN VARCHAR2,
					p_code_scenario IN VARCHAR2,
					p_officiel	IN VARCHAR2
                              		);

   PROCEDURE initialise_reestime ( 	p_codsg 	IN VARCHAR2,
					p_code_scenario IN VARCHAR2,
					p_init_scenario	IN VARCHAR2
                              		);


END pack_scenario;
/

CREATE OR REPLACE PACKAGE BODY pack_scenario AS

  PROCEDURE insert_scenario ( 	p_codsg 	IN VARCHAR2,
				p_code_scenario IN VARCHAR2,
				p_lib_scenario 	IN VARCHAR2,
				p_init_scenario IN VARCHAR2,
				p_officiel      IN VARCHAR2,
				p_commentaire   IN VARCHAR2,
                                p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                              ) IS

     	l_msg VARCHAR2(1024);
     	l_scenario_dpg NUMBER;

   BEGIN

	-- Positionner le nb de curseurs ==> 0
	-- Initialiser le message retour

      	p_nbcurseur := 0;
      	p_message := '';


	BEGIN


	INSERT INTO ree_scenarios
	    ( 	codsg,
		code_scenario,
		lib_scenario,
		officiel,
		commentaire
 		)
         VALUES ( 	TO_NUMBER(p_codsg),
         		p_code_scenario,
         		p_lib_scenario,
         		p_officiel,
         		p_commentaire
		);

	-- Met à jour le caractère officiel du scénario
	scenario_officiel(p_codsg ,
			p_code_scenario ,
			p_officiel ) ;

	-- Initialise le réestimé du scénario à partir du scénario d'initialisation
	initialise_reestime(p_codsg,
			p_code_scenario,
			p_init_scenario ) ;

     	EXCEPTION
      		WHEN DUP_VAL_ON_INDEX THEN
			pack_global.recuperer_message( 21009, NULL, NULL, NULL, l_msg);
               		p_message := l_msg;

        	WHEN OTHERS THEN
               		raise_application_error( -20997, SQLERRM);
     	END;

   END insert_scenario;



   PROCEDURE update_scenario ( 	p_codsg 	IN VARCHAR2,
				p_code_scenario IN VARCHAR2,
				p_lib_scenario 	IN VARCHAR2,
				p_init_scenario IN VARCHAR2,
				p_officiel      IN VARCHAR2,
				p_commentaire   IN VARCHAR2,
				p_nbcurseur  	OUT INTEGER,
                                p_message    	OUT VARCHAR2
                              ) IS

	l_msg VARCHAR2(1024);

   BEGIN

      	-- Positionner le nb de curseurs ==> 0
      	-- initialiser le message retour

	p_nbcurseur := 0;
	p_message := '';

	UPDATE ree_scenarios
	SET	lib_scenario=p_lib_scenario ,
		officiel    =p_officiel ,
		commentaire =p_commentaire
	WHERE codsg = TO_NUMBER(p_codsg) and code_scenario = p_code_scenario;



	IF SQL%NOTFOUND THEN

	   	-- 'Accès concurrent'

	   	pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         	raise_application_error( -20999, l_msg );

      	ELSE

	   	-- Met à jour le caractère officiel du scénario
	   	scenario_officiel(p_codsg ,
				p_code_scenario ,
				p_officiel ) ;

		-- Initialise le réestimé du scénario à partir du scénario d'initialisation
		initialise_reestime(p_codsg,
				p_code_scenario,
				p_init_scenario ) ;

	   	pack_global.recuperer_message( 21010, '%s1', p_code_scenario, NULL, l_msg);
	   	p_message := l_msg;

      	END IF;

   END update_scenario;


   PROCEDURE delete_scenario ( 	p_codsg 	IN VARCHAR2,
				p_code_scenario IN VARCHAR2,
                               	p_nbcurseur 	OUT INTEGER,
                               	p_message   	OUT VARCHAR2
                              ) IS


	l_msg VARCHAR2(1024);
      	referential_integrity EXCEPTION;
      	PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      	-- Positionner le nb de curseurs ==> 0
      	-- Initialiser le message retour

      	p_nbcurseur := 0;
      	p_message := '';

      	BEGIN

	DELETE FROM ree_scenarios
	WHERE codsg = TO_NUMBER(p_codsg) and code_scenario = p_code_scenario;

        EXCEPTION

		WHEN referential_integrity THEN

               		-- habiller le msg erreur

               		pack_global.recuperation_integrite(-2292);

		WHEN OTHERS THEN
		   	raise_application_error( -20997, SQLERRM);
      	END;

      	IF SQL%NOTFOUND THEN

	   	-- 'Accès concurrent'

	   	pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         	raise_application_error( -20999, l_msg );

      	ELSE

	   	-- Met à jour le caractère officiel des scénarios restants ( surtout si on supprime le scénario officiel
	   	scenario_officiel(p_codsg ,
				p_code_scenario ,
				'' ) ;

	   	pack_global.recuperer_message( 21011, '%s1', p_code_scenario, NULL, l_msg);
	   	p_message := l_msg;

      	END IF;

   END delete_scenario;



   PROCEDURE select_scenario_liste ( 	p_codsg 	IN VARCHAR2,
   					p_global 	IN VARCHAR2,
                               		p_curscenario 	IN OUT scenarioCurType_Char ,
                               		p_nbcurseur   	OUT INTEGER,
                               		p_message     	OUT VARCHAR2
                              		) IS

	l_msg VARCHAR2(1024);
	l_codsg NUMBER;

   BEGIN

      	-- Positionner le nb de curseurs ==> 1
      	-- Initialiser le message retour
	p_nbcurseur := 1;
      	p_message := '';

	IF ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
		pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               	raise_application_error(-20203,l_msg);

     	ELSIF ( pack_habilitation.fhabili_me(p_codsg, p_global)= 'faux' ) THEN
		pack_global.recuperer_message(20384, '%s1', p_codsg, NULL, l_msg);
		raise_application_error(-20384,l_msg);

     	ELSE

		BEGIN
        	OPEN   p_curscenario FOR
              	SELECT 	codsg,
              		code_scenario,
              		lib_scenario,
              		DECODE(officiel,'O','Oui','N','Non',' '),
              		commentaire
              	FROM  ree_scenarios
              	WHERE codsg = TO_NUMBER(p_codsg)
              	ORDER BY officiel desc , code_scenario;

      		EXCEPTION
			WHEN OTHERS THEN
         			raise_application_error( -20997, SQLERRM);
       		END;
        END IF;

     	p_message := l_msg;

   END select_scenario_liste;

   PROCEDURE select_scenario ( 	p_codsg 	IN VARCHAR2,
				p_code_scenario IN VARCHAR2,
                               	p_curscenario 	IN OUT scenarioCurType_Char ,
                               	p_nbcurseur   	OUT INTEGER,
                               	p_message     	OUT VARCHAR2
                              	) IS

	l_msg VARCHAR2(1024);

   BEGIN

	-- Positionner le nb de curseurs ==> 1
      	-- Initialiser le message retour

      	p_nbcurseur := 1;
      	p_message := '';

       	-- Attention ordre des colonnes doit correspondre a l ordre
      	-- de declaration dans la table ORACLE (a cause de ROWTYPE)
      	-- ou selectionner toutes les colonnes par *

      	BEGIN
        OPEN   p_curscenario FOR
              SELECT 	codsg,
              		code_scenario,
              		lib_scenario,
              		officiel,
              		commentaire
              FROM  ree_scenarios
              WHERE codsg = TO_NUMBER(p_codsg) and code_scenario = p_code_scenario;


      	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			pack_global.recuperer_message( 21006, NULL, NULL, NULL, l_msg);
         		p_message := l_msg;
        	WHEN OTHERS THEN
          		raise_application_error( -20997, SQLERRM);

      	END;

   END select_scenario;

--
-- Détermine pour un scénario celui qui sera le scénario officiel
--
   PROCEDURE scenario_officiel ( 	p_codsg 	IN VARCHAR2,
					p_code_scenario IN VARCHAR2,
					p_officiel	IN VARCHAR2
                              		) IS

     	l_nb_officiel NUMBER;
   BEGIN

	BEGIN
	--
	-- Compte le nombre de scénarios officiels pour le DPG
	--
	SELECT count(*)
	INTO l_nb_officiel
	FROM ree_scenarios
	WHERE codsg = TO_NUMBER(p_codsg)
	AND   officiel = 'O' ;

	-- En fonction du nombre ramené agit sur la base
	--	- Si le nombre est 1 , ne fait rien car la situation est normale

	IF (l_nb_officiel = 0) THEN
	--
	-- On positionne arbitrairement le statut officiel d'un scénario à O
		update ree_scenarios
		set officiel = 'O'
		where codsg = TO_NUMBER(p_codsg)
		and rownum <= 1 ;

	ELSIF (l_nb_officiel >= 2) THEN
	--
	-- Il y a trop de scénarios officiels , il faut n'en laisser qu'un
		update ree_scenarios
		set officiel = 'N'
		where codsg = TO_NUMBER(p_codsg)
		and code_scenario <> (
			select code_scenario
			from ree_scenarios
			where codsg = TO_NUMBER(p_codsg)
			and code_scenario = DECODE (p_officiel,'O',p_code_scenario,code_scenario)
			and rownum <= 1 );

	END IF ;

      	EXCEPTION
        	WHEN OTHERS THEN
          		raise_application_error( -20997, SQLERRM);
      	END;

   END scenario_officiel;


--
-- initialise les réestimés d'un scénario à partir d'un scénario d'initialisation
--
   PROCEDURE initialise_reestime ( 	p_codsg 	IN VARCHAR2,
					p_code_scenario IN VARCHAR2,
					p_init_scenario	IN VARCHAR2
                              		) IS

   BEGIN
	--
	-- Si init_scenario est vide ou égal à code_scenario on ne fait rien
	--
	IF ( p_init_scenario <> p_code_scenario  AND  p_init_scenario is not null ) THEN

		BEGIN
		--
		-- Supprime tous les réestimés du scénario
		--
		DELETE
		FROM ree_reestime
		WHERE codsg = TO_NUMBER(p_codsg)
		AND   code_scenario = p_code_scenario  ;

		--
		-- Recrée tous les réestimés de init_scenario pour le scénatio
		--
		INSERT INTO ree_reestime (
			CODSG          ,
	  		CODE_SCENARIO  ,
	  		CDEB           ,
	  		TYPE           ,
	  		IDENT          ,
	  		CODE_ACTIVITE  ,
	  		CONSO_PREVU )
	  	SELECT 	CODSG          ,
	  		p_code_scenario  ,
	  		CDEB           ,
	  		TYPE           ,
	  		IDENT          ,
	  		CODE_ACTIVITE  ,
	  		CONSO_PREVU
		FROM ree_reestime
		WHERE codsg = TO_NUMBER(p_codsg)
		AND   code_scenario = p_init_scenario  ;

	      	EXCEPTION
	        	WHEN OTHERS THEN
	          		raise_application_error( -20997, SQLERRM);
	      	END;
	END IF;

   END initialise_reestime;


END pack_scenario;
/
CREATE OR REPLACE PACKAGE pack_schema_histo AS
  -- ------------------------------------------------------------------------
  -- Nom        :  update_fcoduser
  -- Auteur     :  Equipe SOPRA
  --
  -- ------------------------------------------------------------------------
PROCEDURE ajout_schema(P_LOGDIR in varchar2);

END pack_schema_histo;
/

CREATE OR REPLACE PACKAGE BODY pack_schema_histo AS
-- -------------------
-- Gestions exceptions
-- -------------------
	CALLEE_FAILED exception;
	pragma exception_init( CALLEE_FAILED, -20000 );
	CALLEE_FAILED_ID     number := -20000;   -- pour propagation dans pile d'appel
	TRCLOG_FAILED_ID     number := -20001;   -- problème : erreur dans la gestion d'erreur !
	ERR_FONCTIONNELLE_ID number := -20002;   -- pour provoquer erreur alors que Oracle OK
	CONSTRAINT_VIOLATION exception;          -- pour clause when
	pragma exception_init( CONSTRAINT_VIOLATION, -2291 ); -- typiquement : clé étrangère

  -- ------------------------------------------------------------------------
  -- Nom        :  update_fcoduser
  -- Auteur     :  Equipe SOPRA
  --
  -- ------------------------------------------------------------------------
PROCEDURE ajout_schema(P_LOGDIR in varchar2) AS

L_HFILE utl_file.file_type;
L_RETCOD number;
L_PROCNAME varchar2(50) := 'AJOUTSCHEMA';
L_STATEMENT varchar2(64);

l_schema_num  number;

BEGIN
 -- ----------------
 -- Init de la trace
 -- ----------------
	L_RETCOD := TRCLOG.INITTRCLOG( P_LOGDIR , L_PROCNAME, L_HFILE );
	  if ( L_RETCOD <> 0 ) then
	      raise_application_error( TRCLOG_FAILED_ID,
				       'Erreur ' || L_RETCOD || ': Gestion du fichier LOG impossible',
				       false );
	  end if;

 -- -----------
 -- Trace Start
 -- -----------
	TRCLOG.TRCLOG( L_HFILE, 'Debut de ' || L_PROCNAME );

	L_STATEMENT := 'DETERMINER LE NUMERO DU SCHEMA';

   SELECT  count(*) INTO l_schema_num FROM ref_histo ;

   IF l_schema_num >= 14  THEN
       TRCLOG.TRCLOG( L_HFILE, 'Pas d''ajout de schema =' || l_schema_num || ' - Fin normale de ' || L_PROCNAME );
   ELSE
       TRCLOG.TRCLOG( L_HFILE, 'Ajout schema =' || to_char(l_schema_num + 1) || ' - Fin normale de ' || L_PROCNAME );
       INSERT INTO ref_histo
       VALUES ( add_months(sysdate,-36) ,'BIPH' || to_char(l_schema_num + 1) );
   END IF;

-- ----------
 -- Trace Stop
 -- ----------

	TRCLOG.CLOSETRCLOG( L_HFILE );
EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		IF  sqlcode <> CALLEE_FAILED_ID and sqlcode <> TRCLOG_FAILED_ID
        THEN TRCLOG.TRCLOG( L_HFILE, L_PROCNAME ||' : '|| SQLERRM );
	   END IF;
	   IF  sqlcode <> TRCLOG_FAILED_ID
        THEN
		  	TRCLOG.TRCLOG( L_HFILE, 'Fin ANORMALE de ' || L_PROCNAME  );
		  	TRCLOG.CLOSETRCLOG( L_HFILE );
		  	raise_application_error( CALLEE_FAILED_ID,
					 'Erreur : consulter le fichier LOG',false );
  	     ELSE  raise;
      END IF;

END ajout_schema;
END pack_schema_histo;
/
CREATE OR REPLACE PACKAGE Pack_Situation_F AS

TYPE situation_s_ViewType IS RECORD (ident      VARCHAR2(20),
                                     rnom       RESSOURCE.rnom%TYPE,
                                     coutot     VARCHAR2(20),
                                     flaglock   VARCHAR2(20),
                                     datsitu    VARCHAR2(20),
                                     datdep     VARCHAR2(20),
                                     codsg      VARCHAR2(20),
                                     --filcode    situ_ress.filcode%TYPE,
                                     soccode    SITU_RESS.soccode%TYPE,
                                     PRESTATION SITU_RESS.PRESTATION%TYPE,
                                     cpident    VARCHAR2(20),
                                     coufor       VARCHAR2(20),
                                     montant_mensuel VARCHAR2(20),
                                     olddatsitu VARCHAR2(20),
                                     typeForfait RESSOURCE.rtype%TYPE
                                    );

TYPE situationCurType IS REF CURSOR RETURN situation_s_ViewType;

   PROCEDURE insert_situation_f (p_oldatsitu  IN  VARCHAR2,
                                 p_ident      IN  VARCHAR2,
                                 p_coufor     IN  VARCHAR2,
                                 p_montant_mens     IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_coutot     IN  VARCHAR2,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_cpident    IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                );

   PROCEDURE update_situation_f (p_oldatsitu  IN  VARCHAR2,
                                 p_ident      IN  VARCHAR2,
                                 p_coufor     IN  VARCHAR2,
                                 p_montant_mens     IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_coutot     IN  VARCHAR2,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_cpident    IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                );

   PROCEDURE delete_situation_f (p_ident     IN  VARCHAR2,
                                 p_coufor    IN  VARCHAR2,
                                 p_rnom      IN  VARCHAR2,
                                 p_coutot    IN  VARCHAR2,
                                 p_datsitu   IN  VARCHAR2,
				 p_datdep    IN  VARCHAR2,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

   PROCEDURE select_situation_f (p_mode        IN  VARCHAR2,
                                 p_ident        IN  VARCHAR2,
                                 p_coufor       IN  VARCHAR2,
                                 p_montant_mens       IN  VARCHAR2,
                                 p_rnom         IN  RESSOURCE.rnom%TYPE,
                                 p_coutot       IN  VARCHAR2,
                                 p_datsitu      IN  VARCHAR2,
                                 p_flaglock     IN  VARCHAR2,
                                 p_userid       IN  VARCHAR2,
                                 p_cursituation IN OUT situationCurType,
                                 p_codsg           OUT VARCHAR2,
                                 p_soccode         OUT VARCHAR2,
                                 p_cpident         OUT VARCHAR2,
                                 p_dat             OUT VARCHAR2,
                                 p_prestation      OUT VARCHAR2,
                                 p_coul            OUT VARCHAR2,
                                 p_flag            OUT VARCHAR2,
                                 p_nbcurseur       OUT INTEGER,
                                 p_message         OUT VARCHAR2
                                );
END Pack_Situation_F;
/

CREATE OR REPLACE PACKAGE BODY Pack_Situation_F AS
   PROCEDURE insert_situation_f (p_oldatsitu  IN  VARCHAR2,
                                 p_ident      IN  VARCHAR2,
                                 p_coufor     IN  VARCHAR2,
                                 p_montant_mens     IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_coutot     IN  VARCHAR2,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_cpident    IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_ncodsg SITU_RESS.codsg%TYPE;
      l_dsocfer VARCHAR2(20);
      l_ncpident SITU_RESS.cpident%TYPE;
      l_date_courante VARCHAR2(20);
      l_datval VARCHAR2(20);
      l_datfin VARCHAR2(20);
      l_datval1       VARCHAR2(20);
      l_datfin1       VARCHAR2(20);
      l_datvalnext    VARCHAR2(20);
      datval          VARCHAR2(20);
      datfin          VARCHAR2(20);
      l_odatval VARCHAR2(20);
      l_menu 	      VARCHAR2(255);
      l_topfer STRUCT_INFO.topfer%TYPE;
      l_flaglock RESSOURCE.flaglock%TYPE;
      l_habilitation VARCHAR2(10);
      l_rtype_cp         RESSOURCE.rtype%TYPE;


CURSOR curdate IS
	SELECT TO_CHAR(datsitu,'yyyymmdd') ,TO_CHAR(datdep,'yyyymmdd')
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident);

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

     -- ERREUR SPEC : Chap 10.13.4 code qualification doit etre FS ou FH ou MAO ou INI ou ATI
       -- regle 4 non prise en compte.
       -- Positionner le nb de curseurs ==> 0
       -- Initialiser le message retour

       p_nbcurseur := 0;
       p_message := '';
       l_flaglock := p_flaglock;

      -- ====================================================================
      -- 8/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( p_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce DPG 20364
		Pack_Global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', l_msg);
                RAISE_APPLICATION_ERROR(-20364, l_msg);
	END IF;



      -- Gestion de l'utilisateur pour cout (RES)

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;



       -- TEST : codsg > 1

      IF TO_NUMBER(p_codsg) <= 1 THEN
            Pack_Global.recuperer_message( 20223, NULL, NULL, 'CODSG', l_msg);
            RAISE_APPLICATION_ERROR(-20223, l_msg);
      END IF;

      -- TEST : TOPFER de codsg si menutil = DIR

      IF l_menu != 'DIR' THEN

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;



      -- TEST : soccode existe et societe non fermee.

      BEGIN
           SELECT TO_CHAR(socfer,'yyyymmdd')
           INTO l_dsocfer
           FROM SOCIETE
           WHERE soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message( 20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
             Pack_Global.recuperer_message( 20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
      END IF;
      -- TEST p_prestation = FS FH MAO INI ATI

      IF p_prestation != 'FS' AND p_prestation != 'FH' AND p_prestation != 'MAO' AND p_prestation != 'INI' AND p_prestation != 'ATI' THEN
             Pack_Global.recuperer_message( 20276, NULL, NULL, 'PRESTATION', l_msg);
             RAISE_APPLICATION_ERROR(-20276, l_msg);
      END IF;

      -- TEST : cpident existe

      BEGIN
          SELECT ident,rtype
          INTO l_ncpident,l_rtype_cp
          FROM RESSOURCE
          WHERE ident = TO_NUMBER(p_cpident);

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message( 20226, '%s1', p_cpident, 'CPIDENT', l_msg);
             RAISE_APPLICATION_ERROR(-20226, l_msg);

           WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;
           -- TEST pour savoir si cette ressource est une personne
           IF (l_rtype_cp != 'P') AND (l_rtype_cp IS NOT NULL)THEN
               Pack_Global.recuperer_message(20218, NULL, NULL, 'CPIDENT', l_msg);
               RAISE_APPLICATION_ERROR(-20218, l_msg);
           END IF;

-- -------------------------------------------------------------------------------------
-- CONTROLES DE DATES
-- -------------------------------------------------------------------------------------
-- Recherche si la date de valeur existe déjà
  SELECT COUNT(datsitu) INTO l_odatval
  FROM SITU_RESS
  WHERE ident=TO_NUMBER(p_ident)
	AND TO_CHAR(datsitu,'mm/yyyy')=p_datsitu;
IF l_odatval=1 THEN
	SELECT SUBSTR(TO_CHAR(datsitu,'dd/mm/yyyy'),1,2) INTO l_datval
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident)
	AND   TO_CHAR(datsitu,'mm/yyyy')=p_datsitu ;
	-- Impossible de créer une autre situation dans le même mois
	IF l_datval!='01' THEN
		Pack_Global.recuperer_message(20322, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20322, l_msg);
		p_message := l_msg;
   	END IF;
END IF;

l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';
l_datfin:=TO_CHAR(TO_DATE(p_datdep,'dd/mm/yyyy'),'yyyymmdd') ;
---------------------------------------------------------------------------
-- La date de valeur est toujours inférieure à la date de départ
---------------------------------------------------------------------------
IF (p_datdep IS NOT NULL) THEN

	IF l_datval>l_datfin THEN
    		Pack_Global.recuperer_message(20227, NULL, NULL, 'DATSITU', l_msg);
      	     	RAISE_APPLICATION_ERROR(-20227, l_msg);
		p_message := l_msg;
	END  IF ;
END  IF ;

-- Recherche de la date de départ la plus récente
SELECT  TO_CHAR(datdep,'yyyymmdd') INTO  l_datfin1
FROM  SITU_RESS
WHERE  datsitu=(SELECT MAX(datsitu)
		FROM SITU_RESS
		WHERE 	ident=TO_NUMBER(p_ident))
AND 	ident=TO_NUMBER(p_ident);

-- Recherche de la date de valeur la plus récente
SELECT  MAX(TO_CHAR(datsitu,'yyyymmdd')) INTO  l_datval1
FROM  SITU_RESS
WHERE  ident=TO_NUMBER(p_ident);


------------------------------------------------------------------------------------
-- 1) Cas d'une situation intermédiaire ou antérieure à la plus ancienne situation
------------------------------------------------------------------------------------
IF  l_datval<l_datval1 THEN                    /* Cas d'une situation intermédiaire */
  -- La date de départ est obligatoire
  IF  l_datfin IS  NULL  THEN
	Pack_Global.recuperer_message(20441, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20441, l_msg);
		p_message := l_msg;
  END  IF ;

  ---------------------------------------------------------------------------------------
  -- Vérification de la validité des dates (non comprises dans des situations existantes)
  ---------------------------------------------------------------------------------------
  OPEN  curdate;
  LOOP
	FETCH curdate INTO datval,datfin;
	-- la date de valeur se trouve entre les dates d'une situation existante
	IF (l_datval > datval AND  l_datval<=datfin)   THEN
		Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20320, l_msg);
		p_message := l_msg;
	END IF;
	-- la date de depart se trouve entre les dates d'une situation existante
	IF  (l_datfin >=datval AND l_datfin<=datfin ) THEN
	    IF l_odatval<1 THEN
		Pack_Global.recuperer_message(20321, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20321, l_msg);
		p_message := l_msg;
	    END IF;
	END IF;
	EXIT WHEN curdate%NOTFOUND;

  END LOOP;
  CLOSE curdate;

  -- Recherche de la date de valeur qui suit la date de valeur saisie
  SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  FROM SITU_RESS
  WHERE TO_CHAR(datsitu,'yyyymmdd')>l_datval
	AND ident=TO_NUMBER(p_ident);


  ---------------------------------------------------------------------------------------------
  -- La situation  entre la date de valeur et celle de départ ne doit pas chevaucher
  -- les situations existantes
  -- ie la date de départ doit etre inférieure à la date de valeur de la situation postérieure
  ---------------------------------------------------------------------------------------------
IF (l_datfin>=l_datvalnext)  THEN
	Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      	RAISE_APPLICATION_ERROR(-20321, l_msg);
	p_message := l_msg;
  END IF;

END IF;

---------------------------------------------------------------------
-- 2) Cas où d'une situation qui suit la situation la plus récente
---------------------------------------------------------------------
IF (l_datval>l_datval1)  THEN
  IF (l_datfin1 IS NULL) THEN
	-- La date de départ la plus récente est égale à la date de valeur saisie-1jour
	BEGIN
		UPDATE  SITU_RESS
		SET  datdep=(TO_DATE(p_datsitu,'mm/yyyy')-1)
		WHERE  datsitu= (SELECT  MAX(datsitu)
				FROM  SITU_RESS
				WHERE  ident=TO_NUMBER(p_ident))
			AND  ident=TO_NUMBER(p_ident);
	EXCEPTION
		WHEN  referential_integrity THEN
		Pack_Global.recuperation_integrite(-2291);
		WHEN  OTHERS  THEN
		RAISE_APPLICATION_ERROR(-20997,SQLERRM);
	END;

	-- Mise à jour de ressource
	BEGIN
		UPDATE  RESSOURCE
		SET  flaglock=DECODE(l_flaglock,1000000,0,l_flaglock+1)
		WHERE  flaglock=l_flaglock
			AND  ident= TO_NUMBER(p_ident);
	EXCEPTION
		WHEN  referential_integrity THEN
			Pack_Global.recuperation_integrite(-2291);
		WHEN  OTHERS  THEN
		RAISE_APPLICATION_ERROR(-20997,SQLERRM);
	END ;
	l_flaglock:=l_flaglock+1;
  ELSE
	IF  l_datval<=l_datfin1 THEN
		Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20320, l_msg);
		p_message := l_msg;
	END  IF ;
  END  IF ;

END IF;


 /* la date de valeur n'existe pas */
IF l_odatval<1 THEN
	BEGIN
                     INSERT INTO SITU_RESS (ident,
                                            datsitu,
                                            datdep,
                                            cout,
                                            montant_mensuel,
                                            PRESTATION,
                                            soccode,
                                            codsg,
                                            --filcode,
                                            cpident
                                           )
                      VALUES (TO_NUMBER(p_ident),
                              TO_DATE(p_datsitu,'mm/yyyy'),
                              TO_DATE(p_datdep,'dd/mm/yyyy'),
                              TO_NUMBER(p_coufor),
                              TO_NUMBER(p_montant_mens),
                              p_prestation,
                              p_soccode,
                              TO_NUMBER(p_codsg),
                              --p_filcode,
                              p_cpident
                             );
       		EXCEPTION
              	WHEN DUP_VAL_ON_INDEX THEN
                  	-- 'la ressource existe deja'
                       	Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
                              RAISE_APPLICATION_ERROR( -20219, l_msg );
             	WHEN referential_integrity THEN
                        -- habiller le msg erreur
                     	Pack_Global.recuperation_integrite(-2291);

    		WHEN OTHERS THEN
    		RAISE_APPLICATION_ERROR( -20997, SQLERRM);
       	END;
/* La date de valeur existe déjà */
ELSE
       BEGIN
               UPDATE SITU_RESS SET  datdep     = TO_DATE(p_datdep,'dd/mm/yyyy'),
                                     codsg      = TO_NUMBER(p_codsg),
                                     --filcode    = p_filcode,
                                     soccode    = p_soccode,
                                     PRESTATION = p_prestation,
                                     cpident    = TO_NUMBER(p_cpident),
                                     cout       = TO_NUMBER(p_coufor),
                                     montant_mensuel = TO_NUMBER(p_montant_mens)
                WHERE ident = TO_NUMBER(p_ident)
                AND TO_CHAR(datsitu,'yyyymmdd') = l_datval;

            EXCEPTION
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
                 WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR( -20997, SQLERRM);
             END ;

             BEGIN
                 UPDATE RESSOURCE
                 SET    flaglock = DECODE(l_flaglock, 1000000, 0, l_flaglock + 1)
                 WHERE  flaglock = l_flaglock
                 AND    ident = TO_NUMBER(p_ident);

             EXCEPTION
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
                    WHEN OTHERS THEN
                 RAISE_APPLICATION_ERROR( -20997, SQLERRM);
             END;

             IF SQL%NOTFOUND THEN
             Pack_Global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
             RAISE_APPLICATION_ERROR(-20999, l_msg);
             END IF;
END IF;

    -- Message : 'situation forfait || p_rnom || creee';

    Pack_Global.recuperer_message(20323, '%s1', p_ident, NULL, l_msg);
    p_message := l_msg;

   END insert_situation_f;

/***********************************************************************************
***********************************************************************************/

   PROCEDURE update_situation_f (p_oldatsitu  IN  VARCHAR2,
                                 p_ident      IN  VARCHAR2,
                                 p_coufor     IN  VARCHAR2,
                                 p_montant_mens     IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_coutot     IN  VARCHAR2,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_cpident    IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_ncodsg SITU_RESS.codsg%TYPE;
      l_ncpident SITU_RESS.cpident%TYPE;
      l_dsocfer       VARCHAR2(20);
      l_date_courante VARCHAR2(20);
      l_datval        VARCHAR2(20);
      l_oldatval      VARCHAR2(20);
      l_datfin        VARCHAR2(20);
      l_menu          VARCHAR2(255);
      l_topfer        STRUCT_INFO.topfer%TYPE;
      l_datvalnext    VARCHAR2(20);
      l_oldatdep  VARCHAR2(20);
      l_datval1  VARCHAR2(20);
      l_rtype_cp RESSOURCE.rtype%TYPE;

      datval VARCHAR2(20);
      datfin VARCHAR2(20);
CURSOR curdatval IS
	SELECT TO_CHAR(datsitu,'yyyymmdd') ,TO_CHAR(datdep,'yyyymmdd')
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident)
	AND    TO_CHAR(datsitu,'dd/mm/yyyy')!=p_oldatsitu;

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

       -- REGLE non respecte : 9.12.5 regle 4 gestion utilisateur.
       -- Positionner le nb de curseurs ==> 0
       -- Initialiser le message retour

       p_nbcurseur := 0;
       p_message := '';

       -- TEST : codsg > 1

      IF TO_NUMBER(p_codsg) <= 1 THEN
            Pack_Global.recuperer_message(20223, NULL, NULL, 'CODSG', l_msg);
            RAISE_APPLICATION_ERROR(-20223, l_msg);
      END IF;

      -- TEST : TOPFER de codsg si menutil = DIR

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      IF l_menu != 'DIR' THEN

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;



      -- TEST : soccode existe et societe non fermee.

      BEGIN
           SELECT TO_CHAR(socfer,'yyyymmdd')
           INTO l_dsocfer
           FROM SOCIETE
           WHERE soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, l_msg);

      END;

     -- TEST p_prestation = FS FH MAO INI ATI

      IF p_prestation != 'FS' AND p_prestation != 'FH' AND p_prestation != 'MAO' AND p_prestation != 'INI' AND p_prestation != 'ATI' THEN
             Pack_Global.recuperer_message( 20276, NULL, NULL, 'PRESTATION', l_msg);
             RAISE_APPLICATION_ERROR(-20276, l_msg);
      END IF;

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
             Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
     END IF;
      -- TEST : cpident existe

      BEGIN
          SELECT ident ,rtype
          INTO l_ncpident ,l_rtype_cp
          FROM RESSOURCE
          WHERE ident = TO_NUMBER(p_cpident);

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message(20226, '%s1', p_cpident, 'CPIDENT', l_msg);
             RAISE_APPLICATION_ERROR(-20226, l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR ( -20997, SQLERRM);
      END;
       -- TEST pour savoir si cette ressource est une personne
           IF (l_rtype_cp != 'P') AND (l_rtype_cp IS NOT NULL)THEN
               Pack_Global.recuperer_message(20218, NULL, NULL, 'CPIDENT', l_msg);
               RAISE_APPLICATION_ERROR(-20218, l_msg);
           END IF;

--------------------------------------------------
-- CONTROLE DES DATES
-- MAJ le 12/04/2000 par NCM
---------------------------------------------------
l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm');
l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymm');
IF l_datval=l_oldatval THEN
	l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');
	l_datval:=l_oldatval;
ELSE
	l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');
	l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';
END IF;

---------------------------------------------------------------------------
-- La date de valeur est toujours inférieure à la date de départ
---------------------------------------------------------------------------
l_datfin:=TO_CHAR(TO_DATE(p_datdep,'dd/mm/yyyy'),'yyyymmdd') ;

IF (p_datdep IS NOT NULL) THEN
	IF l_datval>l_datfin THEN
    		Pack_Global.recuperer_message(20227, NULL, NULL, 'DATSITU', l_msg);
      	     	RAISE_APPLICATION_ERROR(-20227, l_msg);
		p_message := l_msg;
	END IF;
END IF;

DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);

-- Recherche de la date de valeur la plus récente
SELECT MAX(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datval1
FROM SITU_RESS
WHERE ident=TO_NUMBER(p_ident);

IF  l_datval<l_datval1 THEN                    /* Cas d'une situation intermédiaire */
  -- La date de départ est obligatoire
  IF l_datfin IS NULL THEN
	Pack_Global.recuperer_message(20441, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20441, l_msg);
		p_message := l_msg;
  END IF;
END IF;

-- Recherche de la date de départ avant la modification
SELECT TO_CHAR(datdep,'yyyymmdd') INTO l_oldatdep
FROM SITU_RESS
WHERE TO_CHAR(datsitu,'dd/mm/yyyy')=p_oldatsitu
 AND  ident=TO_NUMBER(p_ident);

--l_oldatval:=to_char(to_date(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');

---------------------------------------------
-- 1) La date de valeur est modifiée
---------------------------------------------
IF (l_oldatval!=l_datval) THEN
	DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);
	-----------------------------------------------------------------------
	-- 1.1) La date de valeur doit etre supérieure à la date de valeur d'origine
	-----------------------------------------------------------------------
	IF l_oldatval>l_datval THEN
	    Pack_Global.recuperer_message(20228, NULL, NULL, 'DATSITU' , l_msg);
            RAISE_APPLICATION_ERROR(-20228, l_msg);
	END IF;

	---------------------------------------------------------
	-- 1.2) La date de départ est modifiée
	---------------------------------------------------------
	IF (l_oldatdep!=l_datfin) THEN
		/*** Les nouvelles dates ne doiventt pes appartenir à d'autres situations ***/
		OPEN curdatval;
		LOOP
			FETCH curdatval INTO datval,datfin;
			-- la date de valeur se trouve entre les dates d'une situation existante
			IF (l_datval >= datval AND  l_datval <= datfin)   THEN
			  DBMS_OUTPUT.PUT_LINE('date valeur: '||datval||' date depart: '||datfin);
			   Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      			   RAISE_APPLICATION_ERROR(-20320, l_msg);
			   p_message := l_msg;
			END IF;
			-- la date de depart se trouve entre les dates d'une situation existante
			IF  (l_datfin >= datval AND l_datfin <= datfin) THEN
			  -- dbms_output.put_line('date valeur: '||datval||' date depart: '||datfin);
			   Pack_Global.recuperer_message(20321, NULL, NULL, 'DATDEP', l_msg);
      			   RAISE_APPLICATION_ERROR(-20321, l_msg);
			   p_message := l_msg;
			END IF;
			EXIT WHEN curdatval%NOTFOUND;

		END LOOP;
		CLOSE curdatval;


		/*** La nouvelle date de départ doit etre inférieure à la date de valeur suivante ***/
		 -- Recherche de la date de valeur qui suit la date de valeur saisie
  		SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  		FROM SITU_RESS
  		WHERE TO_CHAR(datsitu,'yyyymmdd')>l_oldatval
		AND ident=TO_NUMBER(p_ident);

  		IF (l_datfin>=l_datvalnext) THEN
			Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      			RAISE_APPLICATION_ERROR(-20321, l_msg);
			p_message := l_msg;
  		END IF;

	END IF;

	---------------------------------------------------------------------------
	-- 1.3) Création d'une nouvelle situation avec la nouvelle date de valeur
	---------------------------------------------------------------------------
    BEGIN
  	INSERT INTO SITU_RESS (ident,
                                    datsitu,
                                    datdep,
                                    cout,
                                    montant_mensuel,
                                    PRESTATION,
                                    soccode,
                                    codsg
                                   )
             VALUES (TO_NUMBER(p_ident),
                     TO_DATE(p_datsitu,'mm/yyyy'),
                     TO_DATE(p_datdep,'dd/mm/yyyy'),
                     TO_NUMBER(p_coufor),
                     TO_NUMBER(p_montant_mens),
                     p_prestation,
                     p_soccode,
                     TO_NUMBER(p_codsg)
                    );

	--------------------------------------------------------------------
	-- 1.4) Mise à jour de la date de départ de la situation d'origine
	--------------------------------------------------------------------
             	BEGIN
                 	UPDATE SITU_RESS
                            SET datdep = (TO_DATE(p_datsitu,'mm/yyyy')-1)
                        WHERE ident = TO_NUMBER(p_ident)
                             AND TO_CHAR(datsitu,'yyyymmdd') = l_oldatval;

                     EXCEPTION

                        WHEN referential_integrity THEN
                           -- habiller le msg erreur
                           Pack_Global.recuperation_integrite(-2291);
                        WHEN OTHERS THEN
                            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
                    END;

                     IF SQL%NOTFOUND THEN
                         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
                         RAISE_APPLICATION_ERROR(-20999, l_msg );
                    END IF;

 		EXCEPTION
                WHEN DUP_VAL_ON_INDEX THEN
                   Pack_Global.recuperer_message(20229, NULL, NULL, NULL , l_msg);
                   RAISE_APPLICATION_ERROR(-20229, l_msg);
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
               WHEN OTHERS THEN
                    RAISE_APPLICATION_ERROR( -20997, l_msg);
	    END;

ELSE
---------------------------------------------
-- 2) La date de valeur n'est pas modifiée
---------------------------------------------

	DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);
	---------------------------------------------------------
	-- 2.1) La date de départ est modifiée
	---------------------------------------------------------
	IF (l_oldatdep!=l_datfin) THEN
		/*** La nouvelle date de départ doit etre inférieure à la date de valeur suivante ***/
		 -- Recherche de la date de valeur qui suit la date de valeur saisie
  		SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  		FROM SITU_RESS
  		WHERE TO_CHAR(datsitu,'yyyymmdd')>l_datval
		AND ident=TO_NUMBER(p_ident);

  		IF (l_datfin>=l_datvalnext) THEN
			Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      			RAISE_APPLICATION_ERROR(-20321, l_msg);
			p_message := l_msg;
  		END IF;
	END IF;
	--------------------------------
	-- MAJ SITUATION
	-------------------------------
 	BEGIN

          UPDATE SITU_RESS
                SET  datdep = TO_DATE(p_datdep,'dd/mm/yyyy'),
                      codsg = TO_NUMBER(p_codsg),
                    --filcode = p_filcode,
                    soccode = p_soccode,
                 PRESTATION = p_prestation,
                    cpident = TO_NUMBER(p_cpident),
                       cout = TO_NUMBER(p_coufor),
                       montant_mensuel = TO_NUMBER(p_montant_mens)
             WHERE ident = TO_NUMBER(p_ident)
             AND TO_CHAR(datsitu,'yyyymmdd') = l_oldatval;

         EXCEPTION
            WHEN referential_integrity THEN
               -- habiller le msg erreur
               Pack_Global.recuperation_integrite(-2291);
            WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

  	BEGIN
		UPDATE RESSOURCE
        	SET flaglock = DECODE(p_flaglock, 1000000, 0, p_flaglock + 1)
        	WHERE flaglock = p_flaglock
             	AND ident = TO_NUMBER(p_ident);
  	EXCEPTION
		WHEN referential_integrity THEN
               -- habiller le msg erreur
        		Pack_Global.recuperation_integrite(-2291);
		WHEN OTHERS THEN
               		RAISE_APPLICATION_ERROR( -20997, SQLERRM);
  	END;

  	IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR(-20999, l_msg);
  	END IF;

END IF;

    -- Message : 'situation Logiciel || p_rnom || modifie';

    Pack_Global.recuperer_message(2047, '%s1', p_rnom, NULL , l_msg);
    p_message := l_msg;

   END update_situation_f;
/******************************************************************************************/

   PROCEDURE delete_situation_f (p_ident     IN  VARCHAR2,
                                 p_coufor    IN  VARCHAR2,
                                 p_rnom      IN  VARCHAR2,
                                 p_coutot    IN  VARCHAR2,
                                 p_datsitu   IN  VARCHAR2,
				 p_datdep    IN  VARCHAR2,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_datval VARCHAR2(20);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
      l_flag RESSOURCE.flaglock%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';
      l_flag := 0;

      -- TEST : il doit toujours exister un row situation pour la ressource

      BEGIN
         SELECT COUNT(ident)
         INTO l_flag
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

         WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_flag = 1 THEN
         Pack_Global.recuperer_message(20234, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20234, l_msg );
      END IF;

      -- On utilise le flaglock de ressource pour protege l'acces a situ_ress

      BEGIN
         SELECT flaglock
         INTO l_flag
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION
         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_flag != p_flaglock THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      END IF;

     IF p_datdep IS NOT NULL THEN
	SELECT TO_CHAR(datsitu,'dd/mm/yyyy')
	INTO l_datval
	FROM SITU_RESS
	WHERE ident= TO_NUMBER(p_ident)
		AND TO_CHAR(datdep,'dd/mm/yyyy')=p_datdep;
     ELSE
	SELECT TO_CHAR(datsitu,'dd/mm/yyyy')
	INTO l_datval
	FROM SITU_RESS
	WHERE ident= TO_NUMBER(p_ident)
		AND TO_CHAR(datdep,'dd/mm/yyyy')IS NULL;
     END IF;

      BEGIN
          DELETE FROM SITU_RESS
                 WHERE ident = TO_NUMBER(p_ident)
                 AND TO_CHAR(datsitu,'dd/mm/yyyy') = l_datval;

      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            Pack_Global.recuperation_integrite(-2292);

          WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      ELSE
         Pack_Global.recuperer_message(20324, '%s1', p_ident, NULL , l_msg);
         p_message := l_msg;
      END IF;

   END delete_situation_f;



   PROCEDURE select_situation_f (p_mode        IN  VARCHAR2,
                                 p_ident        IN  VARCHAR2,
                                 p_coufor       IN  VARCHAR2,
                                 p_montant_mens       IN  VARCHAR2,
                                 p_rnom         IN  RESSOURCE.rnom%TYPE,
                                 p_coutot       IN  VARCHAR2,
                                 p_datsitu      IN  VARCHAR2,
                                 p_flaglock     IN  VARCHAR2,
                                 p_userid       IN  VARCHAR2,
                                 p_cursituation IN OUT situationCurType,
                                 p_codsg           OUT VARCHAR2,
                                 p_soccode         OUT VARCHAR2,
                                 p_cpident         OUT VARCHAR2,
                                 p_dat             OUT VARCHAR2,
                                 p_prestation      OUT VARCHAR2,
                                 p_coul            OUT VARCHAR2,
                                 p_flag            OUT VARCHAR2,
                                 p_nbcurseur       OUT INTEGER,
                                 p_message         OUT VARCHAR2
                                ) IS

      l_msg        VARCHAR2(1024);
      l_idarpege   VARCHAR2(255);
      l_prestation SITU_RESS.PRESTATION%TYPE;
      l_cout       SITU_RESS.cout%TYPE;
      l_habilitation VARCHAR2(10);
	l_codsg      SITU_RESS.codsg%TYPE;


   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Test : Prestation = FS ou FH -> renvoie coufrofs ou fh sinon 0,00

      -- récupération du coût correspondant à la situation pour la ressource

      BEGIN

         SELECT PRESTATION, cout
         INTO   l_prestation, l_cout
         FROM   SITU_RESS
         WHERE  ident = TO_NUMBER(p_ident)
         AND    PRESTATION != 'FOR'
         AND    TO_CHAR(datsitu,'dd/mm/yyyy') IN (SELECT TO_CHAR(MAX(datsitu),'dd/mm/yyyy')
                                               FROM SITU_RESS
                                               WHERE ident = TO_NUMBER(p_ident)
                                              );
         p_prestation := l_prestation;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM );
      END;

	BEGIN
		SELECT
			codsg INTO  l_codsg
		FROM
			SITU_RESS
		WHERE
			ident=p_ident
			AND  datsitu=Pack_Verif_Restab.f_datsitu_recente(p_ident);
	EXCEPTION
		WHEN  NO_DATA_FOUND THEN  l_codsg := NULL ;
	END ;


           p_coul := '0,00';



      -- TEST : p_choix == Créer -> creation !='Créer' ->modif,supp

      IF  p_mode = 'insert' THEN

        -- FLAGLOCK

        BEGIN
           SELECT flaglock
           INTO   p_flag
           FROM   RESSOURCE
           WHERE  ident = TO_NUMBER(p_ident);
        EXCEPTION
          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

        END;

        -- DATSITU

           p_dat := '';

        -- CODSG, SOCCODE, CPIDENT

        BEGIN
            SELECT codsg, soccode, cpident
            INTO p_codsg, p_soccode, p_cpident
            FROM SITU_RESS
            WHERE ident = TO_NUMBER(p_ident)
            AND TO_CHAR(datsitu,'dd/mm/yyyy') IN (SELECT TO_CHAR(MAX(datsitu),'dd/mm/yyyy')
                              FROM SITU_RESS
                              WHERE ident = TO_NUMBER(p_ident)
                             );

        EXCEPTION

         WHEN NO_DATA_FOUND THEN
            NULL;

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM );

        END;

        -- On ouvre un curseur vide, pour mettre l'automate en mode creation

        BEGIN
          OPEN p_cursituation FOR
                   SELECT RESSOURCE.ident,
                          RESSOURCE.rnom,
                          TO_CHAR(RESSOURCE.coutot, '9999999990D00'),
                          RESSOURCE.flaglock,
                          TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                          TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                          SITU_RESS.codsg,
                          --situ_ress.filcode,
                          SITU_RESS.soccode,
                          SITU_RESS.PRESTATION,
                          SITU_RESS.cpident,
                          TO_CHAR(NVL(SITU_RESS.cout,0), '9999999990D00'),
                          TO_CHAR(NVL(SITU_RESS.montant_mensuel,0), '9999999990D00'),
                          TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy'),
                          RESSOURCE.rtype
                   FROM RESSOURCE,SITU_RESS
                   WHERE RESSOURCE.ident = -1
                     AND SITU_RESS.ident = -1;
      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20997, SQLERRM);
      END;

      ELSE -- CAS d'une modification, suppression

         -- Attention ordre des colonnes doit correspondre a l ordre
         -- de declaration dans la table ORACLE (a cause de ROWTYPE)
         -- ou selectionner toutes les colonnes par *
         -- On ouvre le curseur suivant p_rnom

      -- Gestion du niveau d'acces de l'utilisateur.

      BEGIN
         SELECT codsg
         INTO   l_codsg
         FROM   SITU_RESS
         WHERE  ident = TO_NUMBER(p_ident)
         AND    TO_CHAR(datsitu,'dd/mm/yyyy') = p_datsitu;

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
            Pack_Global.recuperer_message(20245, NULL, NULL, 'IDENT', l_msg);
            RAISE_APPLICATION_ERROR(-20245, l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;


      -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier/supprimer la situation', NULL, l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;


         BEGIN
            OPEN p_cursituation FOR
                 SELECT RESSOURCE.ident,
                        RESSOURCE.rnom,
                        TO_CHAR(RESSOURCE.coutot, 'FM9999999990D00'),
                        RESSOURCE.flaglock,
                        TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                        TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                        SITU_RESS.codsg,
                        --situ_ress.filcode,
                        SITU_RESS.soccode,
                        SITU_RESS.PRESTATION,
                        SITU_RESS.cpident,
                        TO_CHAR(NVL(SITU_RESS.cout,0), 'FM9999999990D00'),
                        TO_CHAR(NVL(SITU_RESS.montant_mensuel,0), 'FM9999999990D00'),
                        TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy'),
                        RESSOURCE.rtype
                 FROM RESSOURCE,SITU_RESS
                 WHERE RESSOURCE.ident = TO_NUMBER(p_ident)
                 AND   SITU_RESS.ident = TO_NUMBER(p_ident)
                 AND TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy')
                     = TO_CHAR(TO_DATE(p_datsitu,'dd/mm/yyyy'),'dd/mm/yyyy');

--                 AND TO_CHAR(situ_ress.datsitu,'mm/yyyy')
--                     = TO_CHAR(TO_DATE(p_datsitu,'dd/mm/yyyy'),'mm/yyyy');

         EXCEPTION

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;
       END IF;

       -- en cas absence
       -- p_message := 'La situation existe deja';

      Pack_Global.recuperer_message(2041, NULL, NULL, NULL , l_msg);
      p_message := l_msg;

   END select_situation_f;

END Pack_Situation_F;
/
CREATE OR REPLACE PACKAGE Pack_Situation_Full IS
	PROCEDURE Maj_Ressource(
		p_ident	IN	RESSOURCE.ident%TYPE
	);

	PROCEDURE Delete_Situation(
		p_ident		IN	SITU_RESS.ident%TYPE,
		p_datsitu	IN	DATE
	);

	PROCEDURE Insert_Situation(
		p_ident		IN	SITU_RESS.ident%TYPE,
		p_datsitu	IN	DATE,
		p_datdep	IN	DATE,
                p_cpident       IN      NUMBER,
                p_cout          IN      NUMBER,
                p_dispo         IN      NUMBER,
                p_marsg2        IN      CHAR,
                p_rmcomp        IN      NUMBER,
                p_prestation    IN      CHAR,
                p_dprest        IN      CHAR,
                p_soccode       IN      CHAR,
                --p_filcode       IN      CHAR,
                p_codsg         IN      NUMBER,
				p_niveau		IN		VARCHAR2,
				p_montant_mensuel		IN		NUMBER

	);
	PROCEDURE Update_Situation(
		p_ident		IN	SITU_RESS.ident%TYPE,
		p_datsitu_b	IN	DATE,
		p_datsitu_a	IN	DATE,
		p_datdep_a	IN	DATE,
                p_cpident       IN      NUMBER,
                p_cout          IN      NUMBER,
                p_dispo         IN      NUMBER,
                p_marsg2        IN      CHAR,
                p_rmcomp        IN      NUMBER,
                p_prestation    IN      CHAR,
                p_dprest        IN      CHAR,
                p_soccode       IN      CHAR,
                --p_filcode       IN      CHAR,
                p_codsg         IN      NUMBER,
				p_niveau		IN		VARCHAR2,
				p_montant_mensuel		IN		NUMBER

	);

	PROCEDURE Maj_Complete;

	FUNCTION Qualif_Ressource(
		p_ident	IN	SITU_RESS.ident%TYPE,
		p_date	IN	DATE
	) RETURN SITU_RESS.PRESTATION%TYPE;
	PRAGMA RESTRICT_REFERENCES (Qualif_Ressource, WNDS, WNPS);

	FUNCTION DatSitu_Ressource(
                p_ident IN      SITU_RESS.ident%TYPE,
                p_date  IN      DATE
        ) RETURN SITU_RESS.DatSitu%TYPE;
        PRAGMA RESTRICT_REFERENCES (DatSitu_Ressource, WNDS, WNPS);

-- procedure de maj de PROPLUS suite a modif des situations
	PROCEDURE Maj_Situation_Proplus_Ress(P_Ident IN RESSOURCE.ident%TYPE);

	NORMAL	CONSTANT CHAR(1) := 'N';
	AVANT	CONSTANT CHAR(1) := 'A';
	APRES	CONSTANT CHAR(1) := 'P';
	VIDE	CONSTANT CHAR(1) := 'V';
END Pack_Situation_Full;
/

CREATE OR REPLACE PACKAGE BODY Pack_Situation_Full IS


PROCEDURE Copie_N(
		p_ident	IN	RESSOURCE.ident%TYPE
	) IS
	BEGIN
-- on retire tout ce qui existait
		DELETE SITU_RESS_FULL WHERE ident=p_ident;

-- on remet les situations existantes normales
		INSERT INTO SITU_RESS_FULL
			(DATSITU,
			DATDEP,
			CPIDENT,
			COUT,
			DISPO,
			MARSG2,
			RMCOMP,
			PRESTATION,
			DPREST,
			IDENT,
			SOCCODE,
			--FILCODE,
			CODSG,
			TYPE_SITU,
			NIVEAU)

		SELECT DATSITU,
			DATDEP,
			CPIDENT,
			COUT,
			DISPO,
			MARSG2,
			RMCOMP,
			PRESTATION,
			DPREST,
			IDENT,
			SOCCODE,
			--FILCODE,
			CODSG,
			NORMAL,
			NIVEAU

		FROM SITU_RESS
		WHERE ident=p_ident;

	END Copie_N;


	PROCEDURE Complete_AVP(
		p_ident	IN	RESSOURCE.ident%TYPE
	) IS
		nombre	INTEGER;

		CURSOR csr_situation(csr_ident IN RESSOURCE.ident%TYPE) IS
			SELECT *
			FROM SITU_RESS_FULL
			WHERE ident=csr_ident
                        AND type_situ = NORMAL
			ORDER BY datsitu;
		rec_situation_prev	csr_situation%ROWTYPE;
	BEGIN
-- ON ajoute la situation avant toutes les autres
-- ON reprend les donnees de la premiere situation
		INSERT INTO SITU_RESS_FULL
			(DATSITU,
			DATDEP,
			CPIDENT,
			COUT,
			DISPO,
			MARSG2,
			RMCOMP,
			PRESTATION,
			DPREST,
			IDENT,
			SOCCODE,
			--FILCODE,
			CODSG,
			TYPE_SITU,
			NIVEAU)

		SELECT NULL,
			DATSITU-1,
			CPIDENT,
			COUT,
			DISPO,
			MARSG2,
			RMCOMP,
			PRESTATION,
			DPREST,
			IDENT,
			SOCCODE,
			--FILCODE,
			CODSG,
			AVANT,
			NIVEAU

		FROM SITU_RESS_FULL
		WHERE ident=p_ident
                AND type_situ = NORMAL
		AND datsitu=(SELECT MIN(datsitu) FROM SITU_RESS_FULL WHERE ident=p_ident);

-- ON teste s'il existe une situation sans DATE de fin (derniere situation)
		SELECT COUNT(1)
			INTO nombre
			FROM SITU_RESS_FULL
			WHERE ident=p_ident
                        AND type_situ = NORMAL
			AND datdep IS NULL;

-- s'il en existe pas ON ajoute une situation apres la derniere
-- ON reprend les donnees de la derniere situation
		IF nombre=0 THEN
			INSERT INTO SITU_RESS_FULL
				(DATSITU,
				DATDEP,
				CPIDENT,
				COUT,
				DISPO,
				MARSG2,
				RMCOMP,
				PRESTATION,
				DPREST,
				IDENT,
				SOCCODE,
				--FILCODE,
				CODSG,
				TYPE_SITU,
				NIVEAU)

			SELECT DATDEP+1,
				NULL,
				CPIDENT,
				COUT,
				DISPO,
				MARSG2,
				RMCOMP,
				PRESTATION,
				DPREST,
				IDENT,
				SOCCODE,
				--FILCODE,
				CODSG,
				APRES,
				NIVEAU

			FROM SITU_RESS_FULL
			WHERE ident=p_ident
                        AND type_situ = NORMAL
			AND datsitu=(SELECT MAX(datsitu) FROM SITU_RESS_FULL WHERE ident=p_ident);
		END IF;

-- il reste a boucher les eventuels trous
		nombre:=0;
		FOR rec_situation IN csr_situation(p_ident) LOOP
			IF nombre=0 THEN
				nombre:=1;
			ELSE
				IF rec_situation_prev.datdep+1<rec_situation.datsitu THEN
					INSERT INTO SITU_RESS_FULL
						(DATSITU,
						DATDEP,
						CPIDENT,
						COUT,
						DISPO,
						MARSG2,
						RMCOMP,
						PRESTATION,
						DPREST,
						IDENT,
						SOCCODE,
						--FILCODE,
						CODSG,
						TYPE_SITU,
						NIVEAU)

					VALUES (rec_situation_prev.datdep+1,
						rec_situation.datsitu-1,
						rec_situation_prev.cpident,
						rec_situation_prev.cout,
						rec_situation_prev.dispo,
						rec_situation_prev.MARSG2,
						rec_situation_prev.RMCOMP,
						rec_situation_prev.PRESTATION,
						rec_situation_prev.DPREST,
						rec_situation_prev.IDENT,
						rec_situation_prev.SOCCODE,
						--rec_situation_prev.FILCODE,
						rec_situation_prev.CODSG,
						VIDE,
						rec_situation_prev.NIVEAU);

				END IF;
			END IF;
			rec_situation_prev:=rec_situation;
		END LOOP;
	END Complete_AVP;

PROCEDURE Delete_AVP(
		p_ident		IN	SITU_RESS.ident%TYPE
	) IS
	BEGIN
         DELETE FROM SITU_RESS_FULL
         WHERE ident = p_ident
         AND TYPE_SITU IN (AVANT,APRES,VIDE);
        END Delete_AVP;



	PROCEDURE Maj_Ressource(
		p_ident	IN	RESSOURCE.ident%TYPE
	) IS
		BEGIN

-- on recopie dans la table situ_ress_full les situations normales de la table situ_ress pour l'identifiant donné
		Copie_N (p_ident);
-- on complète par les avants, après et les vides
                Complete_AVP (p_ident);
	COMMIT;
	END Maj_Ressource;






	PROCEDURE Delete_Situation(
		p_ident		IN	SITU_RESS.ident%TYPE,
		p_datsitu	IN	DATE
	) IS
	BEGIN
-- on delete toutes les situations fictives avant,après et vide
        	Delete_AVP (p_ident);
-- on delete la situation passée en paramètre
        	DELETE FROM SITU_RESS_FULL
        	WHERE ident = p_ident
        	AND   datsitu = p_datsitu;
-- on complète les situations de cet identifiant par les avants,après et vide
        	Complete_AVP(p_ident);
-- on met a jour la table PROPLUS
		Maj_Situation_Proplus_Ress(p_ident);
	END Delete_Situation;


	PROCEDURE Insert_Situation(
		p_ident		IN	SITU_RESS.ident%TYPE,
		p_datsitu	IN	DATE,
		p_datdep	IN	DATE,
		p_cpident       IN      NUMBER,
                p_cout          IN      NUMBER,
                p_dispo         IN      NUMBER,
                p_marsg2        IN      CHAR,
                p_rmcomp        IN      NUMBER,
                p_prestation    IN      CHAR,
                p_dprest        IN      CHAR,
                p_soccode       IN      CHAR,
                --p_filcode       IN      CHAR,
                p_codsg         IN      NUMBER,
				p_niveau		IN		VARCHAR2,
				p_montant_mensuel		IN		NUMBER


	) IS
	BEGIN
		Delete_AVP(p_ident);
                INSERT INTO SITU_RESS_FULL
						(DATSITU,
						DATDEP,
						CPIDENT,
						COUT,
						DISPO,
						MARSG2,
						RMCOMP,
						PRESTATION,
						DPREST,
						IDENT,
						SOCCODE,
						--FILCODE,
						CODSG,
						TYPE_SITU,
						NIVEAU,
						MONTANT_MENSUEL)

		VALUES (p_datsitu,
						p_datdep,
						p_cpident,
						p_cout,
						p_dispo,
						p_marsg2,
						p_rmcomp,
						p_prestation,
						p_dprest,
						p_ident,
						p_soccode,
						--p_filcode,
						p_codsg,
						NORMAL,
						p_niveau,
						p_montant_mensuel);


	        Complete_AVP(p_ident);
-- on met a jour la table PROPLUS
		Maj_Situation_Proplus_Ress(p_ident);
	END Insert_Situation;


	PROCEDURE Update_Situation(
		p_ident		IN	SITU_RESS.ident%TYPE,
		p_datsitu_b	IN	DATE,
		p_datsitu_a	IN	DATE,
		p_datdep_a	IN	DATE,
		p_cpident       IN      NUMBER,
                p_cout          IN      NUMBER,
                p_dispo         IN      NUMBER,
                p_marsg2        IN      CHAR,
                p_rmcomp        IN      NUMBER,
                p_prestation    IN      CHAR,
                p_dprest        IN      CHAR,
                p_soccode       IN      CHAR,
                --p_filcode       IN      CHAR,
                p_codsg         IN      NUMBER,
				p_niveau		IN		VARCHAR2,
				p_montant_mensuel		IN		NUMBER


	) IS
	BEGIN
		  Delete_AVP(p_ident);
                  UPDATE SITU_RESS_FULL
                  SET   cpident       = p_cpident,
                        cout          = p_cout,
	                	dispo         = p_dispo,
                		marsg2        = p_marsg2,
                		rmcomp        = p_rmcomp,
                		PRESTATION    = p_prestation,
                		dprest        = p_dprest,
                		soccode       = p_soccode,
                		--filcode       = p_filcode,
                		codsg         = p_codsg,
                        datsitu       = p_datsitu_a,
                        datdep        = p_datdep_a,
						NIVEAU		  = p_niveau,
						MONTANT_MENSUEL = p_montant_mensuel

                  WHERE ident = p_ident
                  AND   datsitu = p_datsitu_b;
		  Complete_AVP(p_ident);
-- on met a jour la table PROPLUS
		Maj_Situation_Proplus_Ress(p_ident);
	END Update_Situation;



	PROCEDURE Maj_Complete
	IS
		CURSOR csr_ressource IS
			SELECT ident FROM RESSOURCE;
	BEGIN
		FOR rec_ressource IN csr_ressource LOOP
			maj_ressource(rec_ressource.ident);
		END LOOP;
	END Maj_complete;


        FUNCTION Qualif_Ressource(
                p_ident IN      SITU_RESS.ident%TYPE,
                p_date  IN      DATE
        ) RETURN SITU_RESS.PRESTATION%TYPE IS
		CURSOR csr_situation(pcsr_ident IN SITU_RESS.ident%TYPE) IS
			SELECT PRESTATION
				, datsitu
			FROM SITU_RESS
			WHERE ident=pcsr_ident
			ORDER BY datsitu;
		Prev_Qualif	SITU_RESS.PRESTATION%TYPE;
		Current_Qualif	SITU_RESS.PRESTATION%TYPE;
	BEGIN
		Prev_Qualif:=NULL;
		FOR rec_situation IN csr_situation(p_ident) LOOP
			Current_Qualif:=rec_situation.PRESTATION;
			IF rec_situation.datsitu>p_date THEN
				EXIT;
			END IF;
			Prev_Qualif:=Current_Qualif;
		END LOOP;
		IF Prev_Qualif IS NULL THEN
			Prev_Qualif:=Current_Qualif;
		END IF;
		RETURN Prev_Qualif;
	END Qualif_Ressource;


        FUNCTION DatSitu_Ressource(
                p_ident IN      SITU_RESS.ident%TYPE,
                p_date  IN      DATE
        ) RETURN SITU_RESS.DatSitu%TYPE IS
                CURSOR csr_situation(pcsr_ident IN SITU_RESS.ident%TYPE) IS
                        SELECT datsitu
                        FROM SITU_RESS
                        WHERE ident=pcsr_ident
                        ORDER BY datsitu;
                Prev_DatSitu	SITU_RESS.DatSitu%TYPE;
                Current_DatSitu	SITU_RESS.DatSitu%TYPE;
        BEGIN
                Prev_DatSitu:=NULL;
                FOR rec_situation IN csr_situation(p_ident) LOOP
                        Current_DatSitu:=rec_situation.DatSitu;
                        IF rec_situation.datsitu>p_date THEN
                                EXIT;
                        END IF;
                        Prev_DatSitu:=Current_DatSitu;
                END LOOP;
                IF Prev_DatSitu IS NULL THEN
                        Prev_DatSitu:=Current_DatSitu;
                END IF;
                RETURN Prev_DatSitu;
        END DatSitu_Ressource;


	PROCEDURE Maj_Situation_Proplus_Ress(P_Ident IN RESSOURCE.ident%TYPE) IS
	BEGIN
		UPDATE PROPLUS
		SET ( DATDEP, DIVSECGROU, CPIDENT, COUT, SOCIETE, QUALIF, DISPO ) =
		( SELECT DATDEP, CODSG, CPIDENT, COUT, SOCCODE, PRESTATION, DISPO
		  FROM SITU_RESS_FULL
		  WHERE PROPLUS.TIRES = SITU_RESS_FULL.IDENT
			AND ( (PROPLUS.CDEB>=SITU_RESS_FULL.DATSITU OR SITU_RESS_FULL.DATSITU IS NULL)
			      AND (PROPLUS.CDEB<=SITU_RESS_FULL.DATDEP OR SITU_RESS_FULL.DATDEP IS NULL)
			    )
			AND ROWNUM=1		-- petite condition pour se proteger contre les situations en recouvrement
		)
		WHERE tires=P_Ident;
	END Maj_Situation_Proplus_Ress;

END Pack_Situation_Full;
/
CREATE OR REPLACE PACKAGE Pack_Situation_L AS

TYPE situation_s_ViewType IS RECORD (ident      VARCHAR2(20),
                                     rnom       RESSOURCE.rnom%TYPE,
                                     coutot     VARCHAR2(20),
                                     flaglock   VARCHAR2(20),
                                     datsitu    VARCHAR2(20),
                                     datdep     VARCHAR2(20),
                                     codsg      VARCHAR2(20),
                                     --filcode    situ_ress.filcode%TYPE,
                                     soccode    SITU_RESS.soccode%TYPE,
                                     PRESTATION SITU_RESS.PRESTATION%TYPE,
                                     cpident    VARCHAR2(20),
                                     olddatsitu VARCHAR2(20),
                                     coulog	VARCHAR2(20)
                                    );

TYPE situationCurType IS REF CURSOR RETURN situation_s_ViewType;

   PROCEDURE insert_situation_l (p_oldatsitu  IN  VARCHAR2,
                                 p_ident      IN  VARCHAR2,
                                 p_coulog     IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_coutot     IN  VARCHAR2,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_cpident    IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                );

   PROCEDURE update_situation_l (p_oldatsitu  IN  VARCHAR2,
                                 p_ident      IN  VARCHAR2,
                                 p_coulog     IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_coutot     IN  VARCHAR2,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_cpident    IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                );

   PROCEDURE delete_situation_l (p_ident     IN  VARCHAR2,
                                 p_coufor    IN  VARCHAR2,
                                 p_rnom      IN  VARCHAR2,
                                 p_coutot    IN  VARCHAR2,
                                 p_datsitu   IN  VARCHAR2,
				 p_datdep    IN  VARCHAR2,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

   PROCEDURE select_situation_l (p_mode        IN  VARCHAR2,
                                 p_ident        IN  VARCHAR2,
                                 p_coulog       IN  VARCHAR2,
                                 p_rnom         IN  RESSOURCE.rnom%TYPE,
                                 p_coutot       IN  VARCHAR2,
                                 p_datsitu      IN  VARCHAR2,
                                 p_flaglock     IN  VARCHAR2,
                                 p_userid       IN  VARCHAR2,
                                 p_cursituation IN OUT situationCurType,
                                 p_codsg           OUT VARCHAR2,
                                 p_soccode         OUT VARCHAR2,
                                 p_cpident         OUT VARCHAR2,
                                 p_dat             OUT VARCHAR2,
                                 p_coul            OUT VARCHAR2,
                                 p_prestation      OUT VARCHAR2,
                                 p_flag            OUT VARCHAR2,
                                 p_nbcurseur       OUT INTEGER,
                                 p_message         OUT VARCHAR2
                                );
END Pack_Situation_L;
/

CREATE OR REPLACE PACKAGE BODY Pack_Situation_L AS
   PROCEDURE insert_situation_l (p_oldatsitu  IN  VARCHAR2,
                                 p_ident      IN  VARCHAR2,
                                 p_coulog     IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_coutot     IN  VARCHAR2,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_cpident    IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_ncodsg SITU_RESS.codsg%TYPE;
      l_dsocfer VARCHAR2(20);
      l_ncpident SITU_RESS.cpident%TYPE;
      l_date_courante VARCHAR2(20);
      l_datval VARCHAR2(20);
      l_datfin VARCHAR2(20);
      l_datval1       VARCHAR2(20);
      l_datfin1       VARCHAR2(20);
      l_datvalnext    VARCHAR2(20);
      datval          VARCHAR2(20);
      datfin          VARCHAR2(20);
      l_odatval VARCHAR2(20);

      l_menu VARCHAR2(255);
      l_topfer STRUCT_INFO.topfer%TYPE;
      l_flaglock RESSOURCE.flaglock%TYPE;
      l_habilitation VARCHAR2(10);


CURSOR curdate IS
	SELECT TO_CHAR(datsitu,'yyyymmdd') ,TO_CHAR(datdep,'yyyymmdd')
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident);

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

       -- regle 4 non prise en compte.
       -- Positionner le nb de curseurs ==> 0
       -- Initialiser le message retour

       p_nbcurseur := 0;
       p_message := '';
       l_flaglock := p_flaglock;

      -- ====================================================================
      -- 8/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( p_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce DPG 20364
		Pack_Global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', l_msg);
                RAISE_APPLICATION_ERROR(-20364, l_msg);
	END IF;

      -- Gestion de l'utilisateur

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;



       -- TEST : codsg > 100000

      IF TO_NUMBER(p_codsg) <= 100000 THEN
            Pack_Global.recuperer_message( 20223, NULL, NULL, 'CODSG', l_msg);
            RAISE_APPLICATION_ERROR(-20223, l_msg);
      END IF;

      -- TEST : TOPFER de codsg si menutil = DIR

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      IF l_menu != 'DIR' THEN

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;

      END IF;

      -- TEST : soccode existe et societe non fermee.
     IF l_menu != 'DIR' THEN
      BEGIN
           SELECT TO_CHAR(socfer,'yyyymmdd')
           INTO l_dsocfer
           FROM SOCIETE
           WHERE soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message( 20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
             Pack_Global.recuperer_message( 20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
     END IF;
      -- TEST : cpident existe

      BEGIN
          SELECT ident
          INTO   l_ncpident
          FROM   RESSOURCE
          WHERE  ident = TO_NUMBER(p_cpident);

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message( 20226, '%s1', p_cpident, 'CPIDENT', l_msg);
             RAISE_APPLICATION_ERROR(-20226, l_msg);

           WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

-- -------------------------------------------------------------------------------------
-- CONTROLES DE DATES
-- -------------------------------------------------------------------------------------
-- Recherche si la date de valeur existe déjà
  SELECT COUNT(datsitu) INTO l_odatval
  FROM SITU_RESS
  WHERE ident=TO_NUMBER(p_ident)
	AND TO_CHAR(datsitu,'mm/yyyy')=p_datsitu;
IF l_odatval=1 THEN
	SELECT SUBSTR(TO_CHAR(datsitu,'dd/mm/yyyy'),1,2) INTO l_datval
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident)
	AND   TO_CHAR(datsitu,'mm/yyyy')=p_datsitu ;
	-- Impossible de créer une autre situation dans le même mois
	IF l_datval!='01' THEN
		Pack_Global.recuperer_message(20322, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20322, l_msg);
		p_message := l_msg;
   	END IF;
END IF;

l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';
l_datfin:=TO_CHAR(TO_DATE(p_datdep,'dd/mm/yyyy'),'yyyymmdd') ;
---------------------------------------------------------------------------
-- La date de valeur est toujours inférieure à la date de départ
---------------------------------------------------------------------------
IF (p_datdep IS NOT NULL) THEN

	IF l_datval>l_datfin THEN
    		Pack_Global.recuperer_message(20227, NULL, NULL, 'DATSITU', l_msg);
      	     	RAISE_APPLICATION_ERROR(-20227, l_msg);
		p_message := l_msg;
	END IF;
END IF;

-- Recherche de la date de départ la plus récente
SELECT TO_CHAR(datdep,'yyyymmdd') INTO l_datfin1
FROM SITU_RESS
WHERE datsitu=(SELECT MAX(datsitu)
		FROM SITU_RESS
		WHERE 	ident=TO_NUMBER(p_ident))
AND	ident=TO_NUMBER(p_ident);

-- Recherche de la date de valeur la plus récente
SELECT MAX(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datval1
FROM SITU_RESS
WHERE ident=TO_NUMBER(p_ident);


------------------------------------------------------------------------------------
-- 1) Cas d'une situation intermédiaire ou antérieure à la plus ancienne situation
------------------------------------------------------------------------------------
IF  l_datval<l_datval1 THEN                    /* Cas d'une situation intermédiaire */
  -- La date de départ est obligatoire
  IF l_datfin IS NULL THEN
	Pack_Global.recuperer_message(20441, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20441, l_msg);
		p_message := l_msg;
  END IF;

  ---------------------------------------------------------------------------------------
  -- Vérification de la validité des dates (non comprises dans des situations existantes)
  ---------------------------------------------------------------------------------------
  OPEN curdate;
  LOOP
	FETCH curdate INTO datval,datfin;
	-- la date de valeur se trouve entre les dates d'une situation existante
	IF (l_datval > datval AND  l_datval<=datfin)   THEN
		Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20320, l_msg);
		p_message := l_msg;
	END IF;
	-- la date de depart se trouve entre les dates d'une situation existante
	IF  (l_datfin >=datval AND l_datfin<=datfin ) THEN
	    IF l_odatval<1 THEN
		Pack_Global.recuperer_message(20321, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20321, l_msg);
		p_message := l_msg;
	    END IF;
	END IF;
	EXIT WHEN curdate%NOTFOUND;

  END LOOP;
  CLOSE curdate;

  -- Recherche de la date de valeur qui suit la date de valeur saisie
  SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  FROM SITU_RESS
  WHERE TO_CHAR(datsitu,'yyyymmdd')>l_datval
	AND ident=TO_NUMBER(p_ident);


  ---------------------------------------------------------------------------------------------
  -- La situation  entre la date de valeur et celle de départ ne doit pas chevaucher
  -- les situations existantes
  -- ie la date de départ doit etre inférieure à la date de valeur de la situation postérieure
  ---------------------------------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('datedep : '||l_datfin||', datval: '||l_datval);
IF (l_datfin>=l_datvalnext)  THEN
	Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      	RAISE_APPLICATION_ERROR(-20321, l_msg);
	p_message := l_msg;
  END IF;

END IF;

---------------------------------------------------------------------
-- 2) Cas où d'une situation qui suit la situation la plus récente
---------------------------------------------------------------------
IF (l_datval>l_datval1)  THEN
  IF (l_datfin1 IS NULL) THEN
	-- La date de départ la plus récente est égale à la date de valeur saisie-1jour
	BEGIN
		UPDATE SITU_RESS
		SET datdep=(TO_DATE(p_datsitu,'mm/yyyy')-1)
		WHERE datsitu= (SELECT MAX(datsitu)
				FROM SITU_RESS
				WHERE ident=TO_NUMBER(p_ident))
			AND ident=TO_NUMBER(p_ident);
	EXCEPTION
		WHEN referential_integrity THEN
			Pack_Global.recuperation_integrite(-2291);
		WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR(-20997,SQLERRM);
	END;
	-- Mise à jour de ressource
	BEGIN
		UPDATE RESSOURCE
		SET flaglock=DECODE(l_flaglock,1000000,0,l_flaglock+1)
		WHERE flaglock=l_flaglock
			AND ident= TO_NUMBER(p_ident);
	EXCEPTION
		WHEN referential_integrity THEN
			Pack_Global.recuperation_integrite(-2291);
		WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR(-20997,SQLERRM);
	END;
	l_flaglock:=l_flaglock+1;
  ELSE
	IF l_datval<=l_datfin1 THEN
		Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20320, l_msg);
		p_message := l_msg;
	END IF;
  END IF;

END IF;


-- la date de valeur n'existe pas
IF l_odatval<1 THEN
	BEGIN
          	INSERT INTO SITU_RESS (ident,
                                    	datsitu,
                                       	datdep,
                                   	PRESTATION,
                                 	soccode,
                                   	codsg,
                                  	--filcode,
                                 	cpident
                                           )
           	VALUES (TO_NUMBER(p_ident),
                              TO_DATE(p_datsitu,'mm/yyyy'),
                              TO_DATE(p_datdep,'dd/mm/yyyy'),
                              p_prestation,
                              p_soccode,
                              TO_NUMBER(p_codsg),
                              --p_filcode,
                              p_cpident
                             );
       		EXCEPTION
              	WHEN DUP_VAL_ON_INDEX THEN
                  	-- 'la ressource existe deja'
                       	Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
                              RAISE_APPLICATION_ERROR( -20219, l_msg );
             	WHEN referential_integrity THEN
                        -- habiller le msg erreur
                     	Pack_Global.recuperation_integrite(-2291);
    		WHEN OTHERS THEN
                       	RAISE_APPLICATION_ERROR( -20997, SQLERRM);
       	END;
-- La date de valeur existe déjà
ELSE
       BEGIN
               UPDATE SITU_RESS SET  datdep     = TO_DATE(p_datdep,'dd/mm/yyyy'),
                                     codsg      = TO_NUMBER(p_codsg),
                                     --filcode    = p_filcode,
                                     soccode    = p_soccode,
                                     PRESTATION = p_prestation,
                                     cpident    = TO_NUMBER(p_cpident)
                WHERE ident = TO_NUMBER(p_ident)
                AND TO_CHAR(datsitu,'yyyymmdd') = l_datval;

            EXCEPTION
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
                WHEN OTHERS THEN
                     RAISE_APPLICATION_ERROR( -20997, SQLERRM);
             END;

             BEGIN
                 UPDATE RESSOURCE
                 SET    flaglock = DECODE(l_flaglock, 1000000, 0, l_flaglock + 1)
                 WHERE  flaglock = l_flaglock
                 AND    ident = TO_NUMBER(p_ident);

             EXCEPTION
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
                 WHEN OTHERS THEN
                    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
             END;

             IF SQL%NOTFOUND THEN
                Pack_Global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
                RAISE_APPLICATION_ERROR(-20999, l_msg);
             END IF;
END IF;

    -- Message : 'situation Logiciel || p_rnom || creee';

    Pack_Global.recuperer_message(2042, '%s1', p_ident, NULL, l_msg);
    p_message := l_msg;

   END insert_situation_l;

/****************************************************************************************
****************************************************************************************/

   PROCEDURE update_situation_l (p_oldatsitu  IN  VARCHAR2,
                                 p_ident      IN  VARCHAR2,
                                 p_coulog     IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_coutot     IN  VARCHAR2,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_cpident    IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_ncodsg SITU_RESS.codsg%TYPE;
      l_ncpident SITU_RESS.cpident%TYPE;
      l_dsocfer       VARCHAR2(20);
      l_date_courante VARCHAR2(20);
      l_datval        VARCHAR2(20);
      l_oldatval      VARCHAR2(20);
      l_datfin        VARCHAR2(20);
      l_menu 	      VARCHAR2(255);
      l_topfer STRUCT_INFO.topfer%TYPE;
	l_datvalnext    VARCHAR2(20);
	l_oldatdep  VARCHAR2(20);
	l_datval1  VARCHAR2(20);


	datval VARCHAR2(20);
	datfin VARCHAR2(20);
CURSOR curdatval IS
	SELECT TO_CHAR(datsitu,'yyyymmdd') ,TO_CHAR(datdep,'yyyymmdd')
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident)
	AND    TO_CHAR(datsitu,'dd/mm/yyyy')!=p_oldatsitu;

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

       -- REGLE non respecte : 9.12.5 regle 4 gestion utilisateur.
       -- Positionner le nb de curseurs ==> 0
       -- Initialiser le message retour

       p_nbcurseur := 0;
       p_message := '';

      -- Gestion de l'utilisateur

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

       -- TEST : codsg > 100000
      IF TO_NUMBER(p_codsg) <= 100000 THEN
            Pack_Global.recuperer_message(20223, NULL, NULL, 'CODSG', l_msg);
            RAISE_APPLICATION_ERROR(-20223, l_msg);
      END IF;

      -- TEST : TOPFER de codsg si menutil = DIR

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      IF l_menu != 'DIR' THEN

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;



      -- TEST : soccode existe et societe non fermee.

      BEGIN
           SELECT TO_CHAR(socfer,'yyyymmdd')
           INTO l_dsocfer
           FROM SOCIETE
           WHERE soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, l_msg);

      END;

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
             Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
     END IF;
      -- TEST : cpident existe

      BEGIN
          SELECT ident
          INTO l_ncpident
          FROM RESSOURCE
          WHERE ident = TO_NUMBER(p_cpident);

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message(20226, '%s1', p_cpident, 'CPIDENT', l_msg);
             RAISE_APPLICATION_ERROR(-20226, l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR ( -20997, SQLERRM);
      END;


--------------------------------------------------
-- CONTROLE DES DATES
-- MAJ le 10/04/2000 par NCM
---------------------------------------------------
l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm');
l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymm');
IF l_datval=l_oldatval THEN
	l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');
	l_datval:=l_oldatval;
ELSE
	l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');
	l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';
END IF;

---------------------------------------------------------------------------
-- La date de valeur est toujours inférieure à la date de départ
---------------------------------------------------------------------------
l_datfin:=TO_CHAR(TO_DATE(p_datdep,'dd/mm/yyyy'),'yyyymmdd') ;

IF (p_datdep IS NOT NULL) THEN
	IF l_datval>l_datfin THEN
    		Pack_Global.recuperer_message(20227, NULL, NULL, 'DATSITU', l_msg);
      	     	RAISE_APPLICATION_ERROR(-20227, l_msg);
		p_message := l_msg;
	END IF;
END IF;

DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);

-- Recherche de la date de valeur la plus récente
SELECT MAX(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datval1
FROM SITU_RESS
WHERE ident=TO_NUMBER(p_ident);

IF  l_datval<l_datval1 THEN                    /* Cas d'une situation intermédiaire */
  -- La date de départ est obligatoire
  IF l_datfin IS NULL THEN
	Pack_Global.recuperer_message(20441, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20441, l_msg);
		p_message := l_msg;
  END IF;
END IF;

-- Recherche de la date de départ avant la modification
SELECT TO_CHAR(datdep,'yyyymmdd') INTO l_oldatdep
FROM SITU_RESS
WHERE TO_CHAR(datsitu,'dd/mm/yyyy')=p_oldatsitu
 AND  ident=TO_NUMBER(p_ident);

--l_oldatval:=to_char(to_date(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');

---------------------------------------------
-- 1) La date de valeur est modifiée
---------------------------------------------
IF (l_oldatval!=l_datval) THEN
	DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);
	-----------------------------------------------------------------------
	-- 1.1) La date de valeur doit etre supérieure à la date de valeur d'origine
	-----------------------------------------------------------------------
	IF l_oldatval>l_datval THEN
	    Pack_Global.recuperer_message(20228, NULL, NULL, 'DATSITU' , l_msg);
            RAISE_APPLICATION_ERROR(-20228, l_msg);
	END IF;

	---------------------------------------------------------
	-- 1.2) La date de départ est modifiée
	---------------------------------------------------------
	IF (l_oldatdep!=l_datfin) THEN
		/*** Les nouvelles dates ne doiventt pes appartenir à d'autres situations ***/
		OPEN curdatval;
		LOOP
			FETCH curdatval INTO datval,datfin;
			-- la date de valeur se trouve entre les dates d'une situation existante
			IF (l_datval >= datval AND  l_datval <= datfin)   THEN
			  DBMS_OUTPUT.PUT_LINE('date valeur: '||datval||' date depart: '||datfin);
			   Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      			   RAISE_APPLICATION_ERROR(-20320, l_msg);
			   p_message := l_msg;
			END IF;
			-- la date de depart se trouve entre les dates d'une situation existante
			IF  (l_datfin >= datval AND l_datfin <= datfin) THEN
			  -- dbms_output.put_line('date valeur: '||datval||' date depart: '||datfin);
			   Pack_Global.recuperer_message(20321, NULL, NULL, 'DATDEP', l_msg);
      			   RAISE_APPLICATION_ERROR(-20321, l_msg);
			   p_message := l_msg;
			END IF;
			EXIT WHEN curdatval%NOTFOUND;

		END LOOP;
		CLOSE curdatval;


		/*** La nouvelle date de départ doit etre inférieure à la date de valeur suivante ***/
		 -- Recherche de la date de valeur qui suit la date de valeur saisie
  		SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  		FROM SITU_RESS
  		WHERE TO_CHAR(datsitu,'yyyymmdd')>l_oldatval
		AND ident=TO_NUMBER(p_ident);

  		IF (l_datfin>=l_datvalnext) THEN
			Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      			RAISE_APPLICATION_ERROR(-20321, l_msg);
			p_message := l_msg;
  		END IF;

	END IF;

	---------------------------------------------------------------------------
	-- 1.3) Création d'une nouvelle situation avec la nouvelle date de valeur
	---------------------------------------------------------------------------
	BEGIN
             INSERT INTO SITU_RESS (ident,
                                    datsitu,
                                    datdep,
                                    PRESTATION,
                                    soccode,
                                    codsg
                                   )
             VALUES (TO_NUMBER(p_ident),
                     TO_DATE(p_datsitu,'mm/yyyy'),
                     TO_DATE(p_datdep,'dd/mm/yyyy'),
                     p_prestation,
                     p_soccode,
                     TO_NUMBER(p_codsg)
                    );
	--------------------------------------------------------------------
	-- 1.4) Mise à jour de la date de départ de la situation d'origine
	--------------------------------------------------------------------
           BEGIN
                 	UPDATE SITU_RESS
                            SET datdep = (TO_DATE(p_datsitu,'mm/yyyy')-1)
                        WHERE ident = TO_NUMBER(p_ident)
                             AND TO_CHAR(datsitu,'yyyymmdd') = l_oldatval;

    		EXCEPTION
                        WHEN referential_integrity THEN
                           -- habiller le msg erreur
                           Pack_Global.recuperation_integrite(-2291);
                        WHEN OTHERS THEN
                            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
            END;

                     IF SQL%NOTFOUND THEN
                         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
                         RAISE_APPLICATION_ERROR(-20999, l_msg );
                    END IF;

 		EXCEPTION
                WHEN DUP_VAL_ON_INDEX THEN
                   Pack_Global.recuperer_message(20229, NULL, NULL, NULL , l_msg);
                   RAISE_APPLICATION_ERROR(-20229, l_msg);
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
               WHEN OTHERS THEN
                    RAISE_APPLICATION_ERROR( -20997, l_msg);
	    END;

ELSE
---------------------------------------------
-- 2) La date de valeur n'est pas modifiée
---------------------------------------------

	DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);
	---------------------------------------------------------
	-- 2.1) La date de départ est modifiée
	---------------------------------------------------------
	IF (l_oldatdep!=l_datfin) THEN
		/*** La nouvelle date de départ doit etre inférieure à la date de valeur suivante ***/
		 -- Recherche de la date de valeur qui suit la date de valeur saisie
  		SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  		FROM SITU_RESS
  		WHERE TO_CHAR(datsitu,'yyyymmdd')>l_datval
		AND ident=TO_NUMBER(p_ident);

  		IF (l_datfin>=l_datvalnext) THEN
			Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      			RAISE_APPLICATION_ERROR(-20321, l_msg);
			p_message := l_msg;
  		END IF;
	END IF;
	--------------------------------
	-- MAJ SITUATION
	-------------------------------
 	BEGIN
             UPDATE SITU_RESS
                SET datdep     = TO_DATE(p_datdep,'dd/mm/yyyy'),
                    codsg      = TO_NUMBER(p_codsg),
                    --filcode    = p_filcode,
                    soccode    = p_soccode,
                    PRESTATION = p_prestation,
                    cpident    = TO_NUMBER(p_cpident)
             WHERE ident = TO_NUMBER(p_ident)
             AND TO_CHAR(datsitu,'yyyymmdd') = l_oldatval;
  	EXCEPTION
            WHEN referential_integrity THEN
               -- habiller le msg erreur
               Pack_Global.recuperation_integrite(-2291);
            WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

  	BEGIN
		UPDATE RESSOURCE
        	SET flaglock = DECODE(p_flaglock, 1000000, 0, p_flaglock + 1)
        	WHERE flaglock = p_flaglock
             	AND ident = TO_NUMBER(p_ident);
  	EXCEPTION
		WHEN referential_integrity THEN
               -- habiller le msg erreur
        		Pack_Global.recuperation_integrite(-2291);
		WHEN OTHERS THEN
               		RAISE_APPLICATION_ERROR( -20997, SQLERRM);
  	END;

  	IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR(-20999, l_msg);
  	END IF;

END IF;

    -- Message : 'situation Logiciel || p_rnom || modifie';

    Pack_Global.recuperer_message(20230, '%s1', p_rnom, NULL , l_msg);
    p_message := l_msg;

   END update_situation_l;

/*************************************************************************************
*************************************************************************************/

   PROCEDURE delete_situation_l (p_ident     IN  VARCHAR2,
                                 p_coufor    IN  VARCHAR2,
                                 p_rnom      IN  VARCHAR2,
                                 p_coutot    IN  VARCHAR2,
                                 p_datsitu   IN  VARCHAR2,
				 p_datdep    IN  VARCHAR2,
                                 p_flaglock  IN  NUMBER,
                                 p_userid    IN  VARCHAR2,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_datval VARCHAR2(20);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
      l_flag RESSOURCE.flaglock%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';
      l_flag := 0;

      -- TEST : il doit toujours exister un row situation pour la ressource

      BEGIN
         SELECT COUNT(ident)
         INTO l_flag
         FROM SITU_RESS
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION

         WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_flag = 1 THEN
         Pack_Global.recuperer_message(20234, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20234, l_msg );
      END IF;

      -- On utilise le flaglock de ressource pour protege l'acces a situ_ress

      BEGIN
         SELECT flaglock
         INTO l_flag
         FROM RESSOURCE
         WHERE ident = TO_NUMBER(p_ident);

      EXCEPTION
         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_flag != p_flaglock THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      END IF;

      IF p_datdep IS NOT NULL THEN
	SELECT TO_CHAR(datsitu,'dd/mm/yyyy')
	INTO l_datval
	FROM SITU_RESS
	WHERE ident= TO_NUMBER(p_ident)
		AND TO_CHAR(datdep,'dd/mm/yyyy')=p_datdep;
     ELSE
	SELECT TO_CHAR(datsitu,'dd/mm/yyyy')
	INTO l_datval
	FROM SITU_RESS
	WHERE ident= TO_NUMBER(p_ident)
		AND TO_CHAR(datdep,'dd/mm/yyyy')IS NULL;
     END IF;



      BEGIN
          DELETE FROM SITU_RESS
                 WHERE ident = TO_NUMBER(p_ident)
		AND TO_CHAR(datsitu,'dd/mm/yyyy') =l_datval;

      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            Pack_Global.recuperation_integrite(-2292);

          WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg );
      ELSE
         Pack_Global.recuperer_message(2040, '%s1', p_ident, NULL , l_msg);
         p_message := l_msg;
      END IF;

   END delete_situation_l;

/***************************************************************************************
****************************************************************************************/
   PROCEDURE select_situation_l (p_mode        IN  VARCHAR2,
                                 p_ident        IN  VARCHAR2,
                                 p_coulog       IN  VARCHAR2,
                                 p_rnom         IN  RESSOURCE.rnom%TYPE,
                                 p_coutot       IN  VARCHAR2,
                                 p_datsitu      IN  VARCHAR2,
                                 p_flaglock     IN  VARCHAR2,
                                 p_userid       IN  VARCHAR2,
                                 p_cursituation IN OUT situationCurType,
                                 p_codsg           OUT VARCHAR2,
                                 p_soccode         OUT VARCHAR2,
                                 p_cpident         OUT VARCHAR2,
                                 p_dat             OUT VARCHAR2,
                                 p_coul            OUT VARCHAR2,
                                 p_prestation      OUT VARCHAR2,
                                 p_flag            OUT VARCHAR2,
                                 p_nbcurseur       OUT INTEGER,
                                 p_message         OUT VARCHAR2
                                ) IS

      l_msg      VARCHAR2(1024);
      l_ges      NUMBER(3);
      l_idarpege VARCHAR2(255);
      l_habilitation VARCHAR2(10);

	l_codsg    SITU_RESS.codsg%TYPE;


   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

	BEGIN
		SELECT
			codsg INTO l_codsg
		FROM
			SITU_RESS
		WHERE
			ident=p_ident
			AND datsitu=Pack_Verif_Restab.f_datsitu_recente(p_ident);
	END;



      BEGIN
         SELECT TO_CHAR(cout_log,'FM9999D00')
         INTO p_coul
         FROM COUT_STD2 , DATDEBEX
         WHERE annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
			AND dpg_bas = (SELECT dpg_bas FROM COUT_STD2,DATDEBEX WHERE dpg_bas<= l_codsg
						AND l_codsg <=dpg_haut
						AND annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
						AND ROWNUM = 1);


      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           Pack_Global.recuperer_message(20510, NULL, NULL, NULL, l_msg);
           RAISE_APPLICATION_ERROR( -20510, l_msg);

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      p_prestation := 'LG';

      -- TEST : p_choix == Créer -> creation !='Créer' ->modif,supp

      IF  p_mode = 'insert' THEN

        -- FLAGLOCK

        BEGIN
           SELECT flaglock
           INTO   p_flag
           FROM   RESSOURCE
           WHERE  ident = TO_NUMBER(p_ident);
        EXCEPTION
          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

        END;

        -- DATSITU

           p_dat := '';

        -- CODSG, SOCCODE, CPIDENT

        BEGIN
            SELECT  codsg,  soccode,  cpident
            INTO   p_codsg, p_soccode, p_cpident
            FROM   SITU_RESS
            WHERE  ident = TO_NUMBER(p_ident)
            AND    TO_CHAR(datsitu,'dd/mm/yyyy') IN (
                              SELECT TO_CHAR(MAX(datsitu),'dd/mm/yyyy')
                              FROM SITU_RESS
                              WHERE ident = TO_NUMBER(p_ident)
                             );

        EXCEPTION
          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

        END;


        -- On ouvre un curseur vide, pour mettre l'automate en mode creation

        BEGIN
          OPEN p_cursituation FOR
                   SELECT RESSOURCE.ident,
                          RESSOURCE.rnom,
                          TO_CHAR(RESSOURCE.coutot, '9999999999D00'),
                          RESSOURCE.flaglock,
                          TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                          TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                          SITU_RESS.codsg,
                          --situ_ress.filcode,
                          SITU_RESS.soccode,
                          SITU_RESS.PRESTATION,
                          SITU_RESS.cpident,
                          TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy'),
                          TO_CHAR(NVL(cout_log,0), '999990D00')
                   FROM RESSOURCE, SITU_RESS, COUT_STD2, DATDEBEX
                   WHERE RESSOURCE.ident = -1
                     AND SITU_RESS.ident = -1
                     AND annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
                     AND dpg_bas = ( SELECT dpg_bas FROM COUT_STD2,DATDEBEX WHERE dpg_bas <= l_codsg
						AND l_codsg <= dpg_haut
						AND annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
						AND ROWNUM = 1 );

      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20997, SQLERRM);
      END;

      ELSE -- CAS d'une modification, suppression

         -- Attention ordre des colonnes doit correspondre a l ordre
         -- de declaration dans la table ORACLE (a cause de ROWTYPE)
         -- ou selectionner toutes les colonnes par *
         -- On ouvre le curseur suivant p_rnom

      -- Gestion du niveau d'acces de l'utilisateur.

      BEGIN
         SELECT codsg
         INTO   l_codsg
         FROM   SITU_RESS
         WHERE  ident = TO_NUMBER(p_ident)
         AND    TO_CHAR(datsitu,'dd/mm/yyyy') = p_datsitu;

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
            Pack_Global.recuperer_message(20245, NULL, NULL, 'IDENT', l_msg);
            RAISE_APPLICATION_ERROR( -20245, l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

        -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier/supprimer la situation', NULL, l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;


         BEGIN
            OPEN p_cursituation FOR
                 SELECT RESSOURCE.ident,
                        RESSOURCE.rnom,
                        TO_CHAR(RESSOURCE.coutot, 'FM9999999990D00'),
                        RESSOURCE.flaglock,
                        TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                        TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                        SITU_RESS.codsg,
                        --situ_ress.filcode,
                        SITU_RESS.soccode,
                        SITU_RESS.PRESTATION,
                        SITU_RESS.cpident,
                        TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy'),
                        TO_CHAR(NVL(cout_log,0), '999990D00')
                 FROM RESSOURCE,SITU_RESS, COUT_STD2, DATDEBEX
                 WHERE RESSOURCE.ident = TO_NUMBER(p_ident)
                 AND SITU_RESS.ident = TO_NUMBER(p_ident)
                 AND TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy')
                     = TO_CHAR(TO_DATE(p_datsitu,'dd/mm/yyyy'),'dd/mm/yyyy')
                 AND annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
                 AND dpg_bas = ( SELECT dpg_bas FROM COUT_STD2,DATDEBEX WHERE dpg_bas <= l_codsg
						AND l_codsg <= dpg_haut
						AND annee = TO_NUMBER(TO_CHAR(DATDEBEX,'yyyy'))
						AND ROWNUM = 1 );


         EXCEPTION

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;
       END IF;

       -- en cas absence
       -- p_message := 'La situation existe deja';

      Pack_Global.recuperer_message(2041, '%s1', p_ident, NULL , l_msg);
      p_message := l_msg;

   END select_situation_l;

END Pack_Situation_L;
/
CREATE OR REPLACE PACKAGE Pack_Situation_P AS

TYPE situation_s_ViewType IS RECORD (ident      VARCHAR2(20),
                                     rnom       RESSOURCE.rnom%TYPE,
                                     rprenom    RESSOURCE.rprenom%TYPE,
                                     matricule  RESSOURCE.matricule%TYPE,
                                     datsitu    VARCHAR2(20),
                                     datdep     VARCHAR2(20),
                                     codsg      VARCHAR2(20),
                                     --filcode    situ_ress.filcode%TYPE,
                                     soccode    SITU_RESS.soccode%TYPE,
									 p_niveau	SITU_RESS.NIVEAU%TYPE,
                                     PRESTATION SITU_RESS.PRESTATION%TYPE,
                                     cpident    VARCHAR2(20),
                                     rmcomp     VARCHAR2(20),
                                     dispo      VARCHAR2(20),
                                     cout       VARCHAR2(20),
                                     olddatsitu VARCHAR2(20),
                                     flaglock   VARCHAR2(20),
									 code_domaine    TYPE_DOMAINE.CODE_DOMAINE%TYPE
                                    );

TYPE situationCurType IS REF CURSOR RETURN situation_s_ViewType;

   PROCEDURE insert_situation_p (p_oldatsitu  IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_ident      IN  VARCHAR2,
                                 p_rprenom    IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule  IN  RESSOURCE.matricule%TYPE,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_rmcomp     IN  VARCHAR2,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_dispo      IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_cout       IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                );

   PROCEDURE update_situation_p (p_oldatsitu  IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_ident      IN  VARCHAR2,
                                 p_rprenom    IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule  IN  RESSOURCE.matricule%TYPE,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_rmcomp     IN  VARCHAR2,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_dispo      IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_cout       IN  VARCHAR2,
                                 p_niveau     IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                );

   PROCEDURE delete_situation_p (p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_ident      IN  VARCHAR2,
                                 p_rprenom    IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule  IN  RESSOURCE.matricule%TYPE,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_rmcomp     IN  VARCHAR2,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_dispo      IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_cout       IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                );

   PROCEDURE select_situation_p (p_mode        IN  VARCHAR2,
                                 p_rnom         IN  RESSOURCE.rnom%TYPE,
                                 p_ident        IN  VARCHAR2,
                                 p_rprenom      IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule    IN  RESSOURCE.matricule%TYPE,
                                 p_datsitu      IN  VARCHAR2,
                                 p_flaglock     IN  VARCHAR2,
                                 p_userid       IN  VARCHAR2,
                                 p_cursituation IN OUT situationCurType,
                                 p_codsg        OUT VARCHAR2,
                                 p_soccode      OUT VARCHAR2,
					   p_niveau		OUT VARCHAR2,
                                 p_prestation   OUT VARCHAR2,
                                 p_cpident      OUT VARCHAR2,
                                 p_rmcomp       OUT VARCHAR2,
                                 p_dispo        OUT VARCHAR2,
                                 p_cout         OUT VARCHAR2,
								 p_dat          OUT VARCHAR2,
                                 p_flag         OUT VARCHAR2,
                                 p_nbcurseur    OUT INTEGER,
                                 p_message      OUT VARCHAR2,
								 p_code_domaine   OUT PRESTATION.CODE_DOMAINE%TYPE
                                );


-- Curseur permettant de ramener la liste des niveaux existants

TYPE niveau_ViewType IS RECORD ( NIVEAU VARCHAR2(2), LIBNIVEAU VARCHAR2(20)
);

TYPE  niveau_Curseur IS REF CURSOR RETURN  niveau_ViewType;



PROCEDURE select_liste_Niveaux( s_curseur 	IN OUT  niveau_Curseur);


END Pack_Situation_P;
/

CREATE OR REPLACE PACKAGE BODY Pack_Situation_P AS
   PROCEDURE insert_situation_p (p_oldatsitu  IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_ident      IN  VARCHAR2,
                                 p_rprenom    IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule  IN  RESSOURCE.matricule%TYPE,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_rmcomp     IN  VARCHAR2,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_dispo      IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_cout       IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                ) IS

      l_msg           VARCHAR2(1024);
      l_ncodsg        SITU_RESS.codsg%TYPE;
      l_dsocfer       VARCHAR2(20);
      l_ncpident      SITU_RESS.cpident%TYPE;
      l_date_courante VARCHAR2(20);
      l_datval        VARCHAR2(20);
      l_datfin        VARCHAR2(20);
      l_datval1       VARCHAR2(20);
      l_datfin1       VARCHAR2(20);
      l_datvalnext    VARCHAR2(20);
      datval          VARCHAR2(20);
      datfin          VARCHAR2(20);
      l_odatval       NUMBER;

      l_menu          VARCHAR2(255);
      l_prest         PRESTATION.PRESTATION%TYPE;
      l_topfer        STRUCT_INFO.topfer%TYPE;
      l_niveau        SITU_RESS.NIVEAU%TYPE;
      l_flaglock      RESSOURCE.flaglock%TYPE;
      l_habilitation VARCHAR2(10);
	l_codbr NUMBER(2);

      CURSOR curdate IS
	SELECT TO_CHAR(datsitu,'yyyymmdd') ,TO_CHAR(datdep,'yyyymmdd')
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident);

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

       -- regle 4 non prise en compte.
       -- Positionner le nb de curseurs ==> 0
       -- Initialiser le message retour

       p_nbcurseur := 0;
       p_message := '';
       l_flaglock := p_flaglock;

      -- ====================================================================
      -- 8/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( p_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas habilité à ce DPG 20364
		Pack_Global.recuperer_message(20364, '%s1', 'à ce DPG', 'CODSG', l_msg);
                RAISE_APPLICATION_ERROR(-20364, l_msg);
	END IF;

      -- TEST : PRESTATION = MO ou GRA

      IF p_prestation != 'MO' AND p_prestation != 'GRA' AND p_prestation != 'IFO' AND p_prestation != 'STA' AND p_prestation != 'INT' THEN
         IF (p_cout = ',00' OR p_cout = '0,00' OR p_cout IS NULL) AND (p_soccode <> 'SG..') THEN
            Pack_Global.recuperer_message(20247, NULL, NULL, 'COUT', l_msg);
            RAISE_APPLICATION_ERROR(-20247, l_msg);
         END IF;
      END IF;

       -- TEST : RMCOMP doit etre = 0 ou 1

      -- IF (p_rmcomp != 0) AND (p_rmcomp != 1) THEN
         -- Pack_Global.recuperer_message(20275, NULL, NULL, 'RMCOMP', l_msg);
         -- RAISE_APPLICATION_ERROR(-20275, l_msg);
      -- END IF;

      -- TEST : 0< DISPO < 7

      IF (TO_NUMBER(p_dispo) < 0) OR (TO_NUMBER(p_dispo) > 7) THEN
           Pack_Global.recuperer_message(20248, NULL, NULL, 'COUT', l_msg);
           RAISE_APPLICATION_ERROR(-20248, l_msg);
      END IF;

      -- TEST : Il doit exister ds cout_pres un codprest pour l'annee d'arrive de la personne


      -- TEST : Gestion de l'utilisateur pour cout (RES)

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      IF l_menu != 'DIR' THEN

	BEGIN
          SELECT PRESTATION
          INTO l_prest
          FROM PRESTATION
          WHERE UPPER(top_actif)='O'
          AND PRESTATION = p_prestation;

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message(20246, '%s1', p_prestation, 'PRESTATION', l_msg);
             RAISE_APPLICATION_ERROR(-20246, l_msg);

           WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997,SQLERRM);
      END;

      END IF;

      -- TEST : TOPFER de codsg si menutil != DIR

      IF l_menu != 'DIR' THEN

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;

      END IF;


       -- TEST : codsg > 1

      IF TO_NUMBER(p_codsg) <= 1 THEN
            Pack_Global.recuperer_message( 20223, NULL, NULL, 'CODSG', l_msg);
            RAISE_APPLICATION_ERROR(-20223, l_msg);
      END IF;

      -- TEST : soccode existe et societe non fermee.
     IF l_menu != 'DIR' THEN

      BEGIN
           SELECT TO_CHAR(socfer,'yyyymmdd')
           INTO   l_dsocfer
           FROM   SOCIETE
           WHERE  soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message( 20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
             Pack_Global.recuperer_message( 20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
     END IF;
      -- TEST : cpident existe

      BEGIN
          SELECT ident
          INTO l_ncpident
          FROM RESSOURCE
          WHERE ident = TO_NUMBER(p_cpident);

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message( 20226, '%s1', p_cpident, 'CPIDENT', l_msg);
             RAISE_APPLICATION_ERROR(-20226, l_msg);

           WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

-- -------------------------------------------------------------------------------------
-- CONTROLES DE DATES
-- -------------------------------------------------------------------------------------
-- Recherche si la date de valeur existe déjà
  SELECT COUNT(datsitu) INTO l_odatval
  FROM SITU_RESS
  WHERE ident=TO_NUMBER(p_ident)
	AND TO_CHAR(datsitu,'mm/yyyy')=p_datsitu;
IF l_odatval=1 THEN
	SELECT SUBSTR(TO_CHAR(datsitu,'dd/mm/yyyy'),1,2) INTO l_datval
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident)
	AND   TO_CHAR(datsitu,'mm/yyyy')=p_datsitu ;
	-- Impossible de créer une autre situation dans le même mois
	IF l_datval!='01' THEN
		Pack_Global.recuperer_message(20322, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20322, l_msg);
		p_message := l_msg;
   	END IF;
END IF;

l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';
l_datfin:=TO_CHAR(TO_DATE(p_datdep,'dd/mm/yyyy'),'yyyymmdd') ;
---------------------------------------------------------------------------
-- La date de valeur est toujours inférieure à la date de départ
---------------------------------------------------------------------------
IF (p_datdep IS NOT NULL) THEN

	IF l_datval>l_datfin THEN
    		Pack_Global.recuperer_message(20227, NULL, NULL, 'DATSITU', l_msg);
      	     	RAISE_APPLICATION_ERROR(-20227, l_msg);
		p_message := l_msg;
	END IF;
END IF;

-- Recherche de la date de départ la plus récente
-- En profite pour récupérer le niveau
SELECT TO_CHAR(datdep,'yyyymmdd'), NIVEAU INTO l_datfin1, l_niveau
FROM SITU_RESS
WHERE datsitu=(SELECT MAX(datsitu)
		FROM SITU_RESS
		WHERE 	ident=TO_NUMBER(p_ident))
AND	ident=TO_NUMBER(p_ident);

-- Recherche de la date de valeur la plus récente
SELECT MAX(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datval1
FROM SITU_RESS
WHERE ident=TO_NUMBER(p_ident);


------------------------------------------------------------------------------------
-- 1) Cas d'une situation intermédiaire ou antérieure à la plus ancienne situation
------------------------------------------------------------------------------------
IF  l_datval<l_datval1 THEN                    /* Cas d'une situation intermédiaire */
  -- La date de départ est obligatoire
  IF l_datfin IS NULL THEN
	Pack_Global.recuperer_message(20441, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20441, l_msg);
		p_message := l_msg;
  END IF;

  ---------------------------------------------------------------------------------------
  -- Vérification de la validité des dates (non comprises dans des situations existantes)
  ---------------------------------------------------------------------------------------
  OPEN curdate;
  LOOP
	FETCH curdate INTO datval,datfin;
	-- la date de valeur se trouve entre les dates d'une situation existante
	IF (l_datval > datval AND  l_datval<=datfin)   THEN
		Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20320, l_msg);
		p_message := l_msg;
	END IF;
	-- la date de depart se trouve entre les dates d'une situation existante
	IF  (l_datfin >=datval AND l_datfin<=datfin ) THEN
	    IF l_odatval<1 THEN
		Pack_Global.recuperer_message(20321, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20321, l_msg);
		p_message := l_msg;
	    END IF;
	END IF;
	EXIT WHEN curdate%NOTFOUND;

  END LOOP;
  CLOSE curdate;

  -- Recherche de la date de valeur qui suit la date de valeur saisie
  SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  FROM SITU_RESS
  WHERE TO_CHAR(datsitu,'yyyymmdd')>l_datval
	AND ident=TO_NUMBER(p_ident);


  ---------------------------------------------------------------------------------------------
  -- La situation  entre la date de valeur et celle de départ ne doit pas chevaucher
  -- les situations existantes
  -- ie la date de départ doit etre inférieure à la date de valeur de la situation postérieure
  ---------------------------------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('datedep : '||l_datfin||', datval: '||l_datval);
IF (l_datfin>=l_datvalnext)  THEN
	Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      	RAISE_APPLICATION_ERROR(-20321, l_msg);
	p_message := l_msg;
  END IF;

END IF;

---------------------------------------------------------------------
-- 2) Cas où d'une situation qui suit la situation la plus récente
---------------------------------------------------------------------
IF (l_datval>l_datval1)  THEN
  IF (l_datfin1 IS NULL) THEN
	-- La date de départ la plus récente est égale à la date de valeur saisie-1jour
	BEGIN
		UPDATE SITU_RESS
		SET datdep=(TO_DATE(p_datsitu,'mm/yyyy')-1)
		WHERE datsitu= (SELECT MAX(datsitu)
				FROM SITU_RESS
				WHERE ident=TO_NUMBER(p_ident))
			AND ident=TO_NUMBER(p_ident);
	EXCEPTION
		WHEN referential_integrity THEN
			Pack_Global.recuperation_integrite(-2291);
		WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR(-20997,SQLERRM);
	END;
	-- Mise à jour de ressource
	BEGIN
		UPDATE RESSOURCE
		SET flaglock=DECODE(l_flaglock,1000000,0,l_flaglock+1)
		WHERE flaglock=l_flaglock
			AND ident= TO_NUMBER(p_ident);
	EXCEPTION
		WHEN referential_integrity THEN
			Pack_Global.recuperation_integrite(-2291);
		WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR(-20997,SQLERRM);
	END;
	l_flaglock:=l_flaglock+1;
  ELSE
	IF l_datval<=l_datfin1 THEN
		Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      		RAISE_APPLICATION_ERROR(-20320, l_msg);
		p_message := l_msg;
	END IF;
  END IF;

END IF;


 /* la date de valeur n'existe pas */
IF l_odatval<1 THEN
	BEGIN
		INSERT INTO SITU_RESS (ident,
                                            datsitu,
                                            datdep,
                                            codsg,
                                            --filcode,
                                            soccode,
                                            rmcomp,
                                            PRESTATION,
                                            dispo,
                                            cpident,
                                            cout,
                                            NIVEAU
                                           )
                      VALUES (TO_NUMBER(p_ident),
                              TO_DATE(p_datsitu,'mm/yyyy'),
                              TO_DATE(p_datdep,'dd/mm/yyyy'),
                              TO_NUMBER(p_codsg),
                              --p_filcode,
                              p_soccode,
                              NVL(TO_NUMBER(p_rmcomp),0),
                              p_prestation,
                              TO_NUMBER(p_dispo,'FM9D0'),
                              p_cpident,
                              TO_NUMBER(p_cout),
                              l_niveau
                             );

                   EXCEPTION
                         WHEN DUP_VAL_ON_INDEX THEN
                              -- 'la ressource existe deja'
                              Pack_Global.recuperer_message(20219, NULL, NULL, NULL, l_msg);
                              RAISE_APPLICATION_ERROR( -20219, l_msg );
                         WHEN referential_integrity THEN
                              -- habiller le msg erreur
                              Pack_Global.recuperation_integrite(-2291);
                         WHEN OTHERS THEN
                              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
        END;

/* La date de valeur existe déjà */
ELSE
	BEGIN

		UPDATE SITU_RESS SET  datdep     = TO_DATE(p_datdep,'dd/mm/yyyy'),
                                     codsg      = TO_NUMBER(p_codsg),
                                     --filcode    = p_filcode,
                                     soccode    = p_soccode,
                                     rmcomp     = NVL(TO_NUMBER(p_rmcomp),0),
                                     PRESTATION = p_prestation,
                                     dispo      = TO_NUMBER(p_dispo,'FM9D0'),
                                     cpident    = TO_NUMBER(p_cpident),
                                     cout       = TO_NUMBER(p_cout)
                WHERE ident = TO_NUMBER(p_ident)
                AND TO_CHAR(datsitu,'yyyymmdd') = l_datval;


             EXCEPTION
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
                WHEN OTHERS THEN
                     RAISE_APPLICATION_ERROR( -20997, SQLERRM);
             END;

             BEGIN
                 UPDATE RESSOURCE
                 SET    flaglock = DECODE(l_flaglock, 1000000, 0, l_flaglock + 1)
                 WHERE  flaglock = l_flaglock
                 AND    ident = TO_NUMBER(p_ident);

             EXCEPTION
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
                 WHEN OTHERS THEN
                    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
             END;

             IF SQL%NOTFOUND THEN
                Pack_Global.recuperer_message(20999, NULL, NULL, NULL, l_msg);
                RAISE_APPLICATION_ERROR(-20999, l_msg);
             END IF;
END IF;




    -- Message : 'situation Personne || p_rnom || creee';

	IF(p_soccode='SG..')THEN

	          Pack_Global.recuperer_message(21054,'%s1','l''agent SG', '%s2', p_ident, NULL, l_msg);
              p_message := l_msg;

	 ELSE

              Pack_Global.recuperer_message(21054, '%s1','la prestation','%s2', p_ident, NULL, l_msg);
              p_message := l_msg;

	END IF;

 END insert_situation_p;



---------------------------------------------------------------------------------------
-- Procédure de modification d'une situation
---------------------------------------------------------------------------------------
   PROCEDURE update_situation_p (p_oldatsitu  IN  VARCHAR2,
                                 p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_ident      IN  VARCHAR2,
                                 p_rprenom    IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule  IN  RESSOURCE.matricule%TYPE,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_rmcomp     IN  VARCHAR2,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_dispo      IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_cout       IN  VARCHAR2,
                                 p_niveau     IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                ) IS

l_msg           VARCHAR2(1024);
l_ncodsg        SITU_RESS.codsg%TYPE;
l_ncpident      SITU_RESS.cpident%TYPE;
l_dsocfer       VARCHAR2(20);
l_date_courante VARCHAR2(20);
l_datval        VARCHAR2(20);
l_oldatval      VARCHAR2(20);
l_datfin        VARCHAR2(20);
l_prest         PRESTATION.PRESTATION%TYPE;
l_menu          VARCHAR2(255);
l_topfer        STRUCT_INFO.topfer%TYPE;
l_datvalnext    VARCHAR2(20);
l_oldatdep  VARCHAR2(20);
l_datval1  VARCHAR2(20);

datval VARCHAR2(20);
datfin VARCHAR2(20);
CURSOR curdatval IS
	SELECT TO_CHAR(datsitu,'yyyymmdd') ,TO_CHAR(datdep,'yyyymmdd')
	FROM SITU_RESS
	WHERE ident=TO_NUMBER(p_ident)
	AND    TO_CHAR(datsitu,'dd/mm/yyyy')!=p_oldatsitu;

      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2291);

   BEGIN

       -- REGLE non respecte : 9.12.5 regle 4 gestion utilisateur.
       -- Positionner le nb de curseurs ==> 0
       -- Initialiser le message retour

       p_nbcurseur := 0;
       p_message := '';

       -- TEST COUT obligatoire si p_prestation n est pas MO,GRA,STA,IFO,INT

      IF p_prestation != 'MO' AND p_prestation != 'GRA'AND p_prestation != 'IFO' AND p_prestation != 'STA' AND p_prestation != 'INT'THEN
         IF (p_cout = ',00' OR p_cout = '0,00' OR p_cout IS NULL) AND (p_soccode <> 'SG..') THEN
            Pack_Global.recuperer_message(20247, NULL, NULL, 'COUT', l_msg);
            RAISE_APPLICATION_ERROR(-20247, l_msg);
         END IF;
      END IF;

       -- TEST : RMCOMP doit etre = 0 ou 1

  --    IF (p_rmcomp != 0) AND (p_rmcomp != 1) THEN
     --     Pack_Global.recuperer_message(20275, NULL, NULL, 'RMCOMP', l_msg);
         -- RAISE_APPLICATION_ERROR(-20275, l_msg);
      -- END IF;

       -- TEST : 0< DISPO < 7

       IF (TO_NUMBER(p_dispo) < 0) OR (TO_NUMBER(p_dispo) > 7) THEN
          Pack_Global.recuperer_message(20248, NULL, NULL, 'COUT', l_msg);
          RAISE_APPLICATION_ERROR(-20248, l_msg);
       END IF;

       -- TEST : Il doit exister ds cout_pres le codprest pour l'annee d'arrive de la personne
	l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      	IF l_menu != 'DIR' THEN

		BEGIN
        	   	SELECT PRESTATION
           		INTO l_prest
           		FROM PRESTATION
           		WHERE UPPER(top_actif)='O'
           		AND PRESTATION = p_prestation;

       		EXCEPTION

            	WHEN NO_DATA_FOUND THEN
              	Pack_Global.recuperer_message(20246, '%s1', p_prestation, 'PRESTATION', l_msg);
              	RAISE_APPLICATION_ERROR(-20246, l_msg);

            	WHEN OTHERS THEN
               	RAISE_APPLICATION_ERROR( -20997,SQLERRM);
       		END;
	END IF;
       -- TEST : codsg > 1

      IF TO_NUMBER(p_codsg) <= 1 THEN
            Pack_Global.recuperer_message(20223, NULL, NULL, 'CODSG', l_msg);
            RAISE_APPLICATION_ERROR(-20223, l_msg);
      END IF;

      -- TEST : TOPFER de codsg si menutil = DIR

      l_menu := Pack_Global.lire_globaldata(p_userid).menutil;

      IF l_menu != 'DIR' THEN

         BEGIN
            SELECT topfer
            INTO   l_topfer
            FROM   STRUCT_INFO
            WHERE  codsg = TO_NUMBER(p_codsg);

         EXCEPTION

            WHEN NO_DATA_FOUND THEN
               Pack_Global.recuperer_message(20203, NULL, NULL, 'CODSG', l_msg);
               RAISE_APPLICATION_ERROR(-20203, l_msg);

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

         IF l_topfer = 'F' THEN
             Pack_Global.recuperer_message(20274, NULL, NULL, 'CODSG', l_msg);
             RAISE_APPLICATION_ERROR(-20274, l_msg);
         END IF;

      END IF;

      -- TEST : soccode existe et societe non fermee.
      IF l_menu != 'DIR' THEN
      BEGIN
           SELECT TO_CHAR(socfer,'yyyymmdd')
           INTO l_dsocfer
           FROM SOCIETE
           WHERE soccode = p_soccode;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);

         WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR( -20997, l_msg);

      END;

      SELECT TO_CHAR(SYSDATE,'yyyymmdd')
      INTO l_date_courante
      FROM DUAL;

      IF l_dsocfer <= l_date_courante THEN
             Pack_Global.recuperer_message(20225, '%s1', p_soccode, 'SOCCODE', l_msg);
             RAISE_APPLICATION_ERROR(-20225, l_msg);
      END IF;
      END IF;
      -- TEST : cpident existe

      BEGIN
          SELECT ident
          INTO l_ncpident
          FROM RESSOURCE
          WHERE ident = TO_NUMBER(p_cpident);

      EXCEPTION

           WHEN NO_DATA_FOUND THEN
             Pack_Global.recuperer_message(20226, '%s1', p_cpident, 'CPIDENT', l_msg);
             RAISE_APPLICATION_ERROR(-20226, l_msg);

           WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR ( -20997, SQLERRM);
      END;

--------------------------------------------------
-- CONTROLE DES DATES
-- MAJ le 10/04/2000 par NCM
---------------------------------------------------
l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm');
l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymm');
IF l_datval=l_oldatval THEN
	l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');
	l_datval:=l_oldatval;
ELSE
	l_oldatval:=TO_CHAR(TO_DATE(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');
	l_datval:=TO_CHAR(TO_DATE(p_datsitu,'mm/yyyy'),'yyyymm')||'01';
END IF;

---------------------------------------------------------------------------
-- La date de valeur est toujours inférieure à la date de départ
---------------------------------------------------------------------------
l_datfin:=TO_CHAR(TO_DATE(p_datdep,'dd/mm/yyyy'),'yyyymmdd') ;

IF (p_datdep IS NOT NULL) THEN
	IF l_datval>l_datfin THEN
    		Pack_Global.recuperer_message(20227, NULL, NULL, 'DATSITU', l_msg);
      	     	RAISE_APPLICATION_ERROR(-20227, l_msg);
		p_message := l_msg;
	END IF;
END IF;

DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);

-- Recherche de la date de valeur la plus récente
SELECT MAX(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datval1
FROM SITU_RESS
WHERE ident=TO_NUMBER(p_ident);

IF  l_datval<l_datval1 THEN                    /* Cas d'une situation intermédiaire */
  -- La date de départ est obligatoire
  IF l_datfin IS NULL THEN
	Pack_Global.recuperer_message(20441, NULL, NULL, 'DATDEP', l_msg);
      		RAISE_APPLICATION_ERROR(-20441, l_msg);
		p_message := l_msg;
  END IF;
END IF;

-- Recherche de la date de départ avant la modification
SELECT TO_CHAR(datdep,'yyyymmdd') INTO l_oldatdep
FROM SITU_RESS
WHERE TO_CHAR(datsitu,'dd/mm/yyyy')=p_oldatsitu
 AND  ident=TO_NUMBER(p_ident);

--l_oldatval:=to_char(to_date(p_oldatsitu,'dd/mm/yyyy'),'yyyymmdd');

---------------------------------------------
-- 1) La date de valeur est modifiée
---------------------------------------------
IF (l_oldatval!=l_datval) THEN
	DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);
	-----------------------------------------------------------------------
	-- 1.1) La date de valeur doit etre supérieure à la date de valeur d'origine
	-----------------------------------------------------------------------
	IF l_oldatval>l_datval THEN
	    Pack_Global.recuperer_message(20228, NULL, NULL, 'DATSITU' , l_msg);
            RAISE_APPLICATION_ERROR(-20228, l_msg);
	END IF;

	---------------------------------------------------------
	-- 1.2) La date de départ est modifiée
	---------------------------------------------------------
	IF (l_oldatdep!=l_datfin) THEN
		/*** Les nouvelles dates ne doiventt pes appartenir à d'autres situations ***/
		OPEN curdatval;
		LOOP
			FETCH curdatval INTO datval,datfin;
			-- la date de valeur se trouve entre les dates d'une situation existante
			IF (l_datval >= datval AND  l_datval <= datfin)   THEN
			  DBMS_OUTPUT.PUT_LINE('date valeur: '||datval||' date depart: '||datfin);
			   Pack_Global.recuperer_message(20320, NULL, NULL, 'DATSITU', l_msg);
      			   RAISE_APPLICATION_ERROR(-20320, l_msg);
			   p_message := l_msg;
			END IF;
			-- la date de depart se trouve entre les dates d'une situation existante
			IF  (l_datfin >= datval AND l_datfin <= datfin) THEN
			  -- dbms_output.put_line('date valeur: '||datval||' date depart: '||datfin);
			   Pack_Global.recuperer_message(20321, NULL, NULL, 'DATDEP', l_msg);
      			   RAISE_APPLICATION_ERROR(-20321, l_msg);
			   p_message := l_msg;
			END IF;
			EXIT WHEN curdatval%NOTFOUND;

		END LOOP;
		CLOSE curdatval;


		/*** La nouvelle date de départ doit etre inférieure à la date de valeur suivante ***/
		 -- Recherche de la date de valeur qui suit la date de valeur saisie
  		SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  		FROM SITU_RESS
  		WHERE TO_CHAR(datsitu,'yyyymmdd')>l_oldatval
		AND ident=TO_NUMBER(p_ident);

  		IF (l_datfin>=l_datvalnext) THEN
			Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      			RAISE_APPLICATION_ERROR(-20321, l_msg);
			p_message := l_msg;
  		END IF;

	END IF;

	---------------------------------------------------------------------------
	-- 1.3) Création d'une nouvelle situation avec la nouvelle date de valeur
	---------------------------------------------------------------------------
    BEGIN
  	INSERT INTO SITU_RESS (     ident,
                               	    datsitu,
                                    datdep,
                                    codsg,
                                    --filcode,
                                    soccode,
                                    rmcomp,
                                    PRESTATION,
                                    dispo,
                                    cpident,
                                    cout,
                                    NIVEAU
                                   )
		VALUES (TO_NUMBER(p_ident),
                     TO_DATE(p_datsitu,'mm/yyyy'),
                     TO_DATE(p_datdep,'dd/mm/yyyy'),
                     TO_NUMBER(p_codsg),
                     --p_filcode,
                     p_soccode,
                     NVL(TO_NUMBER(p_rmcomp),0),
                     p_prestation,
                     TO_NUMBER(p_dispo,'FM9D0'),
                     TO_NUMBER(p_cpident),
                     TO_NUMBER(p_cout),
                     p_niveau
                    );

	--------------------------------------------------------------------
	-- 1.4) Mise à jour de la date de départ de la situation d'origine
	--------------------------------------------------------------------
             	BEGIN
                 	UPDATE SITU_RESS
                            SET datdep = (TO_DATE(p_datsitu,'mm/yyyy')-1)
                        WHERE ident = TO_NUMBER(p_ident)
                             AND TO_CHAR(datsitu,'yyyymmdd') = l_oldatval;

                     EXCEPTION

                        WHEN referential_integrity THEN
                           -- habiller le msg erreur
                           Pack_Global.recuperation_integrite(-2291);
                        WHEN OTHERS THEN
                            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
                    END;

                     IF SQL%NOTFOUND THEN
                         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
                         RAISE_APPLICATION_ERROR(-20999, l_msg );
                    END IF;

 		EXCEPTION
                WHEN DUP_VAL_ON_INDEX THEN
                   Pack_Global.recuperer_message(20229, NULL, NULL, NULL , l_msg);
                   RAISE_APPLICATION_ERROR(-20229, l_msg);
                WHEN referential_integrity THEN
                    -- habiller le msg erreur
                    Pack_Global.recuperation_integrite(-2291);
               WHEN OTHERS THEN
                    RAISE_APPLICATION_ERROR( -20997, l_msg);
	    END;

ELSE
---------------------------------------------
-- 2) La date de valeur n'est pas modifiée
---------------------------------------------

	DBMS_OUTPUT.PUT_LINE('old: '||l_oldatval||' , new: '||l_datval);
	---------------------------------------------------------
	-- 2.1) La date de départ est modifiée
	---------------------------------------------------------
	IF (l_oldatdep!=l_datfin) THEN
		/*** La nouvelle date de départ doit etre inférieure à la date de valeur suivante ***/
		 -- Recherche de la date de valeur qui suit la date de valeur saisie
  		SELECT MIN(TO_CHAR(datsitu,'yyyymmdd')) INTO l_datvalnext
  		FROM SITU_RESS
  		WHERE TO_CHAR(datsitu,'yyyymmdd')>l_datval
		AND ident=TO_NUMBER(p_ident);

  		IF (l_datfin>=l_datvalnext) THEN
			Pack_Global.recuperer_message(20321, NULL,NULL, 'DATDEP', l_msg);
      			RAISE_APPLICATION_ERROR(-20321, l_msg);
			p_message := l_msg;
  		END IF;
	END IF;
	--------------------------------
	-- MAJ SITUATION
	-------------------------------
 	BEGIN

           UPDATE SITU_RESS
                SET
		datdep     = TO_DATE(p_datdep,'dd/mm/yyyy'),
                    codsg      = TO_NUMBER(p_codsg),
                    --filcode    = p_filcode,
                    soccode    = p_soccode,
                    rmcomp     = NVL(TO_NUMBER(p_rmcomp),0),
                    PRESTATION = p_prestation,
                    dispo      = TO_NUMBER(p_dispo,'FM9D0'),
                    cpident    = TO_NUMBER(p_cpident),
                    cout       = TO_NUMBER(p_cout),
					NIVEAU     = p_niveau
             WHERE ident = TO_NUMBER(p_ident)
             AND TO_CHAR(datsitu,'yyyymmdd') = l_oldatval;

         EXCEPTION
            WHEN referential_integrity THEN
               -- habiller le msg erreur
               Pack_Global.recuperation_integrite(-2291);
            WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;

  	BEGIN
		UPDATE RESSOURCE
        	SET flaglock = DECODE(p_flaglock, 1000000, 0, p_flaglock + 1)
        	WHERE flaglock = p_flaglock
             	AND ident = TO_NUMBER(p_ident);
  	EXCEPTION
		WHEN referential_integrity THEN
               -- habiller le msg erreur
        		Pack_Global.recuperation_integrite(-2291);
		WHEN OTHERS THEN
               		RAISE_APPLICATION_ERROR( -20997, SQLERRM);
  	END;

  	IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR(-20999, l_msg);
  	END IF;

END IF;

    -- Message : 'situation personne || p_rnom || modifie';

	IF(p_soccode='SG..')THEN

	          Pack_Global.recuperer_message(21055,'%s1','l''agent SG', '%s2', p_ident, NULL, l_msg);
              p_message := l_msg;

	 ELSE

              Pack_Global.recuperer_message(21055, '%s1','la prestation','%s2', p_ident, NULL, l_msg);
              p_message := l_msg;

	END IF;


    --Pack_Global.recuperer_message(2055, '%s1', p_rnom, NULL , l_msg);
    --p_message := l_msg;

END update_situation_p;

/********************************************************************************************/

   PROCEDURE delete_situation_p (p_rnom       IN  RESSOURCE.rnom%TYPE,
                                 p_ident      IN  VARCHAR2,
                                 p_rprenom    IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule  IN  RESSOURCE.matricule%TYPE,
                                 p_datsitu    IN  VARCHAR2,
                                 p_datdep     IN  VARCHAR2,
                                 p_codsg      IN  VARCHAR2,
                                 --p_filcode    IN  situ_ress.filcode%TYPE,
                                 p_soccode    IN  SITU_RESS.soccode%TYPE,
                                 p_rmcomp     IN  VARCHAR2,
                                 p_prestation IN  SITU_RESS.PRESTATION%TYPE,
                                 p_dispo      IN  VARCHAR2,
                                 p_cpident    IN  VARCHAR2,
                                 p_cout       IN  VARCHAR2,
                                 p_flaglock   IN  NUMBER,
                                 p_userid     IN  VARCHAR2,
                                 p_nbcurseur  OUT INTEGER,
                                 p_message    OUT VARCHAR2
                                ) IS

      l_msg VARCHAR2(1024);
      l_datval VARCHAR2(20);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
      l_flag RESSOURCE.flaglock%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';
      l_flag := 0;

      -- TEST : il doit toujours exister un row situation pour la ressource

      BEGIN
         SELECT COUNT(ident)
         INTO   l_flag
         FROM   SITU_RESS
         WHERE  ident = TO_NUMBER(p_ident);

      EXCEPTION

         WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF l_flag = 1 THEN
         Pack_Global.recuperer_message(20234, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20234, l_msg );
      END IF;

      -- On utilise le flaglock de ressource pour protege l'acces a situ_ress

      BEGIN
         SELECT flaglock
         INTO   l_flag
         FROM   RESSOURCE
         WHERE  ident = TO_NUMBER(p_ident);

      EXCEPTION
         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

     IF l_flag != p_flaglock THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg);
      END IF;

     IF p_datdep IS NOT NULL THEN
	SELECT TO_CHAR(datsitu,'dd/mm/yyyy')
	INTO l_datval
	FROM SITU_RESS
	WHERE ident= TO_NUMBER(p_ident)
		AND TO_CHAR(datdep,'dd/mm/yyyy')=p_datdep;
     ELSE
	SELECT TO_CHAR(datsitu,'dd/mm/yyyy')
	INTO l_datval
	FROM SITU_RESS
	WHERE ident= TO_NUMBER(p_ident)
		AND TO_CHAR(datdep,'dd/mm/yyyy')IS NULL;
     END IF;

      BEGIN
          DELETE FROM SITU_RESS
                 WHERE ident = TO_NUMBER(p_ident)
                 AND TO_CHAR(datsitu,'dd/mm/yyyy') = l_datval;


      EXCEPTION

         WHEN referential_integrity THEN

            -- habiller le msg erreur

            Pack_Global.recuperation_integrite(-2292);

          WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         Pack_Global.recuperer_message(20999, NULL, NULL, NULL , l_msg);
         RAISE_APPLICATION_ERROR( -20999, l_msg ||'!');
      ELSE

	             IF(p_soccode='SG..')THEN
	 	               Pack_Global.recuperer_message(21056,'%s1','l''agent SG', '%s2', p_ident, NULL, l_msg);
                       p_message := l_msg;
	             ELSE
                      Pack_Global.recuperer_message(21056, '%s1','la prestation','%s2', p_ident, NULL, l_msg);
                      p_message := l_msg;
	              END IF;

        --  Pack_Global.recuperer_message(2056, '%s1', p_ident, NULL , l_msg);
         --p_message := l_msg;
     END IF;

   END delete_situation_p;


   PROCEDURE select_situation_p (p_mode        IN  VARCHAR2,
                                 p_rnom         IN  RESSOURCE.rnom%TYPE,
                                 p_ident        IN  VARCHAR2,
                                 p_rprenom      IN  RESSOURCE.rprenom%TYPE,
                                 p_matricule    IN  RESSOURCE.matricule%TYPE,
                                 p_datsitu      IN  VARCHAR2,
                                 p_flaglock     IN  VARCHAR2,
                                 p_userid       IN  VARCHAR2,
                                 p_cursituation IN OUT situationCurType,
                                 p_codsg           OUT VARCHAR2,
                                 p_soccode         OUT VARCHAR2,
				 p_niveau	   OUT VARCHAR2,
                                 p_prestation      OUT VARCHAR2,
                                 p_cpident         OUT VARCHAR2,
                                 p_rmcomp          OUT VARCHAR2,
                                 p_dispo           OUT VARCHAR2,
                                 p_cout            OUT VARCHAR2,
                                 p_dat             OUT VARCHAR2,
                                 p_flag            OUT VARCHAR2,
                                 p_nbcurseur       OUT INTEGER,
                                 p_message         OUT VARCHAR2,
								 p_code_domaine   OUT PRESTATION.CODE_DOMAINE%TYPE
                                ) IS

      l_msg VARCHAR2(1024);
      l_codsg SITU_RESS.codsg%TYPE;
      l_ges NUMBER(3);
      l_idarpege VARCHAR2(255);
      l_habilitation VARCHAR2(10);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- TEST : p_choix == Créer -> creation !='Créer' ->modif,supp

      IF  p_mode = 'insert' THEN

        -- FLAGLOCK

        BEGIN
           SELECT flaglock
           INTO   p_flag
           FROM   RESSOURCE
           WHERE  ident = TO_NUMBER(p_ident);
        EXCEPTION
          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

        END;

        -- DATSITU

        p_dat := '';

        -- CODSG, SOCCODE, PRESTATION, CPIDENT, RMCOMP, DISPO, COUT

        BEGIN
           /* SELECT 'CODSG#'      || TO_CHAR(codsg),
                   'SOCCODE#'    || soccode,
                   'PRESTATION#' || prestation,
                   'CPIDENT#'    || TO_CHAR(cpident),
                   'RMCOMP#'     || TO_CHAR(rmcomp),
                   'DISPO#'      || TO_CHAR(dispo,'FM9D0'),
                   'COUT#'       || TO_CHAR(cout,'FM9999999990D00')*/
        SELECT TO_CHAR(codsg),
			   	soccode,
				NVL(NIVEAU,''),
				PRESTATION,
				TO_CHAR(cpident),
				TO_CHAR(rmcomp),
                TO_CHAR(dispo,'FM9D0'),
                TO_CHAR(cout,'FM9999999990D00')
		INTO p_codsg,
                 p_soccode,
				 p_niveau,
                 p_prestation,
                 p_cpident,
                 p_rmcomp,
                 p_dispo,
                 p_cout
            FROM SITU_RESS
            WHERE ident = TO_NUMBER(p_ident)
            AND TO_CHAR(datsitu,'dd/mm/yyyy') IN (
                              SELECT TO_CHAR(MAX(datsitu),'dd/mm/yyyy')
                              FROM SITU_RESS
                              WHERE ident = TO_NUMBER(p_ident)
                             );

			--recupere le code_domaine

			         SELECT NVL(CODE_DOMAINE,'') INTO p_code_domaine FROM PRESTATION
                     WHERE PRESTATION=p_prestation;



        EXCEPTION
          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);

        END;

        -- On ouvre un curseur vide, pour mettre l'automate en mode creation
        BEGIN
          OPEN p_cursituation FOR
                   SELECT TO_CHAR(RESSOURCE.ident),
                          RESSOURCE.rnom,
                          RESSOURCE.rprenom,
                          RESSOURCE.matricule,
                          TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                          TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                          TO_CHAR(SITU_RESS.codsg),
                          --situ_ress.filcode,
                          SITU_RESS.soccode,
						  SITU_RESS.NIVEAU,
                          SITU_RESS.PRESTATION,
                          TO_CHAR(SITU_RESS.cpident),
                          TO_CHAR(SITU_RESS.rmcomp),
                          TO_CHAR(SITU_RESS.dispo, 'FM9D0'),
                          TO_CHAR(SITU_RESS.cout, 'FM9999999999D00'),
                          TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                          RESSOURCE.flaglock,
						  PRESTATION.code_domaine
                   FROM RESSOURCE,SITU_RESS,PRESTATION
			WHERE 0=1;
--                   WHERE ressource.ident = -1
--                     AND situ_ress.ident = -1;
      EXCEPTION

         WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20997, SQLERRM);
      END;

      ELSE -- CAS d'une modification, suppression

         -- Attention ordre des colonnes doit correspondre a l ordre
         -- de declaration dans la table ORACLE (a cause de ROWTYPE)
         -- ou selectionner toutes les colonnes par *
         -- On ouvre le curseur suivant p_rnom

      -- Gestion du niveau d'acces de l'utilisateur.

      BEGIN
         SELECT codsg
         INTO   l_codsg
         FROM   SITU_RESS
         WHERE  ident = TO_NUMBER(p_ident)
         AND    TO_CHAR(datsitu,'dd/mm/yyyy') = p_datsitu;

      EXCEPTION

          WHEN NO_DATA_FOUND THEN
            Pack_Global.recuperer_message(20245, NULL, NULL, 'IDENT', l_msg);
            RAISE_APPLICATION_ERROR( -20245, l_msg);

          WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR( -20997, SQLERRM);
      END;

      /*l_ges := pack_global.verifier_habilitation(p_userid, l_codsg,
               'à modifier/supprimer la situation ( ident :' || p_ident ||', code DPG :'|| l_codsg ||')', NULL);

      IF l_ges != 0 THEN
         l_idarpege := pack_global.lire_globaldata(p_userid).idarpege;
         pack_global.recuperer_message( 20244, '%s1', l_idarpege, '%s2', l_codsg, 'IDENT', l_msg);
         raise_application_error( -20244, l_msg);
      END IF;
      */
      -- ====================================================================
      -- 7/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      -- ====================================================================
     	l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid   );
	IF l_habilitation='faux' THEN
		-- Vous n'êtes pas autorisé à modifier cette ressource, son DPG est
		Pack_Global.recuperer_message(20365, '%s1',  'modifier/supprimer la situation', NULL, l_msg);
                RAISE_APPLICATION_ERROR(-20365, l_msg);
	END IF;


         BEGIN
            OPEN p_cursituation FOR
                   SELECT TO_CHAR(RESSOURCE.ident),
                          RESSOURCE.rnom,
                          RESSOURCE.rprenom,
                          RESSOURCE.matricule,
                          TO_CHAR(SITU_RESS.datsitu,'mm/yyyy'),
                          TO_CHAR(SITU_RESS.datdep,'dd/mm/yyyy'),
                          TO_CHAR(SITU_RESS.codsg),
                          --situ_ress.filcode,
                          SITU_RESS.soccode,
						  SITU_RESS.NIVEAU,
                          SITU_RESS.PRESTATION,
                          TO_CHAR(SITU_RESS.cpident),
                          TO_CHAR(SITU_RESS.rmcomp),
                          TO_CHAR(SITU_RESS.dispo, 'FM9D0'),
                          TO_CHAR(SITU_RESS.cout, 'FM9999999990D00'),
                          TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy'),
                          RESSOURCE.flaglock,
						 PRESTATION.code_domaine
                   FROM RESSOURCE, SITU_RESS,PRESTATION
                   WHERE RESSOURCE.ident = TO_NUMBER(p_ident)
                   AND SITU_RESS.ident = TO_NUMBER(p_ident)
                   AND TO_CHAR(SITU_RESS.datsitu,'dd/mm/yyyy')
                       = TO_CHAR(TO_DATE(p_datsitu,'dd/mm/yyyy'),'dd/mm/yyyy')
				  AND PRESTATION.PRESTATION=SITU_RESS.PRESTATION
				  ;

--                   AND TO_CHAR(situ_ress.datsitu,'mm/yyyy')
--                       = TO_CHAR(TO_DATE(p_datsitu,'dd/mm/yyyy'),'mm/yyyy');

        EXCEPTION

            WHEN OTHERS THEN
               RAISE_APPLICATION_ERROR( -20997, SQLERRM);
         END;
     END IF;

       -- en cas absence
       -- p_message := 'La situation n''existe pas';

      Pack_Global.recuperer_message(2041, NULL, NULL, NULL , l_msg);
      p_message := l_msg;

   END select_situation_p;





   -- Récupération de la liste des niveaux existants de la table NIVEAU


   PROCEDURE select_liste_Niveaux(s_curseur 	IN OUT  niveau_Curseur ) IS
   	BEGIN
		 BEGIN



	OPEN s_curseur  FOR
           	 SELECT NIVEAU, LIBNIVEAU
           	 FROM NIVEAU
			 ORDER BY NIVEAU;





   	EXCEPTION
		WHEN OTHERS THEN
   		    RAISE_APPLICATION_ERROR( -20997, SQLERRM);
	END;



END select_liste_Niveaux;



END Pack_Situation_P;
/
CREATE OR REPLACE PACKAGE pack_societe AS

  -- Définition curseur sur la table des contrats

  TYPE contratCurType IS REF CURSOR RETURN contrat%ROWTYPE;

  -- Définition curseur sur la table des situations ressources

  TYPE situ_ressCurType IS REF CURSOR RETURN situ_ress%ROWTYPE;

  TYPE Societe_ViewType IS RECORD( soccode      societe.soccode%TYPE,
				   soclib       societe.soclib%TYPE,
				   socnat       societe.socnat%TYPE,
				   soccat       societe.soccat%TYPE,
				   soccre       varchar2(10),
				   socfer_ch    varchar2(10),
				   socnou       societe.socnou%TYPE,
				   soccop       societe.soccop%TYPE,
				   socfer_cl    varchar2(10),
				   soccom       societe.soccom%TYPE,
				   flaglock     societe.flaglock%TYPE);

  TYPE societeCurType_Char IS REF CURSOR RETURN Societe_ViewType;

PROCEDURE insert_societe ( p_soccode   IN societe.soccode%TYPE,
			   p_soccat    IN societe.soccat%TYPE,
			   p_socnat    IN societe.socnat%TYPE,
			   p_soclib    IN societe.soclib%TYPE,
			   p_soccre    IN VARCHAR2,
			   p_userid    IN VARCHAR2,
			   p_nbcurseur OUT INTEGER,
			   p_message   OUT VARCHAR2
			 );

PROCEDURE update_societe ( p_soccode       IN societe.soccode%TYPE,
			   p_soclib        IN societe.soclib%TYPE,
			   p_socnat        IN societe.socnat%TYPE,
			   p_soccat        IN societe.soccat%TYPE,
			   p_soccre        IN VARCHAR2,
			   p_socfer_ch     IN VARCHAR2,
			   p_socnou        IN societe.socnou%TYPE,
			   p_soccop        IN societe.soccop%TYPE,
			   p_socfer_cl     IN VARCHAR2,
			   p_soccom        IN societe.soccom%TYPE,
			   p_flaglock      IN NUMBER,
			   p_userid        IN VARCHAR2,
			   p_nbcurseur     OUT INTEGER,
			   p_message       OUT VARCHAR2
			 );

PROCEDURE delete_societe ( p_soccode   IN societe.soccode%TYPE,
			   p_flaglock  IN NUMBER,
			   p_userid    IN VARCHAR2,
			   p_nbcurseur OUT INTEGER,
			   p_message   OUT VARCHAR2 );

PROCEDURE select_societe ( p_soccode    IN societe.soccode%TYPE,
			   p_userid     IN VARCHAR2,
			   p_curSociete IN OUT societeCurType_Char,
			   p_datcre     OUT VARCHAR2,
			   p_nbcurseur  OUT INTEGER,
			   p_message    OUT VARCHAR2
			 );

PROCEDURE gestion_contrat( p_ancsoccode IN CHAR,
			   p_dfersoc    IN CHAR,
			   p_nousoccode IN CHAR
			 );

PROCEDURE gestion_situ_res(p_ancsoccode IN CHAR,
			   p_dfersoc    IN CHAR,
 			   p_nousoccode IN CHAR
 			  );

END pack_societe;
/

CREATE OR REPLACE PACKAGE BODY pack_societe AS

PROCEDURE gestion_contrat( p_ancsoccode IN CHAR,
			   p_dfersoc    IN CHAR,
			   p_nousoccode IN CHAR
			 ) IS
   l_msg VARCHAR(1024);
   referential_integrity   EXCEPTION;
   PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

BEGIN
   ------------------------------------------------------------------------
   -- En cas d'erreur on renvoie l'erreur a JS qui fera un rollback
   -------------------------------------------------------------------------

 /**********************************************************************************************
   		TRAITEMENT DES CONTRATS ET LIGNES DE CONTRAT
 ***********************************************************************************************/

   -- Creation des nouveaux contrats avec soccont = nouveau nom de la societe
   -- et cdardeb = date de fermeture de la societe + 1 jour calendaire.
   -- flaglock = 0 et soccont = nouvel societe
   -- Pour Information : CONTRAT_PK = NUMCONT, SOCCONT, CAV
   --
   -- -----------------------------HTM 11/02/2000 --------------------------------------------
   -- IL NE FAUT CREER  CES NOUVEAUX CONTRATS QUE  SI (cdatbeb) <= p_dfersoc  DANS ANCIENNE SOCIETE
   -- car sinon, on finirait par fermer les anciens contrats avec (cdatfin) qui vaudrait p_dfersoc
   -- et qui serait donc inférieur à (cdatdeb)
   -- NE PAS OUBLIER QUE CHAQUE NOUVELLE CREATION EST SUIVIE D'UNE FERMETURE DE L'ANCIEN CONTRAT !!!
   -- Pour les cas où (cdatdeb) > p_dfersoc, IL FAUT FAIRE SIMPLEMENT UN UPDATE du code de la société !!!
   --
   -- ATTENTION : NE PAS MODIFIER L'ORDRE DES ETAPES CI-DESSOUS !!!
   -- -----------------------------------------------------------------------------------------------

   ------------------------------ (ETAPE 1 : CREATION NOUVEAUX CONTRATS) ----------------------------

   BEGIN

      INSERT INTO contrat (numcont   ,
			   cchtsoc   ,
			   ctypfact  ,
			   cobjet1   ,
			   cobjet2   ,
			   cobjet3   ,
			   crem      ,
			   cantfact  ,
			   cmoiderfac,
			   cmmens    ,
			   ccharesti ,
			   cecartht  ,
			   cevainit  ,
			   cnaffair  ,
			   cagrement ,
			   crang     ,
			   cantcons  ,
			   ccoutht   ,
			   cdatannul ,
			   cdatarr   ,
			   cdatclot  ,
			   cdatdeb   ,
			   cdatsoce  ,
			   cdatfin   ,
			   cdatmaj   ,
			   cdatdir   ,
			   cdatbilq  ,
			   cdatrpol  ,
			   cdatsocr  ,
			   cdatsai   ,
			   cduree    ,
			   flaglock  ,
			   soccont   ,
			   cav       ,
			   filcode   ,
			   comcode   ,
			   niche     ,
			   codsg ,
				ccentrefrais)
	(SELECT cont.numcont   ,
	 cont.cchtsoc   ,
	 cont.ctypfact  ,
	 cont.cobjet1   ,
	 cont.cobjet2   ,
	 cont.cobjet3   ,
	 cont.crem      ,
	 cont.cantfact  ,
	 cont.cmoiderfac,
	 cont.cmmens    ,
	 cont.ccharesti ,
	 cont.cecartht  ,
	 cont.cevainit  ,
	 cont.cnaffair  ,
	 cont.cagrement ,
	 cont.crang     ,
	 cont.cantcons  ,
	 cont.ccoutht   ,
	 cont.cdatannul ,
	 cont.cdatarr   ,
	 cont.cdatclot  ,
	 to_date(p_dfersoc, 'yyyymmdd') + 1, -- date de fermeture des anciennes societes +1 jour calendaire
	 cont.cdatsoce  ,
	 cont.cdatfin   ,
	 cont.cdatmaj   ,
	 cont.cdatdir   ,
	 cont.cdatbilq  ,
	 cont.cdatrpol  ,
	 cont.cdatsocr  ,
	 cont.cdatsai   ,
	 cont.cduree    ,
	 0         ,   -- FLAGLOCK
	 p_nousoccode, -- Nouvelle societe
	 cont.cav       ,
	 cont.filcode   ,
	 cont.comcode   ,
	 cont.niche     ,
	 cont.codsg     ,
	 cont.ccentrefrais
	 FROM contrat cont
	 WHERE cont.soccont = p_ancsoccode
	 AND   ( cont.cdatfin > to_date(p_dfersoc, 'yyyymmdd') )
	 --
	 -- HTM 11/02/2000
	 AND  ( cont.cdatdeb <  (to_date(p_dfersoc, 'yyyymmdd') + 1)  )
	 );

   EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
	-- 'Problème lors de la création des nouveaux contrats : Contrat en double pour une même société!'
	pack_global.recuperer_message( 20616, NULL, NULL, NULL, l_msg);
	raise_application_error( -20616, l_msg);

      WHEN OTHERS THEN
      -- Dans les autres cas, quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la creation des nouveaux contrats'
	pack_global.recuperer_message( 20296, NULL, NULL, NULL, l_msg);
	raise_application_error( -20296, l_msg);
   END;

   ------------------------------ (ETAPE 2) ---------------------------------------------------------------
   -- Fermeture des anciens contrats qui ont permis de créer les nouveaux contrats  à l'Etape 1 :
   --	-----------------------------------------------------------------------------------------------------
   -- Mis a jour des anciens contrats
   -- Avec date de fin = date de fermeture de la societe
   -- et cchtsoc = 'A'
   BEGIN

      UPDATE contrat
	SET cdatfin = to_date(p_dfersoc, 'yyyymmdd'),
	cchtsoc = 'A',
	flaglock = decode( flaglock, 1000000, 0, flaglock + 1)
	WHERE soccont = p_ancsoccode
	AND   ( cdatfin > to_date(p_dfersoc, 'yyyymmdd') )
	 --
	 -- HTM 11/02/2000
	 AND  ( cdatdeb <  (to_date(p_dfersoc, 'yyyymmdd') + 1)  ) ;

   EXCEPTION
     WHEN referential_integrity THEN
     -- habiller le msg erreur
     --pack_global.recuperation_integrite(-2292);
     raise_application_error(-20997, sqlerrm);

      -- quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la mis a jour des anciens contrats'
      WHEN OTHERS THEN

	pack_global.recuperer_message( 20297, NULL, NULL, NULL, l_msg );
	raise_application_error( -20297, l_msg || ' (... ETAPE 2 ...)' );
   END;

   ---------------------------- (ETAPE 3) -------------------------------------------------------------

   -- Transfert des anciens contrats vérifiant (cdatdeb) >= p_dfersoc + 1 jour calendaire
   -- vers la nouvelle société :
   -- A CAUSE DE L'INTEGRITE REFERENTIELLE CONTRAT -> LIGNE DE CONTRAT
   -- ON NE PEUT FAIRE DE UPDATE DIRECTE DE LA SOCIETE :
   -- SOLUTION :
   --          (1) Duplication des contrats vérifiant (cdatdeb) >= p_dfersoc + 1 jour calendaire
   --			 Avec société = nouvelle société et et cchtsoc = 'A'
   -- 	   (2) Après MAJ des lignes de contrat, suppression des anciens contrats vérifiant (cdatdeb) >= p_dfersoc + 1
   --------------------------------------------------------------------------------------------------------

   BEGIN

      INSERT INTO contrat (numcont   ,
			   cchtsoc   ,
			   ctypfact  ,
			   cobjet1   ,
			   cobjet2   ,
			   cobjet3   ,
			   crem      ,
			   cantfact  ,
			   cmoiderfac,
			   cmmens    ,
			   ccharesti ,
			   cecartht  ,
			   cevainit  ,
			   cnaffair  ,
			   cagrement ,
			   crang     ,
			   cantcons  ,
			   ccoutht   ,
			   cdatannul ,
			   cdatarr   ,
			   cdatclot  ,
			   cdatdeb   ,
			   cdatsoce  ,
			   cdatfin   ,
			   cdatmaj   ,
			   cdatdir   ,
			   cdatbilq  ,
			   cdatrpol  ,
			   cdatsocr  ,
			   cdatsai   ,
			   cduree    ,
			   flaglock  ,
			   soccont   ,
			   cav       ,
			   filcode   ,
			   comcode   ,
			   niche     ,
			   codsg     ,
			   ccentrefrais)
	(SELECT cont.numcont   ,
	 'A' 	          ,			-- cchtsoc
	 cont.ctypfact  ,
	 cont.cobjet1   ,
	 cont.cobjet2   ,
	 cont.cobjet3   ,
	 cont.crem      ,
	 cont.cantfact  ,
	 cont.cmoiderfac,
	 cont.cmmens    ,
	 cont.ccharesti ,
	 cont.cecartht  ,
	 cont.cevainit  ,
	 cont.cnaffair  ,
	 cont.cagrement ,
	 cont.crang     ,
	 cont.cantcons  ,
	 cont.ccoutht   ,
	 cont.cdatannul ,
	 cont.cdatarr   ,
	 cont.cdatclot  ,
	 cdatdeb	    ,
	 cont.cdatsoce  ,
	 cont.cdatfin   ,
	 cont.cdatmaj   ,
	 cont.cdatdir   ,
	 cont.cdatbilq  ,
	 cont.cdatrpol  ,
	 cont.cdatsocr  ,
	 cont.cdatsai   ,
	 cont.cduree    ,
	 0              ,   -- FLAGLOCK
	 p_nousoccode   ,   -- Nouvelle societe
	 cont.cav       ,
	 cont.filcode   ,
	 cont.comcode   ,
	 cont.niche     ,
	 cont.codsg     ,
       cont.ccentrefrais
	 FROM contrat cont
	 WHERE cont.soccont = p_ancsoccode
	 AND   ( cont.cdatfin > to_date(p_dfersoc, 'yyyymmdd') )
	 AND  ( cont.cdatdeb >=  (to_date(p_dfersoc, 'yyyymmdd') + 1)  )
	 );

   EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
	-- 'Problème lors de la création des nouveaux contrats : Contrat en double pour une même société!'
	pack_global.recuperer_message( 20616, NULL, NULL, NULL, l_msg);
	raise_application_error( -20616, l_msg);

        WHEN OTHERS THEN
      -- Dans les autres cas, quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la creation des nouveaux contrats'
	pack_global.recuperer_message( 20296, NULL, NULL, NULL, l_msg);
	raise_application_error( -20296, l_msg);
   END;



    ------------------------------ (ETAPE 4 : CREATION NOUVELLES LIGNE DE  CONTRATS) ----------------------------
   -- Creation des ligne de contrat
   -- avec la nouvelle societe et une date de debut = date de fermeture de la societe + 1
   ---------------------------------------------------------------------------------------------------------------

   BEGIN

      INSERT INTO ligne_cont(lcnum     ,
			     lfraisdep ,
			     lastreinte,
			     lheursup  ,
			     lresdeb   ,
			     lresfin   ,
			     lcdatact  ,
			     lccouact  ,
			     lccouinit ,
			     lcprest   ,
			     soccont   ,
			     cav       ,
			     numcont   ,
			     ident
			     )
	(SELECT lco.lcnum,
	 lco.lfraisdep ,
	 lco.lastreinte,
	 lco.lheursup  ,
	 (to_date(p_dfersoc, 'yyyymmdd') + 1)   lresdeb,
	 lco.lresfin   ,
	 lco.lcdatact  ,
	 lco.lccouact  ,
	 lco.lccouinit ,
	 lco.lcprest   ,
	 p_nousoccode,
	 lco.cav       ,
	 lco.numcont   ,
	 lco.ident
	 FROM  ligne_cont lco
	 WHERE lco.soccont = p_ancsoccode
	 AND   ( lco.lresfin > to_date(p_dfersoc, 'yyyymmdd') )
       --
	 -- HTM 11/02/2000
	 AND  ( lco.lresdeb <  (to_date(p_dfersoc, 'yyyymmdd') + 1)  )
	 );
   EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
	-- 'Problème lors de la creation des nouvelles lignes de contrats : Ligne de contrat en double pour une même société!'
	pack_global.recuperer_message( 20617, NULL, NULL, NULL, l_msg);
	raise_application_error( -20617, l_msg);

      WHEN OTHERS THEN
      -- Dans les autres cas, quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la creation des nouvelles lignes de contrats'
	pack_global.recuperer_message( 20298, NULL, NULL, NULL, l_msg);
	raise_application_error( -20298, l_msg);
   END;

   ------------------------------ (ETAPE 5) ---------------------------------------------------------------
   -- Fermeture des anciennes ligne de contrats qui ont permis de créer les nouvelles lignes  à l'Etape précédente :
   --
   -- Mis a jour des lignes de contrat
   -- avec la date de fin = date de fermeture de la societe.
   --------------------------------------------------------------------------------------------------------

   BEGIN

      UPDATE ligne_cont
	SET  lresfin     = to_date(p_dfersoc, 'yyyymmdd')
	WHERE soccont = p_ancsoccode
	AND   ( lresfin > to_date(p_dfersoc, 'yyyymmdd') )
	--
	-- HTM 11/02/2000
	AND  ( lresdeb <  (to_date(p_dfersoc, 'yyyymmdd') + 1)  ) ;

   EXCEPTION
     WHEN referential_integrity THEN
     -- habiller le msg erreur
     -- pack_global.recuperation_integrite(-2292);
     raise_application_error(-20997, sqlerrm);

      -- quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la mis a jour des ancienes ligne de contrats'
      WHEN OTHERS THEN
	pack_global.recuperer_message( 20299, NULL, NULL, NULL, l_msg );
	raise_application_error( -20299, l_msg || ' (... ETAPE 5 ...)' );
   END;

   ---------------------------- (ETAPE 6) -------------------------------------------------------------

   -- Transfert des anciennes lignes de contrat vérifiant (lresdeb) >= p_dfersoc + 1 jour calendaire
   -- vers la nouvelle société via un Update du code société

   -- Mise a jour des lignes de contrat
   -- avec la société = Nouvelle société.
   -----------------------------------------------------------------------------------------------------

  BEGIN

      UPDATE ligne_cont
	SET  soccont     = p_nousoccode
	WHERE soccont = p_ancsoccode
	AND   ( lresfin > to_date(p_dfersoc, 'yyyymmdd') )
	--
	-- HTM 11/02/2000
	AND  ( lresdeb >=  (to_date(p_dfersoc, 'yyyymmdd') + 1)  ) ;

   EXCEPTION
     WHEN referential_integrity THEN
     -- habiller le msg erreur
     --pack_global.recuperation_integrite(-2292);
     raise_application_error(-20997, sqlerrm);

      -- quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la mise a jour des ancienes ligne de contrats'
      WHEN OTHERS THEN
	pack_global.recuperer_message( 20299, NULL, NULL, NULL, l_msg);
	raise_application_error( -20299, l_msg || ' (... ETAPE 6 ...)' );
   END;

   ---------------------------- (ETAPE 7) -------------------------------------------------------------
   -- Suppression des anciens contrats qu'on avait conservé à cause INTEGRITE REFERENTIELLE CONTRAT -> LIGNE DE CONTRAT
   ----------------------------------------------------------------------------------------------------

   BEGIN

      DELETE FROM contrat
	WHERE soccont = p_ancsoccode
	AND   ( cdatfin > to_date(p_dfersoc, 'yyyymmdd') )
	AND  ( cdatdeb >=  (to_date(p_dfersoc, 'yyyymmdd') + 1)  ) ;

   EXCEPTION
     WHEN referential_integrity THEN
     -- habiller le msg erreur
     --pack_global.recuperation_integrite(-2292);
     raise_application_error(-20997, sqlerrm);

      -- quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la mis a jour des anciens contrats'
      WHEN OTHERS THEN

	pack_global.recuperer_message( 20297, NULL, NULL, NULL, l_msg );
	raise_application_error( -20297, l_msg || ' (... ETAPE 7  ...)' );
   END;


END gestion_contrat;

PROCEDURE gestion_situ_res(p_ancsoccode IN CHAR,
			   p_dfersoc    IN CHAR,
 			   p_nousoccode IN CHAR
			  ) IS
   l_msg   VARCHAR(1024);

BEGIN
   ------------------------------------------------------------------------
   -- En cas d'erreur on renvoie l'erreur a JS qui fera un rollback
   -------------------------------------------------------------------------

   -- Creation des nouvelles situation
   -- avec une date de situation (datsitu) = p_dfersoc + 1 jour calendaire
   -- Pour Information : SITURESS_PK = IDENT, DATSITU (Code Société ne fait pas partie de la clé!)
   --
   -- IL FAUT EXCLURE DE LA CREATION LES SITUATIONS QUI SONT TELLES QUE (datsitu) > p_dfersoc
   -- De telles situations provoqueraient en effet une remise à p_dfersoc + 1 des
   -- dates de situ qui étaient auparavent supérieures à p_dfersoc + 1 !!!
   -- Pour les cas où (datsitu) > p_dfersoc, IL FAUT FAIRE SIMPLEMENT UN UPDATE du code de la société !!!
   --
   -- ATTENTION : NE PAS MODIFIER L'ORDRE DES ETAPES CI-DESSOUS !!!

   ---------------------------- (ETAPE 1) -------------------------------------------------------------

   BEGIN

      INSERT INTO situ_ress (datsitu   ,
			     datdep    ,
			     cpident   ,
			     cout      ,
			     dispo     ,
			     marsg2    ,
			     rmcomp    ,
	                 prestation,
			     dprest    ,
	                 ident     ,
	                 soccode   ,
			     --filcode   ,
			     codsg
			  )
     ( SELECT (to_date(p_dfersoc, 'yyyymmdd') + 1) datsitu,
       sre.datdep    ,
       sre.cpident   ,
       sre.cout      ,
       sre.dispo     ,
       sre.marsg2    ,
       sre.rmcomp    ,
       sre.prestation,
       sre.dprest    ,
       sre.ident     ,
       p_nousoccode   ,
       --sre.filcode   ,
       sre.codsg
       FROM situ_ress sre
       WHERE sre.soccode = p_ancsoccode
       AND   ( (sre.datdep IS NULL) OR (sre.datdep > to_date(p_dfersoc, 'yyyymmdd')) )
	 --
	 -- HTM 09/02/2000
	 AND  ( sre.datsitu <  (to_date(p_dfersoc, 'yyyymmdd') + 1)  )
     );

   EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
	-- 'Problème lors de la création des nouvelles situations : Situation en double pour une même ressource!'
	pack_global.recuperer_message( 20615, NULL, NULL, NULL, l_msg);
	raise_application_error( -20615, l_msg);

      WHEN OTHERS THEN
      -- quelque soit les autres erreurs on renvoie un message d'erreur
      -- 'Problème lors de la creation des nouvelles situations'
	pack_global.recuperer_message( 20314, NULL, NULL, NULL, l_msg);
	raise_application_error( -20314, l_msg);

	-- RAISE_APPLICATION_ERROR(-pack_utile_numsg.nuexc_others, SQLERRM);

   END;

   ---------------------------- (ETAPE 2) -------------------------------------------------------------
   -- Fermetures  des anciennes situations pour lesquelles on vient de créer de nouvelles pour la nouvelle sté
   --
   BEGIN

   UPDATE situ_ress
     SET  datdep = to_date(p_dfersoc, 'yyyymmdd')
     WHERE soccode = p_ancsoccode
     AND   ( (datdep IS NULL) OR (datdep > to_date(p_dfersoc, 'yyyymmdd')) )
     -- HTM 09/02/2000
     AND ( datsitu < (to_date(p_dfersoc, 'yyyymmdd') + 1) );

   EXCEPTION
      -- quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la modification des anciennes situations'
      WHEN OTHERS THEN
	pack_global.recuperer_message( 20315, NULL, NULL, NULL, l_msg);
	raise_application_error( -20315, l_msg);

   END;


   ---------------------------- (ETAPE 3) -------------------------------------------------------------

   -- ---------------------- HTM 09/02/2000   DEBUT ------------------------------------------

   -- Transfert des anciennes situations vérifiant (datsitu) >= p_dfersoc + 1 jour calendaire
   -- vers la nouvelle société via un Update du code société
   BEGIN

   UPDATE situ_ress
     	SET	soccode = p_nousoccode
     	WHERE soccode = p_ancsoccode
     	AND   ( (datdep IS NULL) OR (datdep > to_date(p_dfersoc, 'yyyymmdd')) )
	AND   ( datsitu >= (to_date(p_dfersoc, 'yyyymmdd') + 1) );

   EXCEPTION
      -- quelque soit l'erreur on renvoie un message d'erreur
      -- 'Problème lors de la creation des nouvelles situations'
      WHEN OTHERS THEN
	pack_global.recuperer_message( 20314, NULL, NULL, NULL, l_msg);
	raise_application_error( -20314, l_msg);

   END;

   -- ---------------------- HTM 09/02/2000   FIN ------------------------------------------


END gestion_situ_res;


PROCEDURE insert_societe ( p_soccode   IN societe.soccode%TYPE,
			   p_soccat    IN societe.soccat%TYPE,
			   p_socnat    IN societe.socnat%TYPE,
			   p_soclib    IN societe.soclib%TYPE,
			   p_soccre    IN VARCHAR2,
			   p_userid    IN VARCHAR2,
			   p_nbcurseur OUT INTEGER,
			   p_message   OUT VARCHAR2
			 ) IS
      -- Variables locales

      l_msg   VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- Contrôle de cohérence des données

      IF ( p_socnat IS NOT NULL AND
           p_socnat != 'RG'  AND  p_socnat != 'RS'   AND  p_socnat != 'G'   AND  p_socnat != 'S' AND  p_socnat != 'R'
	AND  p_socnat != 'E' AND  p_socnat != 'RC'   AND  p_socnat != 'RE'  AND  p_socnat != 'C'  AND  p_socnat != 'L') THEN

         -- 'Code nature erroné: RG référencé généraliste ou RS référencé spécialiste ou G généraliste
         --  ou S spécialiste ou E éditeur ou blanc'

         pack_global.recuperer_message( 20305, NULL, NULL, 'SOCNAT', l_msg);

         raise_application_error( -20305, l_msg);
      END IF;

      IF ( p_soccat IS NOT NULL AND
           p_soccat != 'SSII'   AND
           p_soccat != 'SG..'   AND
           p_soccat != 'CONS'   AND
           p_soccat != 'DIVE'     ) THEN

         -- 'Code catégorie erroné'

         pack_global.recuperer_message( 20309, NULL, NULL, 'SOCCAT', l_msg);
         raise_application_error( -20309, l_msg);
      END IF;

      BEGIN
         INSERT INTO societe ( soccode,
                               soccat,
                               socnat,
                               soclib,
                               soccre)
         VALUES ( p_soccode,
                  p_soccat,
                  p_socnat,
                  p_soclib,
                  TO_DATE( p_soccre, 'DD/MM/YYYY')
                );

         -- 'La société ' || p_soclib || ' a été créé.';

         pack_global.recuperer_message( 3001, '%s1', p_soclib, NULL, l_msg);
         p_message := l_msg;

         EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN

               -- 'Code société déjà créé.'

               pack_global.recuperer_message( 20301, NULL, NULL,
                                              NULL, l_msg);

               raise_application_error( -20301, l_msg);

            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);
         END;

   END insert_societe;

   PROCEDURE update_societe ( p_soccode       IN societe.soccode%TYPE,
			      p_soclib        IN societe.soclib%TYPE,
                              p_socnat        IN societe.socnat%TYPE,
                              p_soccat        IN societe.soccat%TYPE,
                              p_soccre        IN VARCHAR2,
                              p_socfer_ch     IN VARCHAR2,
                              p_socnou        IN societe.socnou%TYPE,
                              p_soccop        IN societe.soccop%TYPE,
                              p_socfer_cl     IN VARCHAR2,
                              p_soccom        IN societe.soccom%TYPE,
                              p_flaglock      IN NUMBER,
                              p_userid        IN VARCHAR2,
                              p_nbcurseur     OUT INTEGER,
                              p_message       OUT VARCHAR2
                            ) IS

      -- Variables locales



      l_msg   VARCHAR(1024);
      l_soccode   societe.soccode%TYPE;
      l_date_fermeture varchar2(10);
      l_date_fermeture_ch varchar2(10);
      l_date_fermeture_cl varchar2(10);
      l_jour varchar2(2);

   BEGIN
      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

        -------------------------------------------------------------------------------
      -- Dates de fermetures
        -------------------------------------------------------------------------------

      IF (p_socfer_ch IS NOT NULL) THEN
          l_date_fermeture := to_char(to_date(p_socfer_ch,'mm/yyyy'),'yyyymm')||'01';
          l_date_fermeture_ch := to_char(add_months(to_date(l_date_fermeture,'yyyymmdd'),1)-1,'yyyymmdd');
      END IF;

      IF (p_socfer_cl IS NOT NULL) THEN
	  l_date_fermeture := to_char(to_date(p_socfer_cl,'mm/yyyy'),'yyyymm')||'01';
          l_date_fermeture_cl := to_char(add_months(to_date(l_date_fermeture,'yyyymmdd'),1)-1,'yyyymmdd');
       --   DBMS_OUTPUT.PUT_LINE(l_date_fermeture_cl);
      END IF;


	--------------------------------------------------------------------------------

      -- Contrôle de cohérence de la saisie

	--------------------------------------------------------------------------------



      -- 'Nature Société
      IF ( p_socnat IS NOT NULL AND
           (p_socnat <> 'RG' AND p_socnat <> 'RS' AND p_socnat <> 'G' AND p_socnat <> 'S' AND p_socnat <> 'E' AND p_socnat <> 'R' AND
            p_socnat <> 'RC' AND p_socnat <> 'RE' AND p_socnat <> 'C' AND p_socnat <> 'L')       ) THEN

         -- 'Code nature erroné
         pack_global.recuperer_message( 20305, NULL, NULL, 'SOCNAT', l_msg);
         raise_application_error( -20305, l_msg );
      END IF;



      IF ( p_soccat IS NOT NULL AND
           p_soccat != 'SSII'   AND
           p_soccat != 'SG..'   AND
           p_soccat != 'CONS'   AND
           p_soccat != 'DIVE'     ) THEN

	   -- 'Code catégorie erroné'

         pack_global.recuperer_message( 20309, NULL, NULL, 'SOCCAT', l_msg);
         raise_application_error( -20309, l_msg);
      END IF;



      -- La nouvelle société doit exister
      IF p_socnou IS NOT NULL THEN
         BEGIN
            SELECT soccode
            INTO   l_soccode
            FROM   SOCIETE
            WHERE  SOCCODE = p_socnou;

	   EXCEPTION
            WHEN NO_DATA_FOUND THEN

               -- 'Code société inexistant'

               pack_global.recuperer_message( 20306, NULL, NULL,
                                              'SOCNOU', l_msg);
               raise_application_error( -20306, l_msg );

            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);
	   END;

	END IF;



      -- Si les deux dates de fermetures sont renseignées -> Erreur
      IF p_socfer_ch IS NOT NULL AND
         p_socfer_cl  IS NOT NULL   THEN

         -- 'Renseigner la date de chment seule ou la date de
         --  fermeture provisoire seule'

         pack_global.recuperer_message( 20302, NULL, NULL,
                                        'SOCFER_CH', l_msg);
         raise_application_error( -20302, l_msg );
      END IF;



      -- Si la date fermeture provisoire < date du jour -> Erreur
      IF ( p_socfer_cl IS NOT NULL)
         AND
         (l_date_fermeture_cl <
           TO_CHAR( sysdate, 'YYYYMMDD'))  THEN

         -- 'Date de fermeture provisoire inférieure à date du jour'

         pack_global.recuperer_message( 20303, NULL, NULL,
                                        'SOCFER_CL', l_msg);
         raise_application_error( -20303, l_msg );

      END IF;



      -- Si date fermeture saisie et pas nouvelle société ou
      -- l'inverse -> Erreur
      IF ( p_socfer_ch IS NOT NULL AND
           p_socnou IS NULL              )
         OR
         ( p_socfer_ch IS NULL     AND
           p_socnou IS NOT NULL          ) THEN

         -- 'Saisir date fermeture et nouvelle société ou aucun des deux'

         pack_global.recuperer_message( 20304, NULL, NULL,
                                        'SOCFER_CH', l_msg);
         raise_application_error( -20304, l_msg );
      END IF;



	-----------------------------------------------------------------------------

      -- Cas d'un chment de nom de societe.

	-----------------------------------------------------------------------------

      IF (p_socfer_ch IS NOT NULL) AND (p_socnou IS NOT NULL) THEN

	 -- gestion des contrats

	 gestion_contrat(p_soccode,
			 l_date_fermeture_ch,
			 p_socnou
			 );



	 -- gestion des situations ressource

	 gestion_situ_res(p_soccode,
			  l_date_fermeture_ch,
			  p_socnou
			  );

      END IF;

      BEGIN
         UPDATE societe
         SET soclib  = p_soclib,
             socnat  = p_socnat,
             soccat  = p_soccat,
             socfer  = DECODE(p_socnou,NULL,to_date(l_date_fermeture_cl,'yyyymmdd'),
	      					   to_date(l_date_fermeture_ch,'yyyymmdd')),
             socnou  = p_socnou,
             soccom  = p_soccom,
             soccop  = p_soccop,
             flaglock = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE soccode = p_soccode
         AND   flaglock = p_flaglock;
     EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;


      IF SQL%NOTFOUND THEN
         -- 'Accès concurrent'
         pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
         -- 'La société p_soclib a été modifiée'
         pack_global.recuperer_message( 3002, '%s1', p_soclib, NULL, l_msg);
         p_message := l_msg;
      END IF;



      -- Si fermeture avec chment de nom de société, il faut
      -- fermer les contrats de l'ancienne et les recréer pour la
      -- nouvelle. Idem pour les situations ressources
   END update_societe;



   PROCEDURE delete_societe ( p_soccode   IN societe.soccode%TYPE,
                              p_flaglock  IN NUMBER,
                              p_userid    IN VARCHAR2,
                              p_nbcurseur OUT INTEGER,
                              p_message   OUT VARCHAR2
                            ) IS
      l_msg   VARCHAR(1024);
      referential_integrity   EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM societe
         WHERE soccode = p_soccode
          AND  flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN
            -- habiller le msg erreur
            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

         -- 'Accès concurrent'

         pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);

         raise_application_error( -20999, l_msg );
      ELSE
         -- message 'La société %s1 a été supprimée.'
         pack_global.recuperer_message( 3003, '%s1', p_soccode, NULL, l_msg);
         p_message := l_msg;
      END IF;

   END delete_societe;

   PROCEDURE select_societe ( p_soccode    IN societe.soccode%TYPE,
                              p_userid     IN VARCHAR2,
                              p_curSociete IN OUT societeCurType_Char,
                              p_datcre     OUT VARCHAR2,
                              p_nbcurseur  OUT INTEGER,
                              p_message    OUT VARCHAR2
                            ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      OPEN p_curSociete FOR
         SELECT soccode,
                soclib,
                socnat,
                soccat,
                TO_CHAR( soccre, 'DD/MM/YYYY'),
                DECODE( socnou, NULL,
                        NULL, TO_CHAR( socfer, 'MM/YYYY')),
                socnou,
                soccop,
                DECODE( socnou, NULL,
                        TO_CHAR( socfer, 'MM/YYYY'), NULL),
                soccom,
                flaglock
         FROM   societe
         WHERE  soccode = p_soccode;


      -- Gestion des paramètres OUT

      BEGIN
        SELECT TO_CHAR( soccre, 'DD/MM/YYYY')
        INTO   p_datcre
        FROM   societe
        WHERE  soccode = p_soccode;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           SELECT TO_CHAR( sysdate, 'DD/MM/YYYY')
           INTO   p_datcre
           FROM   DUAL;
      END;

      -- en cas absence
      -- p_message := 'Code Société inexistant.';
      -- Ce message est utilisé comme message APPLICATIF et
      -- message d'exception. => Il porte un numéro d'EXCEPTION
      pack_global.recuperer_message( 20306, NULL, NULL, NULL, l_msg);
      p_message := l_msg;

   END select_societe;
END pack_societe;
/
CREATE OR REPLACE PACKAGE pack_sous_typo AS

   TYPE sous_typologieCurType IS REF CURSOR RETURN sous_typologie%ROWTYPE;

  PROCEDURE insert_sous_type (p_sous_type   IN sous_typologie.sous_type%TYPE,
                                p_libsoustype    IN sous_typologie.libsoustype%TYPE,
                                p_global    IN CHAR,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                                );

   PROCEDURE update_sous_type (p_sous_type   IN sous_typologie.sous_type%TYPE,
                                 p_libsoustype    IN sous_typologie.libsoustype%TYPE,
                                 p_flaglock  IN NUMBER,
                                 p_global    IN CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

   PROCEDURE delete_sous_type (p_sous_type   IN sous_typologie.sous_type%TYPE,
                                 p_libsoustype    IN sous_typologie.libsoustype%TYPE,
                                 p_flaglock  IN NUMBER,
                                 p_global    IN CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
	   		              );

   PROCEDURE select_sous_type (p_sous_type   IN sous_typologie.sous_type%TYPE,
                                 p_global    IN CHAR,
                                 p_cursor    IN OUT sous_typologieCurType,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

END pack_sous_typo;
/

CREATE OR REPLACE PACKAGE BODY pack_sous_typo AS

   PROCEDURE insert_sous_type (p_sous_type   IN  sous_typologie.sous_type%TYPE ,
                                 p_libsoustype    IN  sous_typologie.libsoustype%TYPE  ,
                                 p_global    IN  CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO sous_typologie ( sous_type,
                                   libsoustype)
         VALUES ( p_sous_type,
                  p_libsoustype);

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN

            -- 'Code type existe déjà'

	      pack_global.recuperer_message(21023,NULL,NULL,NULL,msg);
            raise_application_error( -21023, msg );

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      -- 'Code type ' || p_libsoustype|| ' créé'

	pack_global.recuperer_message( 21024, '%s1', p_libsoustype, NULL, msg);
	p_message := msg;

   END insert_sous_type;


   PROCEDURE update_sous_type (p_sous_type   IN sous_typologie.sous_type%TYPE,
                                 p_libsoustype    IN sous_typologie.libsoustype%TYPE,
                                 p_flaglock  IN NUMBER,
                                 p_global    IN CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN

         UPDATE sous_typologie
         SET libsoustype   = p_libsoustype,
             flaglock = decode( p_flaglock, 1000000, 0,
                                p_flaglock + 1)
         WHERE sous_type  = p_sous_type
         AND   flaglock = p_flaglock;

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, msg);
         raise_application_error( -20999, msg );

      ELSE

         -- 'Code type ||p_libsoustype|| modifié'

         pack_global.recuperer_message( 21025, '%s1', p_libsoustype, NULL, msg);
         p_message := msg;
      END IF;

   END update_sous_type;


   PROCEDURE delete_sous_type (p_sous_type   IN sous_typologie.sous_type%TYPE,
                                 p_libsoustype    IN sous_typologie.libsoustype%TYPE,
                                 p_flaglock  IN NUMBER,
                                 p_global    IN CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT( referential_integrity, -2292);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM sous_typologie
         WHERE sous_type  = p_sous_type
         AND   flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message(20999,NULL,NULL,NULL,msg);
         raise_application_error( -20999, msg );

      ELSE

         -- 'Code type ||p_libsoustype|| supprimé'

	   pack_global.recuperer_message( 21026, '%s1', p_libsoustype, NULL, msg);
         p_message := msg;
      END IF;

   END delete_sous_type;


   PROCEDURE select_sous_type (p_sous_type   IN sous_typologie.sous_type%TYPE,
                                 p_global    IN CHAR,
                                 p_cursor    IN OUT sous_typologieCurType,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      OPEN p_cursor FOR
           SELECT *
           FROM sous_typologie
           WHERE sous_type =  p_sous_type;

      -- en cas absence
      -- 'Code Sous Type inexistant'

      pack_global.recuperer_message( 21022, '%s1', p_sous_type, NULL, msg);
      p_message := msg;

   END select_sous_type;

END pack_sous_typo;
/
CREATE OR REPLACE PACKAGE     pack_stat_page AS

   -- Définition curseur sur la table stat_page

   TYPE statpage_ViewType IS RECORD ( 	id_page  		stat_page.id_page%TYPE,
						  	 			lib_page  		stat_page.lib_page%TYPE,
										trace  			stat_page.trace%TYPE,
										trace_action  	stat_page.trace_action%TYPE
										);


   TYPE statpageCurType_Char IS REF CURSOR RETURN statpage_ViewType;


   PROCEDURE select_liste ( p_curstat 	IN OUT statpageCurType_Char ,
                            p_nbcurseur    OUT INTEGER,
                            p_message      OUT VARCHAR2
                          );


END pack_stat_page;
/

CREATE OR REPLACE PACKAGE BODY     pack_stat_page AS


    PROCEDURE select_liste ( p_curstat 	IN OUT statpageCurType_Char ,
                            p_nbcurseur    OUT INTEGER,
                            p_message      OUT VARCHAR2
                          ) IS

		l_msg VARCHAR2(1024);
		l_codsg NUMBER;

    BEGIN

        -- Positionner le nb de curseurs ==> 1
        -- Initialiser le message retour
		p_nbcurseur := 1;
      	p_message := '';

       	OPEN   p_curstat FOR
           	SELECT id_page,
              	   lib_page,
              	   trace,
				   trace_action
              FROM stat_page
			ORDER BY id_page;

   	EXCEPTION
		WHEN OTHERS THEN
       		raise_application_error( -20997, SQLERRM);

	END select_liste;


END pack_stat_page;
/
CREATE OR REPLACE PACKAGE pack_struct_info AS

   -- Définition curseur sur la table struct_info

   TYPE Struct_info_ViewType IS RECORD ( codsg      	VARCHAR2(20),
					 	sigdep     	struct_info.sigdep%TYPE,
                                  	 	sigpole    	struct_info.sigpole%TYPE,
                                  	 	libdsg     	struct_info.libdsg%TYPE,
						gnom 		struct_info.gnom%TYPE,
                                  	 	centractiv 	VARCHAR2(20),
                                 	 	topfer     	struct_info.topfer%TYPE,
					 	flaglock   	struct_info.flaglock%TYPE,
					 	coddir     	VARCHAR2(20),
					 	cafi 	    	VARCHAR2(20),
					 	scentrefrais 	VARCHAR2(3),
					 	filcode    	VARCHAR2(3)
						);

   TYPE struct_infoCurType_Char IS REF CURSOR RETURN Struct_info_ViewType;

  FUNCTION getCentrefrais (p_codsg      	IN  VARCHAR2,
				  	p_coddir     	IN  VARCHAR2
				) Return VARCHAR2;

   PROCEDURE insert_struct_info ( 	p_codsg      	IN  VARCHAR2,
				  	p_coddir     	IN  VARCHAR2,
                                  	p_sigdep     	IN  struct_info.sigdep%TYPE,
                                  	p_sigpole    	IN  struct_info.sigpole%TYPE,
                                  	p_libdsg     	IN  struct_info.libdsg%TYPE,
					p_gnom 		IN  struct_info.gnom%TYPE,
                                  	p_centractiv 	IN  VARCHAR2,
				  	p_cafi       	IN  VARCHAR2,

				  	p_filcode    	IN  VARCHAR2,
				  	p_centrefrais 	IN  VARCHAR2,
                                  	p_topfer     	IN  struct_info.topfer%TYPE,
                                  	p_userid     	IN  VARCHAR2,
                                  	p_nbcurseur  	OUT INTEGER,
                                  	p_message    	OUT VARCHAR2
                                );

   PROCEDURE update_struct_info ( 	p_codsg      	IN  VARCHAR2,
				  	p_coddir     	IN  VARCHAR2,
                                  	p_sigdep     	IN  struct_info.sigdep%TYPE,
                                  	p_sigpole    	IN  struct_info.sigpole%TYPE,
                                  	p_libdsg     	IN  struct_info.libdsg%TYPE,
					p_gnom 		IN  struct_info.gnom%TYPE,
                                  	p_centractiv 	IN  VARCHAR2,
				  	p_cafi       	IN  VARCHAR2,
				  	p_filcode    	IN  VARCHAR2,
				  	p_centrefrais 	IN  VARCHAR2,
                                  	p_topfer     	IN  struct_info.topfer%TYPE,
                                  	p_flaglock   	IN  NUMBER,
				  	p_userid     	IN  VARCHAR2,
				  	p_nbcurseur  	OUT INTEGER,
                                  	p_message    	OUT VARCHAR2
                              );

   PROCEDURE delete_struct_info ( p_codsg     IN  VARCHAR2,
                                  p_flaglock  IN  NUMBER,
                                  p_userid    IN  VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                              );

   PROCEDURE select_struct_info ( p_codsg	   IN VARCHAR2,
                                  p_userid         IN VARCHAR2,
                                  p_curStruct_info IN OUT struct_infoCurType_Char ,
                                  p_nbcurseur         OUT INTEGER,
                                  p_message           OUT VARCHAR2
                                );

END pack_struct_info;
/

CREATE OR REPLACE PACKAGE BODY pack_struct_info AS
-- Correction bug de la fiche 251 sur la création de nouveaux code DPG
-- et de leur rattachement automatique à un centre de frais
FUNCTION getCentrefrais (p_codsg      	IN  VARCHAR2,
				  p_coddir     	IN  VARCHAR2
				) Return VARCHAR2  IS

 l_codbr varchar2(2);
 l_codbddpg varchar2(11);
 l_centrefrais varchar2(3);
 l_msg VARCHAR2(1024);


BEGIN

      -- récupération du code branche
	BEGIN
        SELECT lpad(codbr,2,'0') INTO l_codbr
        FROM directions
        WHERE coddir = p_coddir;

	  EXCEPTION
        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
      END;


      -- récupération du code centre de frais
	BEGIN

        SELECT codcfrais INTO l_centrefrais
        FROM compo_centre_frais ccf
        WHERE substr(ccf.codbddpg,1,2) = l_codbr
	  AND ((substr(ccf.codbddpg,3,2) = lpad(p_coddir,2,'0')) OR (substr(ccf.codbddpg,3,9) = '000000000'))
	  AND ((substr(ccf.codbddpg,5,3) = substr(LPAD( p_codsg, 7, '0'),1,3)) OR (substr(ccf.codbddpg,5,7) = '0000000'))
	  AND ((substr(ccf.codbddpg,8,2) = substr(LPAD( p_codsg, 7, '0'),4,2)) OR (substr(ccf.codbddpg,8,4) = '0000'))
	  AND ((substr(ccf.codbddpg,10,2) = substr(LPAD( p_codsg, 7, '0'),6,2)) OR (substr(ccf.codbddpg,10,2) = '00'));

	  EXCEPTION
        WHEN NO_DATA_FOUND THEN
		 l_centrefrais:='';


     	  WHEN DUP_VAL_ON_INDEX THEN
	    pack_global.recuperer_message( 20751, NULL, NULL, NULL, l_msg);
          raise_application_error( -20751, l_msg );

        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);
      END;
	RETURN  l_centrefrais;

END getCentrefrais;


  PROCEDURE insert_struct_info ( 	p_codsg		IN VARCHAR2,
				  	p_coddir    	IN VARCHAR2,
                                  	p_sigdep	IN struct_info.sigdep%TYPE,
                                  	p_sigpole	IN struct_info.sigpole%TYPE,
                                  	p_libdsg	IN struct_info.libdsg%TYPE,
					p_gnom 		IN struct_info.gnom%TYPE,
                                  	p_centractiv	IN VARCHAR2,
				  	p_cafi		IN VARCHAR2,
				  	p_filcode   	IN  VARCHAR2,
				 	p_centrefrais 	IN  VARCHAR2,
                                  	p_topfer	IN struct_info.topfer%TYPE,
                                  	p_userid	IN VARCHAR2,
                                  	p_nbcurseur	OUT INTEGER,
                                  	p_message	OUT VARCHAR2
                              ) IS

     l_msg VARCHAR2(1024);
     l_msg_alert VARCHAR2(1024);
     l_codcamo centre_activite.codcamo%TYPE;
     l_exist number;
     l_codbr varchar2(2);
     l_codbddpg varchar2(11);
     l_centrefrais varchar2(3);
     l_ctopact centre_activite.ctopact%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      -- test si le centre d'activité existe

      BEGIN
        SELECT codcamo INTO l_codcamo
        FROM centre_activite
        WHERE TO_NUMBER(p_centractiv)= codcamo;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
 	    pack_global.recuperer_message( 20754, NULL, NULL, NULL, l_msg);
          raise_application_error( -20754, l_msg );

        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);

      END;

      -- test si le CA pour la FI existe

      BEGIN
        SELECT codcamo INTO l_codcamo
        FROM centre_activite
        WHERE TO_NUMBER(p_cafi)= codcamo;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
 	    pack_global.recuperer_message( 20755, NULL, NULL, NULL, l_msg);
          raise_application_error( -20755, l_msg );

        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);

      END;

      -- ce CA pour la FI doit avoir le top amortissement a C
      BEGIN
        SELECT ctopact INTO l_ctopact
        FROM centre_activite
        WHERE TO_NUMBER(p_cafi)= codcamo
        AND ctopact='C';
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
        	-- 'Le centre d'activité pour la FI n'est pas topé à CAFI.'
 	    pack_global.recuperer_message( 20983, NULL, NULL, NULL, l_msg);
          raise_application_error( -20983, l_msg );

        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);

      END;

	l_centrefrais := getCentrefrais (p_codsg, p_coddir) ;

	BEGIN
     	   INSERT INTO struct_info
	    ( codsg,
 		sigdep,
 		sigpole,
 		libdsg,
		gnom,
 		centractiv,
 		topfer,
 		coddep,
 		codpole,
		codgro,
 		coddeppole,
		coddir,
		cafi,
		scentrefrais ,
		filcode,
		flaglock)
         VALUES ( TO_NUMBER(p_codsg),
		   p_sigdep,
		   p_sigpole,
		   p_libdsg,
		   p_gnom,
		   TO_NUMBER(p_centractiv),
		   p_topfer,
		   SUBSTR( LPAD( p_codsg, 7, '0' ), 1, 3) ,
		   SUBSTR( LPAD( p_codsg, 7, '0' ), 4, 2) ,
		   SUBSTR( LPAD( p_codsg, 7, '0' ), 6, 2) ,
		   SUBSTR( LPAD( p_codsg, 7, '0' ), 1, 5) ,
		   TO_NUMBER(p_coddir),
		   to_number(p_cafi),
		   to_number(l_centrefrais),
--		   to_number(p_centrefrais),
		   p_filcode,
		   0
		);

	   -- 'Pôle p_sigpole créé'

         pack_global.recuperer_message( 1001, '%s1', p_codsg, NULL, l_msg);
	if (l_centrefrais!='' or l_centrefrais is not null) then
		 p_message := l_msg;
	else
	  	 p_message := l_msg||'\nATTENTION : Ce code DPG n''appartient à aucun centre de frais. \nPour rattacher ce DPG à un centre de frais, il faut mettre à jour le centre de frais.';
	end if;

     EXCEPTION
      	WHEN DUP_VAL_ON_INDEX THEN
		   pack_global.recuperer_message( 20001, NULL, NULL, NULL, l_msg);
               raise_application_error( -20001, l_msg );

            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);
     END;

   END insert_struct_info;



   PROCEDURE update_struct_info ( 	p_codsg      	IN  VARCHAR2,
				  	p_coddir     	IN  VARCHAR2,
                                  	p_sigdep     	IN  struct_info.sigdep%TYPE,
                                  	p_sigpole    	IN  struct_info.sigpole%TYPE,
                                  	p_libdsg     	IN  struct_info.libdsg%TYPE,
					p_gnom 		IN  struct_info.gnom%TYPE,
                                  	p_centractiv 	IN  VARCHAR2,
				  	p_cafi       	IN  VARCHAR2,
				  	p_filcode    	IN  VARCHAR2,
				  	p_centrefrais 	IN  VARCHAR2,
                                  	p_topfer     	IN  struct_info.topfer%TYPE,
                                  	p_flaglock   	IN  NUMBER,
				  	p_userid     	IN  VARCHAR2,
				  	p_nbcurseur  	OUT INTEGER,
                                  	p_message    	OUT VARCHAR2
                              ) IS

	l_msg VARCHAR2(1024);
	l_codcamo centre_activite.codcamo%TYPE;
     l_centrefrais varchar2(3);
     l_ctopact centre_activite.ctopact%TYPE;


   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- initialiser le message retour

	p_nbcurseur := 0;
	p_message := '';

      -- test si le centre d'activité existe

      BEGIN
        SELECT codcamo INTO l_codcamo
        FROM centre_activite
        WHERE TO_NUMBER(p_centractiv)= codcamo;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
 	    pack_global.recuperer_message( 20754, NULL, NULL, NULL, l_msg);
          raise_application_error( -20754, l_msg );

        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;

	-- test si le CA FI existe
	BEGIN
        SELECT codcamo INTO l_codcamo
        FROM centre_activite
        WHERE TO_NUMBER(p_cafi)= codcamo;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
 	    pack_global.recuperer_message( 20755, NULL, NULL, NULL, l_msg);
          raise_application_error( -20755, l_msg );

        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;

      -- le CA pour la FI doit avoir le top amortissement a C
      BEGIN
        SELECT ctopact INTO l_ctopact
        FROM centre_activite
        WHERE TO_NUMBER(p_cafi)= codcamo
        AND ctopact='C';
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
        	-- 'Le centre d'activité pour la FI n'est pas topé à CAFI.'
 	    pack_global.recuperer_message( 20983, NULL, NULL, NULL, l_msg);
          raise_application_error( -20983, l_msg );

        WHEN OTHERS THEN
           raise_application_error( -20997, SQLERRM);

      END;

	BEGIN
	   l_centrefrais := getCentrefrais (p_codsg, p_coddir) ;

         UPDATE struct_info
		SET	sigdep 		= p_sigdep,
		    	sigpole 	= p_sigpole,
			libdsg 		= p_libdsg,
			gnom 		= p_gnom,
			centractiv 	= p_centractiv,
			topfer 		= p_topfer,
			coddep 		= SUBSTR( LPAD( p_codsg, 7, '0' ), 1, 3) ,
			codpole 	= SUBSTR( LPAD( p_codsg, 7, '0' ), 4, 2) ,
			codgro 		= SUBSTR( LPAD( p_codsg, 7, '0' ), 6, 2) ,
			coddeppole 	= SUBSTR( LPAD( p_codsg, 7, '0' ), 1, 5) ,
			flaglock 	= DECODE( p_flaglock, 1000000, 0, p_flaglock + 1 ) ,
			coddir  	= TO_NUMBER(p_coddir),
 			cafi		= to_number(p_cafi),
			filcode		= p_filcode,
		      scentrefrais = TO_NUMBER(l_centrefrais)
		WHERE codsg 	= TO_NUMBER(p_codsg)
              AND flaglock 	= p_flaglock;

	   EXCEPTION

		WHEN OTHERS THEN
	        raise_application_error( -20754, l_msg );

	--	   raise_application_error( -20997, SQLERRM);
	END;


      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE



	   -- 'Le pôle p_codsg a été modifié'

	   pack_global.recuperer_message( 1002, '%s1', p_codsg, NULL, l_msg);
	if (l_centrefrais!='' or l_centrefrais is not null) then
		 p_message := l_msg;
	else
	  	 p_message := l_msg||'\nATTENTION : Ce code DPG n''appartient à aucun centre de frais. \nPour rattacher ce DPG à un centre de frais, il faut mettre à jour le centre de frais.';
	end if;



      END IF;

   END update_struct_info;


   PROCEDURE delete_struct_info ( p_codsg     IN  VARCHAR2,
                                  p_flaglock  IN  NUMBER,
                                  p_userid    IN  VARCHAR2,
                                  p_nbcurseur OUT INTEGER,
                                  p_message   OUT VARCHAR2
                              ) IS


	l_msg VARCHAR2(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
	   DELETE FROM struct_info
		    WHERE codsg = TO_NUMBER(p_codsg)
			AND flaglock = p_flaglock;

         EXCEPTION

		WHEN referential_integrity THEN

               -- habiller le msg erreur

               pack_global.recuperation_integrite(-2292);

		WHEN OTHERS THEN
		   raise_application_error( -20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE

	   -- 'Le pôle p_codsg a été supprimé'

	   pack_global.recuperer_message( 1003, '%s1', p_codsg, NULL, l_msg);
	   p_message := l_msg;

      END IF;

   END delete_struct_info;



   PROCEDURE select_struct_info ( p_codsg          IN VARCHAR2,
                                  p_userid         IN VARCHAR2,
                                  p_curStruct_info IN OUT struct_infoCurType_Char,
                                  p_nbcurseur         OUT INTEGER,
                                  p_message           OUT VARCHAR2
                              ) IS

	l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

-- dbms_output.put_line('p_codsg = ' || p_codsg || ' --- p_userid = ' || p_userid );

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN   p_curStruct_info FOR
              SELECT 	TO_CHAR(codsg),
                     	sigdep,
                     	sigpole,
                     	libdsg,
			gnom,
                     	TO_CHAR(centractiv),
                     	topfer,
                     	flaglock,
		     	TO_CHAR(coddir),
		     	TO_CHAR(cafi),
		     	TO_CHAR(scentrefrais),
		      	filcode
              FROM  struct_info
              WHERE codsg = TO_NUMBER(p_codsg);

         -- en cas absence
	   -- 'Code Département/Pôle/Groupe p_codsg inexistant'

         pack_global.recuperer_message( 20203, '%s1', p_codsg, NULL, l_msg);
         p_message := l_msg;

      EXCEPTION

        WHEN OTHERS THEN
          raise_application_error( -20997, SQLERRM);

      END;

   END select_struct_info;

END pack_struct_info;
/
CREATE OR REPLACE PACKAGE pack_st_amort AS

TYPE st_amort_RecType IS RECORD (pid         ligne_bip.pid%TYPE,
                                 pnom        ligne_bip.pnom%TYPE,
                                 typproj     ligne_bip.typproj%TYPE,
                                 astatut     ligne_bip.astatut%TYPE,
                                 topfer      ligne_bip.topfer%TYPE,
                                 adatestatut VARCHAR2(10),
                                 flaglock    ligne_bip.flaglock%TYPE,
		         		    date_demande VARCHAR2(10),
		         		    demandeur audit_statut.demandeur%TYPE,
		        		    commentaire audit_statut.commentaire%TYPE
                                );


TYPE st_amortCurType IS REF CURSOR RETURN st_amort_RecType;

TYPE st_amortges_RecType IS RECORD (pid         ligne_bip.pid%TYPE,
                                    pnom        ligne_bip.pnom%TYPE,
                                    libstatut   code_statut.libstatut%TYPE,
                                    adatestatut VARCHAR2(10),
                                    flaglock    ligne_bip.flaglock%TYPE
                                );


TYPE st_amortgesCurType IS REF CURSOR RETURN st_amortges_RecType;

   PROCEDURE update_st_amort (p_pid         IN  ligne_bip.pid%TYPE,
                              p_pnom        IN  ligne_bip.pnom%TYPE,
                              p_filsigle    IN  filiale_cli.filsigle%TYPE,
                              p_typproj	    IN  ligne_bip.typproj%TYPE,
                              p_astatut     IN  ligne_bip.astatut%TYPE,
			      	p_topfer      IN  ligne_bip.topfer%TYPE,
                              p_top         IN  CHAR,--aur
                              p_adatestatut IN  VARCHAR2,
                              p_valid       IN  VARCHAR2,
					p_date_demande  IN  VARCHAR2,
		       		p_demandeur IN  VARCHAR2,
		       		p_commentaire IN  VARCHAR2,
                              p_flaglock    IN  NUMBER,
                              p_userid      IN  VARCHAR2,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             );

  PROCEDURE confirm_st_amort (p_pid         IN  ligne_bip.pid%TYPE,
                              p_pnom        IN  ligne_bip.pnom%TYPE,
                              p_filsigle    IN  filiale_cli.filsigle%TYPE,
                              p_typproj	    IN ligne_bip.typproj%TYPE,
                              p_astatut     IN  ligne_bip.astatut%TYPE,
			      	p_topfer      IN  ligne_bip.topfer%TYPE,
                              p_top         IN CHAR,--aur
                              p_adatestatut IN  VARCHAR2,
                              p_valid       IN VARCHAR2,
					p_date_demande  IN  VARCHAR2,
		       		p_demandeur IN  VARCHAR2,
		       		p_commentaire IN  VARCHAR2,
                              p_flaglock    IN  NUMBER,
                              p_userid      IN  VARCHAR2,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             );

   PROCEDURE select_st_amort (p_pid         IN ligne_bip.pid%TYPE,
                              p_userid      IN VARCHAR2,
                              p_curst_amort IN OUT st_amortCurType,
                              p_date           OUT VARCHAR2,
                              p_filsigle       OUT VARCHAR2,
                              p_nbcurseur      OUT INTEGER,
                              p_message        OUT VARCHAR2
                             );

PROCEDURE select_st_amortges (p_pid            IN ligne_bip.pid%TYPE,
                              p_userid         IN VARCHAR2,
                              p_curst_amortges IN OUT st_amortgesCurType,
                              p_filsigle    	  OUT VARCHAR2,
                              p_nbcurseur 	  OUT INTEGER,
                              p_message   	  OUT VARCHAR2
                             );

PROCEDURE audit ( p_pid            IN ligne_bip.pid%TYPE,
		  		  p_date_demande   IN VARCHAR2,
				  p_demandeur	   IN audit_statut.demandeur%TYPE,
				  p_commentaire	   IN audit_statut.commentaire	%TYPE,
				  p_message     OUT VARCHAR2);

END pack_st_amort;
/

CREATE OR REPLACE PACKAGE BODY pack_st_amort AS

   PROCEDURE update_st_amort (p_pid         IN  ligne_bip.pid%TYPE,
                              p_pnom        IN  ligne_bip.pnom%TYPE,
                              p_filsigle    IN  filiale_cli.filsigle%TYPE,
                              p_typproj	    IN  ligne_bip.typproj%TYPE,
                              p_astatut     IN  ligne_bip.astatut%TYPE,
	                   	p_topfer      IN  ligne_bip.topfer%TYPE,
                              p_top         IN  CHAR, -- pour avoir le bon nombre de paramètre
		       		p_adatestatut IN  VARCHAR2,
		       		p_valid       IN  VARCHAR2,
		       		p_date_demande  IN  VARCHAR2,
		       		p_demandeur IN  VARCHAR2,
		       		p_commentaire IN  VARCHAR2,
                              p_flaglock    IN  NUMBER,
                              p_userid      IN  VARCHAR2,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             ) IS

      	l_msg VARCHAR2(1024);
	l_annee NUMBER;
        l_datesaisie NUMBER;
        l_mois NUMBER;
 	out_of_stock    EXCEPTION;
	l_length_commentaire  NUMBER(4);

 	l_user		ligne_bip_logs.user_log%TYPE;
 	-- Valeurs précédentes pour les logs
 	l_topfer	ligne_bip.topfer%TYPE;
 	l_astatut	ligne_bip.astatut%TYPE;
 	l_adatestatut	ligne_bip.adatestatut%TYPE;


   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      l_user := SUBSTR(pack_global.lire_globaldata(p_userid).idarpege, 1, 30);

      -- On récupère les valeurs précédentes pour les logs
      SELECT topfer, astatut, adatestatut
      INTO l_topfer, l_astatut, l_adatestatut
      FROM ligne_bip
      WHERE pid=p_pid
      AND flaglock = p_flaglock;

      -- Si le statut ancien est Vide et que le nouveau est A ou D ou C
      -- On renvoie un message d'erreur
      If (l_astatut IS NULL) AND ((p_astatut='A') OR (p_astatut='D') OR (p_astatut='C')) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_astatut,''), '%s2', NVL(p_astatut,''), 'ASTATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est D et que le nouveau est A ou Vide ou N ou C
      -- On renvoie un message d'erreur
      If (l_astatut='D') AND ((p_astatut='A') OR (p_astatut='N') OR (p_astatut='C') OR (p_astatut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_astatut,''), '%s2', NVL(p_astatut,''), 'ASTATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est A et que le nouveau est D ou N ou C ou Vide
      -- On renvoie un message d'erreur
      If (l_astatut='A') AND ((p_astatut='D') OR (p_astatut='N') OR (p_astatut='C') OR (p_astatut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_astatut,''), '%s2', NVL(p_astatut,''), 'ASTATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est C et que le nouveau est D ou N ou A ou Vide
      -- On renvoie un message d'erreur
      If (l_astatut='C') AND ((p_astatut='D') OR (p_astatut='N') OR (p_astatut='A') OR (p_astatut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_astatut,''), '%s2', NVL(p_astatut,''), 'ASTATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

      -- Si le statut ancien est N et que le nouveau est D ou C ou A ou Vide
      -- On renvoie un message d'erreur
      If (l_astatut='N') AND ((p_astatut='D') OR (p_astatut='C') OR (p_astatut='A') OR (p_astatut IS NULL)) THEN
         pack_global.recuperer_message(20929, '%s1', NVL(l_astatut,''), '%s2', NVL(p_astatut,''), 'ASTATUT', l_msg);
         raise_application_error( -20929, l_msg);
      END IF;

	--
	-- RG 24/11/2003 : la date du statut est obligatoire si statut différent de vide de 'O' et de 'N',

	IF ( (p_adatestatut IS NULL) AND (p_astatut IS NOT NULL) AND (p_astatut!='O') AND (p_astatut!='N')) THEN
         pack_global.recuperer_message(20002, NULL, NULL, 'ADATESTATUT', l_msg);
         raise_application_error( -20002, l_msg );
	END IF;

	--
	--  la date est obligatoire si top_fermeture est égal à OUI,
	--
	IF ( (p_adatestatut IS NULL) AND (p_topfer ='O')) THEN
         pack_global.recuperer_message(20004, NULL, NULL, 'ADATESTATUT', l_msg);
         raise_application_error( -20004, l_msg );
	END IF;


	--
	-- RG 24/11/2003 : la date du statut ne doit pas être saisie si statut vide ou ='O' ou ='N' et top fermeture égal à 'non'
	IF ( (p_adatestatut IS NOT NULL) AND ((p_astatut IS NULL) OR (p_astatut='O') OR (p_astatut='N')) AND (p_topfer='N') )
		 THEN
         pack_global.recuperer_message(20005, NULL, NULL, 'ADATESTATUT', l_msg);
         raise_application_error( -20005, l_msg );
	END IF;

	--controle de saisie de la DATE de statut d'une ligne bip
	IF p_adatestatut IS NOT NULL THEN
		l_datesaisie := TO_NUMBER(substr(p_adatestatut,4,4) || substr(p_adatestatut,0,2));
		l_annee := TO_NUMBER (to_char(SYSDATE,'yyyy'));
		l_mois :=TO_NUMBER (to_char(SYSDATE,'mm'));


		IF l_mois BETWEEN 01 AND 06 THEN
			IF l_datesaisie < ((l_annee -1) ||12) THEN
			--date saisie antérieure au dernier bilan
			pack_global.recuperer_message(20923,NULL,NULL,'ADATESTATUT',l_msg);
			raise_application_error( -20923, l_msg );
			ELSIF l_datesaisie > (l_annee ||0||5) THEN
			--anticipation sur les dates est interdite
			pack_global.recuperer_message(20924,NULL,NULL,'ADATESTATUT',l_msg);
			raise_application_error( -20924, l_msg );
			END IF;
		ELSE  -- DATE comprise entre juillet et decembre
			IF l_datesaisie < (l_annee||0||6) THEN
			--date saisie antérieure au dernier bilan
			pack_global.recuperer_message(20923,NULL,NULL,'ADATESTATUT',l_msg);
			raise_application_error( -20923, l_msg );
			ELSIF l_datesaisie > (l_annee ||11) THEN
			--anticipation sur les dates est interdite
			pack_global.recuperer_message(20924,NULL,NULL,'ADATESTATUT',l_msg);
			raise_application_error( -20924, l_msg );
			END IF;
		END IF;
	END IF;


      BEGIN
         UPDATE ligne_bip
         SET astatut     = decode(p_astatut, 'E', NULL, p_astatut),
	     topfer      = p_topfer,
             adatestatut = TO_DATE(p_adatestatut, 'MM/YYYY'),
             flaglock    = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  pid = p_pid
         AND flaglock = p_flaglock;

         -- On loggue le type, la typologie, le CA payeur, le topfer, le statut, la date de statut
         pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'Top fermeture', l_topfer, p_topfer, 'MAJ statut de la ligne BIP via dirmenu');
         pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'Statut', l_astatut, p_astatut, 'MAJ statut de la ligne BIP via dirmenu');
         pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'Date statut', TO_CHAR(l_adatestatut, 'MM/YYYY'), p_adatestatut, 'MAJ statut de la ligne BIP via dirmenu');

	 --Audit
	 audit(p_pid, p_date_demande, p_demandeur, p_commentaire, p_message);

      EXCEPTION

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );

      ELSE

        pack_global.recuperer_message(2065, '%s1', p_pid, NULL, l_msg);
        p_message := l_msg;

     END IF;


END update_st_amort;

  PROCEDURE confirm_st_amort (p_pid         IN  ligne_bip.pid%TYPE,
                              p_pnom        IN  ligne_bip.pnom%TYPE,
                              p_filsigle    IN  filiale_cli.filsigle%TYPE,
                              p_typproj	    IN ligne_bip.typproj%TYPE,
                              p_astatut     IN  ligne_bip.astatut%TYPE,
			      	p_topfer      IN  ligne_bip.topfer%TYPE,
                              p_top         IN CHAR, -- pour avoir le bon nombre de paramètre
			      	p_adatestatut IN  VARCHAR2,
			      	p_valid       IN VARCHAR2,
					p_date_demande  IN  VARCHAR2,
		       		p_demandeur IN  VARCHAR2,
		       		p_commentaire IN  VARCHAR2,
                              p_flaglock    IN  NUMBER,
                              p_userid      IN  VARCHAR2,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             ) IS

        l_msg VARCHAR2(1024);
	l_annee NUMBER;
        l_datesaisie NUMBER;
        l_mois NUMBER;

 	l_user		ligne_bip_logs.user_log%TYPE;
 	-- Valeurs précédentes pour les logs
 	l_topfer	ligne_bip.topfer%TYPE;
 	l_astatut	ligne_bip.astatut%TYPE;
 	l_adatestatut	ligne_bip.adatestatut%TYPE;

   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      l_user := SUBSTR(pack_global.lire_globaldata(p_userid).idarpege, 1, 30);

      -- On récupère les valeurs précédentes pour les logs
      SELECT topfer, astatut, adatestatut
      INTO l_topfer, l_astatut, l_adatestatut
      FROM ligne_bip
      WHERE pid=p_pid
      AND flaglock = p_flaglock;

	--
	-- RG 06/10/199 : la date du statut est obligatoire si statut différent de 'en cours',
	-- IF ( (p_astatut!='E') AND (p_adatestatut IS NULL) ) THEN
	-- FE 27 => RG1 : 	la date du statut est obligatoire si :
	--				statut différent de 'a immobiliser'
	--			   ET statut différent de 'non amortissable'
	--			   ET statut différent de 'en cours'
	--
	IF ( (p_adatestatut IS NULL) AND (p_astatut!='O') AND (p_astatut!='N') AND (p_astatut!='E') ) THEN
         pack_global.recuperer_message(20002, NULL, NULL, 'ADATESTATUT', l_msg);
         raise_application_error( -20002, l_msg );
	END IF;

	--
	--  la date est obligatoire si top_fermeture est égal à OUI,
	--

	IF ( (p_adatestatut IS NULL) AND (p_top ='O')) THEN
         pack_global.recuperer_message(20004, NULL, NULL, 'ADATESTATUT', l_msg);
         raise_application_error( -20004, l_msg );
	END IF;


	--
	-- RG 06/10/199 : la date du statut ne doit pas être saisie si statut égal à 'en cours' et top fermeture égal à 'non'
	-- IF ( (p_astatut='E') AND  (p_topfer='N') AND (p_adatestatut IS NOT NULL) ) THEN
	-- FE 27 => RG2 : 	la date du statut ne doit pas être saisie si
	--				statut égal à 'a immobiliser'
	--			   OU statut égal à 'non amortissable'
	--			   OU statut égal à 'en cours'
	--
	IF ( (p_adatestatut IS NOT NULL) AND ( (p_astatut='O') OR (p_astatut='N') OR (p_astatut='E') )AND  (p_top='N') )
		 THEN
         pack_global.recuperer_message(20005, NULL, NULL, 'ADATESTATUT', l_msg);
         raise_application_error( -20005, l_msg );
	END IF;

	--controle de saisie de la DATE de statut d'une ligne bip
	IF p_adatestatut IS NOT NULL THEN

		l_datesaisie := TO_NUMBER(substr(p_adatestatut,4,4) || substr(p_adatestatut,0,2));
		l_annee := TO_NUMBER (to_char(SYSDATE,'yyyy'));
		l_mois :=TO_NUMBER (to_char(SYSDATE,'mm'));

		IF l_mois BETWEEN 01 AND 06 THEN
			IF l_datesaisie > (l_annee ||0||5) THEN
			--anticipation sur les dates est interdite
			pack_global.recuperer_message(20924,NULL,NULL,'ADATESTATUT',l_msg);
			raise_application_error( -20924, l_msg );
			END IF;
		ELSE  -- DATE comprise entre juillet et decembre
			IF l_datesaisie > (l_annee ||11) THEN
			--anticipation sur les dates est interdite
			pack_global.recuperer_message(20924,NULL,NULL,'ADATESTATUT',l_msg);
			raise_application_error( -20924, l_msg );
			END IF;
		END IF;
	END IF;


      BEGIN
         UPDATE ligne_bip
         SET astatut     = decode(p_astatut, 'E', NULL, p_astatut),
	     topfer     = p_topfer,
             adatestatut = TO_DATE(p_adatestatut, 'MM/YYYY'),
             flaglock    = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE  pid = p_pid
         AND flaglock = p_flaglock;

         -- On loggue le type, la typologie, le CA payeur, le topfer, le statut, la date de statut
         pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'Top fermeture', l_topfer, p_topfer, 'MAJ statut de la ligne BIP via dirmenu');
         pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'Statut', l_astatut, p_astatut, 'MAJ statut de la ligne BIP via dirmenu');
         pack_ligne_bip.maj_ligne_bip_logs(p_pid, l_user, 'Date statut', TO_CHAR(l_adatestatut, 'MM/YYYY'), p_adatestatut, 'MAJ statut de la ligne BIP via dirmenu');

	 --Audit
	 audit(p_pid, p_date_demande, p_demandeur, p_commentaire, p_message);

      EXCEPTION

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN
         pack_global.recuperer_message(20999,NULL, NULL, NULL, l_msg);
         raise_application_error( -20999, l_msg );
      ELSE
        pack_global.recuperer_message(2065, '%s1', p_pid, NULL, l_msg);
        p_message := l_msg;
     END IF;

END confirm_st_amort;



   PROCEDURE select_st_amort (p_pid         IN ligne_bip.pid%TYPE,
                              p_userid      IN VARCHAR2,
                              p_curst_amort IN OUT st_amortCurType,
                              p_date        OUT VARCHAR2,
                              p_filsigle    OUT VARCHAR2,
                              p_nbcurseur   OUT INTEGER,
                              p_message     OUT VARCHAR2
                             ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Recuperation de FILCODE dans la table client_mo.

      BEGIN
         SELECT filsigle
         INTO   p_filsigle
         FROM   filiale_cli
         WHERE  filcode IN (
                            SELECT filcode
                            FROM   client_mo
                            WHERE  clicode IN (
                                               SELECT clicode
                                               FROM ligne_bip
                                               WHERE pid = p_pid
                                              )
                           );

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             NULL;

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);

      END;

       BEGIN
         SELECT TO_CHAR(SYSDATE,'mm/yyyy')
         INTO   p_date
         FROM   dual
         ;

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             NULL;

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);

      END;


      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curst_amort FOR
              SELECT 	l.pid,
                 	l.pnom,
                     	l.typproj,
                     	l.astatut,
                     	l.topfer,
                   	TO_CHAR(l.adatestatut,'mm/yyyy') ,
                   	l.flaglock,
  	       		TO_CHAR(a.date_demande,'dd/mm/yyyy') ,
		 		a.demandeur ,
		 		a.commentaire
              FROM ligne_bip l, audit_statut a
              WHERE l.pid=a.pid(+)
	   	  AND l.pid = p_pid;

      EXCEPTION
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'n''existe pas';

      pack_global.recuperer_message(5010, NULL, NULL, NULL, l_msg);
      p_message := l_msg;

   END select_st_amort;


PROCEDURE select_st_amortges (p_pid            IN ligne_bip.pid%TYPE,
                              p_userid         IN VARCHAR2,
                              p_curst_amortges IN OUT st_amortgesCurType,
                              p_filsigle    	  OUT VARCHAR2,
                              p_nbcurseur 	  OUT INTEGER,
                              p_message   	  OUT VARCHAR2
                             ) IS

      l_msg VARCHAR2(1024);

   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Recuperation de FILCODE dans la table client_mo.

      BEGIN
         SELECT filsigle
         INTO   p_filsigle
         FROM   filiale_cli
         WHERE  filcode IN (
                            SELECT filcode
                            FROM   client_mo
                            WHERE  clicode IN (
                                               SELECT clicode
                                               FROM ligne_bip
                                               WHERE pid = p_pid
                                              )
                           );

      EXCEPTION

         WHEN NO_DATA_FOUND THEN
             NULL;

         WHEN OTHERS THEN
            raise_application_error( -20997, SQLERRM);

      END;


      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      BEGIN
         OPEN p_curst_amortges FOR
              SELECT lb.pid,
                     lb.pnom,
                     DECODE(lb.astatut, NULL, 'Pas de statut', cs.libstatut),
                     TO_CHAR(lb.adatestatut,'mm/yyyy'),
                     lb.flaglock
              FROM ligne_bip lb,code_statut cs
              WHERE lb.pid = p_pid
	      AND lb.astatut = cs.astatut (+);

      EXCEPTION
         WHEN OTHERS THEN
             raise_application_error(-20997,SQLERRM);
      END;

      -- en cas absence
      -- p_message := 'n''existe pas';

      pack_global.recuperer_message(5010, NULL, NULL, NULL, l_msg);
      p_message := l_msg;

   END select_st_amortges;

PROCEDURE audit ( p_pid            IN ligne_bip.pid%TYPE,
		  		  p_date_demande   IN VARCHAR2,
				  p_demandeur	   IN audit_statut.demandeur%TYPE,
				  p_commentaire	   IN audit_statut.commentaire	%TYPE,
				  p_message     OUT VARCHAR2) IS
l_msg VARCHAR2(1024);
out_of_stock    EXCEPTION;
l_length_commentaire  NUMBER(4);
l_exist NUMBER(1);
BEGIN
	--Si l'un des 3 champs est renseigné
	IF ((p_date_demande is not null) or (p_demandeur is not null) or (p_commentaire is not null)) THEN
	        IF (p_commentaire is not null) THEN
			BEGIN
				l_length_commentaire := length(p_commentaire);
				IF (l_length_commentaire > 150) THEN
		            		RAISE out_of_stock;
		       	 	END IF;
			EXCEPTION
				WHEN out_of_stock THEN
					pack_global.recuperer_message(20380,NULL,NULL,'commentaire',l_msg);
					raise_application_error( -20380, l_msg );
		 	END;
		END IF;
		BEGIN
			UPDATE audit_statut
			SET 	date_demande = TO_DATE(p_date_demande,'DD/MM/YYYY'),
				demandeur=p_demandeur,
				commentaire=p_commentaire
			WHERE  pid = p_pid;
		EXCEPTION
		       	WHEN OTHERS THEN
		            	raise_application_error(-20997, SQLERRM);
		END;
		IF SQL%NOTFOUND THEN
			--la ligne n'existe pas, on l'insère dans la table
			INSERT INTO audit_statut (pid,date_demande,demandeur,commentaire)
			VALUES (p_pid,TO_DATE(p_date_demande,'DD/MM/YYYY'),p_demandeur,p_commentaire);
	  	END IF;
	ELSE
		BEGIN
			SELECT count(1) into l_exist
			FROM audit_statut
			WHERE  pid = p_pid;

			IF l_exist=1 THEN
				DELETE audit_statut WHERE  pid = p_pid;
			END IF;

		END;
	END IF;
		p_message := l_msg;


END audit;

END pack_st_amort;
/
CREATE OR REPLACE PACKAGE pack_suivijhr AS


PROCEDURE alim12_suivijhr;
PROCEDURE alim_suivijhr;
PROCEDURE alim_histo_suivijhr;

END  pack_suivijhr;
/

CREATE OR REPLACE PACKAGE BODY pack_suivijhr AS

PROCEDURE alim12_suivijhr IS

BEGIN
	-- cette procédure est à lancer en fin de première prémensuelle

	-- on delete ce qu'il y a dans la table suivijhr
	DELETE  FROM suivijhr;
	COMMIT;

	-- on copie les données de la table histo_suivijhr pour le mois -1 et -2 dans la table suivijhr
	INSERT INTO suivijhr (DPG,PRODM2,PRODM1,PROD,ABSM1,ABS)
	(SELECT codsg,
		consmois_2,
		consmois_1,
		NULL,
		absmois_1,
		NULL
	FROM histo_suivijhr
	);

	COMMIT;

END alim12_suivijhr;


PROCEDURE alim_suivijhr IS

BEGIN

	-- cette procédure est à lancer en fin de chaque traitement de mensuelle (1,2,3)

	-- insérer ligne existante dans proplus pour le mois de mensuelle et non existante dans suivijhr
	INSERT INTO suivijhr (DPG,PRODM2,PRODM1,PROD,ABSM1,ABS)
	(SELECT divsecgrou,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
	FROM proplus,datdebex
	WHERE cdeb = moismens
	AND NOT EXISTS (SELECT dpg FROM suivijhr
			WHERE dpg = proplus.divsecgrou)
	GROUP BY divsecgrou);


	-- on update le productif du mois courant par ce qui a été remonté au traitement mensuel

	UPDATE suivijhr SET PROD =(	SELECT sum(cusag)
					FROM proplus,datdebex
					WHERE cdeb = moismens
					AND factpty <>  '7'
					AND suivijhr.dpg = proplus.divsecgrou
					GROUP BY divsecgrou );

	COMMIT;


	-- on update l'autre champ du mois de mensuelle : le champ contenant les absences

	UPDATE suivijhr SET ABS =(	SELECT sum(cusag)
					FROM proplus,datdebex
					WHERE cdeb = moismens
					AND factpty =  '7'
					AND suivijhr.dpg = proplus.divsecgrou
					GROUP BY divsecgrou );

	COMMIT;




END alim_suivijhr;

PROCEDURE alim_histo_suivijhr IS

BEGIN
	-- cette procédure est à lancer en fin de mensuelle
	-- elle met à jour la table histo_suivijhr

	-- on copie ce qu'il y a dans la colonne consmois_1 dans consmois_2
	UPDATE histo_suivijhr SET consmois_2 = consmois_1;


	--on insère les nouvelles lignes ,créées dans la table suivijhr, dans la table histo_suivijhr
	INSERT INTO histo_suivijhr (CODSG,CONSMOIS_2,CONSMOIS_1,ABSMOIS_1)
	(SELECT dpg,
		NULL,
		NULL,
		NULL
	FROM suivijhr
	WHERE NOT EXISTS (SELECT codsg FROM histo_suivijhr
			WHERE codsg = suivijhr.dpg));


	-- on copie les données prod et abs de la table suivijhr (données du mois de mensuelle)
	-- dans la table histo_suivijhr dans consmois_1 et absmois_1
	UPDATE histo_suivijhr SET consmois_1 = (select prod from suivijhr
						WHERE histo_suivijhr.codsg = suivijhr.dpg),
				  absmois_1 = (select abs from suivijhr
						WHERE histo_suivijhr.codsg = suivijhr.dpg);


	COMMIT;

	-- on delete les lignes dont tous les champs sont à NULL
	DELETE FROM histo_suivijhr
	WHERE consmois_2 IS NULL
	AND consmois_1 IS NULL
	AND absmois_1 IS NULL;

	COMMIT;

END alim_histo_suivijhr;


END pack_suivijhr;
/
CREATE OR REPLACE PACKAGE     pack_suivi_investissement AS


  TYPE liste_centre_activite IS RECORD ( codcamo  VARCHAR2(5),
                                      libelle  VARCHAR2(30),
                                      niveau   CHAR(1)
                                      );



  TYPE liste_ca IS REF CURSOR RETURN liste_centre_activite;

   -- definition d'un enregistrement de la table ligne_bip pour la gestion  des entetes

  TYPE ligne_inv_m_ViewType IS RECORD (
                                     codinv      CHAR(3),
  				     annee       VARCHAR2(4),
  				     codcamo     VARCHAR2(5),
  				     type        VARCHAR2(4),
  				     icpi        VARCHAR2(5),
  				     dpcode      VARCHAR2(5),
  				     libelle     VARCHAR2(25),
  				     quantite    ligne_investissement.quantite%TYPE,
  				     demande     VARCHAR2(7),
  				     notifie     VARCHAR2(7),
  				     engage      VARCHAR2(7),
  				     re_estime   VARCHAR2(7),
  				     realise     VARCHAR2(7),
  				     disponible  VARCHAR2(7),
  				     cominv  	VARCHAR2(200),
  				     toprp  	CHAR(1),
  				     flaglock    ligne_investissement.flaglock%TYPE,
                                     clibca      centre_activite.clibca%TYPE,
  				     lib_type    investissements.lib_type%TYPE,
  				     plib        proj_info.ilibel%TYPE,
  				     dplib       dossier_projet.dplib%TYPE
					);

  TYPE ligne_rea_m_ViewType IS RECORD (codrea           CHAR(2),
  				     codinv           VARCHAR2(3),
  				     annee            CHAR(4),
  				     codcamo          CHAR(5),
  				     num_cmd          VARCHAR2(8),
  				     type_cmd         VARCHAR2(16),
  				     marque           VARCHAR2(16),
  				     modele           VARCHAR2(16),
  				     comrea        VARCHAR2(200),
  				     date_saisie      CHAR(10),
  				     engage           VARCHAR2(8),
  				     type_eng         VARCHAR2(16),
  				     type_ligne		VARCHAR2(64), --new
  				     projet		VARCHAR2(5), --new
  				     dossier_projet   	VARCHAR2(35), --new
  				     disponible  	VARCHAR2(7),
  				     disponible_htr  VARCHAR2(7),--kha 09/04
  				     flaglock         INT,
                     clibca      centre_activite.clibca%type
                                    );

   TYPE ca_niveau0_ViewType IS RECORD (codcamo          CHAR(5));


   -- définition du curseur sur la table ligne_bip pour la gestion de l'entete du projet

   TYPE ligneInvCurType IS REF CURSOR RETURN ligne_inv_m_ViewType;

   TYPE ligneReaCurType IS REF CURSOR RETURN ligne_rea_m_ViewType;

   TYPE CANiveauZeroCurType IS REF CURSOR RETURN ca_niveau0_ViewType;

   PROCEDURE select_ligne_inv_c ( p_codcamo          IN CHAR,
                                  p_annee       IN CHAR,
                                  p_codinv OUT VARCHAR2,
                                  p_clibca      OUT VARCHAR2);

   PROCEDURE select_ligne_rea_c ( p_codinv      IN CHAR,
                                  p_codcamo     IN CHAR,
                                  p_annee       IN CHAR,
                                  p_codrea      OUT VARCHAR2,
                                  p_clibca      OUT VARCHAR2,
                                  p_type_ligne	OUT VARCHAR2,
                                  p_projet		OUT VARCHAR2,
                                  p_dossier_projet OUT VARCHAR2,
                                  p_disponible	OUT VARCHAR2,
                                  p_disponible_htr	OUT VARCHAR2,
                                  p_message     OUT VARCHAR2);

   PROCEDURE select_ligne_rea_m ( p_codrea      IN VARCHAR2,
                                  p_codinv      IN CHAR,
                                  p_codcamo     IN CHAR,
                                  p_annee       IN CHAR,
                                  p_curLigneRea IN OUT ligneReaCurType,
                                  p_userid      IN  VARCHAR2,
                                  p_message     OUT VARCHAR2);

   PROCEDURE select_ligne_inv_m (p_mode        IN  VARCHAR2,
   				 p_codinv    IN CHAR,
                                p_codcamo          IN CHAR,
                                p_annee       IN CHAR,
                                p_curLigneInv IN OUT ligneInvCurType,
                                p_userid     IN  VARCHAR2,
                                p_message     OUT VARCHAR2
                              );


   PROCEDURE insert_ligne_inv (
			       p_codinv       	IN CHAR,
			       p_annee     	    IN CHAR,
                               p_codcamo        	    IN CHAR,
                               p_type    	    IN CHAR,
			       p_pcode 		    IN CHAR,
                               p_dpcode    	    IN CHAR,
                               p_libelle       	IN VARCHAR2,
 			       p_quantite       IN VARCHAR2,
                               p_demande      	IN VARCHAR2,
                               p_notifie       	IN VARCHAR2,
                               --p_engage    	    IN VARCHAR2,
                               p_re_estime    	IN VARCHAR2,
                               --p_disponible   	IN VARCHAR2,
                               p_cominv   	IN VARCHAR2,
                               p_toprp   	IN CHAR,
                               p_message    	OUT VARCHAR2
                              );

   PROCEDURE insert_ligne_rea (
			        p_codrea           IN VARCHAR2,
  				p_codinv           IN VARCHAR2,
  				p_annee            IN VARCHAR2,
  				p_codcamo          IN VARCHAR2,
                                p_type_cmd         IN VARCHAR2,
  				p_num_cmd           IN VARCHAR2,
  				p_marque           IN VARCHAR2,
  				p_modele           IN VARCHAR2,
  				p_comrea        IN VARCHAR2,
  				p_date_saisie      IN VARCHAR2,
  				p_engage           IN VARCHAR2,
  				p_type_eng         IN VARCHAR2,
  				p_flaglock         IN INT,
                                p_message    	     OUT VARCHAR2
                              );

   PROCEDURE update_ligne_rea ( p_codrea           IN VARCHAR2,
  				              p_codinv           IN VARCHAR2,
  				              p_annee            IN VARCHAR2,
  				              p_codcamo          IN VARCHAR2,
                              		      p_type_cmd         IN VARCHAR2,
  				              p_num_cmd           IN VARCHAR2,
  				              p_marque           IN VARCHAR2,
  				              p_modele           IN VARCHAR2,
  				              p_comrea        IN VARCHAR2,
  				              p_date_saisie      IN VARCHAR2,
  				              p_engage           IN VARCHAR2,
  				              p_type_eng         IN VARCHAR2,
  				              p_flaglock         IN INT,
                              		      p_message    	     OUT VARCHAR2
                              );

    PROCEDURE delete_ligne_rea ( p_codrea           IN VARCHAR2,
  				 p_codinv           IN VARCHAR2,
  				 p_annee            IN VARCHAR2,
  				 p_codcamo          IN VARCHAR2,
                                 p_flaglock  IN NUMBER,
                                 p_message     OUT VARCHAR2);

   PROCEDURE update_ligne_inv ( p_codinv       	IN VARCHAR2,
			        p_annee     	IN VARCHAR2,
                               p_codcamo        IN VARCHAR2,
                               p_type    	IN VARCHAR2,
			       p_pcode 		IN VARCHAR2,
                               p_dpcode    	IN VARCHAR2,
                               p_libelle       	IN VARCHAR2,
 			       p_quantite       IN VARCHAR2,
                               p_demande      	IN VARCHAR2,
                               p_notifie       	IN VARCHAR2,
                               p_re_estime    	IN VARCHAR2,
                               p_cominv    	IN VARCHAR2,
                               p_toprp    	IN CHAR,
                               p_flaglock    	IN NUMBER,
                               p_message    	OUT VARCHAR2
                              );

    PROCEDURE delete_ligne_inv ( p_codinv      IN CHAR,
                                 p_codcamo          IN CHAR,
                                 p_annee       IN CHAR,
                                 p_flaglock  IN NUMBER,
                                 p_message     OUT VARCHAR2);

    PROCEDURE notifier_centre_activite (
                                 p_codcamo          IN VARCHAR2,
                                 p_niveau      IN VARCHAR2,
                                 p_annee       IN VARCHAR2,
                                 p_flaglock    	IN NUMBER,
                                 p_message     OUT VARCHAR2);

    PROCEDURE liste_globale_ca(p_codcamo in varchar2,
                               p_curseur out liste_ca,
                               p_niveau out varchar2,
                               p_mesage out varchar2);

    PROCEDURE liste_niveau0_ca(p_codcamo in number,
                               p_curseur out liste_ca,
                               p_mesage out varchar2);

    FUNCTION sum_realises(p_codinv IN number,
                          p_codcamo IN number,
                          p_annee IN varchar2)
    RETURN NUMBER;

    FUNCTION sum_realises_htr(p_codinv IN number,
                          p_codcamo IN number,
                          p_annee IN varchar2)
    RETURN NUMBER;

    FUNCTION cherche_tva(p_datetva IN varchar2)
    RETURN NUMBER;

    FUNCTION cherche_date_exercice
    RETURN DATE;

    FUNCTION recherche_niveau(p_codcamo IN varchar2)
    RETURN NUMBER;



END pack_suivi_investissement;
/

CREATE OR REPLACE PACKAGE BODY     pack_suivi_investissement AS

  PROCEDURE liste_niveau0_ca(p_codcamo in number,
                             p_curseur out liste_ca,
                             p_mesage out varchar2)
  is

  cursor ca_cur is
  select niveau
  from entite_structure where codcamo=p_codcamo;

  begin
       p_mesage := '';
       for ca_rec in ca_cur loop

        if(ca_rec.niveau = 0)then

            open p_curseur for
            select ca.codcamo, clibca, 0 as niveau
            from centre_activite ca, entite_structure es
            where
            ca.codcamo=p_codcamo
            and ca.codcamo=es.codcamo;

        elsif(ca_rec.niveau = 1)then

            open p_curseur for
            select ca.codcamo, clibca, 0 as niveau
            from centre_activite ca, entite_structure es
            where
            caniv1=p_codcamo
            and ca.codcamo=es.codcamo;

        elsif(ca_rec.niveau = 2) then

          open p_curseur for
              select ca.codcamo, clibca, 0 as niveau
              from centre_activite ca, entite_structure es
              where
              caniv2=p_codcamo
              and ca.codcamo=es.codcamo;

        elsif(ca_rec.niveau = 3) then

              open p_curseur for
              select ca.codcamo, clibca, 0 as niveau
              from centre_activite ca, entite_structure es
              where
              caniv3=p_codcamo
              and ca.codcamo=es.codcamo;

        elsif(ca_rec.niveau = 4) then

              open p_curseur for
              select ca.codcamo, clibca, 0 as niveau
              from centre_activite ca, entite_structure es
              where
              caniv4=p_codcamo
              and ca.codcamo=es.codcamo;
        end if;
       end loop;

       exception when others then
       raise_application_error(to_char(sqlcode), sqlerrm);

  end liste_niveau0_ca;


  PROCEDURE liste_globale_ca(p_codcamo in varchar2,
                             p_curseur out liste_ca,
                             p_niveau out varchar2,
                             p_mesage out varchar2)
  is

	cursor ca_cur is
  	select codcamo, liloes, niveau
  	from entite_structure where codcamo=p_codcamo;


	begin
	p_mesage := '';

 	if p_codcamo <> 'TOUS' then
       		for ca_rec in ca_cur loop

        		if(ca_rec.niveau = 0)then

            		open p_curseur for
            		select ca.codcamo, clibca, 0 as niveau
            		from centre_activite ca, entite_structure es
            		where
            		ca.codcamo=p_codcamo
            		and ca.codcamo=es.codcamo;
            		p_niveau := 0;

 	       elsif(ca_rec.niveau = 1)then

            open p_curseur for
            select ca.codcamo, clibca, 0 as niveau       --toue les ca de niveau 0
            from centre_activite ca, entite_structure es
            where
            caniv1=p_codcamo
            and caniv1=es.codcamo
            UNION
            select codcamo, liloes, niveau
            from entite_structure
            where
            codcamo=p_codcamo;
            p_niveau := 1;

        elsif(ca_rec.niveau = 2) then

          open p_curseur for
              select ca.codcamo, clibca, 0 as niveau       --tous les ca de niveau 0
              from centre_activite ca, entite_structure es
              where
              caniv2=p_codcamo
              and caniv2=es.codcamo
              UNION
              select distinct caniv1, liloes, niveau     --tous les ca de niveau 1
              from entite_structure es, centre_activite ca
              where
              caniv2=p_codcamo and
              es.codcamo=caniv1
              UNION
              select codcamo, liloes, niveau              -- le ca de niveau 2
              from entite_structure
              where
              codcamo=p_codcamo;
              p_niveau := 2;

        elsif(ca_rec.niveau = 3) then

              open p_curseur for --tous le ca de niveau 0
              select ca.codcamo, clibca, 0 as niveau       --toue les ca de niveau 0
              from centre_activite ca, entite_structure es
              where
              caniv3=p_codcamo
              and caniv3=es.codcamo
              UNION           --tous le ca de niveau 1
              select distinct caniv1, liloes, niveau
              from entite_structure es, centre_activite ca
              where
              caniv3=p_codcamo and
              es.codcamo=caniv1
              UNION              --tous le ca de niveau 2
              select distinct caniv2, liloes, niveau
              from entite_structure es, centre_activite ca
              where
              caniv3=p_codcamo and
              es.codcamo=caniv2
              UNION              --le ca de niveau 3
              select codcamo, liloes, niveau
              from entite_structure
              where
              codcamo=p_codcamo;
              p_niveau := 3;

        elsif(ca_rec.niveau = 4) then

              open p_curseur for --tous le ca de niveau 0
              select ca.codcamo, clibca, 0 as niveau
              from centre_activite ca, entite_structure es
              where
              caniv4=p_codcamo
              and caniv4=es.codcamo
              UNION           --tous le ca de niveau 1
              select distinct caniv1, liloes, niveau
              from entite_structure es, centre_activite ca
              where
              caniv4=p_codcamo and
              es.codcamo=caniv1
              UNION              --tous le ca de niveau 2
              select distinct caniv2, liloes, niveau
              from entite_structure es, centre_activite ca
              where
              caniv4=p_codcamo and
              es.codcamo=caniv2
              UNION              --tous le ca de niveau 3
              select distinct caniv3, liloes, niveau
              from entite_structure es, centre_activite ca
              where
              caniv4=p_codcamo and
              es.codcamo=caniv3
              UNION              --le ca de niveau 3
              select codcamo, liloes, niveau
              from entite_structure
              where
              codcamo=p_codcamo;
              p_niveau := 4;

        end if;
       end loop;
else
	open p_curseur for
            		select distinct ca.codcamo, clibca, 0 as niveau
            		from centre_activite ca
            		order by ca.codcamo;
       end if;
       exception when others then
       raise_application_error(to_char(sqlcode), sqlerrm);



 end liste_globale_ca;

  PROCEDURE select_ligne_inv_c ( p_codcamo     IN CHAR,
                                 p_annee       IN CHAR,
                                 p_codinv      OUT VARCHAR2,
                                 p_clibca      OUT VARCHAR2) IS
  l_msg varchar2(1024);

  BEGIN


         BEGIN
        	 select
             DECODE(max(codinv), null, '001',  TO_CHAR(max(codinv) + 1, 'FM000'))
             into p_codinv
             from ligne_investissement li
             where  li.codcamo  = TO_NUMBER(p_codcamo)
              	 AND annee = TO_NUMBER(p_annee);
             EXCEPTION
             WHEN NO_DATA_FOUND THEN p_codinv := '001';
             WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
         END;


        BEGIN
            select clibca into p_clibca
            from  centre_activite
            where codcamo = TO_NUMBER(p_codcamo);
            EXCEPTION
            /*WHEN NO_DATA_FOUND THEN
            	pack_global.recuperer_message(20969, '%s1', p_codcamo, 'codcamo', p_message);
            	raise_application_error( -20969, p_message);*/
            WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
        END;

        dbms_output.put_line('clibca:' || p_clibca);
        dbms_output.put_line('codinv:' || p_codinv);

  END select_ligne_inv_c;


  PROCEDURE select_ligne_rea_c ( p_codinv      IN CHAR,
                                 p_codcamo     IN CHAR,
                                 p_annee       IN CHAR,
                                 p_codrea      OUT VARCHAR2,
                                 p_clibca      OUT VARCHAR2,
                                 p_type_ligne  OUT VARCHAR2,
                                 p_projet	OUT VARCHAR2,
                                 p_dossier_projet OUT VARCHAR2,
                                 p_disponible	OUT VARCHAR2,
                                 p_disponible_htr OUT VARCHAR2,
                                 p_message     OUT VARCHAR2) IS

   l_msg 		VARCHAR(1024);
   l_codinv 	ligne_investissement.codinv%TYPE;
   l_codcamo 	ligne_investissement.codcamo%TYPE;
   l_annee 	    ligne_investissement.annee%TYPE;
   l_taux       taux_recup.taux%TYPE;
   l_not_tvarecup  ligne_investissement.not_tvarecup%TYPE;

  BEGIN

       p_message := '';

       ------------ Test si la lign correspondant au p_codinv, p_codcamo_, p_annee
       ------------ passes en parametres existe

       IF (p_codinv IS NOT NULL AND p_codcamo IS NOT NULL AND p_annee IS NOT NULL) THEN

           BEGIN

        -- Verifier que le ligne budgetaire existe pour la modification
            SELECT
            	li.codinv,
            	li.codcamo,
            	li.annee,
            	clibca,
            	inv.lib_type,
            	p.ilibel,
            	dp.dplib,
            	lpad(nvl(to_char(li.notifie - pack_suivi_investissement.sum_realises(TO_NUMBER(p_codinv),TO_NUMBER(p_codcamo),TO_NUMBER(p_annee)), 'FM9999999999.00'),'.00'),13,' ') ,
            	lpad(nvl(to_char(li.notifie*decode(not_tvarecup, null,(1+t.tva/100*(1-tr.taux/100)) ,1+not_tvarecup/100) - pack_suivi_investissement.sum_realises_htr(TO_NUMBER(p_codinv),TO_NUMBER(p_codcamo),TO_NUMBER(p_annee)), 'FM9999999999.00'),'.00'),13,' ')
               	INTO
           		l_codinv,
           		l_codcamo,
           		l_annee,
           		p_clibca,
           		p_type_ligne,
           		p_projet,
           		p_dossier_projet,
           		p_disponible,
           		p_disponible_htr
           	FROM
           		ligne_investissement li,
           		investissements inv,
           		dossier_projet dp,
           		centre_activite ca,
           		proj_info p,
           		tva t,
           		taux_recup tr

           	WHERE
           	li.codinv = TO_NUMBER(p_codinv)
           	AND li.codcamo  = TO_NUMBER(p_codcamo)
           	AND li.annee = TO_NUMBER(p_annee)
            AND ca.codcamo = TO_NUMBER(p_codcamo)
            --
            AND li.dpcode = dp.dpcode
            AND li.type = inv.codtype
            --
            AND li.icpi = p.icpi
            --
            AND tr.filcode = ca.filcode
            AND tr.annee = li.annee
            AND t.datetva =(select max(TVA.datetva) from tva where datetva <= pack_suivi_investissement.cherche_date_exercice)
            group by li.codinv,
            	li.codcamo,
            	li.annee,
            	clibca,
            	inv.lib_type,
            	p.ilibel,
            	dp.dplib,
            	li.notifie,
            	not_tvarecup,
            	t.tva,
            	tr.taux;

           EXCEPTION
           	WHEN NO_DATA_FOUND THEN
           	pack_global.recuperer_message(20960, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, 'codinv', l_msg);
           	raise_application_error( -20960, l_msg );
           	WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
           END;

           p_message := l_msg;
       END IF;


       BEGIN
          select
          --DECODE(max(rownum), null, '01',  TO_CHAR(max(rownum) + 1, 'FM00'))
          DECODE(max(codrea), null, '01',  TO_CHAR(max(codrea) + 1, 'FM00'))
          into p_codrea
          from ligne_realisation
          WHERE codinv = TO_NUMBER(p_codinv)
           	    AND codcamo  = TO_NUMBER(p_codcamo)
           	    AND annee = TO_NUMBER(p_annee);

          EXCEPTION
             WHEN NO_DATA_FOUND THEN p_codrea := '01';
             WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
       END;

  END select_ligne_rea_c;

  PROCEDURE select_ligne_rea_m (  p_codrea      IN VARCHAR2,
                                  p_codinv       IN CHAR,
                                  p_codcamo     IN CHAR,
                                  p_annee       IN CHAR,
                                  p_curLigneRea IN OUT ligneReaCurType,
                                  p_userid      IN  VARCHAR2,
                                  p_message     OUT VARCHAR2)
  IS
   l_msg 		VARCHAR(1024);
   l_codinv 	ligne_investissement.codinv%TYPE;
   l_codcamo 	ligne_investissement.codcamo%TYPE;
   l_annee 	    ligne_investissement.annee%TYPE;
   l_codrea 	ligne_realisation.codrea%TYPE;

  BEGIN

       p_message := '';

       ------------ Test si la ligne correspondant au p_codinv, p_codcamo_, p_annee
       ------------ passes en parametres existe

       IF (p_codrea IS NOT NULL AND p_codinv IS NOT NULL AND p_codcamo IS NOT NULL AND p_annee IS NOT NULL) THEN

           BEGIN

           	-- Verifier que le ligne de réalisation existe pour la modification

            SELECT codinv, codcamo, annee, codrea
           	INTO l_codinv, l_codcamo, l_annee, l_codrea
           	FROM ligne_realisation
           	WHERE codinv = TO_NUMBER(p_codinv)
           	AND codcamo  = TO_NUMBER(p_codcamo)
           	AND annee = TO_NUMBER(p_annee)
            AND codrea = TO_NUMBER(p_codrea);

           EXCEPTION
           	WHEN NO_DATA_FOUND THEN
           	--pack_global.recuperer_message(20976, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, 'codinv', p_message);
            pack_global.recuperer_message(20976, '%s1', p_codrea, '%s2', p_codinv, '%s3', p_codcamo, null, p_message);
           	raise_application_error( -20960, p_message);
           	WHEN OTHERS THEN
           	raise_application_error( -20997, SQLERRM);
           END;


       END IF;


       BEGIN
          OPEN p_curLigneRea FOR SELECT
               	       	   lr.codrea,
  		           lr.codinv,
  		           lr.annee,
  			   lr.codcamo,
  			   lr.num_cmd,
  			   lr.type_cmd,
  			   lr.marque,
  			   lr.modele,
  			   decode(lr.comrea, null, '', lr.comrea) as comrea,
  			   lr.date_saisie,
  			   TO_CHAR(lr.engage) as engage,
  			   lr.type_eng,
  			   inv.lib_type,
  			   p.ilibel,
  			   dp.dplib,
  			   lpad(nvl(to_char(li.notifie - pack_suivi_investissement.sum_realises(TO_NUMBER(p_codinv),TO_NUMBER(p_codcamo),TO_NUMBER(p_annee)), 'FM9999999999.00'),'.00'),13,' ') as disponible,
  			   lpad(nvl(to_char(li.notifie*decode(not_tvarecup, null,(1+t.tva/100*(1-tr.taux/100)) ,1+not_tvarecup/100) - pack_suivi_investissement.sum_realises_htr(TO_NUMBER(p_codinv),TO_NUMBER(p_codcamo),TO_NUMBER(p_annee)), 'FM9999999999.00'),'.00'),13,' ') as disponible_htr,
  			   lr.flaglock,
               		    ca.clibca
          from
          	ligne_realisation lr,
          	centre_activite ca,
          	ligne_investissement li,
          	investissements inv,
          	dossier_projet dp,
          	proj_info p,
          	taux_recup tr,
          	tva t
          WHERE lr.codinv = TO_NUMBER(p_codinv)
           	AND lr.codcamo  = TO_NUMBER(p_codcamo)
           	AND lr.annee = TO_NUMBER(p_annee)
                AND lr.codrea = TO_NUMBER(p_codrea)
                AND ca.codcamo =  TO_NUMBER(p_codcamo)
                --
                AND lr.codinv = li.codinv
                AND lr.annee = li.annee
                AND lr.codcamo = li.codcamo
                AND li.dpcode = dp.dpcode
                AND li.type = inv.codtype
                --
            	AND li.icpi = p.icpi
            	--
            	AND tr.filcode = ca.filcode
            	AND tr.annee = li.annee
            	AND t.datetva =(select max(TVA.datetva) from tva where datetva <= TO_DATE(lr.date_saisie, 'DD/MM/YYYY'));
       END;

  END select_ligne_rea_m;


   PROCEDURE select_ligne_inv_m ( p_mode        IN  VARCHAR2,
   				p_codinv       IN CHAR,
                                p_codcamo             IN CHAR,
                                p_annee          IN CHAR,
                                p_curLigneInv    IN OUT ligneInvCurType,
                                p_userid     IN  VARCHAR2,
                                p_message        OUT VARCHAR2
                              ) IS

	l_msg 		VARCHAR(1024);
	l_codinv 	ligne_investissement.codinv%TYPE;
	l_codcamo 	ligne_investissement.codcamo%TYPE;
	l_annee     	ligne_investissement.annee%TYPE;
    	l_icpi      	ligne_investissement.icpi%TYPE;
    	l_dpcode    	ligne_investissement.dpcode%TYPE;
    	l_notifie   	ligne_investissement.notifie%TYPE;
    	l_type      	investissements.codtype%TYPE;
    	l_sousmenus   	VARCHAR2(255);


   BEGIN

    p_message := '';

    -- Récupération des sous menus de l'utilisateur.

    l_sousmenus := pack_global.lire_globaldata(p_userid).sousmenus;

   	--Test si la lign correspondant au p_codinv, p_codcamo_, p_annee
	-- passes en parametres existe

   	IF (p_codinv IS NOT NULL AND p_codcamo IS NOT NULL AND p_annee IS NOT NULL) THEN

		BEGIN

            -- Verifier que le ligne budgetaire existe pour la modification

            SELECT codinv, codcamo, annee,
                   type, icpi, dpcode, notifie
			INTO l_codinv, l_codcamo, l_annee,
                 l_type, l_icpi, l_dpcode, l_notifie
			FROM ligne_investissement
			WHERE codinv = TO_NUMBER(p_codinv)
			AND codcamo  = TO_NUMBER(p_codcamo)
			AND annee = TO_NUMBER(p_annee);

            --vérifier que laligne n'est pas déjà notifiée et que l'utilisateur n'est pas superviseur des investissements
              IF (INSTR(l_sousmenus,'ginv') = 0  AND l_notifie <> 0) THEN

                 pack_global.recuperer_message(20965, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, 'codinv', l_msg);
	         if p_mode = 'delete' then
	         	raise_application_error( -20965, l_msg );
	 	end if;
            END IF;

		    EXCEPTION
 			         WHEN NO_DATA_FOUND THEN
 			         pack_global.recuperer_message(20960, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, 'codinv', l_msg);
 			         raise_application_error( -20960, l_msg );
 			         WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
		END;
		p_message := l_msg;
	END IF;

	OPEN p_curLigneInv FOR SELECT
        	li.codinv,
		li.annee,
		li.codcamo,
		li.type,
		li.icpi,
		li.dpcode,
		li.libelle,
		li.quantite,
		TO_CHAR(li.demande) as demande,
		TO_CHAR(li.notifie) as notifie,
		TO_CHAR(sum(lr.engage)) as engage, --new kha09/04
		TO_CHAR(li.re_estime) as re_estime,
		TO_CHAR(sum(lr.engage)) as realise,
		TO_CHAR(li.notifie - sum(lr.engage)) as disponible, --new kha 09/04
		decode(li.cominv, null, '', li.cominv) as cominv,
		decode(li.toprp, null, '', li.toprp) as toprp,
		li.flaglock,
        	clibca,
        	lib_type,
		ilibel,
		dplib
        FROM  ligne_investissement li,
              ligne_realisation lr,
              centre_activite centre,
              investissements inv,
              proj_info pi,
              dossier_projet dp
         WHERE li.codinv = p_codinv
         AND li.codcamo = p_codcamo
         AND li.annee = p_annee
         AND li.codcamo = centre.codcamo
         AND centre.codcamo = li.codcamo
         AND li.type = inv.codtype
         AND inv.codtype = l_type
         AND li.icpi = pi.icpi
         AND pi.icpi = l_icpi
         AND li.dpcode = dp.dpcode
         AND dp.dpcode = l_dpcode
         -- jointure ligne inv <=> ligne real
         AND li.codinv = lr.codinv(+)
         AND li.annee = lr.annee(+)
         AND li.codcamo = lr.codcamo(+)
         GROUP BY li.codinv,
				li.annee,
				li.codcamo,
				li.type,
				li.icpi,
				li.dpcode,
				li.libelle,
				li.quantite,
				li.demande,
				li.notifie,
				--li.engage, kha 09/04
				li.re_estime,
				--li.disponible, kha 09/04
				li.cominv,
				li.toprp,
				li.flaglock,
		        	clibca,
		        	lib_type,
				ilibel,
				dplib;

   END select_ligne_inv_m;


   PROCEDURE insert_ligne_inv (
   				p_codinv       	IN CHAR,
			       	p_annee     	IN CHAR,
                   		p_codcamo       IN CHAR,
                   		p_type    	IN CHAR,
			       	p_pcode 	IN CHAR,
                   		p_dpcode    	IN CHAR,
                   		p_libelle       IN VARCHAR2,
 			       	p_quantite      IN VARCHAR2,
                   		p_demande      	IN VARCHAR2,
                   		p_notifie       IN VARCHAR2,
                   		--p_engage    	IN VARCHAR2, --kha09/04
                   		p_re_estime    	IN VARCHAR2,
                   		--p_disponible   IN VARCHAR2, --kha09/04
                   		p_cominv   	IN VARCHAR2,
                   		p_toprp   	IN CHAR,
                   		p_message    	OUT VARCHAR2
                              ) IS

 	l_msg 		VARCHAR(1024);
	l_codinv 	ligne_investissement.codinv%TYPE;
	l_codcamo 	ligne_investissement.codcamo%TYPE;
	l_annee 	ligne_investissement.annee%TYPE;

   BEGIN

        BEGIN
            INSERT INTO ligne_investissement (
            codinv,
  	        annee,
            codcamo,
            type,
            icpi,
            dpcode,
            libelle,
            quantite,
            demande,
            notifie,
            --engage,
            re_estime,
            --disponible,
            cominv,
            toprp,
            flaglock,
            not_tvarecup,
            date_modif_re
            )
            VALUES (
            p_codinv,
		    p_annee,
		    p_codcamo,
			p_type,
			p_pcode,
			p_dpcode,
			decode(p_libelle, null, '', p_libelle),
			decode(p_quantite, null, 1, p_quantite),
			decode(p_demande, null, 0, p_demande),
			decode(p_notifie, null, 0, p_notifie),
			--0, --cumul des engagés des realisés
			decode(p_demande, null, 0, p_demande),
			--decode(p_notifie, null, 0, p_notifie), -- disponible = notifie - engagé
		    	decode(p_cominv, null, '', p_cominv),
			decode(p_toprp, null, '', p_toprp),
		    	0,
		    	'',
		    	decode(p_demande, null, '',to_char(pack_suivi_investissement.cherche_date_exercice,'DD/MM/YYYY')));

            --Ligne investissement %s1 pour l''année d''exercice %s2 et le centre d''activité %s3 %s1 créé.

            pack_global.recuperer_message(20961, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, NULL, l_msg);
            p_message := l_msg;

          EXCEPTION

              -- Ne pas intercepter les autres exceptions

            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);

          END;

   END insert_ligne_inv;


   PROCEDURE insert_ligne_rea (
			                  p_codrea           IN VARCHAR2,
  				              p_codinv           IN VARCHAR2,
  				              p_annee            IN VARCHAR2,
  				              p_codcamo          IN VARCHAR2,
                              		      p_type_cmd         IN VARCHAR2,
  				              p_num_cmd          IN VARCHAR2,
  				              p_marque           IN VARCHAR2,
  				              p_modele           IN VARCHAR2,
  				              p_comrea        IN VARCHAR2,
  				              p_date_saisie      IN VARCHAR2,
  				              p_engage           IN VARCHAR2,
  				              p_type_eng         IN VARCHAR2,
  				              p_flaglock         IN INT,
                              		      p_message    	     OUT VARCHAR2

                              ) IS

 	msg 		VARCHAR(1024);
	l_codinv 	ligne_investissement.codinv%TYPE;
	l_ca 		ligne_investissement.codcamo%TYPE;
	l_annee 	ligne_investissement.annee%TYPE;
    l_msg VARCHAR2(1024);
 --   l_engage ligne_realisation.engage%TYPE;
 --   l_disponible ligne_investissement.disponible%TYPE;
    l_notifie ligne_investissement.notifie%TYPE;

   BEGIN

   p_message := '';

   	BEGIN
            INSERT INTO ligne_realisation (
                   codrea,
                   codinv,
		   annee,
		   codcamo,
                   type_cmd,
		   num_cmd,
		   marque,
		   modele,
		   comrea,
		   date_saisie,
                   engage,
		   type_eng,
		   flaglock)
            VALUES ( p_codrea,
                     p_codinv,
                     p_annee,
                     p_codcamo,
                     decode(p_type_cmd, null, '', p_type_cmd),
                     decode(p_num_cmd, null, '', p_num_cmd),
                     decode(p_marque, null, '', p_marque),
                     decode(p_modele, null, '', p_modele),
                     decode(p_comrea, null, '', p_comrea),
                     decode(p_date_saisie, null, TO_CHAR(pack_suivi_investissement.cherche_date_exercice, 'DD/MM/YYYY'), p_date_saisie),
                     decode(p_engage, null, 0, p_engage),
                     decode(p_type_eng, null, '', p_type_eng),
		    	     0);

                     pack_global.recuperer_message(20964, '%s1', p_codrea, '%s2', p_codinv, NULL, l_msg);
                     p_message := l_msg;

          EXCEPTION

              -- Ne pas intercepter les autres exceptions

            WHEN OTHERS THEN
               raise_application_error( -20997, SQLERRM);

          END;

          --maj dans ligne d'investissement du montant ENGAGE et DISPONIBLE
--kha 09/04 engagé et disponible des lignes investissement ne sont plus utilisés
   	--BEGIN
   	--	select nvl(notifie,0) into l_notifie
   	--	from ligne_investissement where
   	--	codcamo=p_codcamo
   	--	and codinv=p_codinv
   	--	and annee=to_number(p_annee);

   	--l_engage := sum_realises(p_codinv, p_codcamo, p_annee);
   	--l_disponible := l_notifie - l_engage;

	--UPDATE ligne_investissement
	--SET engage=nvl(l_engage,0),
	--	disponible=nvl(l_disponible,0)
	--WHERE	codinv = TO_NUMBER(p_codinv)
        --    AND codcamo  = TO_NUMBER(p_codcamo)
        --    AND annee = TO_NUMBER(p_annee)
        --    ;
	--EXCEPTION
              -- Ne pas intercepter les autres exceptions
        --    WHEN OTHERS THEN
        --       raise_application_error( -20997, SQLERRM);
	--END;

   END insert_ligne_rea;

   PROCEDURE update_ligne_rea ( p_codrea           IN VARCHAR2,
  				              p_codinv           IN VARCHAR2,
  				              p_annee            IN VARCHAR2,
  				              p_codcamo          IN VARCHAR2,
                              		      p_type_cmd         IN VARCHAR2,
  				              p_num_cmd           IN VARCHAR2,
  				              p_marque           IN VARCHAR2,
  				              p_modele           IN VARCHAR2,
  				              p_comrea        IN VARCHAR2,
  				              p_date_saisie      IN VARCHAR2,
  				              p_engage           IN VARCHAR2,
  				              p_type_eng         IN VARCHAR2,
  				              p_flaglock         IN INT,
                              		      p_message    	     OUT VARCHAR2
                              )IS

    l_msg 		VARCHAR(1024);
    l_codinv 	ligne_investissement.codinv%TYPE;
	l_codcamo 	ligne_investissement.codcamo%TYPE;
	l_annee 	ligne_investissement.annee%TYPE;
    l_codrea 	ligne_realisation.codrea%TYPE;
  --  l_engage ligne_investissement.engage%TYPE;
   -- l_disponible ligne_investissement.disponible%TYPE;
    l_notifie ligne_investissement.notifie%TYPE;

    BEGIN

           IF (p_codrea IS NOT NULL AND p_codinv IS NOT NULL AND p_codcamo IS NOT NULL AND p_annee IS NOT NULL) THEN

              BEGIN

              	-- Verifier que le ligne de réalisation existe

              SELECT codinv, codcamo, annee, codrea
              INTO l_codinv, l_codcamo, l_annee, l_codrea
              FROM ligne_realisation WHERE codinv = TO_NUMBER(p_codinv)
              AND codcamo  = TO_NUMBER(p_codcamo)
              AND annee = TO_NUMBER(p_annee)
              AND codrea = TO_NUMBER(p_codrea);

              EXCEPTION
              	WHEN NO_DATA_FOUND THEN
                     pack_global.recuperer_message(20976, '%s1', p_codrea, '%s2', p_codinv, '%s3', p_codcamo, null, p_message);
              	     raise_application_error( -20976, p_message);
              	WHEN OTHERS THEN
              	     raise_application_error( -20997, SQLERRM);
              END;


          END IF;

          BEGIN

            UPDATE ligne_realisation SET
		        type_cmd    = p_type_cmd,
		        type_eng    = p_type_eng,
  			num_cmd     = p_num_cmd,
  			marque      = p_marque,
  			modele      = p_modele,
                	comrea   = decode(p_comrea, null, '', p_comrea),
                	date_saisie = p_date_saisie,
                	engage	    = TO_NUMBER(p_engage),
                	flaglock    = decode(p_flaglock, 1000000, 0, p_flaglock + 1)
            WHERE
            codrea  = TO_NUMBER(p_codrea)
            AND codinv = TO_NUMBER(p_codinv)
            AND codcamo  = TO_NUMBER(p_codcamo)
            AND annee = TO_NUMBER(p_annee)
            AND flaglock = p_flaglock;

            IF SQL%NOTFOUND THEN
               -- 'Accès concurrent'
               pack_global.recuperer_message( 20999, NULL, NULL, NULL, p_message);
               raise_application_error( -20999, p_message);
            ELSE
                --'Ligne de réalisation numéro %s1 associée à la ligne d''investissement %s2 et le centre d''activité %s3 modifiée
                pack_global.recuperer_message(20974, '%s1', p_codrea, '%s2', p_codinv, '%s3', p_codcamo, NULL, p_message);
            END IF;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20999, SQLERRM);
         END;
--kha 09/04 engagé et disponible des lignes investissement ne sont plus utilisés

         --maj dans ligne d'investissement du montant ENGAGE et DISPONIBLE

   	--BEGIN
   	--	select nvl(notifie,0) into l_notifie
   	--	from ligne_investissement where
   	--	codcamo=p_codcamo
   	--	and codinv=p_codinv
   	--	and annee=to_number(p_annee);

   	--l_engage := sum_realises(p_codinv, p_codcamo, p_annee);
   	--l_disponible := l_notifie - l_engage;

	--UPDATE ligne_investissement
	--SET engage=nvl(l_engage,0),
	--	disponible=nvl(l_disponible,0)
	--WHERE	codinv = TO_NUMBER(p_codinv)
        --    AND codcamo  = TO_NUMBER(p_codcamo)
        --    AND annee = TO_NUMBER(p_annee)
        --    ;
	--EXCEPTION
              -- Ne pas intercepter les autres exceptions
        --    WHEN OTHERS THEN
        --       raise_application_error( -20997, SQLERRM);
	--END;


    END update_ligne_rea;

    PROCEDURE delete_ligne_rea ( p_codrea      IN VARCHAR2,
  				                 p_codinv      IN VARCHAR2,
  				                 p_annee       IN VARCHAR2,
  				                 p_codcamo     IN VARCHAR2,
                                 p_flaglock    IN NUMBER,
                                 p_message     OUT VARCHAR2)
                                 IS
    l_msg 		VARCHAR(1024);
	l_codinv 	ligne_investissement.codinv%TYPE;
	l_codcamo 	ligne_investissement.codcamo%TYPE;
	l_annee 	ligne_investissement.annee%TYPE;
    l_codrea 	ligne_realisation.codrea%TYPE;
       retour_engage ligne_realisation.engage%TYPE;

    BEGIN

           IF (p_codrea IS NOT NULL AND p_codinv IS NOT NULL AND p_codcamo IS NOT NULL AND p_annee IS NOT NULL) THEN

              BEGIN

              	-- Verifier que le ligne de réalisation existe

              SELECT codinv, codcamo, annee, codrea
              INTO l_codinv, l_codcamo, l_annee, l_codrea
              FROM ligne_realisation WHERE codinv = TO_NUMBER(p_codinv)
              AND codcamo  = TO_NUMBER(p_codcamo)
              AND annee = TO_NUMBER(p_annee)
              AND codrea = TO_NUMBER(p_codrea);

              EXCEPTION
              	WHEN NO_DATA_FOUND THEN
                     pack_global.recuperer_message(20976, '%s1', p_codrea, '%s2', p_codinv, '%s3', p_codcamo, null, p_message);
              	     raise_application_error( -20976, p_message);
              	WHEN OTHERS THEN
              	     raise_application_error( -20997, SQLERRM);
              END;


          END IF;

          BEGIN
          --kha 09/04 engagé et disponible des lignes investissement ne sont plus utilisés

         -- On met à jour la ligne d'investissement

       	 --   SELECT engage
       	 --   INTO retour_engage
       	 --   FROM ligne_realisation r
       	 --   WHERE r.codinv=TO_NUMBER(p_codinv)
       	 --   AND codcamo  = TO_NUMBER(p_codcamo)
       	 --   AND annee = TO_NUMBER(p_annee)
       	 --   AND r.codrea = TO_NUMBER(p_codrea)
         --;


         --   UPDATE ligne_investissement i
         --   SET engage = engage - retour_engage,
         --   	disponible = disponible + retour_engage
         --   WHERE  codinv = TO_NUMBER(p_codinv)
        --    AND codcamo  = TO_NUMBER(p_codcamo)
         --   AND annee = TO_NUMBER(p_annee)
        --    ;

         -- On supprime la ligne de realisation

            DELETE FROM
            ligne_realisation
            WHERE codinv = TO_NUMBER(p_codinv)
            AND codcamo  = TO_NUMBER(p_codcamo)
            AND annee = TO_NUMBER(p_annee)
            AND codrea = TO_NUMBER(p_codrea)
            AND  flaglock = p_flaglock;

            IF SQL%NOTFOUND THEN
               -- 'Accès concurrent'
               pack_global.recuperer_message( 20999, NULL, NULL, NULL, p_message);
               raise_application_error( -20999, p_message);
            ELSE
               --'Ligne de réalisation numéro %s1 associée à la ligne d''investissement %s2 et le centre d''activité %s3 supprimée
               pack_global.recuperer_message(20975, '%s1', p_codrea, '%s2', p_codinv, '%s3', p_codcamo, null, p_message);
            END IF;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
       END;


    END delete_ligne_rea;


  PROCEDURE update_ligne_inv ( p_codinv       	IN VARCHAR2,
			                   p_annee     	    IN VARCHAR2,
                               p_codcamo        	    IN VARCHAR2,
                               p_type    	    IN VARCHAR2,
			                   p_pcode 		    IN VARCHAR2,
                               p_dpcode    	    IN VARCHAR2,
                               p_libelle       	IN VARCHAR2,
 			                   p_quantite       IN VARCHAR2,
                               p_demande      	IN VARCHAR2,
                               p_notifie       	IN VARCHAR2,
                               p_re_estime    	IN VARCHAR2,
                               p_cominv    	IN VARCHAR2,
                               p_toprp    	IN CHAR,
                               p_flaglock    	IN NUMBER,
                               p_message    	OUT VARCHAR2
                              )IS

	l_msg VARCHAR2(1024);
	l_codinv 	ligne_investissement.codinv%TYPE;
	l_codcamo 	ligne_investissement.codcamo%TYPE;
	l_annee 	ligne_investissement.annee%TYPE;
	l_re_estime 	ligne_investissement.re_estime%TYPE;
	l_notifie      ligne_investissement.notifie%TYPE;
	l_not_tvarecup  ligne_investissement.not_tvarecup%TYPE;

   BEGIN

   	p_message := '';

         IF (p_codinv IS NOT NULL AND p_codcamo IS NOT NULL AND p_annee IS NOT NULL) THEN

    		------------ Test si la lign existe

    		BEGIN

    			-- Verifier que le ligne budgetaire existe pour la modification

    			SELECT codinv, codcamo, annee, re_estime, not_tvarecup, notifie
    			INTO l_codinv, l_codcamo, l_annee, l_re_estime, l_not_tvarecup, l_notifie
    			FROM ligne_investissement
    			WHERE codinv = TO_NUMBER(p_codinv)
    			AND codcamo  = TO_NUMBER(p_codcamo)
    			AND annee = TO_NUMBER(p_annee);


    		EXCEPTION
    			WHEN NO_DATA_FOUND THEN
    			pack_global.recuperer_message(20960, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, 'codinv', l_msg);
    			raise_application_error( -20960, l_msg );
    			WHEN OTHERS THEN
    			raise_application_error( -20997, SQLERRM);
    		END;

    		p_message := l_msg;

    	END IF;

        BEGIN
	if (to_number(p_notifie) = 0) then
		l_not_tvarecup := '';
	else

		-- vérifier si déjà notifié ou renotification manuelle
        	--sinon calcul du tva/taux de recup à la notification
        	if (l_not_tvarecup is NULL or l_notifie <> to_number(p_notifie)) then
			--forcer la mise à jour de date_modif_re
			l_re_estime := 0;

			select 	TVA * (1 - tr.taux / 100) into l_not_tvarecup
			from 	tva t ,
				taux_recup tr,
				centre_activite ca
		WHERE  	t.datetva = (select max(TVA.datetva) from tva where datetva <= pack_suivi_investissement.cherche_date_exercice)
			AND tr.annee=TO_NUMBER(p_annee)
			AND tr.filcode  = ca.filcode
			AND ca.codcamo = to_number(p_codcamo) ;
		end if;
	end if;

         UPDATE ligne_investissement SET
		type		= TO_NUMBER(p_type),
		icpi 	 	= p_pcode,
                dpcode 		= TO_NUMBER(p_dpcode),
                libelle 	= decode(p_libelle, null, '', p_libelle),
                quantite	= TO_NUMBER(p_quantite),
                demande		= TO_NUMBER(p_demande),
                notifie		= decode(p_notifie, null, 0, TO_NUMBER(p_notifie)),
                re_estime	= TO_NUMBER(p_re_estime),
                --disponible  = decode(p_notifie, null, 0, TO_NUMBER(p_notifie)) - engage, --kha 09/04
                cominv 	 	= decode(p_cominv, null, '', p_cominv),
                toprp 	 	= decode(p_toprp, null, '', p_toprp),
                flaglock 	= decode(p_flaglock, 1000000, 0, p_flaglock + 1),
                not_tvarecup    = l_not_tvarecup,
                date_modif_re   = decode(l_re_estime,p_re_estime,date_modif_re,to_char(pack_suivi_investissement.cherche_date_exercice,'DD/MM/YYYY'))--date modifiée si re-estimé modifié
            WHERE
             codinv = TO_NUMBER(p_codinv)
             AND codcamo  = TO_NUMBER(p_codcamo)
             AND annee = TO_NUMBER(p_annee)
             AND flaglock = p_flaglock;

            --'Ligne investissement %s1 pour l''année d''exercice %s2 et le centre d''activité %s3 %s1 modifiée.')
            pack_global.recuperer_message(20962, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, NULL, l_msg);
            p_message := l_msg;

            EXCEPTION WHEN OTHERS THEN raise_application_error( -20999, SQLERRM);
         END;

   END update_ligne_inv;

   PROCEDURE delete_ligne_inv ( p_codinv      IN CHAR,
                                 p_codcamo          IN CHAR,
                                 p_annee       IN CHAR,
                                 p_flaglock  IN NUMBER,
                                 p_message     OUT VARCHAR2)

    IS
    l_msg       varchar2(1024);
	l_codinv 	ligne_investissement.codinv%TYPE;
	l_codcamo 	ligne_investissement.codcamo%TYPE;
	l_annee 	ligne_investissement.annee%TYPE;


    BEGIN

        p_message := '';

        IF (p_codinv IS NOT NULL AND p_codcamo IS NOT NULL AND p_annee IS NOT NULL) THEN

  		    BEGIN
  			-- Verifier que le ligne budgetaire existe pour la modification

  			SELECT codinv, codcamo, annee
  			INTO l_codinv, l_codcamo, l_annee
  			FROM ligne_investissement
  			WHERE codinv = TO_NUMBER(p_codinv)
  			AND codcamo  = TO_NUMBER(p_codcamo)
  			AND annee = TO_NUMBER(p_annee);

      		EXCEPTION
      			WHEN NO_DATA_FOUND THEN
      			pack_global.recuperer_message(20960, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, 'codinv', l_msg);
      			raise_application_error( -20960, l_msg );
      			WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
     		END;

     		p_message := l_msg;

       END IF;


       BEGIN
         DELETE FROM ligne_realisation WHERE
         codinv = p_codinv
         AND codcamo = p_codcamo
         AND annee = p_annee;

         EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
       END;

       BEGIN
          DELETE FROM
          ligne_investissement
          WHERE codinv = p_codinv
          AND codcamo = p_codcamo
          AND annee = p_annee
          AND  flaglock = p_flaglock;

          IF SQL%NOTFOUND THEN
             -- 'Accès concurrent'
             pack_global.recuperer_message( 20999, NULL, NULL, NULL, p_message);
             raise_application_error( -20999, p_message );
          ELSE
             --'Ligne investissement %s1 pour l''année d''exercice %s2 et le centre d''activité %s3 %s1 supprimée.')
             pack_global.recuperer_message(20963, '%s1', p_codinv, '%s2', p_annee, '%s3', p_codcamo, NULL, p_message);
          END IF;



          EXCEPTION WHEN OTHERS THEN raise_application_error( -20997, SQLERRM);
       END;

    END delete_ligne_inv;

    PROCEDURE notifier_centre_activite ( p_codcamo          IN VARCHAR2,
                                         p_niveau      IN VARCHAR2,
                                         p_annee       IN VARCHAR2,
                                         p_flaglock    IN NUMBER,
                                         p_message     OUT VARCHAR2)
    IS

--PRINCIPE DE LA NOTIFICATION
-- maj des champs NOTIFIE et REESTIME pour les lignes d'investissement correspondant au centre d'activité notifié
-- maj du DISPONIBLE (=Notifie - somme des réalisés)

    l_msg VARCHAR2(255);
    l_codinv ligne_investissement.CODINV%TYPE;
    l_codrea ligne_realisation.CODREA%TYPE;
    l_niveau NUMBER(1);
	l_codcamo 	centre_activite.codcamo%TYPE;
	l_annee 	ligne_investissement.annee%TYPE;
    l_realises  ligne_realisation.ENGAGE%TYPE;
    l_nb_lignes number(3);
    l_not_tvarecup ligne_investissement.not_tvarecup%TYPE;
    l_taux taux_recup.taux%TYPE;
    --liste des centres d'activités

    --definition du curseur pour le niveau 0
    cursor ca_niv0_cur is
           SELECT codcamo,
           DECODE(CLIBRCA, null, CLIBCA, CLIBRCA) AS CLIBCA,
           filcode
           FROM centre_activite WHERE codcamo=TO_NUMBER(p_codcamo);

    --definition du curseur pour le niveau 1
    cursor ca_niv1_cur is
           SELECT codcamo,
           DECODE(CLIBRCA, null, CLIBCA, CLIBRCA) AS CLIBCA,
           filcode
           FROM centre_activite WHERE caniv1=TO_NUMBER(p_codcamo);

    --definition du curseur pour le niveau 2

    cursor ca_niv2_cur is
           SELECT codcamo,
           DECODE(CLIBRCA, null, CLIBCA, CLIBRCA) AS CLIBCA,
           filcode
           FROM centre_activite WHERE caniv2=TO_NUMBER(p_codcamo);

    --definition du curseur pour le niveau 3
    cursor ca_niv3_cur is
           SELECT codcamo,
           DECODE(CLIBRCA, null, CLIBCA, CLIBRCA) AS CLIBCA,
           filcode
           FROM centre_activite WHERE caniv3=TO_NUMBER(p_codcamo);

    --definition des curseur pour le niveau 4
    cursor ca_niv4_cur is
           SELECT codcamo,
           DECODE(CLIBRCA, null, CLIBCA, CLIBRCA) AS CLIBCA,
           filcode
           FROM centre_activite WHERE caniv4=TO_NUMBER(p_codcamo);

    --liste des lignes d'investissements.

    cursor ligne_inv_cur(p_codcamo number) is
           select codinv, demande from ligne_investissement
           where codcamo = p_codcamo
           and annee = to_number(p_annee)
           order by codinv;

    BEGIN

         --l_niveau := TO_NUMBER(p_niveau);
         l_niveau := recherche_niveau(p_codcamo);
         --dbms_output.put_line('niveau trouvé :' || l_niveau);
         l_nb_lignes := 0;



         IF l_niveau = 0 THEN
            for ca_rec in ca_niv0_cur loop
		-- calcul du taux tva recuperable
		select taux into l_taux
		from taux_recup
		where annee =p_annee and filcode =ca_rec.filcode;
		select TVA * (1 - l_taux / 100) into l_not_tvarecup
		from tva t
		WHERE  t.datetva = (select max(TVA.datetva) from tva where datetva <= pack_suivi_investissement.cherche_date_exercice);
                for li_rec in ligne_inv_cur(ca_rec.codcamo) loop

                   update ligne_investissement set
                              flaglock 	= decode(p_flaglock, 1000000, 0, p_flaglock + 1),
                              notifie = li_rec.demande,
                              re_estime  = li_rec.demande,
                              not_tvarecup = l_not_tvarecup,
                              date_modif_re = to_char(pack_suivi_investissement.cherche_date_exercice,'DD/MM/YYYY')
                              --disponible = li_rec.demande - li_rec.engage
                   where codinv = li_rec.codinv
                   and codcamo = ca_rec.codcamo
                   and annee=TO_NUMBER(p_annee);
                   --and flaglock = p_flaglock;

                   if(sql%found) then
                     l_nb_lignes := l_nb_lignes + 1;
                   end if;

                end loop;

            end loop;

         ELSIF l_niveau = 1 THEN
            for ca_rec in ca_niv1_cur loop
		-- calcul du taux tva recuperable
		select taux into l_taux
		from taux_recup
		where annee =p_annee and filcode =ca_rec.filcode;
		select TVA * (1 - l_taux / 100) into l_not_tvarecup
		from tva t
		WHERE  t.datetva = (select max(TVA.datetva) from tva where datetva <= pack_suivi_investissement.cherche_date_exercice);
              	   for li_rec in ligne_inv_cur(ca_rec.codcamo) loop
                   l_realises := sum_realises(li_rec.codinv, ca_rec.codcamo, p_annee);

                   update ligne_investissement set
                              flaglock 	= decode(p_flaglock, 1000000, 0, p_flaglock + 1),
                              notifie = li_rec.demande,
                              re_estime  = li_rec.demande,
                             not_tvarecup = l_not_tvarecup,
                             date_modif_re = to_char(pack_suivi_investissement.cherche_date_exercice,'DD/MM/YYYY')
                              --disponible = li_rec.demande - li_rec.engage
                   where codinv = li_rec.codinv
                   and codcamo = ca_rec.codcamo
                   and annee=TO_NUMBER(p_annee);

                   if(sql%found) then
                     l_nb_lignes := l_nb_lignes + 1;
                   end if;

                end loop;
            end loop;

         ELSIF l_niveau = 2 THEN
               for ca_rec in ca_niv2_cur loop
		-- calcul du taux tva recuperable
		select taux into l_taux
		from taux_recup
		where annee =p_annee and filcode =ca_rec.filcode;
		select TVA * (1 - l_taux / 100) into l_not_tvarecup
		from tva t
		WHERE  t.datetva = (select max(TVA.datetva) from tva where datetva <= pack_suivi_investissement.cherche_date_exercice);
              	   for li_rec in ligne_inv_cur(ca_rec.codcamo) loop
                   l_realises := sum_realises(li_rec.codinv, ca_rec.codcamo, p_annee);

                   update ligne_investissement set
                              flaglock 	= decode(p_flaglock, 1000000, 0, p_flaglock + 1),
                              notifie = li_rec.demande,
                              re_estime  = li_rec.demande,
                              not_tvarecup = l_not_tvarecup,
                              date_modif_re = to_char(pack_suivi_investissement.cherche_date_exercice,'DD/MM/YYYY')
                              --disponible = li_rec.demande - li_rec.engage
                   where codinv = li_rec.codinv
                   and codcamo = ca_rec.codcamo
                   and annee=TO_NUMBER(p_annee);

                   if(sql%found) then
                     l_nb_lignes := l_nb_lignes + 1;
                   end if;

                end loop;
            end loop;

         ELSIF l_niveau = 3 THEN
            for ca_rec in ca_niv3_cur loop
		-- calcul du taux tva recuperable
		select taux into l_taux
		from taux_recup
		where annee =p_annee and filcode =ca_rec.filcode;
		select TVA * (1 - l_taux / 100) into l_not_tvarecup
		from tva t
		WHERE  t.datetva = (select max(TVA.datetva) from tva where datetva <= pack_suivi_investissement.cherche_date_exercice);
             	   for li_rec in ligne_inv_cur(ca_rec.codcamo) loop
                   l_realises := sum_realises(li_rec.codinv, ca_rec.codcamo, p_annee);

                   update ligne_investissement set
                              flaglock 	= decode(p_flaglock, 1000000, 0, p_flaglock + 1),
                              notifie = li_rec.demande,
                              re_estime  = li_rec.demande,
                              not_tvarecup = l_not_tvarecup,
                              date_modif_re = to_char(pack_suivi_investissement.cherche_date_exercice,'DD/MM/YYYY')
                              --disponible = li_rec.demande - li_rec.engage
                   where codinv = li_rec.codinv
                   and codcamo = ca_rec.codcamo
                   and annee=TO_NUMBER(p_annee);

                   if(sql%found) then
                     l_nb_lignes := l_nb_lignes + 1;

                   end if;
                end loop;
            end loop;

         ELSE
            for ca_rec in ca_niv4_cur loop
		-- calcul du taux tva recuperable
		select taux into l_taux
		from taux_recup
		where annee =p_annee and filcode =ca_rec.filcode;
		select TVA * (1 - l_taux / 100) into l_not_tvarecup
		from tva t
		WHERE  t.datetva = (select max(TVA.datetva) from tva where datetva <= pack_suivi_investissement.cherche_date_exercice);
             	   for li_rec in ligne_inv_cur(ca_rec.codcamo) loop
                   l_realises := sum_realises(li_rec.codinv, ca_rec.codcamo, p_annee);

                   update ligne_investissement set
                              flaglock 	= decode(p_flaglock, 1000000, 0, p_flaglock + 1),
                              notifie = li_rec.demande,
                              re_estime  = li_rec.demande,
                              not_tvarecup = l_not_tvarecup,
                              date_modif_re = to_char(pack_suivi_investissement.cherche_date_exercice,'DD/MM/YYYY')
                              --disponible = li_rec.demande - li_rec.engage
                   where codinv = li_rec.codinv
                   and codcamo = ca_rec.codcamo
                   and annee=TO_NUMBER(p_annee);

                   if(sql%found) then
                     l_nb_lignes := l_nb_lignes + 1;
                   end if;

                end loop;
            end loop;

         END IF;

         if(l_nb_lignes > 1) then
             pack_global.recuperer_message(20966, '%s1', to_char(l_nb_lignes), '%s2', p_annee, '%s3', p_codcamo, NULL, l_msg);
         else
             pack_global.recuperer_message(20967, '%s1', to_char(l_nb_lignes), '%s2', p_annee, '%s3', p_codcamo, NULL, l_msg);
         end if;
         p_message := l_msg;

         EXCEPTION WHEN OTHERS THEN
               -- Accès concurrent
               --pack_global.recuperer_message( 20999, NULL, NULL, NULL, l_msg);
               raise_application_error( -20999,  sqlerrm);

    END notifier_centre_activite;


    /**
    Fonction de calcul des réalisés pour la ligne d'investissement p_codinv
    le centre d'activité p_codcamo
    l'année p_annee
    **/
    FUNCTION sum_realises(p_codinv IN number,
                          p_codcamo IN number,
                          p_annee IN varchar2)
    RETURN NUMBER
    IS

    l_total ligne_realisation.ENGAGE%TYPE;

    BEGIN

       select sum(engage) into l_total
       from ligne_realisation
       where codinv=p_codinv
       and codcamo=p_codcamo
       and annee=to_number(p_annee);

       if(l_total is null) then
        l_total := 0;
       end if;
       return l_total;

       EXCEPTION WHEN OTHERS THEN return 0;

    END sum_realises;

    FUNCTION sum_realises_htr(p_codinv IN number,
                          p_codcamo IN number,
                          p_annee IN varchar2)
    RETURN NUMBER
    IS

    l_total ligne_realisation.ENGAGE%TYPE;

    BEGIN

	select sum(engage*(1+ t.tva/100*(1-tr.taux/100))) into l_total
       from ligne_realisation lr,
       centre_activite ca,
       taux_recup tr,
	   tva t
       where lr.codinv=p_codinv
       and lr.codcamo=p_codcamo
       and lr.annee=to_number(p_annee)
       and tr.annee=lr.annee
       and tr.filcode = ca.filcode
       and lr.codcamo = ca.codcamo
       and t.datetva = (select max(TVA.datetva) from tva where datetva  <= to_date(lr.date_saisie,'DD/MM/YYYY'));

       if(l_total is null) then
        l_total := 0;
       end if;
       return l_total;

       EXCEPTION WHEN OTHERS THEN return 0;

    END sum_realises_htr;

   FUNCTION cherche_tva(p_datetva IN varchar2)
    RETURN NUMBER
    IS

    l_tva tva.tva%TYPE;

    BEGIN

	select t.tva into l_tva
       from tva t
       where
       t.datetva = (select max(TVA.datetva) from tva where datetva  <= to_date(p_datetva,'DD/MM/YYYY'));


       if(l_tva is null) then
        l_tva := 0;
       end if;
       return l_tva;

       EXCEPTION WHEN OTHERS THEN return 0;

    END cherche_tva;


    FUNCTION cherche_date_exercice
    RETURN DATE IS
     l_date datdebex.cmensuelle%TYPE;
     BEGIN

	select to_date(concat('01/', to_char(add_months(cmensuelle, -1),'MM/YYYY'))) into l_date
       from datdebex d;


       return l_date;

       EXCEPTION WHEN OTHERS THEN return sysdate;

    END cherche_date_exercice;




    FUNCTION recherche_niveau(p_codcamo IN varchar2)
    RETURN NUMBER
    IS

    cursor niv0_cur is select codcamo from centre_activite
       where codcamo = TO_NUMBER(p_codcamo);

    cursor niv1_cur is select codcamo from centre_activite
       where caniv1 = TO_NUMBER(p_codcamo);

    cursor niv2_cur is select codcamo from centre_activite
       where caniv2 = TO_NUMBER(p_codcamo);

    cursor niv3_cur is select codcamo from centre_activite
       where caniv3 = TO_NUMBER(p_codcamo);

    cursor niv4_cur is select codcamo from centre_activite
       where caniv4 = TO_NUMBER(p_codcamo);

    l_niveau number(1);

    BEGIN

       for niv_rec in niv0_cur loop
           return 0;
       end loop;
       for niv_rec in niv1_cur loop
           return 1;
       end loop;
       for niv_rec in niv2_cur loop
           return 2;
       end loop;
       for niv_rec in niv3_cur loop
           return 3;
       end loop;
       for niv_rec in niv4_cur loop
           return 4;
       end loop;

    END recherche_niveau;

END pack_suivi_investissement;
/
CREATE OR REPLACE PACKAGE pack_txrecup AS

   TYPE txrecup_RecType IS RECORD (ANNEE        VARCHAR2(4),
                                   FILCODE      CHAR(3),
                                   TAUX_RECUP   VARCHAR2(30),
								   TAUX_SAL     VARCHAR2(30),
								   FLAGLOCK		NUMBER(7));

   TYPE txrecup_CurType IS REF CURSOR RETURN txrecup_RecType;

PROCEDURE select_txrecup( 	p_action    IN VARCHAR2,
							p_annee IN VARCHAR2,
							p_filcode IN CHAR,
							p_userid    IN CHAR,
							p_curselect IN  OUT txrecup_CurType,
		                	p_nbcurseur     OUT INTEGER,
							p_message       OUT VARCHAR2
                           );

 PROCEDURE insert_txrecup(	p_annee IN VARCHAR2,
 							p_filcode  IN  CHAR,
							p_taux_rec IN VARCHAR2,
							p_taux_sal IN VARCHAR2,
							p_nbcurseur     OUT INTEGER,
							p_message       OUT VARCHAR2
				);

 PROCEDURE update_txrecup(	p_annee IN VARCHAR2,
 							p_filcode  IN  CHAR,
							p_taux_rec IN VARCHAR2,
							p_taux_sal IN VARCHAR2,
							p_flaglock  IN  NUMBER,
							p_nbcurseur     OUT INTEGER,
							p_message       OUT VARCHAR2
				);
PROCEDURE delete_txrecup(	p_annee IN VARCHAR2,
				p_filcode  IN  CHAR,
		  					p_flaglock  IN  NUMBER,
							p_nbcurseur     OUT INTEGER,
							p_message       OUT VARCHAR2
				);



END pack_txrecup ;
/

CREATE OR REPLACE PACKAGE BODY pack_txrecup AS

PROCEDURE select_txrecup( 	p_action    IN VARCHAR2,
				p_annee IN VARCHAR2,
				p_filcode IN CHAR,
				p_userid    IN CHAR,
				p_curselect IN  OUT txrecup_CurType,
		                p_nbcurseur     OUT INTEGER,
				p_message       OUT VARCHAR2
                           ) IS

l_annee taux_recup.annee%TYPE;
l_filcode taux_recup.filcode%TYPE;

BEGIN

  p_message :='';
--On teste l'existence du taux de récup pour l'année et la filiale choisie
  BEGIN
	select annee, filcode into l_annee, l_filcode
	from taux_recup
	where annee=to_number(p_annee)
	and filcode=p_filcode;
  EXCEPTION
	WHEN NO_DATA_FOUND THEN
		l_annee := 0;
  END;


IF ((p_action='modifier') or  (p_action='supprimer')) and (l_annee=0)  THEN --Le taux n'existe pas
	-- Message Taux de récupération inexistant pour l'année
	pack_global.recuperer_message(20368,'%s1',p_annee, NULL, p_message);
	raise_application_error(-20368, p_message);

END IF;

OPEN p_curselect FOR
select to_char(r.ANNEE) ANNEE,
        r.FILCODE FILCODE,
	   to_char(r.TAUX) 	TAUX_RECUP,
	   decode(s.TAUX,null,'',to_char(s.TAUX)) 	TAUX_SAL,
	   decode(s.FLAGLOCK, null,0,s.FLAGLOCK)		FLAGLOCK
from taux_recup r, taux_charge_salariale s
where r.ANNEE = s.ANNEE (+)
and r.ANNEE = to_number(p_annee)
and r.FILCODE = p_filcode;

END select_txrecup;

PROCEDURE insert_txrecup(	p_annee IN VARCHAR2,
				p_filcode  IN  CHAR,
							p_taux_rec IN VARCHAR2,
							p_taux_sal IN VARCHAR2,
							p_nbcurseur     OUT INTEGER,
							p_message       OUT VARCHAR2
				) IS
BEGIN

	insert into taux_recup (annee, taux, filcode)
	values (to_number(p_annee),
		to_number(p_taux_rec),
		p_filcode);
	--KHA On renseigne le taux de charge salariale que pour SGPM
	IF (p_filcode = '01') THEN
	insert into taux_charge_salariale (annee,taux,flaglock)
	values (to_number(p_annee),
		    to_number(p_taux_sal),
			0);
	END IF;


 p_message :='';
EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -20997,SQLERRM);

END insert_txrecup;

PROCEDURE update_txrecup(	p_annee IN VARCHAR2,
				p_filcode  IN  CHAR,
							p_taux_rec IN VARCHAR2,
							p_taux_sal IN VARCHAR2,
							p_flaglock  IN  NUMBER,
							p_nbcurseur     OUT INTEGER,
							p_message       OUT VARCHAR2
				) IS
BEGIN
 p_message :='';

	update taux_recup set taux=to_number(p_taux_rec)
	where annee=to_number(p_annee)
	and filcode=p_filcode;
	--KHA On renseigne le taux de charge salariale que pour SGPM
	IF (p_filcode = '01') THEN
	update taux_charge_salariale
	set taux=to_number(p_taux_sal),
		flaglock=decode(p_flaglock,9999999,0,p_flaglock+1)
	where annee=to_number(p_annee);
	END IF;

	IF SQL%NOTFOUND THEN
         -- 'Accès concurrent'
         pack_global.recuperer_message(20999, NULL,NULL,NULL,p_message);
         raise_application_error( -20999, p_message );
	END IF;
 EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -20997,SQLERRM);



END update_txrecup;

PROCEDURE delete_txrecup(	p_annee IN VARCHAR2,
				p_filcode  IN  CHAR,
		  					p_flaglock  IN  NUMBER,
							p_nbcurseur     OUT INTEGER,
							p_message       OUT VARCHAR2
				) IS
BEGIN

	delete taux_recup
	where annee=to_number(p_annee)
	and filcode = p_filcode;
	--KHA On renseigne le taux de charge salariale que pour SGPM
	IF (p_filcode = '01') THEN
	delete taux_charge_salariale
	where annee=to_number(p_annee)
	and flaglock=p_flaglock;
	END IF;


 p_message :='';


END delete_txrecup;

END pack_txrecup ;
/
CREATE OR REPLACE PACKAGE pack_type_activite AS

   TYPE type_activite_ViewType IS RECORD( arctype 	type_activite.arctype%TYPE,
   					  libarc	type_activite.libarc%TYPE,
   					  actif		type_activite.actif%TYPE,
   					  listeType1	VARCHAR2(30),
   					  flaglock	type_activite.flaglock%TYPE
   					  );

   TYPE type_activiteCurType IS REF CURSOR RETURN type_activite_ViewType;

   PROCEDURE insert_type_activite (p_arctype   	IN  type_activite.arctype%TYPE,
                                   p_libarc    	IN  type_activite.libarc%TYPE,
                                   p_actif      IN  type_activite.actif%TYPE,
                                   p_listeType1	IN  VARCHAR2,
                                   p_global    	IN  VARCHAR2,
                                   p_nbcurseur 	OUT INTEGER,
                                   p_message   	OUT VARCHAR2
                                  );

   PROCEDURE update_type_activite (p_arctype    IN  type_activite.arctype%TYPE,
                                   p_libarc     IN  type_activite.libarc%TYPE,
                                   p_actif      IN  type_activite.actif%TYPE,
                                   p_listeType1	IN  VARCHAR2,
                                   p_flaglock   IN  NUMBER,
                                   p_global     IN  VARCHAR2,
                                   p_nbcurseur  OUT INTEGER,
                                   p_message    OUT VARCHAR2
                                  );

   PROCEDURE delete_type_activite (p_arctype   IN type_activite.arctype%TYPE,
                                   p_libarc    IN type_activite.libarc%TYPE,
                                   p_flaglock  IN NUMBER,
                                   p_global    IN VARCHAR2,
                                   p_nbcurseur OUT INTEGER,
                                   p_message   OUT VARCHAR2
	   	    	                );

   PROCEDURE select_type_activite (p_arctype   IN type_activite.arctype%TYPE,
                                   p_global    IN VARCHAR2,
                                   p_cursor    IN OUT type_activiteCurType,
                                   p_nbcurseur OUT INTEGER,
                                   p_message   OUT VARCHAR2
                                  );

END pack_type_activite;
/

CREATE OR REPLACE PACKAGE BODY pack_type_activite AS

   PROCEDURE insert_type_activite (p_arctype    IN  type_activite.arctype%TYPE,
                                   p_libarc     IN  type_activite.libarc%TYPE,
                                   p_actif      IN  type_activite.actif%TYPE,
                                   p_listeType1	IN  VARCHAR2,
                                   p_global     IN  VARCHAR2,
                                   p_nbcurseur 	OUT INTEGER,
                                   p_message   	OUT VARCHAR2
                                  ) IS
      msg 		VARCHAR(1024);
      l_liste_Type1 	VARCHAR2(50);
      l_type1		lien_types_proj_act.type_proj%TYPE;
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO type_activite ( arctype,
                                     libarc,
                                     actif)
         VALUES ( p_arctype,
                  p_libarc,
                  p_actif);

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN

            -- 'Code typologie secondaire existe déjà'

            pack_global.recuperer_message(20614, NULL,NULL,NULL,msg);
            raise_application_error( -20614, msg );

         WHEN OTHERS THEN
            raise_application_error( -20997,SQLERRM);

      END;

      -- On ratache les types 1 avec les types 2
      	BEGIN
      	  l_liste_Type1 := p_listeType1;
      	  WHILE INSTR(l_liste_Type1, ';') > 0 LOOP
      	  	l_type1 := SUBSTR(l_liste_Type1, 1, 2);
      	  	INSERT 	INTO lien_types_proj_act (type_proj, type_act)
      	  		VALUES (l_type1, p_arctype);
      	  	l_liste_Type1 := SUBSTR(l_liste_Type1, INSTR(l_liste_Type1, ';') + 1);
      	  END LOOP;

	EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -20997,SQLERRM);
        END;


      -- 'Code typologie secondaire ' || p_libarc|| ' créé';

      pack_global.recuperer_message( 6010, '%s1', p_libarc, NULL, msg);
      p_message := msg;

   END insert_type_activite;


   PROCEDURE update_type_activite (p_arctype   	IN  type_activite.arctype%TYPE,
                                   p_libarc    	IN  type_activite.libarc%TYPE,
                                   p_actif      IN  type_activite.actif%TYPE,
                                   p_listeType1	IN  VARCHAR2,
                                   p_flaglock  	IN  NUMBER,
                                   p_global    	IN  VARCHAR2,
                                   p_nbcurseur 	OUT INTEGER,
                                   p_message   	OUT VARCHAR2
                                  ) IS
      msg 		VARCHAR2(1024);
      l_liste_Type1 	VARCHAR2(50);
      l_type1		lien_types_proj_act.type_proj%TYPE;
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         UPDATE type_activite
         SET libarc    = p_libarc,
             actif     = p_actif,
             flaglock  = decode( p_flaglock, 1000000, 0, p_flaglock + 1)
         WHERE arctype  = p_arctype
         AND   flaglock = p_flaglock;

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -20997,SQLERRM);

      END;

      IF SQL%NOTFOUND THEN

         -- 'Accès concurrent'

         pack_global.recuperer_message(20999, NULL,NULL,NULL,msg);
         raise_application_error( -20999, msg );

      END IF;

      -- On supprime les anciennes liaisons et
      -- On ratache les types 1 avec les types 2
      	BEGIN
      	  DELETE lien_types_proj_act WHERE type_act = p_arctype;

      	  l_liste_Type1 := p_listeType1;
      	  WHILE INSTR(l_liste_Type1, ';') > 0 LOOP
      	  	l_type1 := SUBSTR(l_liste_Type1, 1, 2);
      	  	INSERT 	INTO lien_types_proj_act (type_proj, type_act)
      	  		VALUES (l_type1, p_arctype);
      	  	l_liste_Type1 := SUBSTR(l_liste_Type1, INSTR(l_liste_Type1, ';') + 1);
      	  END LOOP;

	EXCEPTION
         WHEN OTHERS THEN
            raise_application_error( -20997,SQLERRM);
        END;

         -- 'Code typologie secondaire ' || p_libarc|| 'modifié' ;

         pack_global.recuperer_message( 6011 , '%s1', p_libarc, NULL, msg);
         p_message := msg;


   END update_type_activite;


   PROCEDURE delete_type_activite (p_arctype   IN type_activite.arctype%TYPE,
                                   p_libarc    IN type_activite.libarc%TYPE,
                                   p_flaglock  IN NUMBER,
                                   p_global    IN VARCHAR2,
                                   p_nbcurseur OUT INTEGER,
                                   p_message   OUT VARCHAR2
                                  ) IS
      msg VARCHAR(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT(referential_integrity, -2292);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN

         -- On supprime les liens avec les types 1
         DELETE lien_types_proj_act WHERE type_act = p_arctype;

      	 -- on supprime le lien
         DELETE FROM type_activite
         WHERE arctype = p_arctype
         AND  flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error( -20997,SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

         --'Accès concurrent'

         pack_global.recuperer_message( 20999, NULL, NULL, NULL, msg);
         raise_application_error( -20999, msg );
      ELSE

         -- 'Code typologie secondaire ' || p_libarc|| 'supprimé' ;

         pack_global.recuperer_message( 6012 , '%s1', p_libarc, NULL, msg);
         p_message := msg;
      END IF;

   END delete_type_activite;


   PROCEDURE select_type_activite (p_arctype   IN type_activite.arctype%TYPE,
                                   p_global    IN VARCHAR2,
                                   p_cursor    IN OUT type_activiteCurType,
                                   p_nbcurseur OUT INTEGER,
                                   p_message   OUT VARCHAR2
                                  ) IS
      msg VARCHAR(1024);
      l_listeType1 VARCHAR2(50);
      l_type1 lien_types_proj_act.type_proj%TYPE;

      CURSOR type1_curs IS
        SELECT typproj
        FROM type_projet;
   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';
      l_listeType1 := '';

      -- On construit la liste des types1
      FOR type1_rec IN type1_curs LOOP
      	BEGIN
      	  SELECT type_proj INTO l_type1
      	  FROM lien_types_proj_act
      	  WHERE type_proj = type1_rec.typproj
      	    AND type_act = p_arctype;

      	  l_listeType1 := l_listeType1 || type1_rec.typproj || ';';
      	EXCEPTION
      	   WHEN NO_DATA_FOUND THEN
      	     -- On ne fait rien
      	     dbms_output.put_line('Pas de ligne avec ce type');
	   WHEN OTHERS THEN
	      raise_application_error( -20997,SQLERRM);
	END;
      END LOOP;


      OPEN p_cursor FOR
           SELECT arctype,
           	  libarc,
           	  actif,
           	  l_listeType1,
           	  flaglock
           FROM type_activite
           WHERE arctype = p_arctype;

      -- en cas absence, Code typologie secondaire  p_arctype inexistant

      pack_global.recuperer_message( 6013, '%s1', p_arctype, NULL, msg);
      p_message := msg;

   END select_type_activite;

END pack_type_activite;
/
CREATE OR REPLACE PACKAGE pack_type_projet AS

   TYPE type_projetCurType IS REF CURSOR RETURN type_projet%ROWTYPE;

  PROCEDURE insert_type_projet (p_typproj   IN type_projet.typproj%TYPE,
                                p_libtyp    IN type_projet.libtyp%TYPE,
                                p_global    IN CHAR,
                                p_nbcurseur OUT INTEGER,
                                p_message   OUT VARCHAR2
                                );

   PROCEDURE update_type_projet (p_typproj   IN type_projet.typproj%TYPE,
                                 p_libtyp    IN type_projet.libtyp%TYPE,
                                 p_flaglock  IN NUMBER,
                                 p_global    IN CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

   PROCEDURE delete_type_projet (p_typproj   IN type_projet.typproj%TYPE,
                                 p_libtyp    IN type_projet.libtyp%TYPE,
                                 p_flaglock  IN NUMBER,
                                 p_global    IN CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
	   		              );

   PROCEDURE select_type_projet (p_typproj   IN type_projet.typproj%TYPE,
                                 p_global    IN CHAR,
                                 p_cursor    IN OUT type_projetCurType,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                );

END pack_type_projet;
/

CREATE OR REPLACE PACKAGE BODY pack_type_projet AS

   PROCEDURE insert_type_projet (p_typproj   IN  type_projet.typproj%TYPE ,
                                 p_libtyp    IN  type_projet.libtyp%TYPE  ,
                                 p_global    IN  CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         INSERT INTO type_projet ( typproj,
                                   libtyp)
         VALUES ( p_typproj,
                  p_libtyp);

      EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN

            -- 'Code type existe déjà'

	      pack_global.recuperer_message(20604,NULL,NULL,NULL,msg);
            raise_application_error( -20604, msg );

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      -- 'Code type ' || p_libtyp|| ' créé'

	pack_global.recuperer_message( 6000, '%s1', p_libtyp, NULL, msg);
	p_message := msg;

   END insert_type_projet;


   PROCEDURE update_type_projet (p_typproj   IN type_projet.typproj%TYPE,
                                 p_libtyp    IN type_projet.libtyp%TYPE,
                                 p_flaglock  IN NUMBER,
                                 p_global    IN CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN

         UPDATE type_projet
         SET libtyp   = p_libtyp,
             flaglock = decode( p_flaglock, 1000000, 0,
                                p_flaglock + 1)
         WHERE typproj  = p_typproj
         AND   flaglock = p_flaglock;

      EXCEPTION
         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message( 20999, NULL, NULL, NULL, msg);
         raise_application_error( -20999, msg );

      ELSE

         -- 'Code type ||p_libtyp|| modifié'

         pack_global.recuperer_message( 6001, '%s1', p_libtyp, NULL, msg);
         p_message := msg;
      END IF;

   END update_type_projet;


   PROCEDURE delete_type_projet (p_typproj   IN type_projet.typproj%TYPE,
                                 p_libtyp    IN type_projet.libtyp%TYPE,
                                 p_flaglock  IN NUMBER,
                                 p_global    IN CHAR,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
      referential_integrity EXCEPTION;
      PRAGMA EXCEPTION_INIT( referential_integrity, -2292);
   BEGIN

      -- Positionner le nb de curseurs ==> 0
      -- Initialiser le message retour

      p_nbcurseur := 0;
      p_message := '';

      BEGIN
         DELETE FROM type_projet
         WHERE typproj  = p_typproj
         AND   flaglock = p_flaglock;

      EXCEPTION
         WHEN referential_integrity THEN

            -- habiller le msg erreur

            pack_global.recuperation_integrite(-2292);

         WHEN OTHERS THEN
            raise_application_error(-20997, SQLERRM);
      END;

      IF SQL%NOTFOUND THEN

	   -- 'Accès concurrent'

	   pack_global.recuperer_message(20999,NULL,NULL,NULL,msg);
         raise_application_error( -20999, msg );

      ELSE

         -- 'Code type ||p_libtyp|| supprimé'

	   pack_global.recuperer_message( 6002, '%s1', p_libtyp, NULL, msg);
         p_message := msg;
      END IF;

   END delete_type_projet;


   PROCEDURE select_type_projet (p_typproj   IN type_projet.typproj%TYPE,
                                 p_global    IN CHAR,
                                 p_cursor    IN OUT type_projetCurType,
                                 p_nbcurseur OUT INTEGER,
                                 p_message   OUT VARCHAR2
                                ) IS
      msg VARCHAR(1024);
   BEGIN

      -- Positionner le nb de curseurs ==> 1
      -- Initialiser le message retour

      p_nbcurseur := 1;
      p_message := '';

      -- Attention ordre des colonnes doit correspondre a l ordre
      -- de declaration dans la table ORACLE (a cause de ROWTYPE)
      -- ou selectionner toutes les colonnes par *

      OPEN p_cursor FOR
           SELECT *
           FROM type_projet
           WHERE typproj =  p_typproj;

      -- en cas absence
      -- 'Code Type p_typproj inexistant'

      pack_global.recuperer_message( 6003, '%s1', p_typproj, NULL, msg);
      p_message := msg;

   END select_type_projet;

END pack_type_projet;
/
CREATE OR REPLACE PACKAGE Pack_Utile IS

   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_pnom_lbip
   -- Auteur     :  Equipe SOPRA
   -- Decription :  recupere le libelle d'une ligne bip
   -- Paramètres :  p_pid (IN) identifiant du code projet
   --
   -- Retour     :  le libelle du projet
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_pnom_lbip(p_pid IN LIGNE_BIP.pid%TYPE) RETURN VARCHAR2;
	   PRAGMA RESTRICT_REFERENCES(f_get_pnom_lbip,wnds,wnps);

   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_ref_partenaire
   -- Decription :  savoir si une societe est partenaire avec un code de departement
   -- Paramètres :  p_coddep (IN) code departement
   --                            p_soccode (IN) code societe
   --
   -- Retour     :  Partenaire ou Non partenaire
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_ref_partenaire(p_coddep IN STRUCT_INFO.coddep%TYPE , p_soccode IN SOCIETE.soccode%TYPE) RETURN VARCHAR2;
	   PRAGMA RESTRICT_REFERENCES( f_get_ref_partenaire,wnds,wnps);

   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_codsg_lbip
   -- Auteur     :  Equipe SOPRA
   -- Decription :  recupere le codsg d'une ligne bip
   -- Paramètres :  p_pid (IN) identifiant du code projet
   --
   -- Retour     :  le code DEP/POL/GR de la ligne bip
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_codsg_lbip(p_pid IN LIGNE_BIP.pid%TYPE) RETURN VARCHAR2;
	   PRAGMA RESTRICT_REFERENCES(f_get_codsg_lbip,wnds,wnps);

   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_deppole
   -- Auteur     :  Equipe SOPRA
   -- Decription :  renvoie le département/pole, séparé par un '/'
   -- Paramètres :  p_coddeppole (IN)	code département/pole
   --
   -- Retour     :  renvoie le département/pole, séparé par un '/'
   --	          en cas d'erreur, renvoie une chaine vide.
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_deppole(p_coddeppole IN STRUCT_INFO.coddeppole%TYPE) RETURN VARCHAR2;
	   PRAGMA RESTRICT_REFERENCES(f_get_deppole,wnds,wnps);


   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_deppole_codsg
   -- Auteur     :  Equipe SOPRA
   -- Decription :  renvoie le département/pole, séparé par un '/'
   -- Paramètres :  p_codsg (IN)	code département/pole/Groupe
   --
   -- Retour     :  renvoie le département/pole, séparé par un '/'
   --	          en cas d'erreur, renvoie une chaine vide.
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_deppole_codsg(p_codsg IN STRUCT_INFO.codsg%TYPE) RETURN VARCHAR2;
	   PRAGMA RESTRICT_REFERENCES(f_get_deppole_codsg,wnds,wnps);

   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_deppolegrpe
   -- Auteur     :  Equipe SOPRA
   -- Decription :  renvoie le département/pole/groupe, séparé par un '/'
   -- Paramètres :  p_cosg  (IN)	code département/pole/groupe
   --
   -- Retour     :  renvoie le département/pole/groupe, séparé par un '/'
   --	          en cas d'erreur, renvoie une chaine vide.
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_deppolegrpe(p_codsg IN STRUCT_INFO.codsg%TYPE) RETURN VARCHAR2;
	   PRAGMA RESTRICT_REFERENCES(f_get_deppolegrpe,wnds,wnps);


   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_filiale
   -- Auteur     :  Equipe SOPRA
   -- Decription :  renvoie la filiale et son identifiant
   -- Paramètres :  p_filcode (IN)		code filiale
   --
   -- Retour     :  renvoie la filiale et son identifiant
   --	          en cas d'erreur, renvoie une chaine vide.
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_filiale(p_filcode IN FILIALE_CLI.filcode%TYPE) RETURN VARCHAR2;
	   PRAGMA RESTRICT_REFERENCES(f_get_filiale,wnds);


   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_dep
   -- Auteur     :  Equipe SOPRA
   -- Decription :  renvoie le département
   -- Paramètres :  p_coddep (IN)		code département
   --
   -- Retour     :  renvoie le département
   --	          en cas d'erreur, renvoie une chaine vide.
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_dep(p_coddep IN STRUCT_INFO.coddep%TYPE) RETURN VARCHAR2;
             PRAGMA RESTRICT_REFERENCES(f_get_dep,wnds,wnps);

   -- ------------------------------------------------------------------------
   -- Nom        :  f_verif_soccode
   -- Auteur     :  Equipe SOPRA
   -- Decription :  vérifie l'existence d'une société
   -- Paramètres :  p_soccode (IN)		code société
   --
   -- Retour     :  renvoie TRUE si on trouve la société
   --	          FALSE si la société n'est pas trouvé
   --	          Lève une erreur application en cas d'erreur Oracle
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_verif_soccode(p_soccode IN SOCIETE.soccode%TYPE) RETURN BOOLEAN;
	   PRAGMA RESTRICT_REFERENCES(f_verif_soccode,wnds);


   -- ------------------------------------------------------------------------
   --
   -- Nom        :  f_verif_facture
   -- Auteur     :  Equipe SOPRA (HT)
   -- Decription :  vérification directe de l'existence d'une facture
   -- Paramètres :
   --              p_tablefact IN             de la table des factures
   --              p_socfact (IN)		   Code société
   --              p_numfact IN              Numéro facture
   --              p_typfact IN              Type facture
   --              p_datfact IN              date facture
   -- Retour     :  renvoie TRUE si on trouve la Facture
   --	          FALSE si la Facture n'est pas trouvée
   --	          Lève une erreur application en cas d'erreur Oracle
   --
   -- Remarque   : Si p_tablefact différent de 'FACTURE' et 'HISTO_FACTURE'
   --             On retourne FAUX!!!
   -- ------------------------------------------------------------------------
   FUNCTION f_verif_facture(
			    p_tablefact IN VARCHAR2,
			    p_socfact IN FACTURE.socfact%TYPE,
			    p_numfact IN FACTURE.numfact%TYPE,
			    p_typfact IN FACTURE.typfact%TYPE,
			    p_datfact IN FACTURE.datfact%TYPE
			   ) RETURN BOOLEAN;
	   PRAGMA RESTRICT_REFERENCES(f_verif_facture,wnds);


   -- ------------------------------------------------------------------------
   --
   -- Nom        :  f_verif_numfact
   -- Auteur     :  Equipe SOPRA (HT)
   -- Decription :  vérification existence d'un N° de facture
   -- Paramètres :
   --              p_tablefact IN             de la table des factures
   --              p_numfact IN              Numéro facture
   -- Retour     :  renvoie TRUE si on trouve le N° de Facture dans la table p_tablefact
   --	          FALSE si la Facture n'est pas trouvée
   --	          Lève une erreur application en cas d'erreur Oracle
   --
   -- Remarque   : Si p_tablefact différent de 'FACTURE' et 'HISTO_FACTURE'
   --             On retourne FAUX!!!
   -- ------------------------------------------------------------------------
   FUNCTION f_verif_numfact(p_tablefact IN VARCHAR2,
			                   p_numfact IN FACTURE.numfact%TYPE
			                  ) RETURN BOOLEAN;
	   PRAGMA RESTRICT_REFERENCES(f_verif_numfact,wnds);

   -- ------------------------------------------------------------------------
   -- Nom        :  f_verif_dpg
   -- Auteur     :  Equipe SOPRA
   -- Decription :
   --
   -- Paramètres :  p_codsg   (IN)  code SG, peut avoir une valeur = '1313**'
   --                              ou '131312' ou '1312  ' (avec des blancs)
   --                              suivant la longueur, on recherchera un
   --                              département, un pôle ou un groupe.
   --
   -- Retour     :  renvoie TRUE si on trouve le DEP/POLE/GRP,
   --	        FALSE si la Facture n'est pas trouvée
   --	        Lève une erreur application en cas d'erreur Oracle
   -- ------------------------------------------------------------------------
   FUNCTION  f_verif_dpg(p_codsg   IN VARCHAR2) RETURN BOOLEAN ;


   -- ------------------------------------------------------------------------
   -- Nom        : verif_soccode_msg
   -- Auteur     : Equipe SOPRA
   -- Decription : vérifie l'existence d'une société,
   --              gère le message d'erreur standard et le focus passé
   -- Paramètres : p_soccode (IN)		   code société
   --              p_focus   (IN)            champ sur lequel mettre le focus
   --                                        en cas d'erreur
   --              p_msg     (OUT)           message d'erreur
   --
   -- ------------------------------------------------------------------------
   PROCEDURE verif_soccode_msg
     (p_soccode IN  SOCIETE.soccode%TYPE,
      p_focus IN  VARCHAR2,
      p_msg OUT VARCHAR2
     );

   -- ------------------------------------------------------------------------
   -- Nom        :  f_situ_codsg
   -- Auteur     :  Equipe SOPRA
   -- Decription :  retourne le codsg de la derniere situation de la ressource
   --
   -- Paramètres :  p_ident   (IN)  identifiant de la ressource
   --
   -- Retour     :  un varchar2 contenant le codsg
   -- ------------------------------------------------------------------------
   FUNCTION f_situ_codsg(p_ident IN RESSOURCE.ident%TYPE) RETURN VARCHAR2;
	   PRAGMA RESTRICT_REFERENCES(f_situ_codsg, wnds, wnps);


   -- ------------------------------------------------------------------------
   -- Nom        :  f_get_tva
   -- Auteur     :  Equipe SOPRA
   -- Decription :  retourne la tva correspondant à la date
   --
   -- Paramètres :  p_date (IN)  date
   --
   -- Retour     :  la TVA
   -- ------------------------------------------------------------------------
   FUNCTION f_get_tva(p_date IN DATE ) RETURN NUMBER;
	   PRAGMA RESTRICT_REFERENCES(f_get_tva, wnds, wnps);

END Pack_Utile;
/

CREATE OR REPLACE PACKAGE BODY Pack_Utile IS


   -- **********************************************************************
   -- Nom        : f_get_pnom_lbip
   -- Auteur     : Equipe SOPRA
   -- Decription : recupere le libelle d'une ligne bip
   -- Paramètres : p_pid (IN) identifiant du code projet
   --
   -- Retour     : le libelle du projet
   --
   -- **********************************************************************
   FUNCTION f_get_pnom_lbip(p_pid IN LIGNE_BIP.pid%TYPE) RETURN VARCHAR2 IS

      l_pnom LIGNE_BIP.pnom%TYPE;

   BEGIN
      SELECT  lib.pnom
	INTO  l_pnom
	FROM  LIGNE_BIP lib
	WHERE lib.pid = p_pid;

      RETURN l_pnom;

   END f_get_pnom_lbip;


     -- ------------------------------------------------------------------------
   -- Nom        :  f_get_ref_partenaire
   -- Decription :  savoir si une societe est partenaire avec un code de departement
   -- Paramètres :  p_coddep (IN) code departement
   --                            p_soccode (IN) code societe
   --
   -- Retour     :  Partenaire ou Non partenaire
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_get_ref_partenaire(p_coddep IN STRUCT_INFO.coddep%TYPE , p_soccode IN SOCIETE.soccode%TYPE) RETURN VARCHAR2 IS
	       l_lib NUMBER;
  BEGIN

		 SELECT COUNT(* ) INTO  l_lib
	     FROM  PARTENAIRE pa
	     WHERE pa.coddep = p_coddep
         AND pa.soccode = p_soccode;


         IF(l_lib = 0)THEN
            RETURN 'Non partenaire';
         ELSE
			  RETURN 'Partenaire';
		END IF;

   END f_get_ref_partenaire;




   -- **********************************************************************
   -- Nom        : f_get_codsg_lbip
   -- Auteur     : Equipe SOPRA
   -- Decription : recupere le codsg d'une ligne bip
   -- Paramètres : p_pid (IN) identifiant du code projet
   --
   -- Retour     : le code DEP/POL/GR de la ligne bip
   --
   -- **********************************************************************
   FUNCTION f_get_codsg_lbip(p_pid IN LIGNE_BIP.pid%TYPE) RETURN VARCHAR2 IS

      l_codsg LIGNE_BIP.codsg%TYPE;

   BEGIN
      SELECT  lib.codsg
   	INTO  l_codsg
   	FROM  LIGNE_BIP lib
   	WHERE lib.pid = p_pid;

      RETURN TO_CHAR(l_codsg, 'FM00000');

   END f_get_codsg_lbip;

   -- **********************************************************************
   -- Nom        : f_get_deppole
   -- Aute        : f_get_deppole
   -- Auteur     : Equipe SOPRA
   -- Decription : renvoie le département/pole, séparé par un '/'
   -- Paramètres : p_coddeppole (IN)     code département/pole
   --
   -- Retour     : renvoie le département/pole, séparé par un '/'
   --	           en cas d'erreur, renvoie une chaine vide.
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   --
   -- **********************************************************************
   FUNCTION f_get_deppole(p_coddeppole IN STRUCT_INFO.coddeppole%TYPE) RETURN VARCHAR2 IS
      l_ret VARCHAR2 (20);
   BEGIN
      SELECT  sigdep||'/'||sigpole INTO l_ret
	FROM STRUCT_INFO
	WHERE
	coddeppole = p_coddeppole
	AND ROWNUM <= 1;
      RETURN l_ret;
   EXCEPTION
      WHEN OTHERS THEN
	RETURN 'err :';
   END f_get_deppole ;

   -- **********************************************************************
   -- Nom        : f_get_deppole_codsg
   -- Auteur     : Equipe SOPRA
   -- Decription : renvoie le département/pole, séparé par un '/'
   -- Paramètres : p_codsg (IN)	code département/pole/Groupe
   --
   -- Retour     : renvoie le département/pole, séparé par un '/'
   --	          en cas d'erreur, renvoie une chaine vide.
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_get_deppole_codsg(p_codsg IN STRUCT_INFO.codsg%TYPE) RETURN VARCHAR2 IS
      l_ret VARCHAR2 (20);
   BEGIN
      SELECT  sigdep||'/'||sigpole INTO l_ret
	   FROM STRUCT_INFO
	   WHERE codsg = p_codsg
	         AND ROWNUM <= 1;
      RETURN l_ret;
   EXCEPTION
      WHEN OTHERS THEN 	RETURN '';
   END f_get_deppole_codsg ;


   -- **********************************************************************
   -- Nom        : f_get_dep
   -- Auteur     : Equipe SOPRA
   -- Decription : renvoie le département
   -- Paramètres : p_coddep (IN)		code département
   --
   -- Retour     : renvoie le département
   --	          en cas d'erreur, renvoie une chaine vide.
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_get_dep(p_coddep IN STRUCT_INFO.coddep%TYPE) RETURN VARCHAR2 IS
      l_ret VARCHAR2 (20);
   BEGIN
      SELECT  sigdep INTO l_ret
	   FROM STRUCT_INFO
	   WHERE 	coddep = p_coddep
	            AND ROWNUM <= 1;
      RETURN l_ret;
   EXCEPTION
      WHEN OTHERS THEN 	RETURN '';
   END f_get_dep ;


   -- **********************************************************************
   -- Nom        : f_get_filiale
   -- Auteur     : Equipe SOPRA
   -- Decription : renvoie la filiale et son identifiant
   -- Paramètres : p_filcode (IN)		code filiale
   --
   -- Retour     : renvoie la filiale et son identifiant
   --	          en cas d'erreur, renvoie une chaine vide.
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_get_filiale(p_filcode IN FILIALE_CLI.filcode%TYPE) RETURN VARCHAR2 IS
      l_ret VARCHAR2(40);
   BEGIN

      IF p_filcode IS NOT NULL THEN
	      SELECT filsigle
	      INTO   l_ret
	      FROM   FILIALE_CLI
	      WHERE  RTRIM(filcode)= RTRIM(p_filcode);

	      RETURN p_filcode || ' ' ||l_ret;

         ELSE	 RETURN '';
      END IF;

   EXCEPTION

      WHEN OTHERS THEN
	RETURN '';

   END f_get_filiale;


   -- **********************************************************************
   -- Nom        : f_verif_soccode
   -- Auteur     : Equipe SOPRA
   -- Decription : vérifie l'existence d'une société
   -- Paramètres : p_soccode (IN)		code société
   --
   -- Retour     : renvoie TRUE si on trouve la société
   --	          FALSE si la société n'est pas trouvé
   --	          Lève une erreur application en cas d'erreur Oracle
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_verif_soccode(p_soccode IN SOCIETE.soccode%TYPE) RETURN BOOLEAN IS
      l_count NUMBER;
   BEGIN
      -- TEST existente de la societe dans la table societe.
      BEGIN

         SELECT COUNT(*) INTO l_count
	      FROM   SOCIETE
	      WHERE  soccode = p_soccode;

	      IF (l_count != 1) THEN   RETURN FALSE ;
	                        ELSE 	 RETURN TRUE;
	      END IF ;

      EXCEPTION
	      WHEN OTHERS THEN  RAISE_APPLICATION_ERROR(-20997, SQLERRM);
      END;
   END f_verif_soccode;


   -- **********************************************************************
   --
   -- Nom        : f_verif_facture
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification directe de l'existence d'une facture
   -- Paramètres :
   --              p_tablefact IN            Nom de la table des factures
   --              p_socfact (IN)		code société
   --              p_numfact IN              Numéro facture
   --              p_typfact IN              Type facture
   --              p_datfact IN              date facture
   -- Retour     : renvoie TRUE si on trouve la Facture
   --	          FALSE si la Facture n'est pas trouvée
   --	          Lève une erreur application en cas d'erreur Oracle
   --
   -- Remarque :  Si p_tablefact différent de 'FACTURE' et 'HISTO_FACTURE'
   --             On retourne FAUX!!!
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_verif_facture(p_tablefact IN VARCHAR2,
			    p_socfact IN FACTURE.socfact%TYPE,
			    p_numfact IN FACTURE.numfact%TYPE,
			    p_typfact IN FACTURE.typfact%TYPE,
			    p_datfact IN FACTURE.datfact%TYPE
			   ) RETURN BOOLEAN IS
      l_count NUMBER;
      l_lgnumfact CONSTANT NUMBER := 15;  -- Length de la colonne numfact

   BEGIN

      -- TEST existence de la facture dans la table p_tablefact

      BEGIN
	      IF ( LTRIM(RTRIM(UPPER(p_tablefact))) = 'HISTO_FACTURE' )
            THEN
	            SELECT COUNT(*) INTO l_count
	            FROM   HISTO_FACTURE
	            WHERE  socfact = p_socfact AND
	            numfact = RPAD(p_numfact, l_lgnumfact) AND
	            typfact = p_typfact AND
	            datfact = p_datfact;
	         ELSIF ( LTRIM(RTRIM(UPPER(p_tablefact))) = 'FACTURE' )
                  THEN
	                  SELECT COUNT(*) INTO l_count
	                  FROM   FACTURE
	                  WHERE  socfact = p_socfact AND
	                  numfact = RPAD(p_numfact, l_lgnumfact) AND
	                  typfact = p_typfact AND
	                  datfact = p_datfact;
	               ELSE  l_count := 0;
	      END IF;

	      IF (l_count != 1)   THEN   RETURN FALSE ;
	                          ELSE   RETURN TRUE;
	      END IF ;
      EXCEPTION
         WHEN OTHERS THEN  RAISE_APPLICATION_ERROR(-20997, SQLERRM);
      END;
   END f_verif_facture;

   -- **********************************************************************
   --
   -- Nom        : f_verif_numfact
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence d'un N° de facture
   -- Paramètres :
   --              p_tablefact IN            Nom de la table des factures
   --              p_numfact IN              Numéro facture
   -- Retour     : renvoie TRUE si on trouve le N° de Facture dans la table p_tablefact
   --	          FALSE si la Facture n'est pas trouvée
   --	          Lève une erreur application en cas d'erreur Oracle
   --
   -- Remarque :  Si p_tablefact différent de 'FACTURE' et 'HISTO_FACTURE'
   --             On retourne FAUX!!!
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_verif_numfact(p_tablefact IN VARCHAR2,
			    p_numfact IN FACTURE.numfact%TYPE
			   ) RETURN BOOLEAN IS
      l_count NUMBER;
      l_lgnumfact CONSTANT NUMBER := 15;  -- Length de la colonne numfact

   BEGIN
      -- TEST existente du N° de facture dans la table p_tablefact
      BEGIN
      	IF ( LTRIM(RTRIM(UPPER(p_tablefact))) = 'HISTO_FACTURE' ) THEN
	         SELECT COUNT(*) INTO l_count
	         FROM   HISTO_FACTURE
	         WHERE  numfact = RPAD(p_numfact, l_lgnumfact);
	      ELSIF ( LTRIM(RTRIM(UPPER(p_tablefact))) = 'FACTURE' ) THEN
	         SELECT COUNT(*) INTO l_count
	         FROM   FACTURE
	         WHERE  numfact = RPAD(p_numfact, l_lgnumfact);
	      ELSE
	         l_count := 0;
	      END IF;

	      IF (l_count = 0) THEN    RETURN FALSE;
	                       ELSE    RETURN TRUE;
	      END IF ;

      EXCEPTION
	      WHEN OTHERS THEN  RAISE_APPLICATION_ERROR(-20997, SQLERRM);
      END;
   END f_verif_numfact;


   -- **********************************************************************
   -- Nom        : verif_soccode_msg
   -- Auteur     : Equipe SOPRA
   -- Decription : vérifie l'existence d'une société,
   --              gère le message d'erreur standard et le focus passé
   -- Paramètres : p_soccode (IN)		   code société
   --              p_focus   (IN)            champ sur lequel mettre le focus
   --                                        en cas d'erreur
   --              p_msg     (OUT)           message d'erreur
   --
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --               ANO 074 : on retournait pas le message (stocké dans une variable locale)
   -- **********************************************************************
   PROCEDURE verif_soccode_msg
     (p_soccode IN  SOCIETE.soccode%TYPE,
      p_focus IN  VARCHAR2,
      p_msg OUT VARCHAR2
     ) IS
   BEGIN
      IF (p_soccode IS NOT NULL) THEN
      	 IF (f_verif_soccode(p_soccode) = FALSE) THEN
	          Pack_Global.recuperer_message(Pack_Utile_Numsg.nuexc_soccode_inexistant, NULL, NULL , p_focus, p_msg);
      	 END IF ;
      END IF ;
   END verif_soccode_msg;


   -- **********************************************************************
   -- Nom        : f_verif_dpg
   -- Auteur     : Equipe SOPRA
   -- Decription :
   --
   -- Paramètres : p_codsg   (IN)  code SG, peut avoir une valeur = '1313**'
   --                              ou '131312' ou '1312  ' (avec des blancs)
   --                              suivant la longueur, on recherchera un
   --                              département, un pôle ou un groupe.
   --
   -- Retour     : renvoie TRUE si on trouve le DEP/POLE/GRP,
   --	        FALSE si la Facture n'est pas trouvée
   --	        Lève une erreur application en cas d'erreur Oracle
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --          MRZ  creation?
   -- 29/12/99 QHL  ajout FM000000 pour prendre en compte cas ancien code
   -- **********************************************************************
   FUNCTION  f_verif_dpg(p_codsg   IN VARCHAR2
             				) RETURN BOOLEAN IS
      l_codsg2 STRUCT_INFO.codsg%TYPE;

   BEGIN
      -- P_codsg peut avoir une valeur = '1313**' ou '131312' ou '1312  ' (avec des blancs)
      -- S'il possed un metacaractere (' ', '*'), on va le supprimer
      -- Puis former la condition Where du Select en fonction du longueur de P_codsg

      SELECT   codsg  INTO  l_codsg2
      FROM   STRUCT_INFO
	-- On formate codsg sur 7 caracteres et on le compare avec p_codsg qui est également formaté sur 7 caracteres.
	-- Ensuite on enleve les '*'
	WHERE  SUBSTR(TO_CHAR(codsg,'FM0000000'),1, LENGTH(RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*')))) = RTRIM(RTRIM(LPAD(p_codsg,7,'0'),'*'))
	      AND ROWNUM <= 1;

      RETURN TRUE;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN  RETURN FALSE;
      WHEN OTHERS        THEN	 RAISE_APPLICATION_ERROR(-20997,SQLERRM);
   END  f_verif_dpg;


   -- **********************************************************************
   -- Nom        : f_situ_codsg
   -- Auteur     : Equipe SOPRA
   -- Decription : retourne le codsg de la derniere situation de la ressource
   --
   -- Paramètres : p_ident   (IN)  identifiant de la ressource
   --
   -- Retour     : un varchar2 contenant le codsg
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_situ_codsg (p_ident IN RESSOURCE.ident%TYPE) RETURN VARCHAR2 IS
     l_ret VARCHAR2(20);
   BEGIN
     SELECT  MAX(codsg)
       INTO  l_ret
     FROM  SITU_RESS
     WHERE datsitu = (SELECT MAX(datsitu)
	               	FROM   SITU_RESS
		               WHERE  ident = p_ident
		               GROUP BY ident)
       AND   ident = p_ident;

     RETURN l_ret;
   EXCEPTION
     WHEN OTHERS THEN   RETURN 'err :';
   END f_situ_codsg ;

  -- **********************************************************************
  -- Nom        : f_get_deppolegrpe
  -- Auteur     : Equipe SOPRA
  -- Decription : retourne le libelle correspondant au groupe
  --
  -- Paramètres : p_codsg  (IN) code sg du groupe
  --
  -- Retour     : un varchar2 le libelle du dep/pole/groupe
  -- Quand    Qui  Quoi
  -- -----    ---  --------------------------------------------------------
  --
  -- **********************************************************************
  FUNCTION f_get_deppolegrpe(p_codsg IN STRUCT_INFO.codsg%TYPE) RETURN VARCHAR2 IS
      l_ret VARCHAR2 (30);
   BEGIN
      SELECT  libdsg INTO l_ret
      	FROM  STRUCT_INFO
	      WHERE codsg = p_codsg
	            AND ROWNUM <= 1;
      RETURN l_ret;
   EXCEPTION
      WHEN OTHERS THEN 	RETURN 'err :';
   END f_get_deppolegrpe ;

  -- **********************************************************************
  -- Nom        : f_get_tva
  -- Auteur     : Equipe SOPRA
  -- Decription : retourne la tva correspondant à la date ???
  --
  -- Paramètres : p_date (IN)  date
  --
  -- Retour     : la TVA
  -- **********************************************************************
  FUNCTION f_get_tva(p_date IN DATE ) RETURN NUMBER IS
     l_ret NUMBER;
  BEGIN

     SELECT TVA INTO l_ret
       FROM TVA
       WHERE datetva IS NOT NULL AND
       datetva = (SELECT MAX(datetva) FROM TVA WHERE datetva IS NOT NULL);
     RETURN  l_ret;

  EXCEPTION
     WHEN OTHERS THEN   RETURN 0;
  END ;

END Pack_Utile;
/
CREATE OR REPLACE PACKAGE pack_utile3A IS
   -- ------------------------------------------------------------------------
   -- Nom        : f_verif_dpg_edipara
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence Dpt/Pôle/Groupe dans table des DPG
   -- Paramètres :
   --              p_codsg IN            Code DPG
   -- Retour     : renvoie TRUE si on trouve le code DPG
   --	          	FALSE sinon
   --
   -- Remarque : P_codsg peut être de l'une des formes ci-dessous (n désignant 1 entier quelconque) :
   --            'nnnnnnn'
   --            '*******', '       ',
   --            'nnn****', 'nnn    ',
   --            'nnnnn**', 'nnnnn  '
   --            EN PRINCIPE, l'écran de saisie EDIPARA n'autorise que les CODSG sur 7 positions
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_verif_dpg_edipara(p_codsg IN VARCHAR2) RETURN BOOLEAN;



   -- ------------------------------------------------------------------------
   --
   -- Nom        : verif_date_codsg_edipara
   -- Auteur     : Equipe SOPRA
   -- Decription : Vérification des paramètres Date et Code Dpt/Pôle/Groupe des éditions paramétrées
   -- Paramètres :
   --              p_mois_annee (IN)		Mois et Année traitée
   --              p_codsg      (IN) 		Code DPG
   --		    P_message OUT             Message de sortie
   --
   -- Remarque :
   --
   -- ------------------------------------------------------------------------

   PROCEDURE verif_date_codsg_edipara(
                 p_mois_annee IN  VARCHAR2,	     -- CHAR(7) (Format MM/AAAA)
                 p_codsg IN  VARCHAR2,               -- CHAR(7)
                 P_message OUT VARCHAR2
                 );


   -- ------------------------------------------------------------------------
   -- Nom        : f_verif_factpid_proplus
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence FACTPID  dans table PROPLUS
   -- Paramètres :
   --              p_factpid IN            Code projet
   -- Retour     : renvoie TRUE si on trouve le code projet
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   --
   -- ------------------------------------------------------------------------
   FUNCTION  f_verif_factpid_proplus(p_factpid  IN proplus.factpid%TYPE) RETURN BOOLEAN ;


   -- ------------------------------------------------------------------------
   -- Nom        : f_verif_pid_ligne_bip
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence PID  dans table LIGNE_BIP
   -- Paramètres :
   --              p_pid IN            Code projet
   -- Retour     : renvoie TRUE si on trouve le code projet
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   --
   -- ------------------------------------------------------------------------
   FUNCTION  f_verif_pid_ligne_bip(p_pid  IN ligne_bip.pid%TYPE) RETURN BOOLEAN ;

END pack_utile3A;
/

CREATE OR REPLACE PACKAGE BODY pack_utile3A IS

   -- **********************************************************************
   --
   -- Nom        : f_verif_dpg_edipara
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence Dpt/Pôle/Groupe dans table des DPG (struct_info)
   -- Paramètres :
   --              p_codsg IN            Code DPG
   -- Retour     : renvoie TRUE si on trouve le code DPG
   --	          	FALSE sinon
   --
   -- Remarque : P_codsg peut être de l'une des formes ci-dessous (n désignant 1 entier quelconque) :
   --            'nnnnnnn'
   --            '*******', '       ',
   --            'nnn****', 'nnn    ',
   --            'nnnnn**', 'nnnnn  '
   --            EN PRINCIPE, l'écran de saisie EDIPARA n'autorise que les CODSG sur 7 positions
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_verif_dpg_edipara(p_codsg IN VARCHAR2) RETURN BOOLEAN IS
	l_car_meta_etoile CONSTANT CHAR(1) := '*';
	l_car_meta_blanc  CONSTANT CHAR(1) := ' ';

   BEGIN


      BEGIN

		IF ( (p_codsg IS NULL)
				OR
			(p_codsg = l_car_meta_etoile || l_car_meta_etoile || l_car_meta_etoile || l_car_meta_etoile
					|| l_car_meta_etoile || l_car_meta_etoile || l_car_meta_etoile
			)
				OR
			(p_codsg = l_car_meta_blanc || l_car_meta_blanc || l_car_meta_blanc || l_car_meta_blanc
					|| l_car_meta_blanc || l_car_meta_blanc || l_car_meta_blanc
                  )
		   ) THEN
			-------------------------------------------------------------------------------------------
			-- CAS : p_codsg NULL ou égal à 7 étoiles ou 7 blancs :
			-- On veut traiter tous les Dpt/Pôle/Groupe : FAUT DONC RETOURNER VRAI !!!
			------------------------------------------------------------------------------------------
			RETURN(TRUE);
		ELSE
			-------------------------------------------------------------------------------------------
			-- CAS AUTRE: Appel à la fonction  pack_utile.f_verif_dpg
			------------------------------------------------------------------------------------------
			IF ( pack_utile.f_verif_dpg(p_codsg) = TRUE )
			THEN
				RETURN(TRUE);
			ELSE
				RETURN(FALSE);
			END IF;

		END IF;

      END;

   END f_verif_dpg_edipara;





   -- ------------------------------------------------------------------------
   --
   -- Nom        : verif_prodeta
   -- Auteur     : Equipe SOPRA
   -- Decription : Vérification des paramètres saisis pour l'etat $PRODETA
   -- Paramètres :
   --              p_mois_annee (IN)		Mois et Année traitée
   --              p_codsg      (IN) 		Code DPG
   --		    P_message OUT             Message de sortie
   --
   -- Remarque :
   --
   -- ------------------------------------------------------------------------

PROCEDURE verif_date_codsg_edipara (
                 p_mois_annee IN  VARCHAR2,	     -- CHAR(7) (Format MM/AAAA)
                 p_codsg IN  VARCHAR2,               -- CHAR(7)
                 P_message OUT VARCHAR2
                 ) IS

      l_message   VARCHAR2(1024) := '';
      l_num_exception NUMBER;
	-- nuexc_coddpg_invalide3    CONSTANT NUMBER := 20430; --  Code Département/Pôle/Groupe %s1 invalide
	l_nuexc_date_sup_dat_cour CONSTANT NUMBER := 20603;
	l_nuexc_mois_trop_ancien CONSTANT NUMBER := 20605;

	l_mois_annee_du_jour VARCHAR2(7);  		-- Date jour au format MM/YYYY


BEGIN

   BEGIN

		-----------------------------------------------------------------------------
		-- Récupération date du jour !
		-----------------------------------------------------------------------------
		SELECT TO_CHAR(sysdate, 'MM/YYYY') INTO l_mois_annee_du_jour FROM dual;

		EXCEPTION
	 		WHEN OTHERS THEN
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
   END;


   BEGIN

	---------------------------------------------------------------------------------------------
	-- (1) Vérification Si Date saisie <= Date Système
	---------------------------------------------------------------------------------------------
	IF ( TO_DATE('01/' || p_mois_annee, 'DD/MM/YYYY') > TO_DATE('01/' || l_mois_annee_du_jour , 'DD/MM/YYYY') )
	THEN
		pack_global.recuperer_message(l_nuexc_date_sup_dat_cour , NULL, NULL , ' P_param6 ', l_message);
            l_num_exception := l_nuexc_date_sup_dat_cour;
	END IF;

	---------------------------------------------------------------------------------------------
	-- (2) Vérification Si Date saisie >= Date Système - 14 mois
	---------------------------------------------------------------------------------------------
	IF (l_message IS NULL)
	THEN
		IF ( TO_DATE('01/' || p_mois_annee, 'DD/MM/YYYY')
				<
	     		ADD_MONTHS( TO_DATE('01/' || l_mois_annee_du_jour , 'DD/MM/YYYY'), -14 )
	    	    )
		THEN
			pack_global.recuperer_message(l_nuexc_mois_trop_ancien, NULL, NULL , ' P_param6 ', l_message);
            	l_num_exception := l_nuexc_mois_trop_ancien;
		END IF;
	END IF;

	---------------------------------------------------------------------------------------------
	-- (3) Vérification existence Code DPG dans la table des DPG (Table struct_info)
	---------------------------------------------------------------------------------------------
	IF (l_message IS NULL)
	THEN
		IF ( pack_utile3A.f_verif_dpg_edipara(p_codsg) = FALSE )
		THEN
                  pack_global.recuperer_message(pack_utile_numsg.nuexc_coddpg_invalide3, '%s1',
                                                p_codsg, ' P_param7 ', l_message);
                  l_num_exception := pack_utile_numsg.nuexc_coddpg_invalide3;
		END IF;
      END IF;

      p_message := l_message;

      IF (l_message IS NOT NULL) THEN
          RAISE_APPLICATION_ERROR(-l_num_exception, l_message);
      END IF;

   END;

END verif_date_codsg_edipara;





   -- **********************************************************************
   -- Nom        : f_verif_factpid_proplus
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence FACTPID  dans table PROPLUS
   -- Paramètres :
   --              p_factpid IN            Code projet
   -- Retour     : renvoie TRUE si on trouve le code projet
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   -- 25/01/00  	HTM  	Création
   --
   -- **********************************************************************
   FUNCTION f_verif_factpid_proplus(p_factpid   IN proplus.factpid%TYPE) RETURN BOOLEAN IS
      l_count NUMBER := 0;
   BEGIN

      BEGIN

         SELECT count(*) INTO l_count
	      FROM   proplus
	      WHERE  factpid = p_factpid;

	      IF (l_count = 0)  THEN   RETURN false ;
	                        ELSE 	 RETURN true;
	      END IF ;

      EXCEPTION
	      WHEN OTHERS THEN  raise_application_error(-20997, sqlerrm);
      END;

   END f_verif_factpid_proplus;





   -- **********************************************************************
   -- Nom        : f_verif_pid_ligne_bip
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence PID  dans table LIGNE_BIP
   -- Paramètres :
   --              p_pid IN            Code projet
   -- Retour     : renvoie TRUE si on trouve le code projet
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   -- **********************************************************************
   FUNCTION f_verif_pid_ligne_bip(p_pid   IN ligne_bip.pid%TYPE) RETURN BOOLEAN IS
      l_count NUMBER := 0;
   BEGIN

      BEGIN

         SELECT count(*) INTO l_count
	      FROM   ligne_bip
	      WHERE  pid = p_pid;

	      IF (l_count = 0)  THEN   RETURN false ;
	                        ELSE 	 RETURN true;
	      END IF ;

      EXCEPTION
	      WHEN OTHERS THEN  raise_application_error(-20997, sqlerrm);
      END;
   END f_verif_pid_ligne_bip;



END pack_utile3A;
/
CREATE OR REPLACE PACKAGE pack_utile3B IS
-----------------------------------------

   -- ------------------------------------------------------------------------
   -- Nom        : f_verif_airt_application
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : vérification existence Identifiant application (AIRT) dans table APPLICATION
   -- Paramètres :
   --              p_airt IN            Identifiant Application
   -- Retour     : renvoie TRUE si on trouve l'identifiant
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   -- ------------------------------------------------------------------------
   FUNCTION f_verif_airt_application(p_airt  IN application.airt%TYPE) RETURN BOOLEAN;

   -- ------------------------------------------------------------------------
   -- Nom        : f_verif_icpi_proj_info
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : vérification existence Identifiant projet (ICPI) dans table PROJ_INFO
   -- Paramètres :
   --              p_icpi IN            Identifiant Projet
   -- Retour     : renvoie TRUE si on trouve l'identifiant
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   -- ------------------------------------------------------------------------
   FUNCTION f_verif_icpi_proj_info(p_icpi  IN proj_info.icpi%TYPE) RETURN BOOLEAN;



-- ------------------------------------------------------------------------
   -- Nom        : f_get_top_immo_bip_clicode
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : Retourne le top_immo à partir du code client de ligne bip
   -- Paramètres :
   --              p_clicode IN            Code client de la ligne BIP
   -- Retour     : Top_immo
   --
   -- Remarque :
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
-- ------------------------------------------------------------------------
   FUNCTION f_get_top_immo_bip_clicode(p_clicode  IN ligne_bip.clicode%TYPE) RETURN VARCHAR2;
		PRAGMA restrict_references(f_get_top_immo_bip_clicode, WNDS, WNPS);


-- ------------------------------------------------------------------------
   -- Nom        : f_verif_existence_dpg
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : Test existence Ligne BIP contenant DPG compris entre 2 bornes
   -- Paramètres :
   --              p_codsg_inf IN            Code DPG Inf
   --              p_codsg_sup IN            Code DPG Sup
   -- Retour     : TRUE Si existence, FALSE Sinon
   --
   -- Remarque :
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
-- ------------------------------------------------------------------------
   FUNCTION f_verif_existence_dpg(p_codsg_inf IN ligne_bip.codsg%TYPE,
					    p_codsg_sup ligne_bip.codsg%TYPE
					   ) RETURN BOOLEAN;

-- ------------------------------------------------------------------------
   -- Nom        : f_get_clisigle_climo
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : Renvoi le sigle Direction/Dpt d'un client MO en fonction du code client MO
   -- Paramètres :
   --              p_clicode IN            Code Client MO
   -- Retour     : Sigle Direction/Dpt d'un client MO en fonction du code client MO
   --	          	 ou chaîne vide si on ne trouve rien.
   --
   -- Remarque :
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
-- ------------------------------------------------------------------------
   FUNCTION  f_get_clisigle_climo(p_clicode  IN client_mo.clicode%TYPE) RETURN VARCHAR2;
	PRAGMA restrict_references(f_get_clisigle_climo,WNDS, WNPS);


-- ------------------------------------------------------------------------
   -- Nom        : f_verif_pid_histo_amort
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence PID  dans table HISTO_AMORT
   -- Paramètres :
   --              p_pid IN            Code projet
   -- Retour     : renvoie TRUE si on trouve le code projet
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
-- ------------------------------------------------------------------------
   FUNCTION  f_verif_pid_histo_amort(p_pid  IN histo_amort.pid%TYPE) RETURN BOOLEAN ;


END pack_utile3B;
/

CREATE OR REPLACE PACKAGE BODY pack_utile3B IS
----------------------------------------------

   -- **********************************************************************
   -- Nom        : f_verif_airt_application
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : vérification existence Identifiant application (AIRT) dans table APPLICATION
   -- Paramètres :
   --              p_airt IN            Identifiant Application
   -- Retour     : renvoie TRUE si on trouve l'identifiant
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   -- **********************************************************************
   FUNCTION f_verif_airt_application(p_airt  IN application.airt%TYPE) RETURN BOOLEAN IS
      l_count NUMBER := 0;
   BEGIN

      BEGIN

         	SELECT count(*) INTO l_count
	      FROM   application
	      WHERE  airt = p_airt;

	      IF (l_count = 0)  THEN   RETURN false ;
	                        ELSE 	 RETURN true;
	      END IF ;

      EXCEPTION
	      WHEN OTHERS THEN  raise_application_error(-20997, sqlerrm);
      END;

   END f_verif_airt_application;

   -- **********************************************************************
   -- Nom        : f_verif_icpi_proj_info
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : vérification existence Identifiant projet (ICPI) dans table PROJ_INFO
   -- Paramètres :
   --              p_icpi IN            Identifiant Projet
   -- Retour     : renvoie TRUE si on trouve l'identifiant
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   -- **********************************************************************
   FUNCTION f_verif_icpi_proj_info(p_icpi  IN proj_info.icpi%TYPE) RETURN BOOLEAN IS
      l_count NUMBER := 0;
   BEGIN

      BEGIN

         	SELECT count(*) INTO l_count
	      FROM   proj_info
	      WHERE  icpi = p_icpi;

	      IF (l_count = 0)  THEN   RETURN false ;
	                        ELSE 	 RETURN true;
	      END IF ;

      EXCEPTION
	      WHEN OTHERS THEN  raise_application_error(-20997, sqlerrm);
      END;

   END f_verif_icpi_proj_info;



   -- **********************************************************************
   -- Nom        : f_get_filcode_clicode
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : Retourne le code filiale associé au code client en entrée
   -- Paramètres :
   --              p_clicode IN            Code client
   -- Retour     : Code filiale
   --
   -- Remarque :
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_get_filcode_clicode(p_clicode  IN ligne_bip.clicode%TYPE) RETURN VARCHAR2 IS
      l_ret VARCHAR2(10);

   BEGIN

	SELECT fil.top_immo
	INTO l_ret
	FROM client_mo cmo, filiale_cli fil
	WHERE cmo.clicode = p_clicode
		AND fil.filcode = cmo.filcode;

      RETURN l_ret;

   EXCEPTION
	WHEN OTHERS THEN  RETURN '';

   END f_get_filcode_clicode;


   -- **********************************************************************
   -- Nom        : f_get_top_immo_bip_clicode
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : Retourne le top_immo à partir du code client de ligne bip
   -- Paramètres :
   --              p_clicode IN            Code client de la ligne BIP
   -- Retour     : Top_immo
   --
   -- Remarque :
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_get_top_immo_bip_clicode(p_clicode  IN ligne_bip.clicode%TYPE) RETURN VARCHAR2 IS
      l_ret VARCHAR2(10);

   BEGIN

	SELECT fil.top_immo
	INTO l_ret
	FROM client_mo cmo, filiale_cli fil
	WHERE cmo.clicode = p_clicode
		AND fil.filcode = cmo.filcode;

      RETURN l_ret;

   EXCEPTION
	WHEN OTHERS THEN  RETURN '';

   END f_get_top_immo_bip_clicode;


   -- **********************************************************************
   -- Nom        : f_verif_existence_dpg
   -- Auteur     : Equipe SOPRA (HTM)
   -- Decription : Test existence Ligne BIP contenant DPG compris entre 2 bornes
   -- Paramètres :
   --              p_codsg_inf IN            Code DPG Inf
   --              p_codsg_sup IN            Code DPG Sup
   -- Retour     : TRUE Si existence, FALSE Sinon
   --
   -- Remarque :
   --
   -- Quand    	Qui  	Quoi
   -- -----    	---  	--------------------------------------------------------
   -- **********************************************************************
   FUNCTION f_verif_existence_dpg(p_codsg_inf IN ligne_bip.codsg%TYPE,
					    p_codsg_sup ligne_bip.codsg%TYPE
					   ) RETURN BOOLEAN IS
      l_count NUMBER := 0;
   BEGIN

      BEGIN

         SELECT count(*) INTO l_count
	      FROM   ligne_bip
	      WHERE  codsg BETWEEN  p_codsg_inf AND p_codsg_sup;

	      IF (l_count = 0)  THEN   RETURN false ;
	                        ELSE 	 RETURN true;
	      END IF ;

      EXCEPTION
	      WHEN OTHERS THEN  raise_application_error(-20997, sqlerrm);
      END;

   END f_verif_existence_dpg;


   -- **********************************************************************
   -- Nom        : f_get_clisigle_climo
   -- Auteur     : Equipe SOPRA
   -- Decription : renvoie le département/pole, séparé par un '/'
   -- Paramètres : p_clicode (IN)     code Client MO
   --
   -- Retour     : Sigle Direction/Dpt d'un client MO en fonction du code client MO
   --	          	 ou chaîne vide si on ne trouve rien ou si erreur.
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   --
   -- **********************************************************************
   FUNCTION  f_get_clisigle_climo(p_clicode  IN client_mo.clicode%TYPE)RETURN VARCHAR2 IS
      -- l_ret VARCHAR2 (20);
	l_ret client_mo.clisigle%TYPE;

   BEGIN
      SELECT  clisigle INTO l_ret
	FROM client_mo
	WHERE clicode = p_clicode AND ROWNUM <= 1;

      RETURN l_ret;

   EXCEPTION
	WHEN OTHERS THEN  RETURN '';
   END f_get_clisigle_climo;


   -- **********************************************************************
   -- Nom        : f_verif_pid_histo_amort
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : vérification existence PID  dans table HISTO_AMORT
   -- Paramètres :
   --              p_pid IN            Code projet
   -- Retour     : renvoie TRUE si on trouve le code projet
   --	          	FALSE sinon
   --
   -- Remarque :
   --
   -- Quand    Qui  Quoi
   -- -----    ---  --------------------------------------------------------
   --
   -- **********************************************************************
   FUNCTION f_verif_pid_histo_amort(p_pid  IN histo_amort.pid%TYPE) RETURN BOOLEAN IS
      l_count NUMBER := 0;
   BEGIN

      BEGIN

         SELECT count(*) INTO l_count
	      FROM   histo_amort
	      WHERE  pid = p_pid;

	      IF (l_count = 0)  THEN   RETURN false ;
	                        ELSE 	 RETURN true;
	      END IF ;

      EXCEPTION
	      WHEN OTHERS THEN  raise_application_error(-20997, sqlerrm);
      END;
   END f_verif_pid_histo_amort;



END pack_utile3B;
/
CREATE OR REPLACE PACKAGE pack_Utile3c AS
-- ----------------------------------------------------------------------------
-- FUNCTION qui verifie l'habilitation d'un utlisateur sur un Dep Pole.
   FUNCTION f_Habilit_DP (
                       p_global   IN CHAR,
                       -- p_global contient l'identifiant codedeppole de l'utilisateur.
                       p_DepPole  IN VARCHAR2
                       ) RETURN BOOLEAN;

END pack_Utile3c;
/

CREATE OR REPLACE PACKAGE BODY pack_Utile3c AS
-- ============================================================================
-- FUNCTION qui verifie l'habilitation d'un utlisateur sur un Dep Pole.
--          Attention, les colonnes Pole1 à Pole9 de la table Userbip ne sont
--          pas vérifie. Seule la colonne codpole est prise en compte.
-- Parametres :
--      - p_global : qui contient l'identifiant codedeppole de l'utilisateur
--      - p_DepPole : code departement Pole, il peut prendre les valeurs suivantes
--                    - '01313',
--                    - la chaine '*****' (tous les dep poles)
--                    - '024**' (tous les poles du dep 24)
-- Valeurs Retour :
--      - True : s'il a l'habilitation
--      - False : Il n'a pas l'habilitation Dep Pole
-- ----------------------------------------------------------------------------
 FUNCTION f_Habilit_DP (
                       p_global   IN CHAR,
                       p_DepPole  IN VARCHAR2
                       ) RETURN BOOLEAN IS

   l_UserDP VARCHAR2(4);
   l_ret    VARCHAR2(1);
 BEGIN
      -- Les utilisateur avec code deppole 0000 ont droit à tous les deppole
      l_ret := 'V'; -- par defaut on suppose qu'il a droit à tous

      l_UserDP := SUBSTR(pack_global.lire_globaldata(p_global).codpole, 1,5);
      l_UserDP := RTRIM(l_UserDP,'0'); -- Supprimer des zero à la fin

      IF (LENGTH (l_UserDP) = 1) or (LENGTH (l_UserDP) = 2) or (LENGTH (l_UserDP) = 4) THEN
         l_UserDP := RPAD(l_UserDP, '0');
      END IF;

      IF LENGTH (l_UserDP) = 0 THEN
         null;                    -- droit au dep et au pole
      ELSIF LENGTH (l_UserDP) = 3 THEN     -- Il a un pole 00
         IF l_UserDP != SUBSTR(p_DepPole,1,2) THEN
            l_ret := 'F';                 -- droit au pole uniquement
         END IF;
      ELSIF LENGTH (l_UserDP) = 5 THEN
         IF l_UserDP != p_DepPole THEN
            l_ret := 'F';                 -- droit au dep et au pole
         END IF;
      END IF;

      IF l_ret = 'V' THEN
         return TRUE;
      ELSE
         return FALSE;
      END IF;

 END f_Habilit_DP ;


END pack_Utile3c;
/
CREATE OR REPLACE PACKAGE pack_utile_cout IS
   FUNCTION getCout( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number) Return Number;

  FUNCTION getCoutTTC ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number,
					  p_cdeb    varchar2 ) Return Number;


  FUNCTION AppliqueTauxHTR (   p_annee   number,
					  p_montant number,
					  p_cdeb    varchar2,
					  p_filcode varchar2 ) Return Number;

  FUNCTION getCoutHTR ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number,
					  p_cdeb    varchar2,
					  p_filcode varchar2 ) Return Number ;

FUNCTION getCoutEnv ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_codsg   number  ) Return Number ;

/******************************************************************************
   NAME:       pack_utile_cout
   PURPOSE:    Contient des fonctions de calcul des couts utilisés dans
   		les états et dans les procédures

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        31/03/2005   PPR 			Repris de pack_x_ressmoi
			  02/11/2005   PPR          Rajout d'une fonction pour les couts d'environnement


******************************************************************************/
END pack_utile_cout;
/

CREATE OR REPLACE PACKAGE BODY pack_utile_cout AS


-- Renvoie le cout en fonction du type de ressource
FUNCTION getCout ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number ) Return Number IS
l_cout NUMBER(12,2);
BEGIN
l_cout:=0;

 if (p_soccode='SG..') then
 	select cout_sg into l_cout
	from cout_std_sg
	where p_codsg between dpg_bas and dpg_haut
	and metier = rtrim(p_metier)
	and niveau = decode(p_niveau,'L','HC','M','HC','N','HC',p_niveau)
	and annee = p_annee;
 else
 	 if p_rtype='L' then
	 	select cout_log into l_cout
		from cout_std2
		where p_codsg between dpg_bas and dpg_haut
	 	and annee = p_annee;

	 else
	 	 l_cout := p_cout_ssii;

	 end if;

 end if;


   RETURN l_cout;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       RETURN l_cout;
     WHEN OTHERS THEN
       RETURN l_cout;
END getCout;

-- Renvoie le cout TTC en fonction du type de ressource
FUNCTION getCoutTTC ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number,
					  p_cdeb    varchar2 ) Return Number IS
l_coutTTC NUMBER(12,2);
l_tva tva.tva%TYPE;
BEGIN
l_coutTTC:=0;

	-- Recherche le cout
	l_coutTTC :=getCout ( p_soccode, p_rtype, p_annee, p_metier, p_niveau, p_codsg, p_cout_ssii );

	-- Si ce n'est pas un logiciel et c'est un prestataire
	if (p_rtype<>'L' and p_soccode<>'SG..') then

		-- Recherche du taux de tva
		BEGIN
			SELECT t.tva into l_tva
       			FROM tva t
       			WHERE
       			t.datetva = (SELECT max(tva.datetva) FROM tva where datetva <= to_date(p_cdeb,'DD/MM/YYYY'));
      		EXCEPTION
         	WHEN OTHERS THEN
         	        -- Code TVA inexistant
            		l_tva := 0 ;
      		END;

		-- Applique la TVA au cout
		l_coutTTC := l_coutTTC * ( 1 + l_tva/100 ) ;
	end if ;

   RETURN l_coutTTC;

END getCoutTTC;


-- Applique le taux HTR à un montant
FUNCTION AppliqueTauxHTR (   p_annee   number,
					  p_montant number,
					  p_cdeb    varchar2,
					  p_filcode varchar2 ) Return Number IS
l_montant NUMBER(12,2);
l_tva tva.tva%TYPE;
l_taux_recup taux_recup.taux%TYPE;
BEGIN
l_montant:=p_montant;

	-- Recherche du taux de tva
	BEGIN
		SELECT t.tva into l_tva
		FROM tva t
		WHERE
		t.datetva = (SELECT max(tva.datetva) FROM tva where datetva <= to_date(p_cdeb,'DD/MM/YYYY'));
	EXCEPTION
 	WHEN OTHERS THEN
 	        -- Code TVA inexistant
    		l_tva := 0 ;
	END;

	-- Recherche du taux de récupération pour la filiale
	BEGIN
		SELECT taux into l_taux_recup
		FROM taux_recup
		WHERE	annee = p_annee
		and 	filcode = p_filcode ;

	EXCEPTION
 	WHEN OTHERS THEN
 	        -- Taux de récupération non trouvé
		l_taux_recup := 0 ;
	END;

	-- Applique la TVA et le taux de récup au montant
	l_montant := l_montant * ( 1 + l_tva/100 * (1 - l_taux_recup/100) ) ;

   RETURN l_montant;

END AppliqueTauxHTR;


-- Renvoie le cout HTR en fonction du type de ressource
FUNCTION getCoutHTR ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number,
					  p_cdeb    varchar2,
					  p_filcode varchar2 ) Return Number IS
l_coutHTR NUMBER(12,2);
l_tva tva.tva%TYPE;
l_taux_recup taux_recup.taux%TYPE;
BEGIN
l_coutHTR:=0;

	-- Recherche le cout
	l_coutHTR :=getCout ( p_soccode, p_rtype, p_annee, p_metier, p_niveau, p_codsg, p_cout_ssii );

	-- Si ce n'est pas un logiciel et c'est un prestataire
	if (p_rtype<>'L' and p_soccode<>'SG..') then

		-- Applique le taux HTR au cout
		l_coutHTR := AppliqueTauxHTR ( p_annee , l_coutHTR ,  p_cdeb , p_filcode ) ;

	end if ;

   RETURN l_coutHTR;

END getCoutHTR;

-- Renvoie le cout d'environnement
FUNCTION getCoutEnv ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_codsg   number  ) Return Number IS
l_cout NUMBER(12,2);
BEGIN
l_cout:=0;

-- Ne fait le calcul que si cen n'est pas un logiciel ou un forfait hors site
if (p_rtype<>'L' and p_rtype<>'E') then

	-- Recherche le cout standard d'environnement associé au DPG pour l'année
	SELECT NVL(decode(p_soccode,'SG..',c.coutenv_sg,c.coutenv_ssii),0) into l_cout
	FROM cout_std2 c
	WHERE
	--Sur l'annee
 	c.annee = p_annee
	--sur le dpg de la ressource
	and p_codsg between c.dpg_bas and c.dpg_haut
	and rownum=1;

end if ;

RETURN l_cout;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       RETURN l_cout;
     WHEN OTHERS THEN
       RETURN l_cout;
END getCoutEnv;



END pack_utile_cout;
/
CREATE OR REPLACE PACKAGE pack_utile_numsg AS
-- ---------------------------------------------

-----------------------------------------------------------------------
-- N° de message < 20000
-- ATTENTION : A COMPLETER (suivant les messages de Sylvie !!!)
-----------------------------------------------------------------------

--

-----------------------------------------------------------------------
-- N° d'exceptions (N° de message > 20000)
-----------------------------------------------------------------------
------------------------------
nuexc_coddpg_invalide3    		CONSTANT NUMBER := 20430; --  Code Département/Pôle/Groupe %s1 invalide
nuexc_codligne_bip_inexiste    		CONSTANT NUMBER := 20504; --  Code ligne BIP %s1 inexistant
nuexc_soccode_inexistant 		CONSTANT NUMBER := 20306; --  Code société inexistant
nuexc_numfact_inexistant 		CONSTANT NUMBER := 20601; --  Numéro de facture %s1 inexistant
nuexc_datfact_inexistant 		CONSTANT NUMBER := 20602; --  Date de facture %s1 inexistant



/*

nuexc_codcli_existant    		CONSTANT NUMBER := 20001; -- Code Client déjà existant
nuexc_datstatut_obligatoire    	CONSTANT NUMBER := 20002; -- La date de statut est obligatoire pour ce code statut
nuexc_datstatut_saisi_interdit    CONSTANT NUMBER := 20003; -- La date de statut ne doit pas être saisie pour ce code statut
nuexc_libproj_existant    		CONSTANT NUMBER := 20011; -- Libellé projet déjà existant pour le projet : %s1
nuexc_dpt_non_autorise    		CONSTANT NUMBER := 20012; -- Vous n'êtes pas autorisé %s1 dans ce département, votre département est : %s2
nuexc_pole_non_autorise    		CONSTANT NUMBER := 20013; -- Vous n'êtes pas autorisé %s1 dans ce pôle, votre pôle est : %s2
nuexc_der_ident_atteint    		CONSTANT NUMBER := 20014; -- Dernier identifiant atteint
nuexc_codtypo_non_autorise    	CONSTANT NUMBER := 20015; -- Code typologie d'activité non autorisé
nuexc_climo_ferme    			CONSTANT NUMBER := 20018; -- Client MO fermé
nuexc_fact_existant_hfact    		CONSTANT NUMBER := 20100; -- La facture existe déjà dans HISTO_FACTURE
nuexc_fact_existant_fact    		CONSTANT NUMBER := 20101; -- La facture existe déjà dans FACTURE
nuexc_modif_fact_non_autorise    	CONSTANT NUMBER := 20102; -- La modification de la facture n'est pas autorisée
nuexc_fact_inexistant    		CONSTANT NUMBER := 20103; -- La facture n'existe pas
nuexc_datfact_sup_datjour    		CONSTANT NUMBER := 20104; -- La date de la facture doit être inférieure ou égale à la date du jour
nuexc_suppr_fact_non_autorise    	CONSTANT NUMBER := 20105; -- La suppression de la facture n'est pas autorisée
nuexc_fact_existe_autre_filial    	CONSTANT NUMBER := 20106; -- La facture existe mais pour une autre filiale
nuexc_fact_refcontrat_inexist   CONSTANT NUMBER := 20107; -- Problème de facture faisant référence à un contrat inexistant
nuexc_datrecept_sup_datjour    	CONSTANT NUMBER := 20108; -- La date de réception doit être inférieure ou égale à la date du jour
nuexc_coddpg_inconnu    		CONSTANT NUMBER := 20109; -- Code Departement/Pole/Groupe inconnu
nuexc_codcompta_invalide    		CONSTANT NUMBER := 20110; -- Code Comptable invalide
nuexc_fact_existant    			CONSTANT NUMBER := 20111; -- Facture déjà existante
nuexc_contrat_app_autre_filial    	CONSTANT NUMBER := 20112; -- Le contrat appartient à une autre filiale
nuexc_annee_saisie_incorrecte    	CONSTANT NUMBER := 20200; -- L'année saisie n'est pas correcte
nuexc_codmo_ppal_inconnu    		CONSTANT NUMBER := 20202; -- Code maître d'ouvrage principal inconnu
nuexc_coddpg_inexistant    		CONSTANT NUMBER := 20203; -- Code Département/Pôle/Groupe inexistant
nuexc_codmo_gest_inconnu    		CONSTANT NUMBER := 20204; -- Code maître d'ouvrage gestionnaire inconnu
nuexc_appli_existant    		CONSTANT NUMBER := 20205; -- Application déjà existante
nuexc_mauvais_codappli    		CONSTANT NUMBER := 20206; -- Mauvais code Application, syntaxe: Axxxx
------------------------------
nuexc_coddossier_proj_existant    	CONSTANT NUMBER := 20207; -- Code dossier projet déjà existant
nuexc_mauvais_codproj    		CONSTANT NUMBER := 20208; -- Mauvais code projet, syntaxe: Pxxxx
nuexc_codmo_inexistant    		CONSTANT NUMBER := 20209; -- Code maître d'ouvrage inexistant
nuexc_coddossier_proj_inexiste    CONSTANT NUMBER := 20211; -- Code dossier projet inexistant
nuexc_coddossier_proj_existe2 	CONSTANT NUMBER := 20212; -- Code dossier projet déjà existant
nuexc_immeuble_existant    		CONSTANT NUMBER := 20213; -- Immeuble déjà existant
nuexc_cod_existant    			CONSTANT NUMBER := 20214; -- Code %s1 inexistant
nuexc_coddpg_inexistant2    		CONSTANT NUMBER := 20215; -- Code Département/Pôle/groupe %s1 inexistant
nuexc_coddpg_invalide    		CONSTANT NUMBER := 20216; -- Code Département/Pôle/Groupe invalide
nuexc_idcp_pas_une_personne    	CONSTANT NUMBER := 20218; -- Identifiant du chef de projet n'est pas une personne
nuexc_ressource_existante    		CONSTANT NUMBER := 20219; -- Ressource déjà existante
nuexc_correction_non_aut_div   	CONSTANT NUMBER := 20220; -- Correction non autorisée : vous êtes de la division %s1\n alors que cette ressource est de la division %s2
nuexc_correction_non_aut_pole 	CONSTANT NUMBER := 20221; -- Correction non autorisée : vous êtes du pôle %s1\n alors que cette ressource est du pôle %s2
nuexc_coddpg_invalide2    		CONSTANT NUMBER := 20223; -- Code Département/Pôle/Groupe invalide
nuexc_cod_inconnu_ou_ferme    	CONSTANT NUMBER := 20225; -- Code %s1 inconnu ou fermé
nuexc_idcp_inexistant    		CONSTANT NUMBER := 20226; -- Identifiant chef de projet %s1 inexistant
nuexc_datval_sup_datdepart    	CONSTANT NUMBER := 20227; -- La date de valeur doit être inférieure à la date de départ
------------------------------
nuexc_datvalsai_inf_datvalorig   	CONSTANT NUMBER := 20228; -- La date de valeur saisie est antérieure à la date de valeur d'origine
nuexc_situ_logiciel_modifie    	CONSTANT NUMBER := 20230; -- Situation Logiciel %s1 modifiée
nuexc_datvalsai_inf_datvalsitu    	CONSTANT NUMBER := 20231; -- La date de valeur saisie est inférieure à la plus ancienne des dates de valeur des situations
nuexc_ressource_pas_un_forfait    	CONSTANT NUMBER := 20233; -- Ressource %s1 de type %s2 ne correspond pas à un forfait
nuexc_suppr_imposs_reste_situ  	CONSTANT NUMBER := 20234; -- Suppression impossible, il ne reste qu'une seule situation
nuexc_codprestation_errone    	CONSTANT NUMBER := 20235; -- Code prestation %s1 erroné, saisir FH ou FS
nuexc_saisie_homonyme_imposs    	CONSTANT NUMBER := 20236; -- Il est impossible de saisir un homonyme
nuexc_ressource_pas_logiciel    	CONSTANT NUMBER := 20237; --  Ressource %s1 de type %s2 ne correspond pas un logiciel
nuexc_logiciel_existant    		CONSTANT NUMBER := 20240; --  Logiciel déjà existant
nuexc_codcout_inexistant    		CONSTANT NUMBER := 20241; --  Code coût FI %s1 inexistant pour l'année %s2
nuexc_faut_an_entre_1900_3000 	CONSTANT NUMBER := 20242; -- L'année doit être comprise entre 1900 et 3000
nuexc_coutfi_existant    		CONSTANT NUMBER := 20243; --  Coût FI déjà existant
nuexc_modif_non_autorise    		CONSTANT NUMBER := 20244; --  Modification non autorisée vous êtes %s1 alors que cette ressource est %s2
nuexc_forfait_sans_coddpg    		CONSTANT NUMBER := 20245; --  Forfait sans code Département/Pôle/Groupe
nuexc_prestation_errone    		CONSTANT NUMBER := 20246; --  Prestation %s1 erronée, consultez la table
nuexc_entrez_un_cout    		CONSTANT NUMBER := 20247; --  Entrez un coût
nuexc_faut_dispo_entre_0_et_7    	CONSTANT NUMBER := 20248; --  La disponibilité doit être comprise entre 0 et 7
nuexc_faut_codappli_diff_A0000 	CONSTANT NUMBER := 20249; --  Le code application doit être différent de A0000
nuexc_faut_codproj_diff_P0000  	CONSTANT NUMBER := 20250; --  Le code projet doit être différent de P0000
nuexc_ressource_pas_une_pers		CONSTANT NUMBER := 20251; --  Ressource %s1 de type %s2 ne correspond pas à une personne
nuexc_coddpg_ferme    			CONSTANT NUMBER := 20252; --  Code DPG %s1 fermé
nuexc_client_ferme    			CONSTANT NUMBER := 20253; --  Client %s1 fermé
nuexc_menu_utilise_inexistant    	CONSTANT NUMBER := 20265; --  Menu utilisé inexistant
nuexc_utilisateur_existant    	CONSTANT NUMBER := 20266; --  Utilisateur déjà existant
nuexc_calendrier_existant    		CONSTANT NUMBER := 20267; --  Calendrier déjà existant
nuexc_proposition_budget_exist   	CONSTANT NUMBER := 20268; --  Proposition de budget déjà existante
nuexc_non_habilite_maj_proposi  	CONSTANT NUMBER := 20269; --  Vous n'êtes pas habilité à mettre à jour cette proposition
nuexc_pas_de_cout_pour_cet_an  	CONSTANT NUMBER := 20271; --  Il n'y a pas de coût %s1 définit pour cette année
nuexc_dates_traitements_existe    	CONSTANT NUMBER := 20272; --  Dates de traitement existantes
nuexc_coddpg_inexistant3    		CONSTANT NUMBER := 20273; --  Code Département/Pôle inexistant
nuexc_coddpg_ferme2    			CONSTANT NUMBER := 20274; --  Code Département/Pôle/Groupe fermé
nuexc_codposte_est_0_ou_1    		CONSTANT NUMBER := 20275; --  Le code poste doit être 0 ou 1
nuexc_prestation_est_fs_ou_fh 	CONSTANT NUMBER := 20276; --  La prestation doit être FS ou FH
nuexc_ligne_bip_modifie    		CONSTANT NUMBER := 20277; --  Ligne Bip %s1 modifiée
nuexc_trop_de_select_ligne_bip   	CONSTANT NUMBER := 20278; --  Trop de Lignes Bip sélectionnées, veuillez restreindre votre sélection
nuexc_abs_ligne_bip_coddpg 		CONSTANT NUMBER := 20279; --  Il n'existe pas de ligne BIP pour le code DPG %s1
nuexc_contrat_inexistant    		CONSTANT NUMBER := 20280; --  Contrat inexistant
nuexc_contrat_existe_histo		 CONSTANT NUMBER := 20281; --  Contrat déjà existant dans histo_contrat
nuexc_incoherent_agrement_rang    	CONSTANT NUMBER := 20282; --  Incohérence entre l'agrément et le rang
nuexc_datarriv_gesach_sup_datj 	CONSTANT NUMBER := 20283; --  La date d'arrivée à GES/ACH doit être inférieure ou égale à la date du jour
nuexc_datfin_inf_datdebut    		CONSTANT NUMBER := 20284; --  La date de fin doit être supérieure ou égale à la date de début
nuexc_contrat_existant    		CONSTANT NUMBER := 20285; --  Contrat déjà existant
nuexc_contrat_existe_autre_fil	CONSTANT NUMBER := 20286; --  Le contrat existe déjà pour une autre filiale
nuexc_aucun_contrat_recent    	CONSTANT NUMBER := 20287; --  Aucun contrat récent
nuexc_aucun_contrat_historise    	CONSTANT NUMBER := 20288; --  Aucun contrat historisé
nuexc_codsoc_existant    		CONSTANT NUMBER := 20301; --  Code société déjà existant
nuexc_rens_datchg_datferm_seul 	CONSTANT NUMBER := 20302; --  Renseigner la date de changement seule ou\n la date de fermeture provisoire seule
nuexc_datferme_provis_inf_datj   	CONSTANT NUMBER := 20303; --  Date de fermeture provisoire inférieure à date du jour
nuexc_datferme_nouvsoc_ou_rien 	CONSTANT NUMBER := 20304; --  Saisir date fermeture et nouvelle société ou aucun des deux
nuexc_codnature_errone    		CONSTANT NUMBER := 20305; --  Code nature erroné: A=Agrée ou blanc


nuexc_codfour_existant    		CONSTANT NUMBER := 20307; --  Code fournisseur déjà existant
nuexc_codfour_inexistant    		CONSTANT NUMBER := 20308; --  Code fournisseur inexistant
nuexc_codcat_errone    			CONSTANT NUMBER := 20309; --  Code catégorie erroné
nuexc_propbud_existant    		CONSTANT NUMBER := 20310; --  Proposition de budget déjà existante
nuexc_notifbud_existant    		CONSTANT NUMBER := 20311; --  Notification de budget déjà existante
nuexc_notifarbitrage_existant    	CONSTANT NUMBER := 20312; --  Notification Arbitrage déjà existante
nuexc_pas_de_maj_annees_ant    	CONSTANT NUMBER := 20313; --  Pas de mise à jour sur les années antérieures
nuexc_erreur_lors_extraction    	CONSTANT NUMBER := 20401; --  Erreur lors de l'extraction
nuexc_erreur_gestion_fichier    	CONSTANT NUMBER := 20402; --  Erreur dans la gestion des fichiers
nuexc_bascule_bud_effectue    	CONSTANT NUMBER := 20410; --  Basculement du budget effectué

------------------------------
nuexc_codproj_inexiste_pour_an 	CONSTANT NUMBER := 20420; --  Code projet inexistant pour l'année saisie
nuexc_devis_bloque    			CONSTANT NUMBER := 20421; --  Devis bloqués
nuexc_proj_appartient_pas_pole    	CONSTANT NUMBER := 20422; --  Ce projet n'appartient pas à votre pôle
nuexc_abs_donne_pour_cet_an  		CONSTANT NUMBER := 20423; --  Pas de données pour cette année
nuexc_devis_cree    			CONSTANT NUMBER := 20424; --  Devis de type %s1 crée
nuexc_devis_existant    		CONSTANT NUMBER := 20425; --  Devis de type %s1 déjà existant
nuexc_concurrence_acces_devis		CONSTANT NUMBER := 20426; --  Acces concurrent sur le devis de type %s1
nuexc_devis_modifie    			CONSTANT NUMBER := 20427; --  Devis de type %s1 modifié
nuexc_mise_a_zeo_effectue    		CONSTANT NUMBER := 20428; --  Mise à zéro effectuée
nuexc_coutstd_inexiste_pour_an	CONSTANT NUMBER := 20429; --  Coût standard de type %s1 inexistant pour l'année saisie
nuexc_periode_errone    		CONSTANT NUMBER := 20431; --  Période erronée
nuexc_datenvpole_sup_datsaisie    	CONSTANT NUMBER := 20432; --  Date d'envoi au pôle doit être postérieure ou égale à la date de saisie
nuexc_datretpole_sup_datsaisie    	CONSTANT NUMBER := 20433; --  Date de retour du pôle doit être postérieure ou égale à la date de saisie
nuexc_saisie_obligatoire    		CONSTANT NUMBER := 20434; --  Saisie obligatoire
nuexc_codfiliale_existant    		CONSTANT NUMBER := 20501; --  Code filiale déjà existant
nuexc_codexception_existant    	CONSTANT NUMBER := 20502; --  Code exception déjà existant
nuexc_codcp_pas_une_personne    	CONSTANT NUMBER := 20503; --  Le code chef de projet %s1 ne correspond pas à une personne
nuexc_coddirection_inexiste    	CONSTANT NUMBER := 20505; --  Code direction %s1 inexistant
nuexc_codtypproj_inexistant    	CONSTANT NUMBER := 20506; --  Code type de projet %s1 inexistant
nuexc_erreur_insert_budget    	CONSTANT NUMBER := 20507; --  Erreur lors d'une insertion d'un budget %s1, veuillez recommencer l'initialisation
nuexc_abs_ligne_a_initialise		CONSTANT NUMBER := 20508; --  Il n'y a pas de lignes à initialiser %s1
nuexc_maj_budget    			CONSTANT NUMBER := 20509; --  Erreur lors de la mise à jour d'un budget %s1,\n%s2


nuexc_codtyp_existant    		CONSTANT NUMBER := 20604; --  Code type déjà existant
nuexc_proj_special_existant    	CONSTANT NUMBER := 20609; --  Projet spécial déjà existant
nuexc_typo_secondaire_existant    	CONSTANT NUMBER := 20614; --  Typologie secondaire déjà existante
------------------------------
nuexc_creatmodif_contrat_impos	CONSTANT NUMBER := 20710; --  Création ou modification de contrat impossible,\nce pôle n'existe pas
nuexc_codcompta_inexistant    	CONSTANT NUMBER := 20712; --  Le code comptable n'existe pas
nuexc_coddoss_proj_inexiste2    	CONSTANT NUMBER := 20729; --  Code dossier projet inexistant
nuexc_proj_special_non_aut    	CONSTANT NUMBER := 20730; --  Code projet spécial non autorisé
nuexc_coddpg_inexistant4    		CONSTANT NUMBER := 20731; --  Code Département/Pôle/Groupe inexistant
nuexc_creatmodif_lig_bip_impos 	CONSTANT NUMBER := 20732; --  Création ou modification de ligne BIP impossible,\nce client maîtrise d'ouvrage n'existe pas
nuexc_ident_appli_inexistant    	CONSTANT NUMBER := 20733; --  Identifiant Application inexistant
nuexc_typo_inexistant    		CONSTANT NUMBER := 20734; --  Typologie inexistante
nuexc_codproj_info_inexistant    	CONSTANT NUMBER := 20735; --  Code projet informatique inexistant
nuexc_typproj_inexistant    		CONSTANT NUMBER := 20736; --  Type de projet inexistant
nuexc_coddpg_inexistant5    		CONSTANT NUMBER := 20748; --  Code Département/Pôle/Groupe inexistant
nuexc_societe_inexistante    		CONSTANT NUMBER := 20749; --  Société inexistante
nuexc_codcamo_inexistant    		CONSTANT NUMBER := 20754; --  Code centre d'activité de la maîtrise d'ouvrage inexistant
nuexc_codgestproj_inexistant    	CONSTANT NUMBER := 20756; --  Code Gestionnaire de Projet inexistant
------------------------------
nuexc_crea_app_impos_pole     	CONSTANT NUMBER := 20758; --  Création ou modification de l'application impossible,\nce pôle n'existe pas
nuexc_crea_app_impos_climo   		CONSTANT NUMBER := 20759; --  Création ou modification de l'application impossible,\nce client maîtrise d'ouvrage n'existe pas
nuexc_crea_projinf_impos_climo   	CONSTANT NUMBER := 20760; --  Création ou modification de projet informatique impossible,\nce client maîtrise d'ouvrage n'existe pas
nuexc_crea_projinf_impos_pole  	CONSTANT NUMBER := 20761; --  Création ou modification de projet informatique impossible,\nce pôle n'existe pas
nuexc_crea_appli_impos_gest     	CONSTANT NUMBER := 20762; --  Création ou modification de l'application impossible,\nce gestionnaire d'application n'existe pas
nuexc_filiale_inexistante    		CONSTANT NUMBER := 20765; --  La filiale n'existe pas
nuexc_sup_filiale_impos_climo    	CONSTANT NUMBER := 20856; --  Suppression de la filiale impossible,\des clients maîtrise d'ouvrage sont rattachés à cette filiale
nuexc_sup_pole_impos_situ_ress    	CONSTANT NUMBER := 20860; --  Suppression du pôle impossible,\ndes situations ressources sont rattachées à ce pôle
nuexc_sup_contrat_impos_fact 		CONSTANT NUMBER := 20872; --  Suppression du contrat/avenant impossible,\ndes factures sont liées à ce contrat
nuexc_sup_soc_impos_situ_ress  	CONSTANT NUMBER := 20873; --  Suppression de la société impossible,\ndes situations ressources sont rattachées à cette société
nuexc_sup_proj_impos_ligne_bip    	CONSTANT NUMBER := 20880; --  Suppression de projet impossible,\des lignes BIP sont rattachées à ce projet
nuexc_sup_pole_impos_ligne_bip    	CONSTANT NUMBER := 20881; --  Suppression du pôle impossible,\ndes lignes BIP sont rattachées à ce pôle
nuexc_sup_cli_impos_ligne_bip    	CONSTANT NUMBER := 20882; --  Suppression du client impossible,\ndes lignes BIP sont rattachées à ce client maîtrise d'ouvrage
nuexc_sup_typo_impos_ligne_bip    	CONSTANT NUMBER := 20884; --  Suppression de typologie impossible,\des lignes BIP sont rattachées à cette typologie secondaire
nuexc_sup_type_impos_ligne_bip    	CONSTANT NUMBER := 20886; --  Suppression de type impossible,\des lignes BIP sont rattachées à ce type 1
------------------------------
nuexc_sup_imeub_impos_situ_res    	CONSTANT NUMBER := 20896; --  Suppression de l'immeuble impossible,\ndes ressources sont rattachées à cet immeuble
nuexc_sup_pol_impos_situ_ress2    	CONSTANT NUMBER := 20898; --  Suppression du pôle impossible,\ndes situations ressources sont rattachées à ce pôle
nuexc_sup_soc_impos_situ_ress2    	CONSTANT NUMBER := 20899; --  Suppression de le société impossible,\ndes situations ressources sont rattachées à cette société
nuexc_sup_ca_impos    			CONSTANT NUMBER := 20904; --  Le centre d'activité ne peut être supprimé
nuexc_sup_pole_impos_app    		CONSTANT NUMBER := 20908; --  Suppression du pôle impossible,\ndes applications sont rattachées à ce pôle
nuexc_sup_cli_impos_app    		CONSTANT NUMBER := 20909; --  Suppression du client impossible,\ndes applications sont rattachées à ce client maîtrise d'ouvrage
nuexc_sup_cli_impos_lig_bip    	CONSTANT NUMBER := 20910; --  Suppression du client impossible,\ndes lignes BIP sont rattachées à ce client maîtrise d'ouvrage
nuexc_sup_pole_impos_lig_bip2    	CONSTANT NUMBER := 20911; --  Suppression du pôle impossible,\ndes lignes BIP sont rattachées à ce pôle
nuexc_sup_cli_impos_app2    		CONSTANT NUMBER := 20912; --  Suppression du client impossible,\ndes applications sont rattachées à ce client maîtrise d'ouvrage

nuexc_pb_acces_histo_facture 		CONSTANT NUMBER := 20950; --  Problème d'accès à la table HISTO_FACTURE
nuexc_pb_acces_facture    		CONSTANT NUMBER := 20951; --  Problème d'accès à la table FACTURE
nuexc_pb_acces_facture_ou_soc		CONSTANT NUMBER := 20952; --  Problème d'accès à la table FACTURE ou SOCIETE
nuexc_pb_acces_contrat    		CONSTANT NUMBER := 20953; --  Problème d'accès à la table CONTRAT
nuexc_pb_acces_struct_info    	CONSTANT NUMBER := 20954; --  Problème d'accès à la table STRUCT_INFO
nuexc_pb_acces_code_compt    		CONSTANT NUMBER := 20955; --  Problème d'accès à la table CODE_COMPT

-- N° d'exception à lever dans la clause WHEN OTHERS
-- -------------------------------------------------
nuexc_others 				CONSTANT NUMBER := 20997;

nuexc_msg_inexiste_table_msg    	CONSTANT NUMBER := 20998; --  Message d'erreur inexistant dans la table des messages
nuexc_pb_acces_concurrent    		CONSTANT NUMBER := 20999; --  Accès concurrent sur les mêmes données,\nveuillez recharger vos données
*/

END pack_utile_numsg;
/
CREATE OR REPLACE PACKAGE Pack_Util_Situ IS
/*
	La fonction DureePresenceRessource indique la duree en jours
	entre l'arrivee de la ressource et la date recue en parametre,
	sachant que les periodes d'absence de plus de 6 mois (constante
	Delai a 183 jours) remettent le compteur a zero.
*/
	FUNCTION DureePresenceRessource(id_ress IN NUMBER, DateCourante IN DATE) RETURN NUMBER;
	PRAGMA RESTRICT_REFERENCES (DureePresenceRessource, WNDS, WNPS);

	/*
	La fonction DureePresenceRessource indique la duree en mois
	entre l'arrivee de la ressource et la date recue en parametre,
	sachant que les periodes d'absence de plus de 6 mois (constante
	Delai a 183 jours) remettent le compteur a zero.
*/
	FUNCTION DureePresenceRessourceMois(id_ress IN NUMBER, DateCourante IN DATE) RETURN NUMBER;
	PRAGMA RESTRICT_REFERENCES (DureePresenceRessourceMois, WNDS, WNPS);

/*
	La fonction DebutPresenceRessource indique la date de debut
	de presence de la ressource à la SG sans interruption
	egale ou superieure a 6 mois.
*/
	FUNCTION DebutPresenceRessource(id_ress IN NUMBER) RETURN DATE;
	PRAGMA RESTRICT_REFERENCES (DebutPresenceRessource, WNDS, WNPS);

/*
	Fonction qui permet de connaitre la durée réelle de présence
	de la ressource en otant les interruptions inférieures à 6 mois
	Si interruption supérieure à 6 mois : remise à zéro
*/
	FUNCTION DureeReellePresence(id_ress IN NUMBER, DateCourante IN DATE) RETURN NUMBER;
	PRAGMA RESTRICT_REFERENCES (DureeReellePresence, WNDS, WNPS);

END;
/

CREATE OR REPLACE PACKAGE BODY Pack_Util_Situ IS
/*
	La constante Delai correspond au nombre de jours d'une annee
	(on recherche les periodes sans interruption superieure ou egale
	a 6 mois=180 jours).
*/
	Delai		CONSTANT INTEGER := 180;
/*
	La procedure PeriodePrecence recherche la derniere periode
	de presence de la ressource sans interruption de plus de 6 mois.
*/
	PROCEDURE PeriodePresence(id_ress IN NUMBER, DateDebut OUT DATE, DateFin OUT DATE, PresenceTotale OUT NUMBER) IS
		CURSOR periode(ID IN NUMBER) IS
			SELECT DatSitu, DatDep
			FROM SITU_RESS
			WHERE ident=id_ress
			ORDER BY DatSitu;
		situ	periode%ROWTYPE;
		DateArrivee	DATE;
		DateDepart	DATE;
		aujourdhui	DATE;

	BEGIN
		SELECT TRUNC(SYSDATE) INTO aujourdhui
		FROM DUAL;

		DateArrivee:=NULL;
		DateDepart:=NULL;
		OPEN periode(id_ress);
		LOOP
			FETCH periode INTO situ;
			EXIT WHEN periode%NOTFOUND;
			IF (DateArrivee IS NULL) THEN			-- premiere periode
				DateArrivee:=situ.DatSitu;
				DateDepart:=situ.DatDep;

				IF (DateDepart IS NULL) THEN	-- Si date de départ non renseignée(=>ressource toujours présente)
					PresenceTotale:=aujourdhui - situ.DatSitu;
				ELSE				-- Sinon
					PresenceTotale:=(situ.DatDep - situ.DatSitu) + 1;
				END IF;

			ELSE						-- pas premiere periode
				IF situ.DatSitu>=DateDepart+Delai THEN		-- interruption > 6 mois
					DateArrivee:=situ.DatSitu;
					DateDepart:=situ.DatDep;

					IF (DateDepart IS NULL) THEN	-- Si date de départ non renseignée(=>ressource toujours présente)
						PresenceTotale := aujourdhui - situ.DatSitu;
					ELSE				-- Sinon
						PresenceTotale := situ.DatDep - situ.DatSitu + 1;
					END IF;

				ELSE						-- interruption < 6 mois
					DateDepart:=situ.DatDep;
					IF (DateDepart IS NOT NULL) THEN	-- Si date de départ renseignée
						PresenceTotale := PresenceTotale + (situ.DatDep - situ.DatSitu) + 1;
					ELSE -- Sinon la presence Totale est calculée avec aujourd'hui comme date de fin
						PresenceTotale := PresenceTotale + (aujourdhui - situ.DatSitu);
					END IF;
				END IF;
			END IF;
		END LOOP;
		CLOSE periode;

		DateDebut:=DateArrivee;
		DateFin:=DateDepart;
	END;

	FUNCTION DureePresenceRessource(id_ress IN NUMBER, DateCourante IN DATE) RETURN NUMBER IS
		DateArrivee	DATE;
		DateDepart	DATE;
		PresenceTotale	NUMBER;
		Duree		NUMBER;
	BEGIN
		PeriodePresence(id_ress, DateArrivee, DateDepart, PresenceTotale);
/*
	On a les dates de debut et de fin de periode.
	On compare la date de fin de periode avec la date recue en parametre :
		- si difference >= delai alors duree = 0
		- si difference < delai alors duree = DateCourante-DateArrivee
		- si date de fin de periode NULL ou superieure a DateCourante : ressource toujours presente : duree = DateCourante-DateArrivee
*/
		IF DateDepart IS NULL THEN			-- ressource toujours presente, depart non programee
			Duree:=DateCourante-DateArrivee;
		ELSIF DateDepart>DateCourante THEN		-- ressource toujours presente, depart programme
			Duree:=DateCourante-DateArrivee;
		ELSIF DateCourante-DateDepart>Delai THEN	-- ressource partie depuis plus d'un an
			Duree:=0;
		ELSE						-- ressource partie depuis moins d'un an
			Duree:=DateCourante-DateArrivee;
		END IF;
		RETURN Duree;
	END;


	FUNCTION DureePresenceRessourceMois(id_ress IN NUMBER, DateCourante IN DATE) RETURN NUMBER IS
			PresenceTotalej	NUMBER;
			PresenceTotaleMois	NUMBER;
	BEGIN

	    PresenceTotalej := DureePresenceRessource(id_ress, DateCourante) ;

	   SELECT (TO_NUMBER(SUBSTR(A,6,2)) - 01)+DECODE(SUBSTR(A,1,4),'2000',0,12*(TO_NUMBER(SUBSTR(A,1,4)) - 2000)) + TRUNC((TO_NUMBER(SUBSTR(A,9,2)) /30),1) INTO PresenceTotaleMois
       FROM (SELECT TO_CHAR(TO_DATE('20000101','YYYYMMDD')+PresenceTotalej ,'YYYY MM DD ') A FROM DUAL);

	    RETURN  PresenceTotaleMois;

	END;



	FUNCTION DebutPresenceRessource(id_ress IN NUMBER) RETURN DATE IS
		DateArrivee	DATE;
		DateDepart	DATE;
		PresenceTotale	NUMBER;
	BEGIN
		PeriodePresence(id_ress, DateArrivee, DateDepart, PresenceTotale);
		RETURN DateArrivee;
	END;


	FUNCTION DureeReellePresence(id_ress IN NUMBER, DateCourante IN DATE) RETURN NUMBER IS
		DateArrivee	DATE;
		DateDepart	DATE;
		PresenceTotale	NUMBER;
		Duree		NUMBER;
	BEGIN
		PeriodePresence(id_ress, DateArrivee, DateDepart, PresenceTotale);

		IF DateDepart IS NULL THEN			-- ressource toujours presente, depart non programee
			Duree:=PresenceTotale;
		ELSIF DateDepart>DateCourante THEN		-- ressource toujours presente, depart programme
			Duree:=PresenceTotale - 1 - (DateDepart - DateCourante);
		ELSIF DateCourante-DateDepart>Delai THEN	-- ressource partie depuis plus de 6 mois
			Duree:=0;
		ELSE						-- ressource partie depuis moins de 6 mois
			Duree:=PresenceTotale;
		END IF;
		RETURN Duree;
	END;

END;
/
CREATE OR REPLACE PACKAGE pack_verif_alphres  AS


   PROCEDURE verif_alphres(
			p_nomressource IN VARCHAR2,
			p_userid	IN VARCHAR2
			);



END pack_verif_alphres;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_alphres  AS
-- ---------------------------------------------------


PROCEDURE verif_alphres(
			p_nomressource IN VARCHAR2,
			p_userid	IN VARCHAR2
                       )
IS

     nom_ress	VARCHAR2(30);
     l_msg	VARCHAR2(100);

   BEGIN

	-- Recherche d'un nom de ressource correspondant au critère p_nomressource

	select rnom into nom_ress from ressource
		where rnom like (p_nomressource || '%')
		and rownum = 1;

 	EXCEPTION
 		WHEN NO_DATA_FOUND THEN -- Msg  ressource inconnue
                          pack_global.recuperer_message(20016, NULL, NULL, NULL, l_msg);
                          raise_application_error(-20016,l_msg);
		WHEN OTHERS THEN
	                 raise_application_error(-20997, SQLERRM);


   END verif_alphres;




END pack_verif_alphres;
/
CREATE OR REPLACE PACKAGE pack_verif_amortviw  AS
-- ----------------------------------------------

-- ------------------------------------------------------------------------
--
-- Nom        : verif_amortviw
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'état AMORTVIW
-- Paramètres :
--              p_pid (IN)		Code ligne BIP
--              p_codsg      (IN) 		Code DPG
--		    P_message OUT             Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------

     PROCEDURE verif_amortviw(
                 p_pid IN  VARCHAR2,	     -- CHAR(4)
                 P_message OUT VARCHAR2
                 );


END pack_verif_amortviw ;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_amortviw  AS
-- ---------------------------------------------------

-- ------------------------------------------------------------------------
--
-- Nom        : verif_amortviw
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'état AMORTVIW
-- Paramètres :
--              p_pid (IN)		Code Ligne BIP
--              p_codsg      (IN) 		Code DPG
--		    P_message OUT             Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------

PROCEDURE verif_amortviw(
                 p_pid IN  VARCHAR2,	     -- CHAR(4)
                 P_message OUT VARCHAR2
                 ) IS

      l_message   VARCHAR2(1024) := '';

BEGIN

   BEGIN

	---------------------------------------------------------------------------------------------
	-- Vérification existence Code ligne bip dans la table HISTO_AMORT
	---------------------------------------------------------------------------------------------
	IF ( pack_utile3B.f_verif_pid_histo_amort(p_pid) = FALSE )
	THEN
            pack_global.recuperer_message(pack_utile_numsg.nuexc_codligne_bip_inexiste, '%s1',
                                          p_pid, ' P_param6 ', l_message);
	END IF;

      p_message := l_message;

      IF (l_message IS NOT NULL) THEN
          RAISE_APPLICATION_ERROR(-pack_utile_numsg.nuexc_codligne_bip_inexiste, l_message);
      END IF;

   END;

END verif_amortviw;

END pack_verif_amortviw ;
/
CREATE OR REPLACE PACKAGE Pack_Verif_Consit  AS

   PROCEDURE verif_consit(
			p_coderessource IN VARCHAR2,
			p_userid 	IN VARCHAR2
			);
END Pack_Verif_Consit;
/

CREATE OR REPLACE PACKAGE BODY Pack_Verif_Consit  AS
-- ---------------------------------------------------

PROCEDURE verif_consit(
			p_coderessource IN VARCHAR2,
			p_userid 	IN VARCHAR2
                       )

IS
     code_ress	VARCHAR2(30);
     l_msg	VARCHAR2(100);
     l_codsg    VARCHAR2(7);
     l_habilitation VARCHAR2(10);
	 l_menu          VARCHAR2(255);
	 l_perim_me          VARCHAR2(1024);
   BEGIN

   l_menu := Pack_Global.lire_globaldata(p_userid).menutil;
   l_perim_me := Pack_Global.lire_globaldata(p_userid).perime;

	-- Recherche d'un code ressource correspondant au critère p_coderessource
	BEGIN
		SELECT ident INTO code_ress
		FROM RESSOURCE
		WHERE ident = p_coderessource
		AND ROWNUM =1;

		SELECT TO_CHAR(codsg, 'FM0000000') INTO l_codsg
		FROM SITU_RESS
		WHERE ident=p_coderessource
		AND datsitu IN (SELECT MAX(datsitu)
				FROM SITU_RESS
				WHERE ident=p_coderessource);

		 IF l_menu != 'DIR' and (l_perim_me is not null and l_perim_me != '') THEN
              -- ====================================================================
              -- 08/12/2005 : BAA Test appartenance du DPG au périmètre de l'utilisateur
              -- ====================================================================
              l_habilitation := Pack_Habilitation.fhabili_me( l_codsg,p_userid);
	          IF l_habilitation='faux' THEN
		           --ous n'êtes pas autorisé à visualiser cette ressource, son DPG est
		          	Pack_Global.recuperer_message(20365, '%s1',  'visualiser cette ressource, son DPG est '||l_codsg, 'IDENT', l_msg);
                    RAISE_APPLICATION_ERROR(-20365, l_msg);
				   	 END IF;
        END IF;


 	EXCEPTION
 		WHEN NO_DATA_FOUND THEN -- Msg Code  ressource inconnue
                          Pack_Global.recuperer_message(20017, NULL, NULL, NULL, l_msg);
                          RAISE_APPLICATION_ERROR(-20017,l_msg);

		WHEN OTHERS THEN
	                 RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

   END verif_consit;

END Pack_Verif_Consit;
/
CREATE OR REPLACE PACKAGE pack_verif_edsstr  AS


   -- Paramètres :
   --              p_factpid (IN)
   --			 p_soci(IN)     'SG ou SSII' soc. des ressources
   --              p_type (IN)    'M ou A' mensuel ou annuel
   --              p_moisannee (IN)  Ex. : 01/04/1999
   -- ---------------------------------------------------------------


FUNCTION f_cp(	p_pid	IN varchar2
			) RETURN VARCHAR2;


PRAGMA restrict_references(f_cp, WNDS, WNPS);

FUNCTION f_jhcout(	p_pole		in varchar2,
			p_pole_client	in varchar2,
			p_societe	in varchar2,
			p_type		in varchar2,
			p_fi		in varchar2,
			p_rf		in varchar2
			  ) return number;

PRAGMA restrict_references(f_jhcout, WNDS, WNPS);

FUNCTION f_calcul(	p_poler		IN  VARCHAR2 ,
			p_polee		IN  VARCHAR2 ,
			p_type		IN  VARCHAR2 ,
			p_ident		IN  VARCHAR2,
			p_ligr		in VARCHAR2,
			p_lige		IN VARCHAR2,
			p_soc		IN VARCHAR2
			  ) return number;

PRAGMA restrict_references(f_calcul, WNDS, WNPS);

PROCEDURE f_ins_edsstr(p_pole in varchar2);
PROCEDURE f_ins_edsstr3(p_pole IN VARCHAR2);
PROCEDURE f_ins_edsstr4(p_pole IN VARCHAR2);

END pack_verif_edsstr;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_edsstr  AS
-- ---------------------------------------------------

FUNCTION f_cp (
		p_pid		IN varchar2
		) RETURN VARCHAR2
IS

l_nom_pid	VARCHAR2(30);

BEGIN
	select pnom into l_nom_pid from ligne_bip where pid=p_pid;
	return(l_nom_pid);
END f_cp;


/*******************************************************/
FUNCTION f_jhcout(	p_pole		IN  VARCHAR2 ,
			p_pole_client	IN  VARCHAR2 ,
			p_societe	IN  VARCHAR2 ,
			p_type		IN  VARCHAR2 ,
			p_fi		IN  VARCHAR2 ,
			p_rf		IN  VARCHAR2
		  ) return number
IS

l_nombre	number(10,2);

BEGIN
IF  p_type='1' THEN    -- calcul des jh
	IF  p_societe = 'SG..' THEN
		BEGIN
		SELECT
			sum(nvl(cusag,0)) into l_nombre
		FROM
			tmpedsstr
		WHERE
			societe = 'SG..'
			and pole_r = LPAD(p_pole, 5, '0')
			and pole_e = LPAD(p_pole_client, 5, '0')
			and sstr = p_rf;
		end;
	ELSE
		BEGIN
		SELECT
			sum(nvl(cusag,0)) into l_nombre
		FROM
			tmpedsstr
		WHERE
			societe <> 'SG..'
			and pole_r = LPAD(p_pole, 5, '0')
			and pole_e = LPAD(p_pole_client, 5, '0')
			and sstr = p_rf;
		END;
	END  IF ;
ELSIF  p_type='2' then	-- calcul des couts
  IF  p_fi = 'N' then
	IF  p_societe = 'SG..' then
		BEGIN
		SELECT
			sum(cout*nvl(cusag,0)) into l_nombre
		FROM
			tmpedsstr
		WHERE
			societe = 'SG..'
			and pole_r = LPAD(p_pole, 5, '0')
			and pole_e = LPAD(p_pole_client, 5, '0')
			and sstr = p_rf;
		END ;
	ELSE
		BEGIN
		SELECT
			sum(cout*nvl(cusag,0)) into l_nombre
		FROM
			tmpedsstr
		WHERE
			societe <> 'SG..'
			and pole_r = LPAD(p_pole, 5, '0')
			and pole_e = LPAD(p_pole_client, 5, '0')
			and sstr = p_rf;
		END ;
	END  IF ;
    END  IF ;
END  IF ;

return(nvl(l_nombre,0));

END f_jhcout;

/*******************************************************/
FUNCTION f_calcul(	p_poler		IN  VARCHAR2 ,
			p_polee	IN  VARCHAR2 ,
			p_type		IN  VARCHAR2 ,
			p_ident		IN  VARCHAR2,
			p_ligr		in VARCHAR2,
			p_lige		IN VARCHAR2,
			p_soc		IN VARCHAR2
		  ) return number
IS

l_nombre	NUMBER(10,2);

BEGIN
IF  p_type='1' THEN    -- calcul des jh
	BEGIN
		SELECT
			sum(nvl(cusag,0)) into l_nombre
		FROM
			tmpedsstr
		WHERE 	pole_r = LPAD(p_poler, 5, '0')
			and pole_e = LPAD(p_polee, 5, '0')
			and ident = p_ident
			and pid_r = p_ligr
			and pid_e = p_lige
			and societe = p_soc;
	END;
ELSIF  p_type='2' then	-- calcul des couts
  		BEGIN
		SELECT
			sum(cout*nvl(cusag,0)) into l_nombre
		FROM
			tmpedsstr
		WHERE   pole_r = LPAD(p_poler, 5, '0')
			AND pole_e = LPAD(p_polee, 5, '0')
			AND ident = p_ident
			and pid_r = p_ligr
			and pid_e = p_lige
			and societe = p_soc;
		END ;

END  IF ;

return(nvl(l_nombre,0));

END f_calcul;

/*****************************************/
PROCEDURE f_ins_edsstr(p_pole IN  VARCHAR2)
IS

CURSOR C0 IS
--sous traitance recue
SELECT
	 SUBSTR(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5) pole_e,
	 SUBSTR(TO_CHAR(p.factpdsg, 'FM0000000'),1,5) 	pole_r,
	 p.factpid 	pid_r,
	 p.tires 	ident,
	 p.cusag 	cusag,
	 p.pid 		pid_e,
	 TO_CHAR(p.pdsg, 'FM0000000') 	codsg,
	 p.societe 	societe,
	 p.qualif 	qualif,
	 'R'		sstr,
	 p.divsecgrou
FROM
	 proplus p,
	 situ_ress_full srf,
	 ressource r,
	 datdebex dx
WHERE
	srf.ident=p.tires
	AND srf.ident=r.ident
	AND (srf.datsitu <= p.cdeb or srf.datsitu IS NULL)
	AND (srf.datdep >= p.cdeb or srf.datdep IS NULL)
	and substr(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5)<>substr(TO_CHAR(p.factpdsg, 'FM0000000'),1,5)
	and p.cusag <>0 and p.cusag is not null
	and substr(to_char(p.factpdsg, 'FM0000000'),1,5) like LPAD(p_pole, 5 , '0')
	and trunc(p.cdeb,'Y') = dx.datdebex
	and trunc(p.cdeb,'mm') <= dx.moismens
        and p.qualif not in ('MO ','STA','INT','IFO','GRA')
UNION ALL
--sous traitance fournie
SELECT
	substr(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5) 	pole_e,
	substr(TO_CHAR(p.factpdsg, 'FM0000000'),1,5)	pole_r,
	p.factpid					pid_r,
	p.tires						ident,
	p.cusag						cusag,
	p.pid						pid_e,
	TO_CHAR(p.pdsg, 'FM0000000')			codsg,
	p.societe					societe,
	p.qualif					qualif,
	'F'						sstr,
	p.divsecgrou
FROM
	proplus p,
	situ_ress_full srf,
	ressource r,
	datdebex dx
WHERE
	srf.ident=p.tires
	AND srf.ident=r.ident
	AND (srf.datsitu <= p.cdeb or srf.datsitu IS NULL)
	AND (srf.datdep >= p.cdeb or srf.datdep IS NULL)
	and substr(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5)<>substr(TO_CHAR(p.factpdsg, 'FM0000000'),1,5)
	and p.cusag <>0 and p.cusag is not null
	and substr(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5) like LPAD(p_pole,5,'0')
	and trunc(p.cdeb,'Y') = dx.datdebex
	and trunc(p.cdeb,'mm') <= dx.moismens
        and p.qualif not in ('MO ','STA','INT','IFO','GRA');

ligne0 C0%rowtype;
l_coutfi number(12,2);

BEGIN

OPEN C0;
LOOP
FETCH C0 into ligne0;
EXIT when C0%notfound;



INSERT  into tmpedsstr
(pole_e,pole_r,pid_r,ident,cout,coutfi,cusag,pid_e,codsg,societe,sstr)
values
(ligne0.pole_e,
ligne0.pole_r,
ligne0.pid_r,
ligne0.ident,
0,
0,
ligne0.cusag,
ligne0.pid_e,
ligne0.codsg,
ligne0.societe,
ligne0.sstr
);
END LOOP;


END f_ins_edsstr;

/*******************************************************/
PROCEDURE f_ins_edsstr3(p_pole IN VARCHAR2)
IS
--cette procedure est appelee pour le reports EDSSTR3.rdf
--qui calcule la sous traitance fournie
CURSOR C0 IS
--sous traitance fournie en tenant compte du périmètre utilisateur
SELECT SUBSTR(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5) pole_e,
         SUBSTR(TO_CHAR(p.factpdsg, 'FM0000000'),1,5) pole_r,
         p.factpid 	pid_r,
         p.tires 	ident,
         p.cusag 	cusag,
         p.pid 		pid_e,
         TO_CHAR(p.pdsg, 'FM0000000') codsg,
         p.societe 	societe,
         p.qualif 	qualif,
         'F'            sstr
FROM
        datdebex d,
        situ_ress_full srf,
        ressource r,
        proplus p
WHERE
	srf.ident=p.tires
	AND srf.ident=r.ident
	AND (srf.datsitu <= p.cdeb or srf.datsitu IS NULL)
	AND (srf.datdep >= p.cdeb or srf.datdep IS NULL)
        and substr(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5)<>substr(TO_CHAR(p.factpdsg, 'FM0000000'),1,5)
        and p.cusag <>0 and p.cusag is not null
        and trunc(p.cdeb,'YEAR')=d.datdebex
        and substr(to_char(p.divsecgrou, 'FM0000000'),1,5) like LPAD(p_pole, 5 , '0')
        and to_char(p.cdeb,'mm') <= to_char(d.moismens,'mm')
        and p.qualif not in ('MO ','STA','INT','IFO','GRA')
;


ligne0 C0%rowtype;
l_coutfi number(12,2);

BEGIN

	OPEN C0;
	LOOP
	FETCH C0 into ligne0;
	EXIT when C0%notfound;

	INSERT  into tmpedsstr
		(pole_e,pole_r,pid_r,ident,cout,coutfi,cusag,pid_e,codsg,societe,sstr)
	values	(ligne0.pole_e,
		ligne0.pole_r,
		ligne0.pid_r,
		ligne0.ident,
		0,
		0,
		ligne0.cusag,
		ligne0.pid_e,
		ligne0.codsg,
		ligne0.societe,
		ligne0.sstr);
	END LOOP;

END f_ins_edsstr3;
/*******************************************************/

/*******************************************************/
PROCEDURE f_ins_edsstr4(p_pole IN VARCHAR2)
IS
--cette procedure est appelee pour le reports EDSSTR4.rdf
--qui calcule la sous traitance recue
CURSOR C0 IS
--sous traitance recue pour le périmètre de l'utilisateur
SELECT SUBSTR(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5) pole_e,
         SUBSTR(TO_CHAR(p.factpdsg, 'FM0000000'),1,5) pole_r,
         p.factpid pid_r,
         p.tires ident,
         p.cusag cusag,
         p.pid pid_e,
         TO_CHAR(p.pdsg, 'FM0000000') codsg,
         p.societe societe,
         p.qualif qualif,
         'R'            sstr
FROM
        datdebex d,
        situ_ress_full srf,
        ressource r,
        proplus p
WHERE
	srf.ident=p.tires
	AND srf.ident=r.ident
	AND (srf.datsitu <= p.cdeb or srf.datsitu IS NULL)
	AND (srf.datdep >= p.cdeb or srf.datdep IS NULL)
        and substr(TO_CHAR(p.divsecgrou, 'FM0000000'),1,5)<>substr(TO_CHAR(p.factpdsg, 'FM0000000'),1,5)
        and p.cusag <>0 and p.cusag is not null
        and substr(to_char(p.factpdsg, 'FM0000000'),1,5) like LPAD(p_pole, 5 , '0')
        and to_char(p.cdeb,'yyyy') =  TO_CHAR(d.datdebex,'yyyy')
        and to_char(p.cdeb,'mm') <= to_char(d.moismens,'mm')
        and p.qualif not in ('MO ','STA','INT','IFO','GRA')
;

ligne0 C0%rowtype;
l_coutfi number(12,2);

BEGIN
	OPEN C0;
	LOOP FETCH C0 into ligne0;
	EXIT when C0%notfound;

	INSERT  into tmpedsstr
		(pole_e, pole_r, pid_r, ident, cout, coutfi, cusag, pid_e, codsg, societe, sstr)
	values
		(ligne0.pole_e,
		ligne0.pole_r,
		ligne0.pid_r,
		ligne0.ident,
		0,
		0,
		ligne0.cusag,
		ligne0.pid_e,
		ligne0.codsg,
		ligne0.societe,
		ligne0.sstr);
	END LOOP;

END f_ins_edsstr4;

END pack_verif_edsstr;
/
CREATE OR REPLACE PACKAGE pack_verif_facconsrh AS
-- ----------------------------------------------

-- ------------------------------------------------------------------------
--
-- Nom        : verif_facconsr
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'etat FACCONSR
-- Paramètres :
--              p_soccode (IN)		   Code société
--              p_numfact IN              Numéro facture
--              p_typfact IN              Type facture
--              p_datfact IN              date facture
--			 P_message OUT             Message de sortie
--
-- Remarque :  Cette procédure se contente d'appeler verif_facconsrh en lui passant en paramètre
--   		la table FACTURE et les paramètres ci-dessus.
--
-- ------------------------------------------------------------------------

     PROCEDURE verif_facconsr(
		 p_centrefrais IN VARCHAR2,
                 p_soccode IN  societe.soccode%TYPE, -- CHAR(4)
                 p_numfact IN  VARCHAR2,             -- CHAR(15)
                 p_typfact IN  VARCHAR2,             -- CHAR(1)
                 p_datfact IN  VARCHAR2,             -- DATE
                 P_message OUT VARCHAR2
                 );

-- ------------------------------------------------------------------------
--
-- Nom        : verif_facconsr
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'etat FACCONSH
-- Paramètres :
--              p_soccode (IN)		   Code société
--              p_numfact IN              Numéro facture
--              p_typfact IN              Type facture
--              p_datfact IN              date facture
--			 P_message OUT             Message de sortie
--
-- Remarque :  Cette procédure se contente d'appeler verif_facconsrh en lui passant en paramètre
--   		la table HISTO_FACTURE et les paramètres ci-dessus.
--
-- ------------------------------------------------------------------------

      PROCEDURE verif_facconsh(
                 p_centrefrais IN VARCHAR2,
                 p_soccode IN  societe.soccode%TYPE, -- CHAR(4)
                 p_numfact IN  VARCHAR2,             -- CHAR(15)
                 p_typfact IN  VARCHAR2,             -- CHAR(1)
                 p_datfact IN  VARCHAR2,             -- DATE
                 P_message OUT VARCHAR2
                 );

-- ------------------------------------------------------------------------
--
-- Nom        : verif_facconsrh
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'etat FACCONSR ou FACCONSH
-- Paramètres :
--              p_tablefact IN            Nom de la table des factures
--              p_socfact (IN)		Code société
--              p_numfact IN              Numéro facture
--              p_typfact IN              Type facture
--              p_datfact IN              date facture
--		    P_message OUT          	Message d'erreur
--
-- Remarque :  p_tablefact doit valoir 'FACTURE' ou 'HISTO_FACTURE'.
--             Attention : ce contrôle n'est pas effectué!!!
-- ------------------------------------------------------------------------

      PROCEDURE verif_facconsrh(
                 p_tablefact IN VARCHAR2,            -- Nom de la table des factures
                 p_soccode IN  societe.soccode%TYPE, -- CHAR(4)
                 p_numfact IN  VARCHAR2,             -- CHAR(15)
                 p_typfact IN  VARCHAR2,             -- CHAR(1)
                 p_datfact IN  VARCHAR2,             -- DATE
	 	 p_centrefrais IN VARCHAR2,
                 P_message OUT VARCHAR2
                 );

END pack_verif_facconsrh;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_facconsrh AS
-- ---------------------------------------------------

    PROCEDURE verif_facconsr(
	         p_centrefrais IN VARCHAR2,
                 p_soccode IN  societe.soccode%TYPE, -- CHAR(4)
                 p_numfact IN  VARCHAR2,             -- CHAR(15)
                 p_typfact IN  VARCHAR2,             -- CHAR(1)
                 p_datfact IN  VARCHAR2,             -- DATE
                 P_message OUT VARCHAR2
                 ) IS

   BEGIN
      p_message := '';
     -- verif_facconsrh('FACTURE', p_soccode, p_numfact, p_typfact, p_datfact, p_message);
   verif_facconsrh('FACTURE', p_soccode, p_numfact, p_typfact, p_datfact,p_centrefrais, p_message);

   END verif_facconsr;

   PROCEDURE verif_facconsh(   p_centrefrais IN VARCHAR2,
                 p_soccode IN  societe.soccode%TYPE, -- CHAR(4)
                 p_numfact IN  VARCHAR2,             -- CHAR(15)
                 p_typfact IN  VARCHAR2,             -- CHAR(1)
                 p_datfact IN  VARCHAR2,             -- DATE
                 p_message OUT VARCHAR2
                 ) IS

   BEGIN
      p_message := '';
     -- verif_facconsrh('HISTO_FACTURE', p_soccode, p_numfact, p_typfact, p_datfact, p_message);
verif_facconsrh('HISTO_FACTURE', p_soccode, p_numfact, p_typfact, p_datfact,p_centrefrais, p_message);

   END verif_facconsh;


   PROCEDURE verif_facconsrh(
                 p_tablefact IN VARCHAR2,
                 p_soccode IN  societe.soccode%TYPE, -- CHAR(4)
                 p_numfact IN  VARCHAR2,             -- CHAR(15)
                 p_typfact IN  VARCHAR2,             -- CHAR(1)
                 p_datfact IN  VARCHAR2,             -- DATE
                p_centrefrais IN VARCHAR2,
		 P_message OUT VARCHAR2
                 ) IS

      l_message   VARCHAR2(1024);
      l_num_exception NUMBER;
      l_centre_frais centre_frais.codcfrais%TYPE;
      l_fcentrefrais centre_frais.codcfrais%TYPE;

   BEGIN
      l_message := '';

      IF ( pack_utile.f_verif_facture(p_tablefact, p_soccode, p_numfact, p_typfact, TO_DATE(p_datfact, 'DD/MM/YYYY')) = FALSE ) THEN

          -- Facture inexistante : On recherche l'existence des champs ...

          -----------------------------------------------------------------
          -- (1) Vérification Code Société
          -----------------------------------------------------------------
          IF ( pack_utile.f_verif_soccode(p_soccode) = FALSE ) THEN
              pack_global.recuperer_message(pack_utile_numsg.nuexc_soccode_inexistant, NULL,
                                            NULL , ' P_param6 ', l_message);
              l_num_exception := pack_utile_numsg.nuexc_soccode_inexistant;
          END IF;

          -----------------------------------------------------------------
          -- (2) Vérification Numéro facture si société existe
          -----------------------------------------------------------------
          IF (l_message IS NULL) THEN
              IF ( pack_utile.f_verif_numfact(p_tablefact, p_numfact) = FALSE ) THEN
                  pack_global.recuperer_message(pack_utile_numsg.nuexc_numfact_inexistant, '%s1',
                                                p_numfact, ' P_param7 ', l_message);
                  l_num_exception := pack_utile_numsg.nuexc_numfact_inexistant;
              END IF;
          END IF;

          -----------------------------------------------------------------
          -- (3) Si Code société et N° Facture sont corrects,
          --     La non existance de la facture ne peut provenir que
          --     de la non existence de la date de facturation
          --  ATTENTION : Le message "date de facture inexistante" sera aussi
          --              affiché si c'est le type de facture qui n'est pas le bon
          --              (Typfact = 'F' existe par exemple alors qu'on a choisi 'A')
          -----------------------------------------------------------------

          IF (l_message IS NULL) THEN
              pack_global.recuperer_message(pack_utile_numsg.nuexc_datfact_inexistant, '%s1',
                                            p_datfact , ' P_param9 ', l_message);
              l_num_exception := pack_utile_numsg.nuexc_datfact_inexistant;
          END IF;

     ELSE

       -- ======================================================================================
      -- 21/12/2000 :Contrôler que la facture appartient au centre de frais de l'utilisateur
      -- =======================================================================================
	 l_centre_frais := to_number(p_centrefrais);

	 -- Recherche du centre de frais de la facture

	BEGIN
	  IF p_tablefact='FACTURE' then
	    select fcentrefrais into l_fcentrefrais
	    from facture
	    where socfact= p_soccode
	    and   rtrim(numfact)= p_numfact
	    and   typfact= p_typfact
	    and   datfact= to_date(p_datfact,'DD/MM/YYYY');
	  ELSE
	    select fcentrefrais into l_fcentrefrais
	    from histo_facture
	    where socfact= p_soccode
	    and   rtrim(numfact)= p_numfact
	    and   typfact= p_typfact
	    and   datfact= to_date(p_datfact,'DD/MM/YYYY');

	  END IF;
	EXCEPTION
		WHEN NO_DATA_FOUND then
			-- la facture n'est rattachée à aucun centre de frais
			pack_global.recuperer_message(20337,NULL,NULL,NULL, l_message);
         	 	raise_application_error(-20337, l_message);
		WHEN OTHERS then
			 raise_application_error(-20997, SQLERRM);

	END;

     	IF l_centre_frais!=0 then    -- le centre de frais 0 donne tout les droits à l'utilisateur
		IF l_fcentrefrais is null THEN
			-- la facture n'est rattachée à aucun centre de frais
			pack_global.recuperer_message(20337,NULL,NULL,NULL, l_message);
         	 	raise_application_error(-20337, l_message);

		ELSE
			IF l_centre_frais!=l_fcentrefrais THEN
				-- la facture n'est pas rattachée au centre de frais %s1 mais au centre de frais %s2
				pack_global.recuperer_message(20338,'%s1',to_char(l_centre_frais),'%s2',
									to_char(l_fcentrefrais),NULL, l_message);
         			raise_application_error(-20338,l_message);

			END IF;
		END IF;
	END IF;
      END IF;
      p_message := l_message;

/*************************************************************************************************
      dbms_output.put_line('NUM ERR : '||l_num_exception);
      dbms_output.put_line('NUM ERR datfact: '||pack_utile_numsg.nuexc_datfact_inexistant);
      dbms_output.put_line('NUM ERR numfact: '||pack_utile_numsg.nuexc_numfact_inexistant);
      dbms_output.put_line('NUM ERR soccode: '||pack_utile_numsg.nuexc_soccode_inexistant);
*************************************************************************************************/
      IF (l_message IS NOT NULL) THEN
          RAISE_APPLICATION_ERROR(-l_num_exception, l_message);
      END IF;

   END verif_facconsrh;



END pack_verif_facconsrh;
/
CREATE OR REPLACE PACKAGE pack_verif_factab6 AS
-- ---------------------------------------------
      PROCEDURE verif_factab6(
                 p_soccode 	IN  societe.soccode%TYPE, -- CHAR(4)
                 p_fregcompta1 	IN  VARCHAR2,             -- date
                 p_fregcompta2 	IN  VARCHAR2,          	  -- date
                 p_userid  	IN  VARCHAR2,
                 P_message 	OUT VARCHAR2
                 );

END pack_verif_factab6;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_factab6 AS
-- ------------------------------------------------
 PROCEDURE verif_factab6(
                 p_soccode 	IN  societe.soccode%TYPE, -- CHAR(4)
                 p_fregcompta1 	IN  VARCHAR2,             -- date
                 p_fregcompta2 	IN  VARCHAR2,             -- date
                 p_userid  	IN  VARCHAR2,
                 P_message 	OUT VARCHAR2
                 ) is

      l_message   VARCHAR2(1024);
   BEGIN
      l_message := '';

      IF (p_soccode IS NOT NULL) THEN
            pack_ctl_lstcontl.select_societe (p_soccode,'P_param6', l_message);
      END IF;

      -- Controle de la periode
      IF (l_message IS NULL) THEN
		pack_ctl_lstcontl.select_periode(p_fregcompta1 , p_fregcompta2 , 'P_param7', l_message);
      END IF;

      p_message := l_message;
   END verif_factab6;

END pack_verif_factab6;
/
CREATE OR REPLACE PACKAGE pack_verif_import AS

   PROCEDURE verif_import  (	p_bidon   IN  VARCHAR2,
				p_global  IN  VARCHAR2,
                  		p_message OUT VARCHAR2
			);

  PROCEDURE update_import(p_userid IN VARCHAR2);


END pack_verif_import ;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_import  AS


PROCEDURE verif_import(	p_bidon   IN  VARCHAR2,
			p_global  IN  VARCHAR2,
                        p_message OUT VARCHAR2
			) IS

      l_msg        VARCHAR2(512);
      l_coduser    VARCHAR2(255);
      l_res 	   number;

   BEGIN
      -- Initialiser le message retour
      p_message := '';

      -- On recupere le code user (idarpege)
      l_coduser := pack_global.lire_globaldata(p_global).idarpege;


--insert into import_compta_res values (l_coduser,'global');
      -- Recherche du message de fin de traitement d'import
	select 1 into l_res
	from import_compta_res
	where userid=l_coduser
	and rownum=1
	and etat!='IMPORT EN COURS';


   EXCEPTION
	WHEN NO_DATA_FOUND THEN
		pack_global.recuperer_message(20447, NULL, NULL, NULL, l_msg);
         	raise_application_error(-20447,l_msg);
	WHEN OTHERS THEN
		raise_application_error(-20997,SQLERRM);

END verif_import;
------------------------------------------------------------------------------------------------------
 PROCEDURE update_import(p_userid IN VARCHAR2) IS

  l_date varchar2(50);

  BEGIN
	select TO_CHAR(SYSDATE, 'DD/MM/YYYY')||' A '||TO_CHAR(SYSDATE,'HH24:MI:SS') into l_date
	from dual;

	update import_compta_res
	set etat = 'IMPORT DU '||l_date||' TERMINE'
	where userid=p_userid;

  EXCEPTION
	WHEN OTHERS THEN
		raise_application_error(-20997,SQLERRM);
  END update_import;


END pack_verif_import;
/
CREATE OR REPLACE PACKAGE pack_verif_prodeta  AS
-- ----------------------------------------------


   -- ------------------------------------------------------------------------
   --
   -- Nom        : f_conso_ress
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : Calcul du consommé d'une ressource pour le mois, l'année, le projet, l'étape,
   --              la tâche, la sous-tâche et la ressource fournis en paramètres
   -- Paramètres :
   --              p_mois (IN)            Mois traité 'MM'
   --			 p_annee(IN)            Année traitée 'AAAA'
   --              p_pid (IN)             Code Projet
   --              p_ecet (IN)            N° Etape
   --              p_acta (IN)            N° Tache
   --              p_acst (IN)            N° Sous-Tache
   --              p_ident (IN)           Identifiant ressource
   -- Retour     : Nbre de jours consommés de la ressource
   --
   -- Remarque :  Utilisation de la table cons_sstache_res_mois
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_conso_ress(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_pid		  IN cons_sstache_res_mois.pid%TYPE,
			    p_ecet                IN cons_sstache_res_mois.ecet%TYPE,
			    p_acta                IN cons_sstache_res_mois.acta%TYPE,
			    p_acst                IN cons_sstache_res_mois.acst%TYPE,
			    p_ident               IN cons_sstache_res_mois.ident%TYPE
			   ) RETURN NUMBER;

FUNCTION  f_conso_ress_qualif(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_pid		  IN cons_sstache_res_mois.pid%TYPE,
			    p_ecet                IN cons_sstache_res_mois.ecet%TYPE,
			    p_acta                IN cons_sstache_res_mois.acta%TYPE,
			    p_acst                IN cons_sstache_res_mois.acst%TYPE,
			    p_ident               IN cons_sstache_res_mois.ident%TYPE,
			    p_qualif              IN proplus.qualif%TYPE
			    ) RETURN NUMBER ;

-----------------------------------------------------------------------------
-- Différents PRAGMA
-----------------------------------------------------------------------------
PRAGMA restrict_references(f_conso_ress, WNDS);
PRAGMA restrict_references(f_conso_ress_qualif, WNDS);


END pack_verif_prodeta ;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_prodeta  AS
-- ---------------------------------------------------



   --*************************************************************************
   --
   -- Nom        : f_conso_ress
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : Calcul du consommé d'une ressource pour le mois, l'année, le projet, l'étape,
   --              la tâche, la sous-tâche et la ressource fournis en paramètres
   -- Paramètres :
   --              p_mois (IN)            Mois traité 'MM'
   --			 p_annee(IN)            Année traitée 'AAAA'
   --              p_pid (IN)             Code Projet
   --              p_ecet (IN)            N° Etape
   --              p_acta (IN)            N° Tache
   --              p_acst (IN)            N° Sous-Tache
   --              p_ident (IN)           Identifiant ressource
   -- Retour     : Nbre de jours consommés de la ressource
   --
   -- Remarque :  Utilisation de la table cons_sstache_res_mois
   --
   --*************************************************************************
   FUNCTION f_conso_ress(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_pid		        IN cons_sstache_res_mois.pid%TYPE,
			    p_ecet                IN cons_sstache_res_mois.ecet%TYPE,
			    p_acta                IN cons_sstache_res_mois.acta%TYPE,
			    p_acst                IN cons_sstache_res_mois.acst%TYPE,
			    p_ident               IN cons_sstache_res_mois.ident%TYPE
			   ) RETURN NUMBER IS
      l_conso_res cons_sstache_res_mois.cusag%TYPE := 0 ;
	l_annee_traite VARCHAR2(4) := p_annee ;

	l_mois_annee_datdebex VARCHAR2(7) := '12/2000';  /* MM/AAAA */
	l_mois_datdebex VARCHAR2(2) := '12';


BEGIN

	BEGIN

		-----------------------------------------------------------------------------
		-- Determination de l'année à traiter si p_annee est nul !
		-----------------------------------------------------------------------------
            IF ( p_annee IS NULL )
		THEN
			SELECT TO_CHAR(cmensuelle, 'MM/YYYY') INTO l_mois_annee_datdebex  FROM datdebex;

			l_annee_traite := SUBSTR(l_mois_annee_datdebex, 4, 4);
			l_mois_datdebex := SUBSTR(l_mois_annee_datdebex, 1, 2);

			---------------------------------------------------------------
			-- Dans ce cas, on ne fera les calculs que si p_mois (mois traité)
			-- <= l_mois_datdebex (mois de datdebex)
			-- Sinon, on retourne 0 tout de suite
			----------------------------------------------------------------
			IF ( l_mois_datdebex < p_mois )
			THEN
				RETURN (0);
			END IF;
		END IF;

		EXCEPTION
	 		WHEN OTHERS THEN
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

	BEGIN
		  SELECT 	cusag
		  INTO	l_conso_res
		  FROM  	cons_sstache_res_mois
	 	  WHERE
				pid 		= p_pid
				AND ecet	= p_ecet
				AND acta	= p_acta
				AND acst	= p_acst
				AND ident	= p_ident
				AND cdeb 	= TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');
		RETURN( NVL(l_conso_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_conso_res  := 0;
				RETURN(0);
	 		WHEN OTHERS THEN
				l_conso_res  := 0;
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_conso_ress;


---
---
FUNCTION  f_conso_ress_qualif(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_pid		  IN cons_sstache_res_mois.pid%TYPE,
			    p_ecet                IN cons_sstache_res_mois.ecet%TYPE,
			    p_acta                IN cons_sstache_res_mois.acta%TYPE,
			    p_acst                IN cons_sstache_res_mois.acst%TYPE,
			    p_ident               IN cons_sstache_res_mois.ident%TYPE,
			    p_qualif              IN proplus.qualif%TYPE
			    ) RETURN NUMBER IS

        l_conso_res NUMBER(15, 2) := 0 ;
	l_derjour_mois VARCHAR2(2) := '31';
	l_annee_traite VARCHAR2(4) := p_annee ;
	l_mois_annee_datdebex VARCHAR2(7) := '12/2000';  /* MM/AAAA */
	l_mois_datdebex VARCHAR2(2) := '12';
	l_qualif proplus.qualif%TYPE;


BEGIN

	BEGIN
		-----------------------------------------------------------------------------
		-- Determination de l'année à traiter si p_annee est nul !
		-----------------------------------------------------------------------------
            IF ( p_annee IS NULL )
		THEN
			SELECT TO_CHAR(cmensuelle, 'MM/YYYY') INTO l_mois_annee_datdebex  FROM datdebex;

			l_annee_traite := SUBSTR(l_mois_annee_datdebex, 4, 4);
			l_mois_datdebex := SUBSTR(l_mois_annee_datdebex, 1, 2);

			---------------------------------------------------------------
			-- Dans ce cas, on ne fera les calculs que si p_mois (mois traité)
			-- <= l_mois_datdebex (mois de datdebex)
			-- Sinon, on retourne 0 tout de suite
			----------------------------------------------------------------
			IF ( l_mois_datdebex < p_mois )
			THEN
				RETURN (0);
			END IF;
		END IF;

		EXCEPTION
	 		WHEN OTHERS THEN
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

	BEGIN
l_derjour_mois := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || p_mois  ||'/'||l_annee_traite,'DD/MM/YYYY')),'DD');

		-- ON recupere la qualif
			SELECT DISTINCT sr.prestation INTO l_qualif
			FROM situ_ress_full sr,cons_sstache_res c
			WHERE c.ident=sr.ident
			AND c.ident= p_ident
			AND sr.datsitu <= TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
			AND ( sr.datdep >= TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
			OR sr.datdep IS NULL)
			;


		IF l_qualif <> p_qualif
			THEN l_conso_res :=null;
		ELSE
		   	SELECT 	cusag
		  	INTO	l_conso_res
		  	FROM  	cons_sstache_res_mois
	 	  	WHERE
				pid 		= p_pid
				AND ecet	= p_ecet
				AND acta	= p_acta
				AND acst	= p_acst
				AND ident	= p_ident
				AND cdeb 	= TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');
		END IF;

		RETURN( NVL(l_conso_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_conso_res  := 0;
				RETURN (0);
	 		WHEN OTHERS THEN
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_conso_ress_qualif;


END pack_verif_prodeta ;
/
CREATE OR REPLACE PACKAGE pack_verif_proeta1  AS

   --
   -- Nom        : f_reserve
   -- Auteur     : Equipe SOPRA (HT)
   -- Paramètres :
   --              p_factpid (IN)
   --			 p_soci(IN)     'SG ou SSII' soc. des ressources
   --              p_type (IN)    'M ou A' mensuel ou annuel
   --              p_moisannee (IN)  Ex. : 01/04/1999
   -- ---------------------------------------------------------------
   FUNCTION f_reserve(
			    p_pid             IN VARCHAR2,
			    p_annee	      IN VARCHAR2
			    ) RETURN NUMBER;

  PRAGMA restrict_references(f_reserve, WNDS);

-- **************************************************************************************
-- Nom 		: habili_direction
-- Auteur 	: NBM
-- Description 	: Vérifie si l'utilisateur est habilité à la direction
--
-- Paramètres 	: p_codperime (IN) code périmètre de l'utilisateur
--		  p_direction (IN) code direction sur 2 caractères
-- Retour	: message d'erreur si non habilitation
--
-- **************************************************************************************
  PROCEDURE habili_direction(	p_perime    IN  VARCHAR2,
				p_direction IN  VARCHAR2,
				p_message   OUT VARCHAR2) ;

-- **************************************************************************************
-- Nom 		: habili_branche
-- Auteur 	: NBM
-- Description 	: Vérifie si l'utilisateur est habilité à la branche
--
-- Paramètres 	: p_codperime (IN) code périmètre de l'utilisateur
--		  p_branche (IN) code branche sur 2 caractères
-- Retour	: message d'erreur si non habilitation
--
-- **************************************************************************************
  PROCEDURE habili_branche(	p_perime  IN VARCHAR2,
				p_branche IN VARCHAR2,
				p_message OUT VARCHAR2) ;

-- ************************************************************************************************
-- Nom 		: verif_proeta1
-- Auteur 	: NBM
-- Description 	: Vérifie si l'utilisateur est habilité au BDDPG et l'existence des codes saisis
--
-- Paramètres 	: p_codperime (IN) code périmètre de l'utilisateur
--		  p_direction(IN) code direction sur 2 caractères
-- Retour	: message d'erreur si non habilitation
--
-- ************************************************************************************************
  PROCEDURE verif_proeta1(
			p_nomproj   IN  VARCHAR2,
			p_branche   IN  VARCHAR2,
			p_direction IN  VARCHAR2,
			p_codsg     IN  VARCHAR2,
			p_global    IN  VARCHAR2,
                        p_message   OUT VARCHAR2
			);
END pack_verif_proeta1;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_proeta1  AS
-- ---------------------------------------------------

FUNCTION f_reserve(
			   p_pid         IN VARCHAR2,
			   p_annee	 IN VARCHAR2
			)
			     RETURN NUMBER IS

	montant1 number;
	montant2 number;
	l_datdebex date;

BEGIN
	select datdebex into l_datdebex from datdebex;

	select reserve,bpmontme into montant1,montant2
		from budget
		where	pid = p_pid
			and annee=p_annee;

	if p_annee = to_char(l_datdebex,'YYYY') then
		if montant1 is null then
			return 0;
		else
			return(montant1);
		end if;
	else
	if p_annee = to_char(add_months(l_datdebex,12),'YYYY') then
		if montant2 is null then
			return 0;
		else
			return(montant2);
		end if;
	else
		return 0;
	end if;

	end if;


	EXCEPTION
		WHEN no_data_found THEN return 0;
		WHEN others THEN return 0;

END f_reserve;

-- ******************************************************************************************************************
-- Nom 		: habili_direction
-- Auteur 	: NBM
-- Description 	: Vérifie si l'utilisateur est habilité à la direction
--
-- Paramètres 	: p_codperime (IN) code périmètre de l'utilisateur
--		  p_direction (IN) code direction sur 2 caractères
-- Retour	: message d'erreur si non habilitation
--
-- ******************************************************************************************************************
 PROCEDURE habili_direction(	p_perime    IN  VARCHAR2,
				p_direction IN  VARCHAR2,
				p_message   OUT VARCHAR2) IS
   l_coddir  number;


   BEGIN

	select 1 into l_coddir
	from vue_dpg_perime
	where INSTR(p_perime, codbddpg) > 0
	and codhabili='dir'
	and substr(codbddpg,3,2)=LPAD(p_direction, 2, '0');

   EXCEPTION
	WHEN NO_DATA_FOUND THEN --Vous n'êtes pas habilité à cette direction
		pack_global.recuperer_message(20364,'%s1', 'à cette direction','P_param9', p_message);
              	raise_application_error(-20364,p_message);



 END habili_direction;

-- ******************************************************************************************************************
-- Nom 		: habili_branche
-- Auteur 	: NBM
-- Description 	: Vérifie si l'utilisateur est habilité à la branche
--
-- Paramètres 	: p_codperime (IN) code périmètre de l'utilisateur
--		  p_branche (IN) code branche sur 2 caractères
-- Retour	: message d'erreur si non habilitation
--
-- *******************************************************************************************************************
  PROCEDURE habili_branche(	p_perime    IN  VARCHAR2,
				p_branche   IN  VARCHAR2,
				p_message   OUT VARCHAR2) IS
  l_codbr  number;


   BEGIN

	select 1 into l_codbr
	from vue_dpg_perime
	where INSTR(p_perime, codbddpg) > 0
	and codhabili='br'
	and substr(codbddpg,1,2)=LPAD(p_branche, 2, '0');

   EXCEPTION
	WHEN NO_DATA_FOUND THEN --Vous n'êtes pas habilité à cette branche
		pack_global.recuperer_message(20364,'%s1', 'à cette branche','P_param8', p_message);
              	raise_application_error(-20364,p_message);



 END habili_branche;
-- *******************************************************************************************************************
-- Nom 		: verif_proeta1
-- Auteur 	: NBM
-- Description 	: Vérifie si l'utilisateur est habilité au BDDPG et l'existence des codes saisis
--
-- Paramètres 	: p_codperime (IN) code périmètre de l'utilisateur
--		  p_direction(IN) code direction sur 2 caractères
-- Retour	: message d'erreur si non habilitation
--
-- ******************************************************************************************************************
PROCEDURE verif_proeta1(
			p_nomproj   IN VARCHAR2,
			p_branche   IN VARCHAR2,
			p_direction IN VARCHAR2,
			p_codsg     IN VARCHAR2,
			p_global    IN VARCHAR2,
                        p_message   OUT VARCHAR2
			)
IS

      l_msg       VARCHAR2(512);
      l_coddir    struct_info.coddir%TYPE;
      l_codbr     directions.codbr%TYPE;
      l_perimetre VARCHAR2(255);

   BEGIN
      -- Initialiser le message retour
      	p_message := '';

      -- Récupérer le code user (idarpege)
      	l_perimetre := pack_global.lire_globaldata(p_global).perime;

	IF p_branche!='**' THEN     -- Branche renseignée
	    IF p_direction!='**' THEN  --Direction renseignée
		IF p_codsg!='*******' THEN  --Codsg renseigné
			-- Vérifier que le codsg existe et appartient bien à la direction et à la branche
			If ( pack_utile.f_verif_dpg(LPAD(p_codsg, 7, '0'))= false ) then -- Message Dep/pole inconnu
				pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               			raise_application_error(-20203,l_msg);
     			End if;
			BEGIN
				select distinct d.coddir,d.codbr into l_coddir, l_codbr
				from struct_info s,directions d
				where s.coddir=d.coddir
				and substr(to_char(codsg,'FM0000000'),1, length(rtrim(rtrim(LPAD(p_codsg, 7, '0'),'*')))) = rtrim(rtrim(LPAD(p_codsg, 7, '0'),'*'))
				and topfer='O'
				and rownum<2;

			EXCEPTION
				WHEN NO_DATA_FOUND THEN -- Le codsg n'est rattaché à aucune direction
					pack_global.recuperer_message(20356,'%s1', 'DPG', NULL, l_msg);
              	 			raise_application_error(-20356,l_msg);

			END;
			If l_codbr!=to_number(p_branche) Then  --'%s1 n'appartient pas %s2 mais %s3'
				-- Le codsg n'appartient pas à la branche p_branche mais à l_codbr
				pack_global.recuperer_message(20362, '%s1', 'Le DPG','%s2',
				'à la branche '||p_branche,'%s3','à la branche '||LPAD(l_codbr,2,0),'P_param8', l_msg);
               			raise_application_error(-20362,l_msg);

			End if;
			If l_coddir!=to_number(p_direction) Then
			-- Le codsg n'appartient pas à la direction p_direction mais à l_coddir
				pack_global.recuperer_message(20362, '%s1', 'Le DPG','%s2',
				'à la direction '||p_direction,'%s3','à la direction'||LPAD(l_coddir,2,0),'P_param9',l_msg);
               			raise_application_error(-20362,l_msg);
			End if;
			-- **************************************************
			-- Vérifier l'habilitation de l'utilisateur au DPG
			-- **************************************************
			pack_habilitation.verif_habili_me(p_codsg,p_global,l_msg);

		ELSE --toute la direction
			--Vérifier l'existence de la direction et de la branche
			BEGIN
				select coddir, codbr into l_coddir, l_codbr
				from directions d
				where coddir=to_number(p_direction);
			EXCEPTION
				WHEN NO_DATA_FOUND THEN --Direction inexistante
					pack_global.recuperer_message(20363,'%s1', 'Direction','P_param9', l_msg);
              	 			raise_application_error(-20363,l_msg);
			END;
			If l_codbr!=to_number(p_branche) Then
			-- La direction n'appartient pas à la branche
				pack_global.recuperer_message(20362, '%s1', 'La direction','%s2',
				'à la branche '||p_branche,'%s3','à la branche '||LPAD(l_codbr,2,0),'P_param8', l_msg);
               			raise_application_error(-20362,l_msg);

			End if;
			-- ***************************************************
			-- Habilitation de l'utilisateur à toute la direction
			-- ***************************************************
			habili_direction(l_perimetre,p_direction ,l_msg );

		END IF;
	    ELSE  -- Toute la branche
		BEGIN
			select codbr into l_codbr
			from branches
			where codbr=to_number(p_branche);
		EXCEPTION
				WHEN NO_DATA_FOUND THEN --Branche inexistante
					pack_global.recuperer_message(20363,'%s1', 'Branche','P_param8', l_msg);
              	 			raise_application_error(-20363,l_msg);
		END;
 	  	-- ***************************************************
		-- Habilitation de l'utilisateur à toute la branche
		-- ***************************************************
		habili_branche(l_perimetre,p_branche ,l_msg );

	    END IF;
	ELSE --Branche **
		IF p_direction='**' THEN
			IF p_codsg='*******' THEN   -- Toute la BIP
				-- *******************************************************
				--Vérifier que l'utilisateur est habilité à toute la BIP
				-- ******************************************************
				pack_habilitation.verif_habili_me(p_codsg,p_global,l_msg);

			ELSE
				-- Existence du codsg
				If ( pack_utile.f_verif_dpg(p_codsg)= false ) then -- Message Dep/pole inconnu
				pack_global.recuperer_message(20203, NULL, NULL, NULL, l_msg);
               			raise_application_error(-20203,l_msg);
     				End if;
				-- ***************************************************
				-- Habilitation de l'utilisateur au codsg
				-- ***************************************************
				pack_habilitation.verif_habili_me(p_codsg,p_global,l_msg);
			END IF;
		ELSE
			IF p_codsg='*******' THEN --Toute la direction
				-- Existence de la direction
				BEGIN
				 	select coddir into l_coddir
				 	from directions d
				 	where coddir=to_number(p_direction);
				EXCEPTION
				WHEN NO_DATA_FOUND THEN --Direction inexistante
					pack_global.recuperer_message(20363,'%s1', 'Direction','P_param9', l_msg);
              	 			raise_application_error(-20363,l_msg);
				END;
				-- ***************************************************
				-- Habilitation de l'utilisateur à toute la direction
				-- ***************************************************
				habili_direction(l_perimetre,p_direction ,l_msg );

			ELSE  -- Codsg
				-- vérifier l'appartenance du codsg à la direction
				BEGIN
					select  coddir into l_coddir
					from struct_info
					where
			        	substr(to_char(codsg,'FM0000000'),1, length(rtrim(rtrim(LPAD(p_codsg, 7, '0'),'*')))) = rtrim(rtrim(LPAD(p_codsg, 7, '0'),'*'))
					and topfer='O'
					and rownum<2;
				EXCEPTION
					WHEN NO_DATA_FOUND THEN --codsg inexistant
					pack_global.recuperer_message(20225, '%s1', 'DPG', 'P_param7', l_msg);
               				raise_application_error(-20225,l_msg);
				END;
				If l_coddir!=to_number(p_direction) Then
				-- Le codsg n'appartient pas à la direction p_direction mais à l_coddir
				pack_global.recuperer_message(20362, '%s1', 'Le DPG','%s2','à la direction '||p_direction,
						'%s3','à la direction '||LPAD(l_coddir,2,0),'P_param9',l_msg);
               			raise_application_error(-20362,l_msg);
				End if;
				-- ***************************************************
				-- Habilitation de l'utilisateur au codsg
				-- ***************************************************
				pack_habilitation.verif_habili_me(p_codsg,p_global,l_msg);

			END IF;
		END IF;
	END IF;

  --pack_habilitation.verif_habili_me(p_codsg,p_global,l_msg);


END verif_proeta1;

END pack_verif_proeta1;
/
CREATE OR REPLACE PACKAGE pack_verif_prohist  AS
-- ----------------------------------------------

   -- ------------------------------------------------------------------------
   --
   -- Nom         : f_conso_ress
   -- Auteur      : Equipe SOPRA (HT)
   -- Description : Calcul du consommé d'une ressource pour le mois et année
   --              fourni en paramètres
   -- Paramètres  :
   --               p_mois (IN)            Mois traité 'MM'
   --			  p_annee(IN)            Année traitée 'AAAA'
   --               p_factpdsg (IN)        Code Dpt/Pole/Groupe Projet principal
   --               p_factpid (IN)         Code Projet principal
   --               p_pdsg (IN)            Code Dpt/Pole/Groupe projet associé au Projet principal
   --               p_pid (IN)             Code Projet associé au Projet principal
   --               p_tires (IN)           Identifiant ressource
   --               p_qualif (IN)          Qualification ressource
   -- Retour      : Nbre de jours consommés de la ressource
   --
   -- Remarque  :
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_conso_ress(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_factpdsg            IN proplus.factpdsg%TYPE,
			    p_factpid		  IN proplus.factpid%TYPE,
			    p_pdsg                IN proplus.pdsg%TYPE,
			    p_pid                 IN proplus.pid%TYPE,
			    p_tires               IN proplus.tires%TYPE,
			    p_qualif              IN proplus.qualif%TYPE
			   ) RETURN NUMBER;

 PRAGMA restrict_references(f_conso_ress, WNDS);

END pack_verif_prohist ;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_prohist  AS
-- ---------------------------------------------------



FUNCTION f_conso_ress(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_factpdsg            IN proplus.factpdsg%TYPE,
			    p_factpid		  IN proplus.factpid%TYPE,
			    p_pdsg                IN proplus.pdsg%TYPE,
			    p_pid                 IN proplus.pid%TYPE,
			    p_tires               IN proplus.tires%TYPE,
			    p_qualif              IN proplus.qualif%TYPE
			   ) RETURN NUMBER IS
      l_conso_res NUMBER(15, 2) := 0 ;
	l_derjour_mois VARCHAR2(2) := '31';
	l_annee_traite VARCHAR2(4) := p_annee ;

	l_mois_annee_datdebex VARCHAR2(7) := '12/2000';  /* MM/AAAA */
	l_mois_datdebex VARCHAR2(2) := '12';

BEGIN

	BEGIN
		-----------------------------------------------------------------------------
		-- Determination de l'année à traiter si p_annee est nul !
		-----------------------------------------------------------------------------
            IF ( p_annee IS NULL )
		THEN
			SELECT TO_CHAR(cmensuelle, 'MM/YYYY') INTO l_mois_annee_datdebex  FROM datdebex;

			l_annee_traite := SUBSTR(l_mois_annee_datdebex, 4, 4);
			l_mois_datdebex := SUBSTR(l_mois_annee_datdebex, 1, 2);

			---------------------------------------------------------------
			-- Dans ce cas, on ne fera les calculs que si p_mois (mois traité)
			-- <= l_mois_datdebex (mois de datdebex)
			-- Sinon, on retourne 0 tout de suite
			----------------------------------------------------------------
			IF ( l_mois_datdebex < p_mois )
			THEN
				RETURN (0);
			END IF;
		END IF;

		EXCEPTION
	 		WHEN OTHERS THEN
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

	BEGIN
            l_derjour_mois := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || p_mois  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );

		IF ( (p_qualif = 'GRA') OR  (p_qualif = 'MO') )
		THEN
		  	SELECT SUM(cusag)
		  	INTO	l_conso_res
		  	FROM  proplus
	 	  	WHERE
				factpdsg 	= p_factpdsg
				AND factpid 	= p_factpid
				AND pdsg	= p_pdsg
				AND pid		= p_pid
				AND tires	= p_tires
				AND qualif	= p_qualif
				AND cdeb BETWEEN TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
				AND TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');
		ELSE
		  	SELECT SUM(cusag)
		  	INTO	l_conso_res
		  	FROM  proplus
	 	  	WHERE
				factpdsg 	= p_factpdsg
				AND factpid 	= p_factpid
				AND pdsg	= p_pdsg
				AND pid		= p_pid
				AND tires	= p_tires
				AND ( (qualif NOT IN ('GRA', 'MO')) OR (qualif IS NULL) )
				AND cdeb BETWEEN TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
				AND TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');

		END IF;

		RETURN( NVL(l_conso_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_conso_res  := 0;
				RETURN( 0 );
	 		WHEN OTHERS THEN
				l_conso_res  := 0;
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_conso_ress;


END pack_verif_prohist ;
/
CREATE OR REPLACE PACKAGE pack_verif_prosbum  AS

   --
   -- Nom        : f_sg
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : Calcul du consommé d'une ressource pour le mois/
   --     année fourni en paramètres
   -- Paramètres :
   --              p_factpid (IN)
   --			 p_soci(IN)     'SG ou SSII' soc. des ressources
   --              p_type (IN)    'M ou A' mensuel ou annuel
   --              p_moisannee (IN)  Ex. : 01/04/1999
   -- ---------------------------------------------------------------
   FUNCTION f_sg(
			    p_factpid             IN VARCHAR2,
			    p_soci		  IN VARCHAR2,
			    p_type		  IN VARCHAR2,
			    p_moisannee           IN DATE
			    ) RETURN NUMBER;

PRAGMA restrict_references(f_sg, WNDS);

-----------------------------------------------------------------------------------------------------------
--	NOM		ConsommeLigneBIP
--	Fonction	retourne la somme du consommé sur une ligne bip
--	Parametres	p_PID		identifiant de la ligne BIP
--			p_mensuel	0	consomme sur l'annee de la derniere mensuelle
--					1	consomme sur le mois de l'annee de la derniere mensuelle
--					-1	consomme total sur les annees precedentes a l'annee de la derniere mensuelle
--			p_SG		0	seulement les SSII
--					1	seulement les SG
--					NULL	tout le monde
-----------------------------------------------------------------------------------------------------------
	FUNCTION ConsommeLigneBIP(
		p_PID		IN	ligne_bip.pid%TYPE,
		p_mensuel	IN	INTEGER,
		p_SG		IN	INTEGER
	) RETURN NUMBER;

PRAGMA restrict_references(ConsommeLigneBIP, WNDS);

END pack_verif_prosbum;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_prosbum  AS
-- ---------------------------------------------------

FUNCTION f_sg(
			   p_factpid             IN VARCHAR2,
			    p_soci		  IN VARCHAR2,
			    p_type		  IN VARCHAR2,
			    p_moisannee           IN DATE
			)
			     RETURN NUMBER IS

	l_sg number;
	l_ssii number;
	l_type varchar2(8);

BEGIN
	if p_type = 'M' then
		l_type := 'MM/YYYY';
	elsif p_type = 'A' then
		l_type := 'YYYY';
	end if;
	if p_soci = 'SG' then
          SELECT SUM(cusag)
		  INTO	l_sg
		  FROM  proplus
	 	  WHERE
		factpid    = p_factpid
		AND societe like 'SG%'
		AND qualif not in ('MO','GRA')
		AND to_char(cdeb,l_type) = to_char(p_moisannee,l_type)
		AND to_date(to_char(cdeb,'MM/YYYY'),'MM/YYYY') <=
			 to_date(to_char(p_moisannee,'MM/YYYY'),'MM/YYYY');
	    RETURN( nvl(l_sg,0) );
	end if;

	if p_soci = 'SSII' then
	    SELECT SUM(cusag)
		  INTO	l_ssii
		  FROM  proplus
	 	  WHERE
		factpid    = p_factpid
		AND societe not like 'SG%'
		AND qualif not in ('MO','GRA')
		AND to_char(cdeb,l_type) = to_char(p_moisannee,l_type)
         	AND to_date(to_char(cdeb,'MM/YYYY'),'MM/YYYY') <=
			to_date(to_char(p_moisannee,'MM/YYYY'),'MM/YYYY');
	   RETURN( nvl(l_ssii,0) );
	end if;

	--	DBMS_OUTPUT.PUT_LINE('pid: '|| p_factpid);
	--	DBMS_OUTPUT.PUT_LINE('mois: '|| p_type);
	--	DBMS_OUTPUT.PUT_LINE('total: '|| l_sg);
	--	DBMS_OUTPUT.PUT_LINE('total: '|| l_ssii);

	EXCEPTION
		WHEN no_data_found THEN return 0;

END f_sg;

	FUNCTION ConsommeLigneBIP(
		p_PID		IN	ligne_bip.pid%TYPE,
		p_mensuel	IN	INTEGER,
		p_SG		IN	INTEGER
	) RETURN NUMBER IS
		result	NUMBER;
	BEGIN
		IF (p_mensuel=1) THEN
			IF (p_SG=1) THEN
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND TRUNC(cdeb,'MONTH')=TRUNC(DatDebEx.MoisMens,'MONTH')
				AND societe='SG..';
			ELSIF (p_SG=0) THEN
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND TRUNC(cdeb,'MONTH')=TRUNC(DatDebEx.MoisMens,'MONTH')
				AND societe!='SG..';
			ELSE
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND TRUNC(cdeb,'MONTH')=TRUNC(DatDebEx.MoisMens,'MONTH');
			END IF;
		ELSIF (p_mensuel=0) THEN	-- annuel
			IF (p_SG=1) THEN
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND TRUNC(cdeb,'YEAR')=TRUNC(DatDebEx.MoisMens,'YEAR')
				AND societe='SG..';
			ELSIF (p_SG=0) THEN
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND TRUNC(cdeb,'YEAR')=TRUNC(DatDebEx.MoisMens,'YEAR')
				AND societe!='SG..';
			ELSE
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND TRUNC(cdeb,'YEAR')=TRUNC(DatDebEx.MoisMens,'YEAR');
			END IF;
		ELSE				-- annees precedentes
			IF (p_SG=1) THEN
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND cdeb<TRUNC(DatDebEx.MoisMens,'YEAR')
				AND societe='SG..';
			ELSIF (p_SG=0) THEN
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND cdeb<TRUNC(DatDebEx.MoisMens,'YEAR')
				AND societe!='SG..';
			ELSE
				SELECT SUM(cusag)
				INTO result
				FROM proplus, DatDebEx
				WHERE factpid=p_PID
				AND cdeb<TRUNC(DatDebEx.MoisMens,'YEAR');
			END IF;
		END IF;
		RETURN result;
	END;

END pack_verif_prosbum;
/
CREATE OR REPLACE PACKAGE pack_verif_reshist  AS
-- ----------------------------------------------

   -- ------------------------------------------------------------------------
   --
   -- Nom        : f_conso_ress
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : Calcul du consommé d'une ressource pour le mois et année
   --              fourni en paramètres
   -- Paramètres :
   --              p_mois (IN)            Mois traité 'MM'
   --			 p_annee(IN)            Année traitée 'AAAA'
   --              p_divsecgrou (IN)      Code Dpt/Pole/Groupe
   --              p_tires (IN)           Identifiant ressource
   --              p_pid (IN)             Identifiant projet
   --              p_aist (IN)            Identifiant sous-tâche
   -- Retour     : Nbre de jours consommés de la ressource
   --
   -- Remarque :
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_conso_ress(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_divsecgrou          IN proplus.divsecgrou%TYPE,
			    p_tires               IN proplus.tires%TYPE,
			    p_pid                 IN proplus.pid%TYPE,
			    p_aist                IN proplus.aist%TYPE
			   ) RETURN NUMBER;

   -- ------------------------------------------------------------------------
   --
   -- Nom        : f_nbjour_ouvre
   -- Auteur     : Equipe SOPRA (HT)
   -- Decription : Calcul du nbre de jours ouvrés pour le mois ('MM') de l' année ('AAAA')
   --              fourni en paramètres : Si l'année est NUL, on prend l'année de datdebex!!!
   --
   -- Paramètres :
   --			 p_annee(IN)            Année traitée 'AAAA'
   --              p_mois (IN)            Mois traité 'MM'
   -- Retour     : Nbre de jours ouvrés du mois p_mois de l'année p_année
   --
   -- Remarque :  Si p_annee est NUL, on prend l'année de datdebex!!!
   --          On retourne 0 si l'information recherchée ne se trouve pas dans la table
   --          CALENDRIER.
   -- ------------------------------------------------------------------------
   FUNCTION f_nbjour_ouvre( p_annee IN VARCHAR2, p_mois IN VARCHAR2 ) RETURN calendrier.cjours%TYPE ;

   -- ------------------------------------------------------------------------
   --
   -- Nom        : f_societe_ress
   -- Auteur     : ODu
   -- Decription : Recherche du code societe d'une ressource a une date
   --              donnee dans PROPLUS
   -- Paramètres :
   --              p_tires (IN)           Identifiant ressource
   --              p_date (IN)            'MM/AAAA'
   -- Retour     : Code societe
   --
   -- Remarque :
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_societe_ress( p_date IN VARCHAR2, p_tires IN INTEGER) RETURN VARCHAR2;

    -- ------------------------------------------------------------------------
   --
   -- Nom        : f_conso_ress_cp
   -- Auteur     : MMC
   -- Decription : Calcul du consommé d'une ressource pour le mois et année
   --              fourni en paramètres en fonction du CP
   -- Paramètres :
   --              p_mois (IN)            Mois traité 'MM'
   --		   p_annee(IN)            Année traitée 'AAAA'
   --              p_divsecgrou (IN)      Code Dpt/Pole/Groupe
   --              p_tires (IN)           Identifiant ressource
   --              p_pid (IN)             Identifiant projet
   --              p_aist (IN)            Identifiant sous-tâche
   -- Retour     : Nbre de jours consommés de la ressource
   -- ------------------------------------------------------------------------
   FUNCTION  f_conso_ress_cp(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_divsecgrou          IN proplus.divsecgrou%TYPE,
			    p_cpident IN proplus.cpident%TYPE,
			    p_tires               IN proplus.tires%TYPE,
			    p_pid                 IN proplus.pid%TYPE,
			    p_aist                IN proplus.aist%TYPE
			    ) RETURN NUMBER ;

 -- ------------------------------------------------------------------------
   --
   -- Nom        : f_conso_abs
   -- Auteur     : MMC
   -- Decription : Calcul du consommé d'une ressource pour le mois pour les lignes de type absence
   -- Paramètres :
   --              p_mois (IN)            Mois traité 'MM'
   --		   p_divsecgrou (IN)      Code Dpt/Pole/Groupe
   --              p_tires (IN)           Identifiant ressource
   --              p_pid (IN)             Identifiant projet
   --              p_aist (IN)            Identifiant sous-tâche
   -- Retour     : Nbre de jours consommés de la ressource
   -- ------------------------------------------------------------------------
   FUNCTION  f_conso_abs(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_divsecgrou          IN proplus.divsecgrou%TYPE,
			    p_tires               IN proplus.tires%TYPE,
			    p_pid                 IN proplus.pid%TYPE,
			    p_aist                IN proplus.aist%TYPE
			    ) RETURN NUMBER ;


PRAGMA restrict_references(f_conso_ress, WNDS);
PRAGMA restrict_references(f_nbjour_ouvre, WNDS);
PRAGMA restrict_references(f_societe_ress, WNDS);
PRAGMA restrict_references(f_conso_ress_cp, WNDS);


END pack_verif_reshist ;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_reshist  AS
-- ---------------------------------------------------


-------------------------------------------------------------------
--
------------------------------------------------------------------

FUNCTION f_conso_ress(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_divsecgrou          IN proplus.divsecgrou%TYPE,
			    p_tires               IN proplus.tires%TYPE,
			    p_pid                 IN proplus.pid%TYPE,
			    p_aist                IN proplus.aist%TYPE
			   ) RETURN NUMBER IS
      l_conso_res NUMBER(15, 2) := 0 ;
	l_derjour_mois VARCHAR2(2) := '31';
	l_annee_traite VARCHAR2(4) := p_annee ;

	l_mois_annee_datdebex VARCHAR2(7) := '12/2000';  /* MM/AAAA */
	l_mois_datdebex VARCHAR2(2) := '12';


BEGIN

	BEGIN
		-----------------------------------------------------------------------------
		-- Determination de l'année à traiter si p_annee est nul !
		-----------------------------------------------------------------------------
            IF ( p_annee IS NULL )
		THEN
			SELECT TO_CHAR(cmensuelle, 'MM/YYYY') INTO l_mois_annee_datdebex  FROM datdebex;

			l_annee_traite := SUBSTR(l_mois_annee_datdebex, 4, 4);
			l_mois_datdebex := SUBSTR(l_mois_annee_datdebex, 1, 2);

			---------------------------------------------------------------
			-- Dans ce cas, on ne fera les calculs que si p_mois (mois traité)
			-- <= l_mois_datdebex (mois de datdebex)
			-- Sinon, on retourne 0 tout de suite
			----------------------------------------------------------------
			IF ( l_mois_datdebex < p_mois )
			THEN
				RETURN (0);
			END IF;
		END IF;

		EXCEPTION
	 		WHEN OTHERS THEN
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

	BEGIN
            l_derjour_mois := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || p_mois  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );

		IF ( p_aist IS NOT NULL)
		THEN
		  SELECT SUM(cusag)
		  INTO	l_conso_res
		  FROM  proplus
	 	  WHERE
			divsecgrou = p_divsecgrou
			AND tires  = p_tires
			AND pid    = p_pid
			AND aist   = p_aist
			AND cdeb BETWEEN TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
						     AND TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');
		ELSE
		  SELECT SUM(cusag)
		  INTO	l_conso_res
		  FROM  proplus
	 	  WHERE
			divsecgrou = p_divsecgrou
			AND tires  = p_tires
			AND pid    = p_pid
			AND aist   IS NULL
			AND cdeb BETWEEN TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
						     AND TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');

		END IF;
		/*****************************************************************************************
		DBMS_OUTPUT.PUT_LINE('f_conso_ress.mois: '|| p_mois);
		DBMS_OUTPUT.PUT_LINE('f_conso_ress.Annee: '|| l_annee_traite);
		DBMS_OUTPUT.PUT_LINE('f_conso_ress.derjour_mois: '|| l_derjour_mois);
		DBMS_OUTPUT.PUT_LINE('f_conso_ress.DPG: '|| p_divsecgrou);
		DBMS_OUTPUT.PUT_LINE('f_conso_ress.Tires: '|| p_tires);
		DBMS_OUTPUT.PUT_LINE('f_conso_ress.pid: '|| p_pid);
		DBMS_OUTPUT.PUT_LINE('f_conso_ress.ss_tache: '|| p_aist);
      	DBMS_OUTPUT.PUT_LINE('f_conso_ress.l_conso_res  : '|| l_conso_res );
            *****************************************************************************************/

		RETURN( NVL(l_conso_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_conso_res  := 0;
				RETURN (0);
	 		WHEN OTHERS THEN
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_conso_ress;




-------------------------------------------------------------------
--
------------------------------------------------------------------

FUNCTION f_nbjour_ouvre(
			    p_annee    IN VARCHAR2,
			    p_mois     IN VARCHAR2
			   ) RETURN calendrier.cjours%TYPE  IS
      l_nbjour_ouvre calendrier.cjours%TYPE := 0 ;
      l_annee_traite VARCHAR2(4) := p_annee ;

BEGIN

	BEGIN
		-----------------------------------------------------------------------------
		-- Determination de l'année à traiter si p_annee est nul !
		-----------------------------------------------------------------------------
            IF ( p_annee IS NULL )
		THEN
			SELECT TO_CHAR(datdebex, 'YYYY') INTO l_annee_traite FROM datdebex;
		END IF;

		EXCEPTION
	 		WHEN OTHERS THEN
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

	BEGIN
		SELECT cjours
		INTO   l_nbjour_ouvre
		FROM   calendrier
		WHERE  calanmois = TRUNC(TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY'), 'MONTH') ;

		RETURN( NVL(l_nbjour_ouvre , 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_nbjour_ouvre   := 0;
				RETURN(0);
	 		WHEN OTHERS THEN
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

END f_nbjour_ouvre;




-------------------------------------------------------------------
--
------------------------------------------------------------------

   FUNCTION f_societe_ress( p_date IN VARCHAR2, p_tires IN INTEGER) RETURN VARCHAR2 IS
	l_societe	proplus.societe%TYPE;
	l_date		DATE;
   BEGIN
	l_date:=TO_DATE('01/'||p_date, 'DD/MM/YYYY');

	BEGIN
		SELECT soccode
			INTO l_societe
			FROM situ_ress
			WHERE ident=p_tires
			AND datsitu<=l_date
			AND (datdep>=l_date OR datdep IS NULL);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
-- si rien trouve on prend la derniere situation de la ressource
			SELECT soccode
				INTO l_societe
				FROM situ_ress
				WHERE ident=p_tires
				AND datsitu=(SELECT MAX(datsitu) FROM situ_ress WHERE ident=p_tires);
		WHEN OTHERS THEN
			RAISE;
	END;

	RETURN l_societe;
   END f_societe_ress;

---
---
FUNCTION  f_conso_ress_cp(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_divsecgrou          IN proplus.divsecgrou%TYPE,
			    p_cpident IN proplus.cpident%TYPE,
			    p_tires               IN proplus.tires%TYPE,
			    p_pid                 IN proplus.pid%TYPE,
			    p_aist                IN proplus.aist%TYPE
			    ) RETURN NUMBER IS

        l_conso_res NUMBER(15, 2) := 0 ;
	l_derjour_mois VARCHAR2(2) := '31';
	l_annee_traite VARCHAR2(4) := p_annee ;
	l_mois_annee_datdebex VARCHAR2(7) := '12/2000';  /* MM/AAAA */
	l_mois_datdebex VARCHAR2(2) := '12';
	l_cpident VARCHAR2(5);


BEGIN

	BEGIN
		-----------------------------------------------------------------------------
		-- Determination de l'année à traiter si p_annee est nul !
		-----------------------------------------------------------------------------
            IF ( p_annee IS NULL )
		THEN
			SELECT TO_CHAR(cmensuelle, 'MM/YYYY') INTO l_mois_annee_datdebex  FROM datdebex;

			l_annee_traite := SUBSTR(l_mois_annee_datdebex, 4, 4);
			l_mois_datdebex := SUBSTR(l_mois_annee_datdebex, 1, 2);

			---------------------------------------------------------------
			-- Dans ce cas, on ne fera les calculs que si p_mois (mois traité)
			-- <= l_mois_datdebex (mois de datdebex)
			-- Sinon, on retourne 0 tout de suite
			----------------------------------------------------------------
			IF ( l_mois_datdebex < p_mois )
			THEN
				RETURN (0);
			END IF;
		END IF;

		EXCEPTION
	 		WHEN OTHERS THEN
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

	BEGIN
            l_derjour_mois := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || p_mois  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );

		-- ON recupere le CP
			SELECT DISTINCT sr.cpident INTO l_cpident
			FROM situ_ress sr,proplus p
			WHERE p.tires=sr.ident
			AND p.tires= p_tires
			AND sr.datsitu <= TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
			AND ( sr.datdep >= TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
			OR sr.datdep IS NULL)
			;

		IF ( p_aist IS NOT NULL)
		THEN
			IF l_cpident <> p_cpident
			THEN l_conso_res :=null;
			ELSE
		  SELECT SUM(cusag)
		  INTO	l_conso_res
		  FROM  proplus p
	 	  WHERE
			divsecgrou = p_divsecgrou
			AND tires  = p_tires
			AND pid    = p_pid
			AND aist   = p_aist
			AND cdeb BETWEEN TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
			AND TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');
			END IF;

		ELSE
			IF l_cpident <> p_cpident
			THEN l_conso_res :=null;
			ELSE
		  SELECT SUM(cusag)
		  INTO	l_conso_res
		  FROM  proplus p
	 	  WHERE
			divsecgrou = p_divsecgrou
			AND tires  = p_tires
			AND pid    = p_pid
			AND aist   IS NULL
			AND cdeb BETWEEN TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
			AND TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');
			END IF;
		END IF;

		RETURN( NVL(l_conso_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_conso_res  := 0;
				RETURN (0);
	 		WHEN OTHERS THEN
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_conso_ress_cp;

FUNCTION f_conso_abs(
			    p_mois                IN VARCHAR2,
			    p_annee               IN VARCHAR2,
			    p_divsecgrou          IN proplus.divsecgrou%TYPE,
			    p_tires               IN proplus.tires%TYPE,
			    p_pid                 IN proplus.pid%TYPE,
			    p_aist                IN proplus.aist%TYPE
			   ) RETURN NUMBER IS
l_conso_res_sg NUMBER(15, 2) := 0 ;
l_conso_res_ssii NUMBER(15, 2) := 0 ;
l_res NUMBER(15, 2) := 0 ;
l_derjour_mois VARCHAR2(2) := '31';
l_annee_traite VARCHAR2(4) := p_annee ;
l_societe VARCHAR2(4);

l_mois_annee_datdebex VARCHAR2(7) := '12/2000';  /* MM/AAAA */
l_mois_datdebex VARCHAR2(2) := '12';


BEGIN

	BEGIN
		-----------------------------------------------------------------------------
		-- Determination de l'année à traiter si p_annee est nul !
		-----------------------------------------------------------------------------
            IF ( p_annee IS NULL )
		THEN
			SELECT TO_CHAR(cmensuelle, 'MM/YYYY') INTO l_mois_annee_datdebex  FROM datdebex;

			l_annee_traite := SUBSTR(l_mois_annee_datdebex, 4, 4);
			l_mois_datdebex := SUBSTR(l_mois_annee_datdebex, 1, 2);

			---------------------------------------------------------------
			-- Dans ce cas, on ne fera les calculs que si p_mois (mois traité)
			-- <= l_mois_datdebex (mois de datdebex)
			-- Sinon, on retourne 0 tout de suite
			----------------------------------------------------------------
			IF ( l_mois_datdebex < p_mois )
			THEN
				RETURN (0);
			END IF;
		END IF;

		EXCEPTION
	 		WHEN OTHERS THEN
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;


	BEGIN
            l_derjour_mois := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || p_mois  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );
		--total absences  non facturees pour les SG
		  SELECT NVL(SUM(p.cusag),0)
		  INTO	l_conso_res_sg
		  FROM  proplus	p,ligne_bip lb
	 	  WHERE
			p.divsecgrou = p_divsecgrou
			AND p.tires  = p_tires
			AND p.pid    = lb.pid
			AND lb.typproj=7
			AND p.societe='SG..'
			AND p.cdeb BETWEEN TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
			     AND TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_conso_res_sg  := 0;
			WHEN OTHERS THEN
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;

	BEGIN
            l_derjour_mois := TO_CHAR( LAST_DAY(TO_DATE('01' || '/' || p_mois  || '/' || l_annee_traite, 'DD/MM/YYYY')), 'DD' );
		--total absences  non facturees pour les SSII
		  SELECT NVl(SUM(p.cusag),0)
		  INTO	l_conso_res_ssii
		  FROM  proplus	p,ligne_bip lb
	 	  WHERE
			p.divsecgrou = p_divsecgrou
			AND p.tires  = p_tires
			AND p.pid    = lb.pid
			AND lb.typproj=7
			AND p.societe <> 'SG..'
			AND (p.aist NOT IN ('SEMINA','FORFAC','DEMENA','CLUBUT','COLOQU') OR p.aist IS NULL)
			AND p.cdeb BETWEEN TO_DATE('01' || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY')
			     AND TO_DATE(l_derjour_mois || '/' || p_mois || '/' || l_annee_traite, 'DD/MM/YYYY');

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_conso_res_ssii  := 0;
			WHEN OTHERS THEN
	   			--raise_application_error(-pack_utile_numsg.nuexc_others, SQLERRM);
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);
	END;




	l_res := l_conso_res_ssii + l_conso_res_sg;
	RETURN( NVL(l_res, 0) );



END f_conso_abs;

END pack_verif_reshist ;
/
CREATE OR REPLACE PACKAGE pack_verif_restab  AS
   --
   -- Nom        : f_reserve
   -- Auteur     : Equipe SOPRA (HT)
   -- Paramètres :
   --              p_factpid (IN)
   --			 p_soci(IN)     'SG ou SSII' soc. des ressources
   --              p_type (IN)    'M ou A' mensuel ou annuel
   --              p_moisannee (IN)  Ex. : 01/04/1999
   -- ---------------------------------------------------------------

   FUNCTION f_datsitu_recente(
			    p_ident             IN NUMBER
			     ) RETURN DATE;

PRAGMA restrict_references(f_datsitu_recente, WNDS, WNPS);

   FUNCTION f_date_arrivee(
			    p_ident             IN NUMBER
			    ) RETURN VARCHAR2;


PRAGMA restrict_references(f_date_arrivee, WNDS, WNPS);

   FUNCTION f_codsoc(
			    p_ident	IN NUMBER
			    ) RETURN VARCHAR2;


PRAGMA restrict_references(f_codsoc, WNDS, WNPS);

   FUNCTION f_dateclot(
			  date_cloture 	IN DATE,
			  typ		IN CHAR
			    ) RETURN VARCHAR2;


PRAGMA restrict_references(f_dateclot, WNDS, WNPS);

   FUNCTION f_absences(
			  p_tires		IN NUMBER,
			  mois_calcule		IN VARCHAR2,
			  annee_calculee	IN VARCHAR2,
			  typ			IN VARCHAR2,
			  codsg			IN VARCHAR2
			) RETURN NUMBER;


PRAGMA restrict_references(f_absences, WNDS, WNPS);

   FUNCTION f_cp(
			cpident		IN NUMBER
			) RETURN VARCHAR2;


PRAGMA restrict_references(f_cp, WNDS, WNPS);

END pack_verif_restab;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_restab  AS
-- ---------------------------------------------------


FUNCTION f_datsitu_recente(
			p_ident             IN NUMBER
		) return DATE
IS

p_datsitu_recente	DATE;

BEGIN
	select max(datsitu) into p_datsitu_recente from situ_ress where ident=p_ident
		;
	return(p_datsitu_recente);

END f_datsitu_recente;


FUNCTION f_date_arrivee(
			   p_ident             IN NUMBER
			) return VARCHAR2
IS

compteur 	NUMBER(5);
nbjour		NUMBER(7);
datsitu_max	DATE;
datdep_prec	DATE;
p_date_arrivee  VARCHAR2(10);

CURSOR C1 IS select datsitu,datdep from situ_ress where ident=p_ident order by datsitu;
CURSOR C2 IS select datsitu,datdep from situ_ress where ident=p_ident order by datsitu;
ligne1 C1%rowtype;
ligne2 C2%rowtype;

BEGIN
select max(datsitu) into datsitu_max from situ_ress where ident=p_ident;
select count(*) into compteur from situ_ress where ident=p_ident;
if compteur=1 then
	select to_char(datsitu,'DD/MM/YYYY') into p_date_arrivee
		from situ_ress where ident=p_ident;
elsif compteur > 1 then
	BEGIN
	OPEN C1;
	LOOP
	FETCH C1 into ligne1;
	datdep_prec := ligne1.datdep;
	EXIT when C1%notfound;
		OPEN C2;
		LOOP
		FETCH C2 into ligne2;
		EXIT when C2%notfound;
			if ligne2.datsitu <= ligne1.datsitu then
				 null;
			else
				nbjour := ligne2.datsitu - datdep_prec;
				if nbjour >= 365 then
					exit;
				else
					datdep_prec := ligne2.datdep;
					if ligne2.datsitu = datsitu_max then
					p_date_arrivee := to_char(ligne1.datsitu,'DD/MM/YYYY');
					exit;
					end if;
				end if;
			end if;
		END LOOP;
		CLOSE C2;
	if p_date_arrivee is not null then exit;end if;
	END LOOP;
	CLOSE C1;
	if p_date_arrivee is null then p_date_arrivee := to_char(datsitu_max,'DD/MM/YYYY');
	end if;
	END;
end if;
return(p_date_arrivee);
END f_date_arrivee;

FUNCTION f_codsoc(
			p_ident             IN NUMBER
		) return VARCHAR2
IS

code_societe VARCHAR2(4);
p_date_arrivee	VARCHAR2(10);

BEGIN
	p_date_arrivee := f_date_arrivee(p_ident);
	select soccode into code_societe from situ_ress
		where datsitu=to_date(p_date_arrivee,'DD/MM/YYYY')
		and ident = p_ident;
return(code_societe);

END f_codsoc;


FUNCTION f_dateclot(
			date_cloture	 IN DATE,
			typ		 IN CHAR
		) return VARCHAR2
IS

mois_calcule	VARCHAR2(2);
annee_calculee	VARCHAR2(4);

BEGIN

	if date_cloture > sysdate and to_char(date_cloture,'YYYY')=to_char(sysdate,'YYYY') then
		mois_calcule := '12';
		annee_calculee := to_char(add_months(sysdate,-12),'YYYY');
	else
		mois_calcule := to_char(add_months(sysdate,-1),'MM');
		annee_calculee :=  to_char(add_months(sysdate,-1),'YYYY');
	end if;

	if typ = 'M' then
		return(mois_calcule);
	elsif typ = 'A' then
		return(annee_calculee);
	end if;

END f_dateclot;

FUNCTION f_absences(
		p_tires 	IN NUMBER,
		mois_calcule	IN VARCHAR2,
		annee_calculee	IN VARCHAR2,
		typ		IN VARCHAR2,
		codsg		IN VARCHAR2
			) return NUMBER
IS

calcul		NUMBER;
dern_jour	DATE;
l_codsg 	varchar2(10);

BEGIN

dern_jour :=last_day(to_date(mois_calcule || '/' || annee_calculee, 'MM/YYYY'));
l_codsg := codsg||'%';

	select sum(cusag) into calcul from proplus
	where tires=p_tires
	and ((TO_CHAR(divsecgrou, 'FM0000000')) like l_codsg
	    or (TO_CHAR(divsecgrou)) like l_codsg)
	and cdeb between
		to_date('01/01/' || (annee_calculee),'DD/MM/YYYY')
		and
		dern_jour
	and aist like decode(typ,'TOTAL','%',typ)
	and aist in ('CONGES','ABSDIV','FORMAT','FORFAC','MOBILI','CLUBUT','SEMINA','DEMENA','PARTIE','RTT');

return(calcul);
END f_absences;


FUNCTION f_cp (
		cpident		IN NUMBER
		) RETURN VARCHAR2
IS

nom_cp	VARCHAR2(30);

BEGIN
	select rnom into nom_cp from ressource where ident=cpident;
	return(nom_cp);
END f_cp;

END pack_verif_restab;
/
CREATE OR REPLACE PACKAGE pack_verif_visuproj  AS
-- ----------------------------------------------

-- ------------------------------------------------------------------------
--
-- Nom        : verif_visuproj
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'état visuproj
-- Paramètres :
--              p_pid (IN)			Code projet
--              p_userid      (IN) 		Code user BIP
--		    P_message OUT             Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------

     PROCEDURE verif_visuproj(
                 p_pid 		IN  VARCHAR2,	     -- CHAR(4)
		 p_userid 	IN  VARCHAR2,
                 P_message 	OUT VARCHAR2
                 );


   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_propose
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget proposé pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant du budget proposé
   --
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_budget_propose(
				p_pid   IN budget.pid%TYPE,
			        p_annee IN budget.annee%TYPE
			     	) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_budget_propose,wnds);

-- ------------------------------------------------------------------------

   -- Nom        : f_calc_budget_propose_mo
   -- Auteur     : MMC
   -- Decription : calcul le budget proposé pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant du budget proposé
   -- ------------------------------------------------------------------------

   FUNCTION f_calc_budget_propose_mo(
				p_pid   IN budget.pid%TYPE,
 			        p_annee IN budget.annee%TYPE
			     	) RETURN NUMBER;



   PRAGMA restrict_references(f_calc_budget_propose_mo,wnds);
   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_reserve
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget réservé pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant du budget réservé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_budget_reserve(
				p_pid   IN budget.pid%TYPE,
			        p_annee IN budget.annee%TYPE
			     	) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_budget_reserve,wnds);

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_notifie
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget notifier pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_budget_notifie(
				p_pid   IN budget.pid%TYPE,
			     	p_annee IN budget.annee%TYPE
			    	) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_budget_notifie,wnds);

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_arb_notifie
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget arbitré notifié pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_budget_arb_notifie(p_pid   IN budget.pid%TYPE,
				      p_annee IN budget.annee%TYPE
				) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_budget_arb_notifie,wnds);

 -- ------------------------------------------------------------------------
   -- Nom        : f_calc_reestime
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le réestimé
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant Calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_reestime(     p_pid   IN budget.pid%TYPE,
				 p_annee IN budget.annee%TYPE
				) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_reestime,wnds);
   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_conso
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget consommé de : Année courante ou  AN - 1 ou  AN - 2 ou AN - 3
   --
   -- Paramètres : p_pid   		(IN) code projet
   --              p_indic_annee 	(IN) Indicateur de l'année à prendre en compte
   --							'0' --> Année en cour
   --							'1' --> Année -1
   --							'2' --> Année -2
   --							'3' --> Année -3
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_budget_conso(
				p_pid         IN consomme.pid%TYPE,
				p_indic_annee IN VARCHAR2			-- CHAR(1)
				) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_budget_conso,wnds);

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_conso_mois_cour
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul  budget consommé mois courant
   --
   -- Paramètres : p_pid   		(IN) code projet
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_budget_conso_mois_cour(
				p_pid   IN consomme.pid%TYPE
				) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_budget_conso_mois_cour, wnds);

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_totbudcons_depuis_creat
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul  budget consommé au total par un projet depuis sa création
   --
   -- Paramètres : p_pid   		(IN) code projet
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_totbudcons_depuis_creat(
				p_pid   IN consomme.pid%TYPE
				) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_totbudcons_depuis_creat, wnds);

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_fact_interne_decn1_fr
   -- Auteur     : Equipe SOPRA
   -- Decription : Facturation interne de decembre de l'année N - 1 en FRANC !!!
   --      		 pour un projet et une année donnés
   -- Paramètres : p_pid   		(IN) code projet
   --              p_annee 		(IN) annee considérée
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_fact_interne_decn1_fr(
				p_pid   IN stock_fi.pid%TYPE,
				p_annee IN NUMBER
				) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_fact_interne_decn1_fr, wnds);

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_fact_interne_annee_fr
   -- Auteur     : Equipe SOPRA
   -- Decription : Facturation interne (en FRANC !!!) de l'année pour un projet et une année donnés
   --      		 pour un projet et une année donnés
   -- Paramètres : p_pid   		(IN) code projet
   --              p_annee 		(IN) annee considérée
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_fact_interne_annee_fr(
				p_pid   IN stock_fi.pid%TYPE,
				p_annee IN NUMBER
				) RETURN NUMBER;

   PRAGMA restrict_references(f_calc_fact_interne_annee_fr, wnds);

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_immos
   -- Auteur     : PPR
   -- Decription : Immobilisations de l'année pour un projet et une année donnés
   --
   -- Paramètres : p_pid   		(IN) code projet
   --              p_annee 		(IN) annee considérée
   -- Retour     : Montant calculé en euros
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_immos (
				p_pid   IN stock_immo.pid%TYPE,
				p_annee IN NUMBER
				) RETURN NUMBER ;

   PRAGMA restrict_references(f_calc_immos, wnds);


END pack_verif_visuproj ;
/

CREATE OR REPLACE PACKAGE BODY pack_verif_visuproj  AS
-- ---------------------------------------------------

-- ------------------------------------------------------------------------
--
-- Nom        : verif_visuproj
-- Auteur     : Equipe SOPRA
-- Decription : Vérification des paramètres saisis pour l'état visuproj
-- Paramètres :
--              p_pid (IN)			Code projet
--              p_userid      (IN) 		Code user BIP
--		    P_message OUT             Message de sortie
--
-- Remarque :
--
-- ------------------------------------------------------------------------

     PROCEDURE verif_visuproj(
                 p_pid 		IN  VARCHAR2,	     -- CHAR(4)
		 p_userid 	IN  VARCHAR2,
                 P_message 	OUT VARCHAR2
                 ) IS

      l_message      	VARCHAR2(1024) 		:= '';
      l_menutil   	VARCHAR2(255);
      l_clicode   	client_mo.clicode%TYPE;
      l_perimetre 	VARCHAR2(255);
      l_bool      	boolean;
      l_num_exception 	NUMBER;

BEGIN

   BEGIN

	---------------------------------------------------------------------------------------------
	-- (1) Vérification existence Code ligne bip dans la table LIGNE_BIP
	---------------------------------------------------------------------------------------------
	IF ( pack_utile3A.f_verif_pid_ligne_bip(p_pid) = FALSE )
	THEN
		l_num_exception := pack_utile_numsg.nuexc_codligne_bip_inexiste;
            	pack_global.recuperer_message(l_num_exception , '%s1', p_pid, ' P_param6 ', l_message);
		RAISE_APPLICATION_ERROR(-l_num_exception, l_message);

	END IF;

	p_message   := l_message;

   END;

END verif_visuproj;

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_propose
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget proposé pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant du budget proposé
   --
   --
   -- ------------------------------------------------------------------------
FUNCTION f_calc_budget_propose(
				p_pid   IN budget.pid%TYPE,
			        p_annee IN budget.annee%TYPE
			    	) RETURN NUMBER IS

   l_montant_res budget.bpmontme%TYPE := 0;

BEGIN

	BEGIN

		SELECT bpmontme
		INTO  l_montant_res
		FROM  budget
		WHERE pid = p_pid
		AND   annee = p_annee;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;


END f_calc_budget_propose;

 -- ------------------------------------------------------------------------

   -- Nom        : f_calc_budget_propose

   -- Auteur     : Equipe SOPRA

   -- Decription : calcul le budget proposé pour une annee

   --

   -- Paramètres : p_pid   (IN) code projet

   --              p_annee (IN) annee du buget

   -- Retour     : Montant du budget proposé

   --

   --

   -- ------------------------------------------------------------------------

FUNCTION f_calc_budget_propose_mo(
				p_pid   IN budget.pid%TYPE,
			        p_annee IN budget.annee%TYPE
			    	) RETURN NUMBER IS
   l_montant_res budget.bpmontmo%TYPE := 0;
BEGIN

	BEGIN

		SELECT bpmontmo
		INTO  l_montant_res
		FROM  budget
		WHERE pid = p_pid
		AND   annee = p_annee;
		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION

			WHEN NO_DATA_FOUND THEN

				RETURN(0);

	 		WHEN OTHERS THEN

				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);



	END;
END f_calc_budget_propose_mo;


   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_reserve
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget proposé pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant du budget proposé
   --
   --
   -- ------------------------------------------------------------------------
FUNCTION f_calc_budget_reserve(
				p_pid   IN budget.pid%TYPE,
			        p_annee IN budget.annee%TYPE
			     	) RETURN NUMBER IS

	l_montant_res budget.reserve%TYPE := 0;

BEGIN

	BEGIN

		SELECT reserve
		INTO  l_montant_res
		FROM  budget
		WHERE pid = p_pid
		AND   annee = p_annee;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_calc_budget_reserve;


   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_totbudcons_depuis_creat
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul  budget consommé au total par un projet depuis sa création
   --
   -- Paramètres : p_pid   		(IN) code projet
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
FUNCTION f_calc_totbudcons_depuis_creat(
				p_pid   IN consomme.pid%TYPE
			     	) RETURN NUMBER IS

	l_montant_res NUMBER(15, 2) := 0;

BEGIN

	BEGIN
	SELECT MAX(xcusag)
	INTO l_montant_res
	FROM  consomme ,datdebex
 	WHERE  pid=p_pid
	AND annee >= (TO_NUMBER(TO_CHAR(datdebex,'YYYY')) -2);

	RETURN( NVL(l_montant_res, 0) );
	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_calc_totbudcons_depuis_creat;


   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_notifie
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget notifier pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
FUNCTION f_calc_budget_notifie(
				p_pid   IN budget.pid%TYPE,
			     	p_annee IN budget.annee%TYPE
			    	) RETURN NUMBER IS

	l_montant_res budget.bnmont%TYPE := 0;

BEGIN

	BEGIN

		SELECT bnmont
		INTO  l_montant_res
		FROM  budget
		WHERE pid = p_pid
		AND   annee = p_annee;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;


END f_calc_budget_notifie;

  -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_arb_notifie
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget arbitré notifié pour une annee
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant Calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_budget_arb_notifie(p_pid   IN budget.pid%TYPE,
				      p_annee IN budget.annee%TYPE

				) RETURN NUMBER IS

	l_montant_res budget.anmont%TYPE := 0;

BEGIN

	BEGIN

		SELECT anmont
		INTO  l_montant_res
		FROM  budget
		WHERE pid = p_pid
		AND   annee = p_annee;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_calc_budget_arb_notifie;

 -- ------------------------------------------------------------------------
   -- Nom        : f_calc_reestime
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le réestimé
   --
   -- Paramètres : p_pid   (IN) code projet
   --              p_annee (IN) annee du buget
   -- Retour     : Montant Calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_reestime(p_pid   IN budget.pid%TYPE,
		   	    p_annee IN budget.annee%TYPE
				) RETURN NUMBER IS

	l_montant_res budget.reestime%TYPE := 0;

BEGIN

	BEGIN

		SELECT reestime
		INTO  l_montant_res
		FROM  budget
		WHERE pid = p_pid
		AND   annee = p_annee;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_calc_reestime;

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_conso
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul le budget consommé de année courante ou  AN - 1, AN - 2 , AN - 3
   --
   -- Paramètres : p_pid   		(IN) code projet
   --              p_indic_annee 	(IN) Indicateur de l'année à prendre en compte
   --							'0' --> Année en cour
   --							'1' --> Année -1
   --							'2' --> Année -2
   --							'3' --> Année -3
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
  FUNCTION f_calc_budget_conso(
				p_pid         IN consomme.pid%TYPE,
				p_indic_annee IN VARCHAR2			-- CHAR(1)
				) RETURN NUMBER IS

	l_montant_res consomme.cusag%TYPE := 0;

BEGIN

	BEGIN

		IF ( p_indic_annee = '0') THEN
			SELECT cusag
			INTO  l_montant_res
			FROM  consomme,datdebex
			WHERE pid = p_pid
			AND annee = TO_NUMBER(TO_CHAR(datdebex,'YYYY'));
		ELSIF ( p_indic_annee = '1') THEN
			SELECT cusag
			INTO  l_montant_res
			FROM  consomme,datdebex
			WHERE pid = p_pid
			AND annee = TO_NUMBER(TO_CHAR(ADD_MONTHS(datdebex,-12),'YYYY'));
		ELSIF ( p_indic_annee = '2') THEN
			SELECT cusag
			INTO  l_montant_res
			FROM  consomme,datdebex
			WHERE pid = p_pid
			AND annee = TO_NUMBER(TO_CHAR(ADD_MONTHS(datdebex,-24),'YYYY'));
		ELSIF ( p_indic_annee = '3') THEN
			SELECT cusag
			INTO  l_montant_res
			FROM  consomme,datdebex
			WHERE pid = p_pid
			AND annee = TO_NUMBER(TO_CHAR(ADD_MONTHS(datdebex,-36),'YYYY'));
		ELSE
			l_montant_res := 0;
		END IF;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_calc_budget_conso;

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_budget_conso_mois_cour
   -- Auteur     : Equipe SOPRA
   -- Decription : calcul  budget consommé mois courant
   --
   -- Paramètres : p_pid   		(IN) code projet
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
FUNCTION f_calc_budget_conso_mois_cour(
				p_pid   IN consomme.pid%TYPE
				) RETURN NUMBER IS
		l_pid consomme.pid%TYPE;
		l_montant_res consomme.xcusag%TYPE := 0;

BEGIN

	BEGIN
		SELECT factpid pid,SUM(cusag) xcusmois  INTO l_pid,l_montant_res FROM proplus,datdebex
		WHERE proplus.factpid=p_pid
		AND (qualif not in ('MO','GRA','IFO','STA','INT') OR qualif is null)
		AND trunc(proplus.cdeb,'MONTH')=trunc(datdebex.moismens,'MONTH')
	 	GROUP BY factpid;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END  f_calc_budget_conso_mois_cour;


   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_fact_interne_decn1_fr
   -- Auteur     : Equipe SOPRA
   -- Decription : Facturation interne de decembre de l'année N - 1 en FRANC !!!
   --      		 pour un projet et une année donnés
   -- Paramètres : p_pid   		(IN) code projet
   --              p_annee 		(IN) annee considérée
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
FUNCTION f_calc_fact_interne_decn1_fr(
				p_pid   IN stock_fi.pid%TYPE,
				p_annee IN NUMBER
				) RETURN NUMBER IS
	l_montant_res NUMBER(25, 2) := 0;

BEGIN

	BEGIN
		SELECT
			SUM(consoft) + SUM(consoenvimmo) + SUM(nconsoenvimmo)
		INTO
			l_montant_res
		FROM
			STOCK_FI
		WHERE
			pid=p_pid
		AND to_char(cdeb, 'MM') = '12';

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_calc_fact_interne_decn1_fr;

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_fact_interne_annee_fr
   -- Auteur     : Equipe SOPRA
   -- Decription : Facturation interne (en FRANC !!!) de l'année pour un projet et une année donnés
   --      		 pour un projet et une année donnés
   -- Paramètres : p_pid   		(IN) code projet
   --              p_annee 		(IN) annee considérée
   -- Retour     : Montant calculé
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_fact_interne_annee_fr(
				p_pid   IN stock_fi.pid%TYPE,
				p_annee IN NUMBER
				) RETURN NUMBER IS

	l_montant_res NUMBER(25, 2) := 0;

BEGIN

	BEGIN

		SELECT
			SUM(consoft + consoenvimmo + nconsoenvimmo)
		INTO
			l_montant_res
		FROM
			STOCK_FI
		WHERE
			pid=p_pid;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_calc_fact_interne_annee_fr;

   -- ------------------------------------------------------------------------
   -- Nom        : f_calc_immos
   -- Auteur     : PPR
   -- Decription : Immobilisations de l'année pour un projet et une année donnés
   --
   -- Paramètres : p_pid   		(IN) code projet
   --              p_annee 		(IN) annee considérée
   -- Retour     : Montant calculé en euros
   --
   -- ------------------------------------------------------------------------
   FUNCTION f_calc_immos (
				p_pid   IN stock_immo.pid%TYPE,
				p_annee IN NUMBER
				) RETURN NUMBER IS

	l_montant_res NUMBER(25, 2) := 0;

BEGIN

	BEGIN

		SELECT
			SUM(consoft)
		INTO
			l_montant_res
		FROM
			STOCK_IMMO
		WHERE
			pid=p_pid;

		RETURN( NVL(l_montant_res, 0) );

      	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN(0);
	 		WHEN OTHERS THEN
				l_montant_res  := 0;
	   			RAISE_APPLICATION_ERROR(-20997, SQLERRM);

	END;

END f_calc_immos;

END pack_verif_visuproj ;
/
CREATE OR REPLACE PACKAGE pack_visuprojprin IS
-----------------------------------------


------------------------------------------------------------------------------
-- Constantes globales
------------------------------------------------------------------------------

CST_BUD_XXXX CONSTANT CHAR(4) := '';			-- Chaîne 'XXXX' affichée dans les états PRODEC


------------------------------------------------------------------------------
-- Types et Curseurs
------------------------------------------------------------------------------


------------------------------------------------------------------------------
-- Les Fonctions
------------------------------------------------------------------------------

-- ------------------------------------------------------------------------
   -- Nom        : tmp_visuprojprin_budget2
   -- Auteur     : MMC
   -- Decription : met a jour de la table tmp_visuprojprin  a partir des tables
   --              cons_sstache_res_mois,budget
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_pid1  (IN) identifiant ligne BIP
   --              p_pid2  (IN) identifiant ligne BIP
   --              p_pid3  (IN) identifiant ligne BIP
   --              p_pid4  (IN) identifiant ligne BIP
   --              p_pid5  (IN) identifiant ligne BIP
   --              p_pid6  (IN) identifiant ligne BIP
   --			 p_date_traite  (DATE) Date traitée : En principe, Sysdate ou datedebex
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   -- Modifié le 22/05/2006 par DDI : Passage du rééstimé sur 2 décimales.
   -- Modifié le 22/05/2006 par DDI : Passage de tous les montants sur 2 décimales.
   -- ------------------------------------------------------------------------
   FUNCTION tmp_visuprojprin_budget2 (p_codsg IN ligne_bip.codsg%TYPE,
				 p_pid1  IN ligne_bip.pid%TYPE,
				 p_pid2  IN ligne_bip.pid%TYPE,
				 p_pid3  IN ligne_bip.pid%TYPE,
				 p_pid4  IN ligne_bip.pid%TYPE,
				 p_pid5  IN ligne_bip.pid%TYPE,
				 p_pid6  IN ligne_bip.pid%TYPE,
		             p_date_traite IN DATE) RETURN NUMBER;


------------------------------------------------------------------------------
-- Les Procédures
------------------------------------------------------------------------------

   -- ------------------------------------------------------------------------
   -- Nom        : verif_projprin
   -- Auteur     : Equipe SOPRA
   -- Decription : Test les champs saisies dans la page WEB
   --
   -- Paramètres : p_param6  (IN) codsg
   --              p_param7  (IN) code ligne bip
   --              p_param8  (IN) code ligne bip
   --              p_param9  (IN) code ligne bip
   --              p_param10 (IN) code ligne bip
   --              p_param11 (IN) code ligne bip
   --              p_param12 (IN) code ligne bip
   --              p_userid  (IN) donnee de l'utilisateur
   -- Retour     : p_message (OUT) message d'erreur
   --
   -- Modif      : 20/01/2000 correction d'un bug dans le test de retour d'info
   --              dans le cas de la non saisie d'un codsg
   -- 	  PJOSSE : 14/08/2003 Ajout d'un test pour savoir si le DPG demandé est cloturé.
   -- ------------------------------------------------------------------------
   PROCEDURE verif_projprin (p_param6  IN VARCHAR2,
			     p_param7  IN ligne_bip.pid%TYPE,
			     p_param8  IN ligne_bip.pid%TYPE,
			     p_param9  IN ligne_bip.pid%TYPE,
			     p_param10 IN ligne_bip.pid%TYPE,
			     p_param11 IN ligne_bip.pid%TYPE,
			     p_param12 IN ligne_bip.pid%TYPE,
			     p_userid  IN  CHAR,
			     p_message OUT VARCHAR2
			    );



   -- ------------------------------------------------------------------------
   -- Nom        : verif_pid
   -- Auteur     : Equipe SOPRA
   -- Decription : Test les champs saisis dans la page WEB
   --
   -- Paramètres : p_pid   (IN) code ligne_bip
   --              p_focus (IN) focus pour les pages WEB
   -- Retour     :
   --
   -- ------------------------------------------------------------------------
   PROCEDURE verif_pid(p_pid     ligne_bip.pid%TYPE,
		       p_focus   VARCHAR2,
		       p_userid  IN  VARCHAR2);

END pack_visuprojprin;
/

CREATE OR REPLACE PACKAGE BODY pack_visuprojprin IS
----------------------------------------------

--****************************************************************************
-- Les Fonctions
--****************************************************************************

-- ------------------------------------------------------------------------
   -- Nom        : tmp_visuprojprin_budget2
   -- Auteur     : MMC
   -- Decription : met a jour de la table tmp_visuprojprin a partir des tables
   --              cons_sstache_res_mois,budget
   -- Paramètres : p_codsg (IN) codsg du projet
   --              p_pid1  (IN) identifiant ligne BIP
   --              p_pid2  (IN) identifiant ligne BIP
   --              p_pid3  (IN) identifiant ligne BIP
   --              p_pid4  (IN) identifiant ligne BIP
   --              p_pid5  (IN) identifiant ligne BIP
   --              p_pid6  (IN) identifiant ligne BIP
   --			 p_date_traite  (DATE) Date traitée : En principe, Sysdate ou datedebex
   --
   -- Retour     : number  : numero de sequence > 0, 0 cas d'erreur
   --
   --
   -- ------------------------------------------------------------------------
   FUNCTION tmp_visuprojprin_budget2 (p_codsg IN ligne_bip.codsg%TYPE,
				 p_pid1  IN ligne_bip.pid%TYPE,
				 p_pid2  IN ligne_bip.pid%TYPE,
				 p_pid3  IN ligne_bip.pid%TYPE,
				 p_pid4  IN ligne_bip.pid%TYPE,
				 p_pid5  IN ligne_bip.pid%TYPE,
				 p_pid6  IN ligne_bip.pid%TYPE,
		             p_date_traite IN DATE) RETURN NUMBER IS

      -- numero de sequence
      l_var_seq NUMBER;

      cursor l_pid  (c_codsg CHAR, c_pid1 CHAR, c_pid2 CHAR, c_pid3 CHAR, c_pid4 CHAR, c_pid5 CHAR, c_pid6 CHAR )IS
	SELECT  lbi.pid pid
	  FROM  ligne_bip lbi
	  WHERE lbi.typproj != '7 '
	  AND   decode(c_pid1, NULL, '0', lbi.pid) IN
	  (nvl(c_pid1, '0'), nvl(c_pid2, '0'), nvl(c_pid3, '0'), nvl(c_pid4, '0'), nvl(c_pid5, '0'), nvl(c_pid6, '0'))
	  AND   (((decode(c_codsg, NULL, '0', substr(to_char(lbi.codsg) ,1 ,length(c_codsg)))) = decode(c_codsg, NULL, '0', c_codsg))
		 OR ((decode(c_codsg, NULL, '0', substr(to_char(lbi.codsg, 'FM0000000') ,1 ,length(c_codsg)))) = decode(c_codsg, NULL, '0', c_codsg)));

	l_lig_pid l_pid%ROWTYPE;

	l_temp1 VARCHAR2(50);
	l_temp2 VARCHAR2(50);
	l_temp3 VARCHAR2(50);
	l_temp4 VARCHAR2(50);
	l_temp5 VARCHAR2(50);
	l_temp6 VARCHAR2(50);

   BEGIN

      SELECT sbudget.nextval INTO l_var_seq FROM dual;

      open l_pid(p_codsg, p_pid1,  p_pid2, p_pid3, p_pid4, p_pid5, p_pid6);

      LOOP

	 fetch l_pid INTO l_lig_pid;

	 IF l_pid%NOTFOUND THEN
	    EXIT;
	 END IF;

	 --dbms_output.put_line('FETCH :' || l_lig_pid.pid||' '||numseq);
	 -- insert dans la table tmp_visuprojprin de budget propose ME
	 INSERT INTO tmp_visuprojprin (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES ( l_var_seq,
		    'A',
		    l_lig_pid.pid,
		    '',
			'',
			'',
		    CST_BUD_XXXX,
		    to_char(pack_verif_visuproj.f_calc_budget_propose(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))),'FM9999990D00'),
		    to_char(pack_verif_visuproj.f_calc_budget_propose(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +1)),'FM9999990D00'),
		    to_char(pack_verif_visuproj.f_calc_budget_propose(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +2)),'FM9999990D00'),
		    to_char(pack_verif_visuproj.f_calc_budget_propose(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +3)),'FM9999990D00'),
		    CST_BUD_XXXX
		    );
	 -- insert dans la table tmp_visuprojprin de budget propose MO
	 INSERT INTO tmp_visuprojprin (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES ( l_var_seq,
		    'B',
		    l_lig_pid.pid,
		    '',
			'',
			'',
		    CST_BUD_XXXX,
		    to_char(pack_verif_visuproj.f_calc_budget_propose_mo(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))),'FM9999990D00'),
		    to_char(pack_verif_visuproj.f_calc_budget_propose_mo(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +1)),'FM9999990D00'),
		    to_char(pack_verif_visuproj.f_calc_budget_propose_mo(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +2)),'FM9999990D00'),
		    to_char(pack_verif_visuproj.f_calc_budget_propose_mo(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) +3)),'FM9999990D00'),
		    CST_BUD_XXXX
		    );

	 -- insert dans la table tmp_visuprojprin de budget notifie

	 l_temp2 := to_char(pack_verif_visuproj.f_calc_budget_notifie(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) -1)),'FM9999990D00');
	 l_temp3 := to_char(pack_verif_visuproj.f_calc_budget_notifie(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))),'FM9999990D00');

	 INSERT INTO tmp_visuprojprin (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'C',
		   l_lig_pid.pid,
		   '',
			'',
			'',
		   l_temp2,
		   l_temp3,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp2), 0) + nvl(to_number(l_temp3), 0),'FM9999990D00')
		   );

	 -- insert dans la table tmp_visuprojprin de budget reserve

	 l_temp2 := to_char(pack_verif_visuproj.f_calc_budget_reserve(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))),'FM9999990D00');

	 INSERT INTO tmp_visuprojprin  (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'D',
		   l_lig_pid.pid,
		   '',
			'',
			'',
		   CST_BUD_XXXX,
			l_temp2,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp2), 0) ,
			      'FM9999990D00' )
		   );

	 -- insert dans la table tmp_visuprojprin de budget arbitre
	 l_temp2 := to_char(pack_verif_visuproj.f_calc_budget_arb_notifie(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')) -1)),'FM9999990D00');
	 l_temp3 := to_char(pack_verif_visuproj.f_calc_budget_arb_notifie(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))),'FM9999990D00');

	 INSERT INTO tmp_visuprojprin (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'E',
		   l_lig_pid.pid,
		   '',
			'',
			'',
		   l_temp2,
		   l_temp3,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp2), 0) + nvl(to_number(l_temp3), 0),'FM9999990D00')
		   );


	 -- insert dans la table tmp_visuprojprin de budget consomme

	 l_temp2 := to_char(pack_verif_visuproj.f_calc_budget_conso(l_lig_pid.pid,'1'),'FM9999990D00');
	 l_temp3 := to_char(pack_verif_visuproj.f_calc_budget_conso(l_lig_pid.pid,'0'),'FM9999990D00');


	 INSERT INTO tmp_visuprojprin (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'F',
		   l_lig_pid.pid,
		  '',
			'',
			'',
		   l_temp2,
		   l_temp3,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp2), 0) + nvl(to_number(l_temp3), 0),
			      'FM9999990D00')
		   );
-- insert dans la table tmp_visuprojprin de budget cons/mois
	 l_temp2 := to_char(pack_verif_visuproj.f_calc_budget_conso_mois_cour(l_lig_pid.pid),'FM9999990D00');

	 INSERT INTO tmp_visuprojprin  (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'G',
		   l_lig_pid.pid,
		   '',
			'',
			'',
		CST_BUD_XXXX,
		   l_temp2,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp2), 0) ,
			      'FM9999990D00' )
		   );

-- insert dans la table tmp_visuprojprin de budget reestime
	 l_temp2 := to_char(pack_verif_visuproj.f_calc_reestime(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))),'FM9999990D00');

	 INSERT INTO tmp_visuprojprin  (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'H',
		   l_lig_pid.pid,
		   '',
			'',
			'',
			CST_BUD_XXXX,
		   l_temp2,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp2), 0) ,
			      'FM9999990D00' )
		   );


-- insert dans la table tmp_visuprojprin de conso ligne Bip
	 l_temp2 := to_char(pack_verif_visuproj.f_calc_totbudcons_depuis_creat(l_lig_pid.pid),'FM9999990D00');

	 INSERT INTO tmp_visuprojprin  (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'I',
		   l_lig_pid.pid,
		   '',
			'',
			'',
			CST_BUD_XXXX,
		   l_temp2,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp2), 0) ,
			      'FM9999990D00' )
		   );

-- insert donnees Facturation Interne
l_temp1 := to_char((pack_verif_visuproj.f_calc_immos(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))))/1000,'FM9999990D00');
l_temp2 := to_char((pack_verif_visuproj.f_calc_fact_interne_decn1_fr(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))))/1000,'FM9999990D00');
l_temp3 := to_char((pack_verif_visuproj.f_calc_fact_interne_annee_fr(l_lig_pid.pid, (to_number(to_char(p_date_traite, 'YYYY')))))/1000,'FM9999990D00');

	 INSERT INTO tmp_visuprojprin  (numseq,
					 typeb,
					 pid,
					 immo,
					fidec,
					fiannee,
					 minus1,
					 n,
					 plus1,
					 plus2,
					 plus3,
					 total)
	   VALUES (l_var_seq,
		   'J',
		   l_lig_pid.pid,
		   	l_temp1,
			l_temp2,
			l_temp3,
			CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   CST_BUD_XXXX,
		   to_char( nvl(to_number(l_temp2), 0) + nvl(to_number(l_temp3), 0),
			      'FM9999990D00' )
		   );


	 commit;

      END LOOP;

      -- Fermeture du curseur
      close l_pid;

      RETURN l_var_seq;

   EXCEPTION
      WHEN OTHERS THEN raise; --RETURN 0;

   END tmp_visuprojprin_budget2;



--****************************************************************************
-- Les Procédures
--****************************************************************************


   -- ------------------------------------------------------------------------
   -- Nom        : verif_projprin
   -- Auteur     : Equipe SOPRA
   -- Decription : Test les champs saisies dans la page WEB
   --
   -- Paramètres : p_param6  (IN) codsg
   --              p_param7  (IN) code ligne bip
   --              p_param8  (IN) code ligne bip
   --              p_param9  (IN) code ligne bip
   --              p_param10 (IN) code ligne bip
   --              p_param11 (IN) code ligne bip
   --              p_param12 (IN) code ligne bip
   --              p_userid  (IN) donnee de l'utilisateur
   -- Retour     : p_message (OUT) message d'erreur
   --
   -- Modif      : 20/01/2000 correction d'un bug dans le test de retour d'info
   --              dans le cas de la non saisie d'un codsg
   -- 	  PJOSSE : 14/08/2003 Ajout d'un test pour savoir si le DPG demandé est cloturé.
   -- ------------------------------------------------------------------------
   PROCEDURE verif_projprin (p_param6  IN VARCHAR2,
			     p_param7  IN ligne_bip.pid%TYPE,
			     p_param8  IN ligne_bip.pid%TYPE,
			     p_param9  IN ligne_bip.pid%TYPE,
			     p_param10 IN ligne_bip.pid%TYPE,
			     p_param11 IN ligne_bip.pid%TYPE,
			     p_param12 IN ligne_bip.pid%TYPE,
			     p_userid  IN  CHAR,
			     p_message OUT VARCHAR2
			    ) IS

      l_codsg ligne_bip.codsg%TYPE;
      l_msg  VARCHAR2(1000);


   BEGIN


      -- TEST d'existance du codsg pour DIRMENU
      IF p_param6 IS NOT NULL THEN
         BEGIN
	    SELECT  codsg
	      INTO  l_codsg
	      FROM  ligne_bip
	      WHERE substr(to_char(codsg, 'FM0000000'), 1, length(rtrim(rtrim(LPAD(p_param6,7,'0'), '*')))) = rtrim(rtrim(LPAD(p_param6,7,'0'), '*'))
	      AND   ROWNUM < 2;

	   EXCEPTION
	    WHEN no_data_found THEN
	      pack_global.recuperer_message( 20273, NULL, NULL, 'P_param6', l_msg);
	      raise_application_error( -20273, l_msg );

	    WHEN OTHERS THEN
	      raise_application_error( -20997, SQLERRM );
	   END;


	-- ====================================================================
      	-- 19/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      	-- ====================================================================
     	pack_habilitation.verif_habili_me(p_param6,p_userid ,l_msg  );


	-- ====================================================================
      	-- 14/08/2003 : Test de fermeture du DPG
      	-- ====================================================================
         BEGIN
	    SELECT  l.codsg
	      INTO  l_codsg
	      FROM  ligne_bip l, struct_info s
	      WHERE l.codsg = s.codsg
	      AND   s.topfer = 'O'
	      AND   substr(to_char(l.codsg, 'FM0000000'), 1, length(rtrim(rtrim(LPAD(p_param6,7,'0'), '*')))) = rtrim(rtrim(LPAD(p_param6,7,'0'), '*'))
	      AND   ROWNUM < 2;

	   EXCEPTION
	    -- Pas de DPG ouverts correspondants.
	    WHEN no_data_found THEN
	      pack_global.recuperer_message( 20925, '%s1', LPAD(p_param6,7,'0'), 'P_param6', l_msg);
	      raise_application_error( -20925, l_msg );
	    -- Autre problème
	    WHEN OTHERS THEN
	      raise_application_error( -20997, SQLERRM );
	   END;


      END IF;

      -- TEST des pid message 20504
      IF p_param7 IS NOT NULL THEN
	 verif_pid(p_param7 , 'P_param7', p_userid);
	 IF p_param8 IS NOT NULL THEN verif_pid(p_param8 , 'P_param8', p_userid); END IF;
	 IF p_param9 IS NOT NULL THEN verif_pid(p_param9 , 'P_param9', p_userid); END IF;
	 IF p_param10 IS NOT NULL THEN verif_pid(p_param10, 'P_param10', p_userid); END IF;
	 IF p_param11 IS NOT NULL THEN verif_pid(p_param11, 'P_param11', p_userid); END IF;
	 IF p_param12 IS NOT NULL THEN verif_pid(p_param12, 'P_param12', p_userid); END IF;

      ELSIF (p_param8  IS NOT NULL OR
	     p_param9  IS NOT NULL OR
	     p_param10 IS NOT NULL OR
	     p_param11 IS NOT NULL OR
	     p_param12 IS NOT NULL
	     ) THEN
	 pack_global.recuperer_message( 20293, NULL, NULL, 'P_param7', l_msg);
	 raise_application_error( -20293, l_msg );
      END IF;

      -- TEST si l'edition retourne des informations
      BEGIN
	 IF (p_param6 IS NOT NULL) AND (p_param7 IS NOT NULL) THEN

	    SELECT lbi.codsg
	      INTO l_codsg
	      FROM ligne_bip lbi
	      WHERE to_char(lbi.codsg, 'FM0000000') LIKE rtrim(rtrim(LPAD(p_param6,7,'0'), '*')) || '%'
	      AND   lbi.pid IN (p_param7, p_param8, p_param9, p_param10, p_param11, p_param12)
	      AND   lbi.typproj != '7 '
	      AND   ROWNUM < 2;

	 END IF;

      EXCEPTION
	 WHEN no_data_found THEN
	   pack_global.recuperer_message( 20292 , NULL, NULL, 'P_param6', l_msg);
	   raise_application_error( -20292, l_msg);

	 WHEN OTHERS THEN
	    raise_application_error( -20997, SQLERRM );
      END;
   END verif_projprin;

   -- ------------------------------------------------------------------------
   -- Nom        : verif_pid
   -- Auteur     : Equipe SOPRA
   -- Decription : Test les champs saisies dans la page WEB
   --
   -- Paramètres : p_pid   (IN) code ligne_bip
   --              p_focus (IN) focus pour les pages WEB
   --              p_userid (IN) var globale de l'utilisateur
   -- Retour     :
   --
   -- ------------------------------------------------------------------------
   PROCEDURE verif_pid(p_pid   ligne_bip.pid%TYPE,
		       p_focus VARCHAR2,
		       p_userid  IN  VARCHAR2) IS

      l_codsg ligne_bip.codsg%TYPE;
      l_msg VARCHAR2(1000);
      l_codpole VARCHAR2(25);
      l_habilitation varchar2(10);

   BEGIN
      BEGIN
	 -- Test l'existance de la ligne_bip
	 SELECT  lbi.codsg
	   INTO  l_codsg
	   FROM  ligne_bip lbi
	   WHERE lbi.pid = p_pid;

      EXCEPTION
	 WHEN no_data_found THEN
	   pack_global.recuperer_message( 20504, '%s1', p_pid, p_focus, l_msg);
	   raise_application_error( -20504, l_msg );

	 WHEN OTHERS THEN
	      raise_application_error( -20997, SQLERRM );
      END;

      ------------------------------------------------
      -- Vérification que la ligne BIP a un DPG ouvert
      ------------------------------------------------
      BEGIN
	 -- Test l'existance de la ligne_bip
	 SELECT  lbi.codsg
	   INTO  l_codsg
	   FROM  ligne_bip lbi,
	         struct_info si
	   WHERE lbi.pid = p_pid
	     AND lbi.codsg = si.codsg
	     AND si.topfer = 'O';

      EXCEPTION
	 WHEN no_data_found THEN
	   pack_global.recuperer_message( 20926, '%s1', p_pid, p_focus, l_msg);
	   raise_application_error( -20926, l_msg );

	 WHEN OTHERS THEN
	      raise_application_error( -20997, SQLERRM );
      END;



      -- Si l'utilisateur est PCMMENU alors test l'habilitation sur la ligne_bip
      l_codpole := pack_global.lire_globaldata(p_userid).codpole;

      IF l_codpole != '0000' THEN -- Utilisateur non DIRMENU

	-- ====================================================================
      	-- 19/02/2001 : Test appartenance du DPG au périmètre de l'utilisateur
      	-- ====================================================================
     		l_habilitation := pack_habilitation.fhabili_me( l_codsg,p_userid   );
		IF l_habilitation='faux' THEN
			pack_global.recuperer_message(20364,'%s1', 'à la ligne bip '||p_pid, p_focus, l_msg);
	  		raise_application_error( -20364, l_msg );
		END IF;
      END IF;

   END verif_pid;


END  pack_visuprojprin;
/
CREATE OR REPLACE PACKAGE pack_x_consossii AS
-- ******************************************************************************
-- Fonction qui récupère le top ressource
-- *******************************************************************************
   FUNCTION getTop_ressource( p_last_month		IN NUMBER,
					p_mois_preced		IN NUMBER,
					p_cle_contrat		IN VARCHAR2,
					p_date_fin_contrat	IN DATE
				    ) RETURN CHAR ;
-- ******************************************************************************
-- Fonction qui récupère la date de fin d'utilisation de la ressource
-- *******************************************************************************
   FUNCTION getDateFinUtilRess(    p_ident	IN NUMBER,
					p_soccont	IN VARCHAR2,
					p_lcprest	IN VARCHAR2,
					p_cdeb	IN DATE
				    ) RETURN DATE ;
END pack_x_consossii;
/

CREATE OR REPLACE PACKAGE BODY pack_x_consossii AS
-- ******************************************************************************
-- Fonction qui récupère le top ressource
-- *******************************************************************************
 FUNCTION getTop_ressource( p_last_month		IN NUMBER,
					p_mois_preced		IN NUMBER,
					p_cle_contrat		IN VARCHAR2,
					p_date_fin_contrat	IN DATE
				    ) RETURN CHAR IS

   l_result CHAR(1);

   BEGIN
	IF ( p_last_month < p_mois_preced ) THEN
	   l_result := 'F';
	ELSIF ( p_last_month = p_mois_preced ) THEN
	   IF ( p_cle_contrat IS NULL OR p_date_fin_contrat < sysdate ) THEN
		l_result := 'S';
	    ELSIF (p_date_fin_contrat > sysdate ) THEN
		l_result := 'M';
	   END IF;
	ELSE
	   l_result := '?';
	END IF;

	RETURN l_result;

   END getTop_ressource;

-- ******************************************************************************
-- Fonction qui récupère la date de fin d'utilisation de la ressource
-- *******************************************************************************
  FUNCTION getDateFinUtilRess(    p_ident	IN NUMBER,
					p_soccont	IN VARCHAR2,
					p_lcprest	IN VARCHAR2,
					p_cdeb	IN DATE
				    ) RETURN DATE IS

   l_result DATE;

   BEGIN
	SELECT max(lresfin) into l_result
		FROM   ligne_cont
		WHERE ident    = p_ident
		AND   soccont  =p_soccont
		AND   lcprest  = p_lcprest
		AND   to_number(to_char(lresdeb,'YYYYMM')) <=  to_number(to_char(p_cdeb,'YYYYMM'));

	RETURN l_result;


 END getDateFinUtilRess;


END pack_x_consossii;
/
CREATE OR REPLACE PACKAGE pack_x_ressmoi IS
   FUNCTION getCout( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number) Return Number;

  FUNCTION getCoutTTC ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number,
					  p_cdeb    varchar2 ) Return Number;
  FUNCTION getCoutHTR ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number,
					  p_cdeb    varchar2,
					  p_filcode varchar2 ) Return Number ;


/******************************************************************************
   NAME:       pack_x_ressmoi
   PURPOSE:    utilisé dans l'extraction des ressources par mois x_ressmoi.rdf

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        24/11/2003   NBM 			   Création du document
   1.0        14/03/2005   PPR 			   Gestion du taux HTR




******************************************************************************/
END pack_x_ressmoi;
/

CREATE OR REPLACE PACKAGE BODY pack_x_ressmoi AS

FUNCTION getCout ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number ) Return Number IS
l_cout NUMBER(12,2);
BEGIN
l_cout:=0;

 if (p_soccode='SG..') then
 	select cout_sg into l_cout
	from cout_std_sg
	where p_codsg between dpg_bas and dpg_haut
	and metier = rtrim(p_metier)
	and niveau = decode(p_niveau,'L','HC','M','HC','N','HC',p_niveau)
	and annee = p_annee;
 else
 	 if p_rtype='L' then
	 	select cout_log into l_cout
		from cout_std2
		where p_codsg between dpg_bas and dpg_haut
	 	and annee = p_annee;

	 else
	 	 l_cout := p_cout_ssii;

	 end if;

 end if;


   RETURN l_cout;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       RETURN l_cout;
     WHEN OTHERS THEN
       RETURN l_cout;
END getCout;

-- Renvoie le cout TTC
FUNCTION getCoutTTC ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number,
					  p_cdeb    varchar2 ) Return Number IS
l_coutTTC NUMBER(12,2);
l_tva tva.tva%TYPE;
BEGIN
l_coutTTC:=0;

	-- Recherche le cout
	l_coutTTC :=getCout ( p_soccode, p_rtype, p_annee, p_metier, p_niveau, p_codsg, p_cout_ssii );

	-- Si ce n'est pas un logiciel et c'est un prestataire
	if (p_rtype<>'L' and p_soccode<>'SG..') then

		-- Recherche du taux de tva
		BEGIN
			SELECT t.tva into l_tva
       			FROM tva t
       			WHERE
       			t.datetva = (SELECT max(tva.datetva) FROM tva where datetva <= to_date(p_cdeb,'DD/MM/YYYY'));
      		EXCEPTION
         	WHEN OTHERS THEN
         	        -- Code TVA inexistant
            		l_tva := 0 ;
      		END;

		-- Applique la TVA au cout
		l_coutTTC := l_coutTTC * ( 1 + l_tva/100 ) ;
	end if ;

   RETURN l_coutTTC;

END getCoutTTC;

-- Renvoie le cout HTR
FUNCTION getCoutHTR ( p_soccode varchar2,
   					  p_rtype   char,
					  p_annee   number,
					  p_metier  varchar2,
					  p_niveau  varchar2,
					  p_codsg   number ,
					  p_cout_ssii number,
					  p_cdeb    varchar2,
					  p_filcode varchar2 ) Return Number IS
l_coutHTR NUMBER(12,2);
l_tva tva.tva%TYPE;
l_taux_recup taux_recup.taux%TYPE;
BEGIN
l_coutHTR:=0;

	-- Recherche le cout
	l_coutHTR :=getCout ( p_soccode, p_rtype, p_annee, p_metier, p_niveau, p_codsg, p_cout_ssii );

	-- Si ce n'est pas un logiciel et c'est un prestataire
	if (p_rtype<>'L' and p_soccode<>'SG..') then

		-- Recherche du taux de tva
		BEGIN
			SELECT t.tva into l_tva
       			FROM tva t
       			WHERE
       			t.datetva = (SELECT max(tva.datetva) FROM tva where datetva <= to_date(p_cdeb,'DD/MM/YYYY'));
      		EXCEPTION
         	WHEN OTHERS THEN
         	        -- Code TVA inexistant
            		l_tva := 0 ;
      		END;

		-- Recherche du taux de récupération pour la filiale
		BEGIN
			SELECT taux into l_taux_recup
       			FROM taux_recup
       			WHERE	annee = p_annee
       			and 	filcode = p_filcode ;

      		EXCEPTION
         	WHEN OTHERS THEN
         	        -- Taux de récupération non trouvé
			l_taux_recup := 0 ;
      		END;

		-- Applique la TVA et le taux de récup au cout
		l_coutHTR := l_coutHTR * ( 1 + l_tva/100 * (1 - l_taux_recup/100) ) ;
	end if ;

   RETURN l_coutHTR;

END getCoutHTR;

END pack_x_ressmoi;
/
CREATE OR REPLACE PROCEDURE select_facqua6 (p_param6  IN  VARCHAR2,
					     p_param7  IN  Varchar2,
					     p_userid  IN  VARCHAR2,
					     p_message OUT VARCHAR2
					    ) IS

      l_msg   VARCHAR2(1024);

BEGIN

   -- Initialiser le message retour

   p_message := '';

   IF p_param6 > p_param7 THEN
      pack_global.recuperer_message(20284, NULL, NULL, NULL, l_msg);
      raise_application_error(-20284, l_msg);
   END IF;

END select_facqua6;
/
CREATE OR REPLACE package TRCLOG as

	/* ------------------------------------------------ */
	/* On appelle l'Init. au début d'un traitement dont */
	/* on veut que les informations de trace soient     */
	/* toutes dans un même fichier. L'intégralité du    */
	/* traitement devra avoir accés au hFile rendu.     */
	/* Renvoie 0 si tout va bien, <> 0 sinon            */
	/* Le nom de fichier passé va servir à construire   */
	/* un nom de fichier avec la date "devant" et       */
	/* l'extension LOG "derrière"                       */
	/* ------------------------------------------------ */
	function INITTRCLOG( P_DIRNAME in varchar2, P_FILENAME in varchar2,
	                     P_HFILE out utl_file.file_type ) return number;

	/* ------------------------------------------------ */
	/* Permet la mise en fichier d'une chaîne de        */
	/* caractère. La procédure ajoute la séquence de    */
	/* ligne.                                           */
	/* ------------------------------------------------ */
	procedure TRCLOG( P_HFILE in utl_file.file_type, P_STRING in varchar2 );

	/* ------------------------------------------------ */
	/* Fermeture propre du fichier                      */
	/* ------------------------------------------------ */
	procedure CLOSETRCLOG( P_HFILE in out utl_file.file_type );

end TRCLOG;
/

CREATE OR REPLACE package body TRCLOG is

	/* ************ */
	/*              */
	/* INITTRCLOG   */
	/*              */
	/* ************ */
	function INITTRCLOG( P_DIRNAME in varchar2, P_FILENAME in varchar2,
	                     P_HFILE out utl_file.file_type ) return number is

		L_FILENAME varchar2( 64 );

	begin

		-- nom de fichier null interdit
		-- ----------------------------
		if P_FILENAME is null then
			return 1;
		end if;

		-- nom de fichier vide ou tout blanc interdit
		-- ------------------------------------------
		if length( rtrim( ltrim( P_FILENAME ) ) ) = 0 then
			return 2;
		end if;

		-- Date système en début de nom
		-- ----------------------------
		select to_char( SYSDATE, 'YYYY.MM.DD.' ) into L_FILENAME from dual;

		-- Ajout du nom passé
		-- ------------------
		L_FILENAME := L_FILENAME || P_FILENAME;

		-- Ajout de l'extension
		-- --------------------
		L_FILENAME := L_FILENAME || '.log';

		-- Ouverture en ajout ou création si n'existe pas
		-- Documentation Oracle manifestement fausse : on
		-- ne peut pas utiliser le mode Append si le
		-- fichier n'existe pas. Donc on essaye en 'a' et
		-- si on reçoit une erreur on essaye en 'w'
		-- ----------------------------------------------
		begin
	      	P_HFILE := utl_file.fopen( P_DIRNAME, L_FILENAME, 'a' );
		exception
			when utl_file.invalid_operation then
				begin
					P_HFILE := utl_file.fopen( P_DIRNAME, L_FILENAME, 'w' );
				exception
					when others then
						return 3;
				end;
				return 0;
		end;
		return 0;

	exception
		when others then
			return 3;

	end INITTRCLOG;




	/* ************ */
	/*              */
	/* TRCLOG       */
	/*              */
	/* ************ */
	procedure TRCLOG( P_HFILE in utl_file.file_type, P_STRING in varchar2 ) is
		NOW varchar2(32);
		THELINE varchar2(1024);
	begin

		-- construction ligne
		-- ------------------
		select to_char( sysdate, 'YYYY/MM/DD HH24:MI:SS' ) into NOW from dual;
		THELINE := NOW || ' ' || P_STRING;

		-- moi, j'aime bien la séquence
		-- put flush, mais il faut
		-- dire qu'en ce moment j'ai
		-- une période scato.
		utl_file.put_line( P_HFILE, THELINE );
		utl_file.fflush( P_HFILE );

	exception
		when others then
			return;

	end TRCLOG;



	/* ************ */
	/*              */
	/* CLOSETRCLOG  */
	/*              */
	/* ************ */
	procedure CLOSETRCLOG( P_HFILE in out utl_file.file_type ) is
	begin

		utl_file.fclose( P_HFILE );

	exception
		when others then
			return;

	end CLOSETRCLOG;


end TRCLOG;
/
CREATE OR REPLACE TRIGGER update_situation
AFTER UPDATE ON SITU_RESS
FOR EACH ROW
BEGIN
	Pack_Situation_Full.update_situation(:OLD.ident, :OLD.datsitu, :NEW.datsitu ,:NEW.datdep, :NEW.cpident,
	 :NEW.cout , :NEW.dispo, :NEW.marsg2, :NEW.rmcomp, :NEW.PRESTATION, :NEW.dprest, :NEW.soccode,
	:NEW.codsg,:NEW.NIVEAU,:NEW.MONTANT_MENSUEL);
END;
/
CREATE OR REPLACE FORCE VIEW VUE_CALEND
(CALANMOIS, CJOURS)
AS 
SELECT  distinct calanmois ,
           cjours
FROM       CALENDRIER
WHERE      to_char(sysdate,'yyyy') = to_char(calanmois,'yyyy');

COMMENT ON TABLE VUE_CALEND IS 'Vue donnant le nombre de jours ouvrés des mois de l''année d''exercice';

COMMENT ON COLUMN VUE_CALEND.CALANMOIS IS 'Mois/Année de traitement';

COMMENT ON COLUMN VUE_CALEND.CJOURS IS 'Nombre de jours ouvrés';


CREATE OR REPLACE FORCE VIEW VUE_CLICODE_HIERARCHIE
(CLICODE, CLICODERATT, CODHABILI)
AS 
select
	c.clicode,
	d.clicode CLICODERATT,
	'dir' CODHABILI
from
	client_mo c,
	client_mo d
where
	c.clidir = d.clidir
and c.clidep='0'
and c.clipol='0'
--
UNION
-- DEPARTEMENT ou POLE
select
	c.clicode,
	d.clicode,
	'dep' CODHABILI
from
	client_mo c,
	client_mo d
where
	c.clidir = d.clidir
and c.clidep = d.clidep
and c.clipol='0'
--
UNION
--  POLE
select
	c.clicode,
	c.clicode,
	'pole' CODHABILI
from
	client_mo c
where
	c.clipol <> '0';

COMMENT ON TABLE VUE_CLICODE_HIERARCHIE IS 'Vue permettant d''obtenir une vision hiérarchique des clients et de savoir quels services clients sont rattachés à un service';

COMMENT ON COLUMN VUE_CLICODE_HIERARCHIE.CLICODE IS 'Code client MO';

COMMENT ON COLUMN VUE_CLICODE_HIERARCHIE.CLICODERATT IS 'Code client MO rattaché';

COMMENT ON COLUMN VUE_CLICODE_HIERARCHIE.CODHABILI IS 'Niveau du code client MO (dir=direction, dep=département, pole=pôle)';


CREATE OR REPLACE FORCE VIEW VUE_CLICODE_PERIMO
(CLICODE, BDCLICODE, CODHABILI)
AS 
select
	c.clicode,
	(TO_CHAR(d.codbr,  'FM00')
	|| TO_CHAR(c.clidir, 'FM00')
	|| TO_CHAR(c.clicode, 'FM00000')
	) BDCLICODE,
	'cli' CODHABILI
from
	client_mo c,
	directions d
where
	c.clidir = d.coddir
and	c.clidep <> 999

UNION
-- Lien Pole - Département
select
	c.clicode,
	(TO_CHAR(d.codbr,  'FM00')
	|| TO_CHAR(c.clidir, 'FM00')
	|| TO_CHAR(c2.clicode, 'FM00000')
	) BDCLICODE,
	'pole' CODHABILI
from
	client_mo c,
	client_mo c2,
	directions d
where
	c.clidir = d.coddir
and 	c.clidir = c2.clidir
and 	c.clidep = c2.clidep
and	c2.clipol = 0
and	c.clidep <> 999
and 	c.clipol <> 0
and 	c.clidep <> 0
--
UNION
-- Lien Pole ou Département - Direction
select
	c.clicode,
	(TO_CHAR(d.codbr,  'FM00')
	|| TO_CHAR(c.clidir, 'FM00')
	|| TO_CHAR(c2.clicode, 'FM00000')
	) BDCLICODE,
	'dep' CODHABILI
from
	client_mo c,
	client_mo c2,
	directions d
where
	c.clidir = d.coddir
and 	c.clidir = c2.clidir
and 	c2.clidep = 0
and	c2.clipol = 0
and	c.clidep <> 999
and 	c.clidep <> 0
--
UNION
--  DIRECTION
select
	c.clicode,
	(TO_CHAR(d.codbr,  'FM00')
	|| TO_CHAR(c.clidir, 'FM00')
	|| '00000'
	) BDCLICODE,
	'dir' CODHABILI
from
	client_mo c,
	directions d
where
	c.clidir = d.coddir
--
UNION
-- BRANCHE
select
	c.clicode,
	(TO_CHAR(d.codbr,  'FM00')
	|| '0000000'
	) BDCLICODE,
	'br' CODHABILI
from
	client_mo c,
	directions d
where
	c.clidir = d.coddir
--
UNION
-- TOUT
select
	c.clicode,
	'000000000' BDCLICODE,
	'bip' CODHABILI
from
	client_mo c,
	directions d
where
	c.clidir = d.coddir;

COMMENT ON TABLE VUE_CLICODE_PERIMO IS 'Vue permettant de lister les services clients rattachés à un code habilitation client';

COMMENT ON COLUMN VUE_CLICODE_PERIMO.CLICODE IS 'Code du client MO';

COMMENT ON COLUMN VUE_CLICODE_PERIMO.BDCLICODE IS 'Périmètre client';

COMMENT ON COLUMN VUE_CLICODE_PERIMO.CODHABILI IS 'Niveau du périmètre client (bip=toute la bip, br=branche, dir=direction, dep=département, pole=pôle, cli=client)';


CREATE OR REPLACE FORCE VIEW VUE_DIRECTION
(CLIDOM, CLISIGLE)
AS 
select distinct clicode,clisigle
from client_mo;

COMMENT ON TABLE VUE_DIRECTION IS 'Vue listant les clients MO et leur sigle';

COMMENT ON COLUMN VUE_DIRECTION.CLIDOM IS 'Code client MO';

COMMENT ON COLUMN VUE_DIRECTION.CLISIGLE IS 'Sigle client MO';


CREATE OR REPLACE FORCE VIEW VUE_DPG_PERIME
(CODSG, CODBDDPG, CODHABILI)
AS 
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| TO_CHAR(s.coddir, 'FM00')
		|| TO_CHAR(s.codsg, 'FM0000000')
		) CODBDDPG,
		'grpe' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond au p¿le
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| TO_CHAR(s.coddir, 'FM00')
		|| SUBSTR(TO_CHAR(s.codsg, 'FM0000000'),1,5)
		|| '00'
		) CODBDDPG,
		'pole' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond au d¿partement
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| TO_CHAR(s.coddir, 'FM00')
		|| SUBSTR(TO_CHAR(s.codsg, 'FM0000000'),1,3)
		|| '0000'
		) CODBDDPG,
		'dpt' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond ¿ la direction
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| TO_CHAR(s.coddir, 'FM00')
		|| '0000000'
		) CODBDDPG,
		'dir' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond ¿ la branche
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| '000000000'
		) CODBDDPG,
		'br' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond ¿ toute la BIP
select s.codsg, '00000000000' CODBDDPG, 'bip' CODHABILI
from struct_info s;

COMMENT ON TABLE VUE_DPG_PERIME IS 'Vue permettant de lister les DPG rattachés à un code habilitation fournisseur';

COMMENT ON COLUMN VUE_DPG_PERIME.CODSG IS 'Code Département/Pôle/Groupe';

COMMENT ON COLUMN VUE_DPG_PERIME.CODBDDPG IS 'Périmètre fournisseur';

COMMENT ON COLUMN VUE_DPG_PERIME.CODHABILI IS 'Niveau du périmètre fournisseur (bip=toute la bip, br=branche, dir=direction, dpt=département, pole=pôle, grpe=groupe)';


CREATE OR REPLACE FORCE VIEW VUE_DPG_PERIME_ALL
(CODSG, CODBDDPG, CODHABILI)
AS 
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| TO_CHAR(s.coddir, 'FM00')
		|| TO_CHAR(s.codsg, 'FM0000000')
		) CODBDDPG,
		'grpe' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond au pôle
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| TO_CHAR(s.coddir, 'FM00')
		|| SUBSTR(TO_CHAR(s.codsg, 'FM0000000'),1,5)
		|| '00'
		) CODBDDPG,
		'pole' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond au département
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| TO_CHAR(s.coddir, 'FM00')
		|| SUBSTR(TO_CHAR(s.codsg, 'FM0000000'),1,3)
		|| '0000'
		) CODBDDPG,
		'dpt' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond à la direction
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| TO_CHAR(s.coddir, 'FM00')
		|| '0000000'
		) CODBDDPG,
		'dir' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond à la branche
select s.codsg, (TO_CHAR(d.codbr, 'FM00')
		|| '000000000'
		) CODBDDPG,
		'br' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond à toute la BIP
select s.codsg, '00000000000' CODBDDPG, 'bip' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir
UNION  --Cas ou le BDDPG correspond à toute la BIP et le DPG n'est rattaché à aucune direction
select s.codsg, '00000000000' CODBDDPG, 'bip' CODHABILI
from struct_info s, directions d
where s.coddir = d.coddir(+);

COMMENT ON TABLE VUE_DPG_PERIME_ALL IS 'Vue permettant de lister les DPG rattachés à un code habilitation fournisseur - Inclut en plus les DPG qui ne sont pas rattachés à une direction';

COMMENT ON COLUMN VUE_DPG_PERIME_ALL.CODSG IS 'Code Département/Pôle/Groupe';

COMMENT ON COLUMN VUE_DPG_PERIME_ALL.CODBDDPG IS 'Périmètre fournisseur';

COMMENT ON COLUMN VUE_DPG_PERIME_ALL.CODHABILI IS 'Niveau du périmètre fournisseur (bip=toute la bip, br=branche, dir=direction, dpt=département, pole=pôle, grpe=groupe)';


CREATE OR REPLACE FORCE VIEW VUE_EXT_PPCM2
(IDENT, CDATDEB, CDATFIN, CODSG)
AS 
SELECT lc.ident, c.cdatdeb, c.cdatfin, c.codsg codsg
FROM  ligne_cont lc, contrat c
WHERE lc.soccont  = c.soccont
  AND lc.cav      = c.cav
  AND lc.numcont  = c.numcont
  AND c.cdatdeb <= trunc(SYSDATE)   -- Regle de gestion
  AND c.cdatfin >= trunc(SYSDATE)   -- Regle de gestion;

COMMENT ON TABLE VUE_EXT_PPCM2 IS 'Vue listant les ressources ayant un contrat en cours';

COMMENT ON COLUMN VUE_EXT_PPCM2.IDENT IS 'Identifiant de la ressource';

COMMENT ON COLUMN VUE_EXT_PPCM2.CDATDEB IS 'Date de début du contrat';

COMMENT ON COLUMN VUE_EXT_PPCM2.CDATFIN IS 'Date de fin du contrat';

COMMENT ON COLUMN VUE_EXT_PPCM2.CODSG IS 'Code Département Pôle Groupe';


CREATE OR REPLACE FORCE VIEW VUE_IMMO
(TYPE_ENREG, ORIGINE, ENTITE_PROJET, PROJET, COMPOSANT, 
 CADA, ANNEE, MOIS, TYPE_MONTANT, MONTANT, 
 SENS, DEVISE, CAFI)
AS 
select
   	  	2 	   	   		 		      			type_enreg,
		'BIP' 	   			  		    			origine,
		'P7090'    	  		  		    			entite_projet,
		max(s.icpi) 		  		    			projet,
		'0BIPIAS' 			  		    			composant,
		max(s.cada) 		  		    			cada,
		to_char(max(d.datdebex),'YYYY') 			annee,
		to_char(max(d.moismens),'MM') 				mois,
		'P' 										type_montant,
		to_char(abs(sum(s.a_consoft)),'FM999999999990.00') 						montant,
		decode(sign(sum(s.a_consoft)),-1,'C',1,'D') sens,
		'EUR' 										devise,
		max(s.cafi) 								cafi
from stock_immo s,
	 datdebex d
where soccode<>'SG..'
group by s.icpi,s.cafi
having sum(a_consoft)<>0
UNION
-- Charges salariales SSII
select
	  2 											type_enreg,
	  'BIP' 										origine,
	  'P7090' 										entite_projet,
	  max(s.icpi) 									projet,
	  '0BIPIAS' 										composant,
	  max(s.cada) 									cada,
	  to_char(max(d.datdebex),'YYYY') 				annee,
	  to_char(max(d.moismens),'MM') 				mois,
	  'C' 											type_montant,
	  to_char(abs(sum(a_consoft*(t.taux/100))),'FM999999999990.00') 				montant,
	  decode(sign(sum(s.a_consoft)),-1,'C',1,'D') 	sens,
	  'EUR' 										devise,
	  max(s.cafi) 									cafi
from stock_immo s,
	 taux_charge_salariale t,
	 datdebex d
where
t.annee = to_number(to_char(d.datdebex,'YYYY'))
and soccode='SG..'
group by s.icpi,s.cafi
having sum(a_consoft)<>0
UNION
--salaires SG
select
	  2 									   		type_enreg,
	  'BIP' 								   		origine,
	  'P7090' 								   		entite_projet,
	  max(s.icpi) 						   			projet,
	  '0BIPIAS' 								   		composant,
	  max(s.cada) 							   		cada,
	  to_char(max(d.datdebex),'YYYY') 		   		annee,
	  to_char(max(d.moismens),'MM') 		   		mois,
	  'S' 									   		type_montant,
	  to_char(abs(sum(s.a_consoft*((100-taux)/100))),'FM999999999990.00')   		montant,
	  decode(sign(sum(s.a_consoft)),-1,'C',1,'D') 	sens,
	  'EUR' 										devise,
	  max(s.cafi) 									cafi
from stock_immo s,
	 taux_charge_salariale t,
	 datdebex d
where
t.annee = to_number(to_char(d.datdebex,'YYYY'))
and soccode='SG..'
group by s.icpi,s.cafi
having sum(a_consoft)<>0;

COMMENT ON TABLE VUE_IMMO IS 'Vue de préparation des données nécessaires au fichier des immobilisations';

COMMENT ON COLUMN VUE_IMMO.TYPE_ENREG IS 'Type d''enregistrement (=2)';

COMMENT ON COLUMN VUE_IMMO.ORIGINE IS 'Origine (=BIP)';

COMMENT ON COLUMN VUE_IMMO.ENTITE_PROJET IS 'Entité Projet (=P7090)';

COMMENT ON COLUMN VUE_IMMO.PROJET IS 'Code du projet informatique';

COMMENT ON COLUMN VUE_IMMO.COMPOSANT IS 'Composant (=0BIPIAS)';

COMMENT ON COLUMN VUE_IMMO.CADA IS 'Centre d''activité de dotation aux amortissements';

COMMENT ON COLUMN VUE_IMMO.ANNEE IS 'Année d''exercice';

COMMENT ON COLUMN VUE_IMMO.MOIS IS 'Mois de la mensuelle';

COMMENT ON COLUMN VUE_IMMO.TYPE_MONTANT IS 'Type de montant (=P: Prestation, C:Charges salariales, S:Salaires)';

COMMENT ON COLUMN VUE_IMMO.MONTANT IS 'Montant ';

COMMENT ON COLUMN VUE_IMMO.SENS IS 'Sens (=C:Crédit , D:Débit)';

COMMENT ON COLUMN VUE_IMMO.DEVISE IS 'Devise (=EUR)';

COMMENT ON COLUMN VUE_IMMO.CAFI IS 'Centre d''activité de facturation interne';


CREATE OR REPLACE FORCE VIEW VUE_INVALID
(COMMANDE)
AS 
select distinct
'alter ' || decode(object_type, 'PACKAGE BODY', 'PACKAGE', object_type) || ' ' || object_name || ' compile;' commande
from obj where status='INVALID';

COMMENT ON TABLE VUE_INVALID IS 'Vue Technique des objets Oracle invalides';

COMMENT ON COLUMN VUE_INVALID.COMMANDE IS 'Commande pour recompiler l''objet';


CREATE OR REPLACE FORCE VIEW VUE_POLE
(CODE, LIBELLE)
AS 
select substr(to_char(codsg,'FM0099999'),1,7) AS code,
			substr(libdsg,1,12) As libelle
		   FROM
			struct_info
		   WHERE
			codsg > 1 and topfer like 'O'
		   -- -----
		   UNION
		   -- -----
		   -- ----------------------------------------------------------------------
		   -- Liste de tous les pôles
		   -- ----------------------------------------------------------------------
	           SELECT DISTINCT
			substr(to_char(codsg,'FM0099999'),1,5)||'00' AS code,
			sigdep                                 || '/'    ||
			sigpole AS libelle
		   FROM
			struct_info
		   WHERE
			codsg > 1 and topfer like 'O'
		   -- -----
		   UNION
		   -- -----
   		   -- ----------------------------------------------------------------------
		   -- Liste de tous les departements (XX**)
		   -- ----------------------------------------------------------------------
		   SELECT DISTINCT
			substr(to_char(codsg,'FM0099999'),1,3) || '0000'  AS code,
			rpad(sigdep,6,' ') AS libelle
		   FROM
			struct_info
		   WHERE
			codsg > 1 and topfer like 'O'
		   -- -----
		   UNION
		   -- -----
   		   -- ----------------------------------------------------------------------
		   -- Code special '0000'
		   -- ----------------------------------------------------------------------
		   SELECT
			'0000000' AS code,
		        rpad('Tous',6,' ') AS libelle
		   FROM
			dual;

COMMENT ON TABLE VUE_POLE IS 'Vue listant tous les départements pôles et groupes';

COMMENT ON COLUMN VUE_POLE.CODE IS 'Code du DPG';

COMMENT ON COLUMN VUE_POLE.LIBELLE IS 'Libellé du DPG';



